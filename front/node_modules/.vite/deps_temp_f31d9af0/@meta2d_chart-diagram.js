import "./chunk-RDEAKAAS.js";
import {
  deepClone,
  deepSetValue,
  formatTime,
  getter,
  register,
  setElemPosition,
  setter
} from "./chunk-PFF6Q7CQ.js";
import "./chunk-USJHI7ER.js";

// node_modules/@meta2d/chart-diagram/src/echarts.js
var ReplaceMode;
(function(ReplaceMode2) {
  ReplaceMode2[ReplaceMode2["Add"] = 0] = "Add";
  ReplaceMode2[ReplaceMode2["Replace"] = 1] = "Replace";
  ReplaceMode2[ReplaceMode2["ReplaceAll"] = 2] = "ReplaceAll";
})(ReplaceMode || (ReplaceMode = {}));
var keyWords = [
  "fontSize",
  "nameGap",
  "margin",
  "width",
  "symbolSize",
  "itemWidth",
  // 图例宽度
  "itemHeight",
  // 图例高度
  "fontWeight",
  "top",
  "left",
  "right",
  "bottom",
  "zoom",
  "edgeSymbolSize",
  "nodeWidth",
  "nodeGap",
  "distance",
  "length",
  "length2",
  "offsetCenter",
  "size",
  "symbolOffset",
  "padding",
  "barWidth",
  "symbolOffset",
  "shadowOffsetY",
  "shadowOffsetX"
];
function echarts(pen) {
  var _a, _b;
  let echarts2 = globalThis.echarts;
  if (!pen.echarts || !echarts2) {
    return;
  }
  if (typeof pen.echarts === "string") {
    try {
      pen.echarts = JSON.parse(pen.echarts);
    } catch (e) {
    }
  }
  keyWords = ((_a = pen.calculative.canvas.store.options.diagramOptions["chart"]) == null ? void 0 : _a.keyWords) || keyWords;
  if (!pen.onDestroy) {
    pen.onDestroy = destory;
    pen.onMove = move;
    pen.onResize = resize;
    pen.onRotate = move;
    pen.onValue = value;
    pen.onBeforeValue = beforeValue;
    pen.onBinds = binds;
    pen.onMouseEnter = move;
    pen.onRenderPenRaw = onRenderPenRaw;
    pen.onScale = scale;
  }
  if (!pen.calculative.singleton) {
    pen.calculative.singleton = {};
  }
  const path = new Path2D();
  const worldRect = pen.calculative.worldRect;
  if (!pen.calculative.singleton.div) {
    const div = document.createElement("div");
    div.style.position = "absolute";
    div.style.outline = "none";
    div.style.left = "-9999px";
    div.style.top = "-9999px";
    div.style.width = worldRect.width + "px";
    div.style.height = worldRect.height + "px";
    document.body.appendChild(div);
    (_b = pen.calculative.canvas.externalElements) == null ? void 0 : _b.parentElement.appendChild(div);
    setElemPosition(pen, div);
    pen.calculative.singleton.div = div;
    pen.calculative.singleton.echart = echarts2.init(div, pen.echarts.theme);
    initEvent(pen);
    pen.calculative.singleton.echartsReady = true;
    if (pen.echarts.geoName && !echarts2.getMap(pen.echarts.geoName)) {
      if (pen.echarts.geoJson) {
        echarts2.registerMap(pen.echarts.geoName, pen.echarts.geoJson);
      } else if (pen.echarts.geoUrl) {
        pen.calculative.singleton.echartsReady = false;
        fetch(pen.echarts.geoUrl).then((e) => {
          e.text().then((data) => {
            if (typeof data === "string") {
              try {
                data = JSON.parse(data);
              } catch {
              }
            }
            if (data.constructor !== Object && data.constructor !== Array) {
              console.warn("Invalid data:", data);
              return;
            }
            echarts2.registerMap(pen.echarts.geoName, data);
            pen.calculative.singleton.echartsReady = true;
            pen.calculative.singleton.echart.setOption(updateOption(pen.echarts.option, pen.calculative.canvas.store.data.scale), true);
            pen.calculative.singleton.echart.resize();
            setTimeout(() => {
              onRenderPenRaw(pen);
            }, 300);
          });
        });
      }
    }
    if (pen.calculative.singleton.echartsReady) {
      setTimeout(() => {
        pen.calculative.singleton.echart.setOption(updateOption(pen.echarts.option, pen.calculative.canvas.store.data.scale), true);
        setTimeout(() => onRenderPenRaw(pen), 300);
      });
    }
  }
  return path;
}
function initEvent(pen) {
  var _a;
  const _chart = pen.calculative.singleton.echart;
  const eventNames = ["click", "dblclick", "mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "globalout", "contextmenu"];
  eventNames.forEach((eventName) => {
    _chart.off(eventName);
  });
  (_a = pen.events) == null ? void 0 : _a.forEach((event) => {
    if (event.actions && event.actions.length) {
      if (eventNames.includes(event.name)) {
        _chart.on(event.name, (params) => {
          let flag = false;
          if (event.conditions && event.conditions.length) {
            if (event.conditionType === "and") {
              flag = event.conditions.every((condition) => {
                return pen.calculative.canvas.parent.judgeCondition(pen, condition.key, condition);
              });
            } else if (event.conditionType === "or") {
              flag = event.conditions.some((condition) => {
                return pen.calculative.canvas.parent.judgeCondition(pen, condition.key, condition);
              });
            }
          } else {
            flag = true;
          }
          if (flag) {
            event.actions.forEach((action) => {
              if (action.timeout) {
                let timer = setTimeout(() => {
                  if (pen.calculative.canvas.parent.events[action.action]) {
                    pen.calculative.canvas.parent.events[action.action](pen, action, params);
                    clearTimeout(timer);
                    timer = null;
                  }
                }, action.timeout);
              } else {
                if (pen.calculative.canvas.parent.events[action.action]) {
                  pen.calculative.canvas.parent.events[action.action](pen, action, params);
                }
              }
            });
          }
        });
      }
    }
  });
}
function destory(pen) {
  if (pen.calculative.singleton && pen.calculative.singleton.div) {
    pen.calculative.singleton.div.remove();
    let echarts2 = globalThis.echarts;
    echarts2 && echarts2.dispose(pen.calculative.singleton.echart);
    delete pen.calculative.singleton.div;
    delete pen.calculative.singleton.echart;
  }
}
function move(pen) {
  pen.calculative.singleton.div && setElemPosition(pen, pen.calculative.singleton.div);
}
function resize(pen) {
  var _a;
  move(pen);
  if (!((_a = pen.calculative.singleton) == null ? void 0 : _a.echart)) {
    return;
  }
  pen.calculative.singleton.echart.resize();
}
function scale(pen) {
  var _a, _b;
  if (!pen.calculative.singleton.echart) {
    return;
  }
  let echarts2 = globalThis.echarts;
  setElemPosition(pen, pen.calculative.singleton.div);
  if (pen.echarts.geoName && !echarts2.getMap(pen.echarts.geoName))
    return;
  if (!pen.echarts.diabled) {
    if ((_a = pen.echarts.option) == null ? void 0 : _a.dataZoom) {
      const options = pen.calculative.singleton.echart.getOption();
      const dataZoom = options.dataZoom;
      (_b = pen.echarts.option.dataZoom) == null ? void 0 : _b.forEach((item, index) => {
        if (dataZoom[index]) {
          item.start = dataZoom[index].start;
          item.end = dataZoom[index].end;
        }
      });
    }
    pen.calculative.singleton.echart.setOption(updateOption(pen.echarts.option, pen.calculative.canvas.store.data.scale), true);
  }
  pen.calculative.singleton.echart.resize();
}
function value(pen) {
  var _a, _b;
  if (!pen.calculative.singleton.echart) {
    return;
  }
  setElemPosition(pen, pen.calculative.singleton.div);
  if (pen.calculative.singleton.echartsReady) {
    if (pen.calculative.partialOption) {
      const option = pen.calculative.partialOption.echarts.option;
      let isReplaceMerge = Array.isArray((_a = pen.echarts) == null ? void 0 : _a.replaceMerge) ? (_b = pen.echarts) == null ? void 0 : _b.replaceMerge.some((key) => option[key]) : false;
      if (isReplaceMerge) {
        pen.calculative.singleton.echart.setOption(deepClone(option), {
          replaceMerge: pen.echarts.replaceMerge
        });
      } else {
        pen.calculative.singleton.echart.setOption(deepClone(option));
      }
    } else {
      pen.calculative.singleton.echart.setOption(updateOption(pen.echarts.option, pen.calculative.canvas.store.data.scale), true);
    }
  }
}
function beforeValue(pen, value4) {
  pen.calculative.partialOption = null;
  if (value4.echarts) {
    let echarts3 = globalThis.echarts;
    if (value4.echarts.geoName && !echarts3.getMap(value4.echarts.geoName)) {
      if (value4.echarts.geoJson) {
        echarts3.registerMap(value4.echarts.geoName, value4.echarts.geoJson);
      } else if (value4.echarts.geoUrl) {
        pen.calculative.singleton.echartsReady = false;
        fetch(value4.echarts.geoUrl).then((e) => {
          e.text().then((data) => {
            if (typeof data === "string") {
              try {
                data = JSON.parse(data);
              } catch {
              }
            }
            if (data.constructor !== Object && data.constructor !== Array) {
              console.warn("Invalid data:", data);
              return;
            }
            echarts3.registerMap(value4.echarts.geoName, data);
            pen.calculative.singleton.echartsReady = true;
            pen.onValue(pen);
            return false;
          });
        });
      }
    }
    return value4;
  }
  if (pen.realTimes && pen.realTimes.length) {
    let keys = Object.keys(value4);
    const { xAxis: xAxis2, yAxis: yAxis2 } = pen.echarts.option;
    const { max: max2, replaceMode: replaceMode2, timeFormat } = pen.echarts;
    let dataDotArr = [];
    let chartFlag = false;
    for (let key in value4) {
      if (key.includes("echarts.option")) {
        chartFlag = true;
        let beforeV = getter(pen, key);
        if (Array.isArray(beforeV) && replaceMode2 === ReplaceMode.Add) {
          beforeV.push(value4[key]);
          if (max2) {
            beforeV.splice(0, beforeV.length - max2);
          }
          value4[key] = beforeV;
          if (!keys.includes("echarts.option.xAxis.data")) {
            let _key = "echarts.option.xAxis.data";
            if (Array.isArray(xAxis2) && xAxis2.length) {
              _key = "echarts.option.xAxis.0.data";
            }
            let _value = getter(pen, _key);
            let _time = formatTime(timeFormat || "`${hours}:${minutes}:${seconds}`");
            _value.push(_time);
            if (max2) {
              _value.splice(0, _value.length - max2);
            }
            value4[_key] = _value;
          }
        }
        if (key.includes(".data.")) {
          let _key = key.substring(0, key.indexOf(".data.") + 5);
          if (!dataDotArr.includes(_key)) {
            dataDotArr.push(_key);
          }
        }
      }
    }
    if (chartFlag) {
      const _value = deepClone(value4);
      pen.calculative.partialOption = dotNotationToObject(_value, pen);
      dataDotArr.forEach((key) => {
        let value5 = getter(pen, key);
        setter(pen.calculative.partialOption, key, value5);
      });
    }
    return value4;
  }
  if (!value4.dataX && !value4.dataY) {
    return value4;
  }
  const echarts2 = pen.echarts;
  const { max, replaceMode } = echarts2;
  let x = value4.dataX;
  let y = value4.dataY;
  let dataArr = [];
  if (y) {
    dataArr.push("echarts.option.series");
  }
  const series = echarts2.option.series;
  const length = series.length;
  const { xAxis, yAxis } = echarts2.option;
  if (Array.isArray(xAxis) && xAxis.length > 1) {
    console.warn("echarts 只支持单 x 轴，多 x 轴将被忽略");
  }
  const oneXAxis = Array.isArray(xAxis) ? xAxis[0] : xAxis;
  const oneYAxis = Array.isArray(yAxis) ? yAxis[0] : yAxis;
  if (!replaceMode) {
    if (x) {
      !Array.isArray(x) && (x = [x]);
      const xData = oneXAxis.data;
      xData.push(...x);
      xData.splice(0, xData.length - max);
      dataArr.push("echarts.option.xAxis");
    }
    if (y) {
      if (length === 1) {
        !Array.isArray(y) && (y = [y]);
        const yData = series[0].data;
        yData.push(...y);
        yData.splice(0, yData.length - max);
      } else {
        series.forEach((serie, index) => {
          if (!Array.isArray(y[index])) {
            y[index] = [y[index]];
          }
          const yData = serie.data;
          yData.push(...y[index]);
          yData.splice(0, yData.length - max);
        });
      }
    }
  } else if (replaceMode === ReplaceMode.Replace) {
    if (!oneXAxis && !oneYAxis) {
      if (y) {
        if (length === 1) {
          !Array.isArray(y) && (y = [y]);
          y.forEach((yItem, index) => {
            const part = series[0].data.find((part2) => part2.name === yItem.name);
            part && (part.value = yItem.value);
          });
        } else {
          series.forEach((serie, index) => {
            if (!Array.isArray(y[index])) {
              y[index] = [y[index]];
            }
            y[index].forEach((yItem, index2) => {
              const part = serie.data.find((part2) => part2.name === yItem.name);
              part && (part.value = yItem.value);
            });
          });
        }
      }
    } else if (oneXAxis.type === "category" || oneYAxis.type === "category") {
      if (x && y) {
        const categoryData = oneXAxis.type === "category" ? oneXAxis.data : oneYAxis.data;
        !Array.isArray(x) && (x = [x]);
        !Array.isArray(y) && (y = [y]);
        if (oneXAxis.type === "category") {
          dataArr.push("echarts.option.xAxis");
        } else {
          dataArr.push("echarts.option.yAxis");
        }
        if (length === 1) {
          y.forEach((yItem, index) => {
            const xIndex = categoryData.indexOf(x[index]);
            series[0].data[xIndex] = yItem;
          });
        } else {
          series.forEach((serie, index) => {
            y[index].forEach((yItem, index2) => {
              const xIndex = categoryData.indexOf(x[index2]);
              serie.data[xIndex] = yItem;
            });
          });
        }
      }
    }
  } else if (replaceMode === ReplaceMode.ReplaceAll) {
    if (x) {
      oneXAxis.data = x;
      oneXAxis.data.splice(0, oneXAxis.data.length - max);
      dataArr.push("echarts.option.xAxis");
    }
    if (y) {
      if (length === 1) {
        series[0].data = y;
        series[0].data.splice(0, series[0].data.length - max);
      } else {
        series.forEach((serie, index) => {
          serie.data = y[index];
          serie.data.splice(0, serie.data.length - max);
        });
      }
    }
  }
  pen.calculative.partialOption = {};
  dataArr.forEach((key) => {
    let value5 = getter(pen, key);
    setter(pen.calculative.partialOption, key, value5);
  });
  delete value4.dataX;
  delete value4.dataY;
  return Object.assign(value4, { echarts: echarts2 });
}
function binds(pen, values, formItem) {
  if (formItem.key !== "dataY") {
    return;
  }
  const echarts2 = pen.echarts;
  const { xAxis, yAxis } = echarts2.option;
  if (Array.isArray(xAxis) && xAxis.length > 1) {
    console.warn("echarts 只支持单 x 轴，多 x 轴将被忽略");
  }
  const oneXAxis = Array.isArray(xAxis) ? xAxis[0] : xAxis;
  const oneYAxis = Array.isArray(yAxis) ? yAxis[0] : yAxis;
  const series = echarts2.option.series;
  if (!oneXAxis && !oneYAxis) {
    const dataY = [];
    if (Array.isArray(series) && series.length === 1) {
      series[0].data.forEach((item) => {
        const { dataId: id } = formItem.dataIds.find((dataId) => dataId.name === item.name);
        if (id) {
          const value4 = values.find((value5) => value5.dataId === id);
          if (value4) {
            dataY.push({
              name: item.name,
              value: value4.value
            });
          }
        }
      });
      return {
        id: pen.id,
        dataY
      };
    } else {
    }
  } else if (oneXAxis.type === "category" || oneYAxis.type === "category") {
    const dataY = [], dataX = [];
    const categoryData = oneXAxis.type === "category" ? oneXAxis.data : oneYAxis.data;
    categoryData == null ? void 0 : categoryData.forEach((category) => {
      const { dataId: id } = formItem.dataIds.find((dataId) => dataId.name === category);
      if (id) {
        const value4 = values.find((value5) => value5.dataId === id);
        if (value4) {
          dataX.push(category);
          dataY.push(value4.value);
        }
      }
    });
    return {
      id: pen.id,
      dataY,
      dataX
    };
  } else if (oneXAxis.type === "time") {
    const dataY = [];
    const now = +/* @__PURE__ */ new Date();
    let hasValue = false;
    series.forEach((serie, index) => {
      const oneDataY = [];
      const { dataId: id } = formItem.dataIds.find((dataId) => dataId.name === serie.name);
      if (id) {
        const value4 = values.find((value5) => value5.dataId === id);
        if (value4) {
          oneDataY.push([now, value4.value]);
          hasValue = true;
        }
      }
      dataY[index] = oneDataY;
    });
    if (hasValue) {
      dataY.forEach((oneDataY, index) => {
        if (!oneDataY || oneDataY.length === 0) {
          const last = series[index].data[series[index].data.length - 1];
          dataY[index] = [[now, last[1]]];
        }
      });
    } else {
      return;
    }
    return {
      id: pen.id,
      dataY: dataY.length === 1 ? dataY[0] : dataY
    };
  }
  return;
}
function setEchartsOption(pen, ids, isTime = false, isYCategory = false) {
  if (pen.name !== "echarts") {
    console.warn("当前画笔不是 echarts");
    return;
  }
  const echarts2 = pen.echarts;
  const { xAxis, yAxis } = echarts2.option;
  const oneXAxis = Array.isArray(xAxis) ? xAxis[0] : xAxis;
  const oneYAxis = Array.isArray(yAxis) ? yAxis[0] : yAxis;
  const series = echarts2.option.series;
  if (!oneXAxis && !oneYAxis) {
    echarts2.option.legend = {};
    series[0].data = ids.map((id) => {
      return {
        name: id.name,
        value: 100
        // TODO: 该值为初始值
      };
    });
  } else {
    if (isTime) {
      const yType = series[0].type;
      const now = +/* @__PURE__ */ new Date();
      oneXAxis.type = "time";
      oneXAxis.data = [];
      oneYAxis.type = "value";
      oneYAxis.data = [];
      echarts2.option.legend = {};
      echarts2.option.series = ids.map((id) => {
        return {
          name: id.name,
          type: yType,
          data: [[now, 0]]
          // TODO: 初始值
        };
      });
      echarts2.replaceMode = ReplaceMode.Add;
    } else {
      const [categoryAxis, valueAxis] = isYCategory ? [oneYAxis, oneXAxis] : [oneXAxis, oneYAxis];
      categoryAxis.type = "category";
      categoryAxis.data = ids.map((id) => id.name);
      valueAxis.type = "value";
      valueAxis.data = [];
      series.length = 1;
      series[0].data.length = ids.length;
      echarts2.replaceMode = ReplaceMode.Replace;
    }
  }
  const meta2d = pen.calculative.canvas.parent;
  meta2d.setValue({ id: pen.id, echarts: echarts2 }, { render: false, doEvent: false });
}
function onRenderPenRaw(pen) {
  var _a, _b;
  const img = new Image();
  img.src = (_b = (_a = pen.calculative.singleton) == null ? void 0 : _a.echart) == null ? void 0 : _b.getDataURL({
    pixelRatio: 2
  });
  pen.calculative.img = img;
}
function updateOption(_option, ratio) {
  const option = deepClone(_option);
  if (option.dataZoom) {
    let props = ["right", "top", "width", "height", "left", "bottom"];
    for (let i = 0; i < props.length; i++) {
      option.dataZoom.forEach((item) => {
        if (!isNaN(item[props[i]])) {
          item[props[i]] *= ratio;
        }
      });
    }
  }
  deepSetValue(option, keyWords, ratio);
  return option;
}
function dotNotationToObject(dotNotationObj, pen) {
  const result = {};
  Object.keys(dotNotationObj).forEach((dotNotationStr) => {
    const keys = dotNotationStr.split(".");
    let current = result;
    keys.forEach((key, index) => {
      const isArrayIndex = !isNaN(parseInt(key));
      if (index === 6) {
        let _key = keys.slice(0, 7).join(".");
        setter(pen, dotNotationStr, dotNotationObj[dotNotationStr]);
        let value4 = getter(pen, _key);
        current[keys[index]] = value4;
      } else if (index > 6) {
        return;
      } else if (index === keys.length - 1) {
        if (isArrayIndex) {
          if (!Array.isArray(current)) {
            current = [];
          }
          current[parseInt(key)] = dotNotationObj[dotNotationStr];
        } else {
          current[key] = dotNotationObj[dotNotationStr];
        }
      } else {
        if (isArrayIndex) {
          const arrayIndex = parseInt(key);
          if (!Array.isArray(current)) {
            if (!current[keys[index - 1]]) {
            }
          }
          if (!current[arrayIndex]) {
            current[arrayIndex] = {};
          }
          if (Array.isArray(current)) {
            for (let i = 0; i < parseInt(key); i++) {
              if (!current[i]) {
                current[i] = {};
              }
            }
          }
          current = current[arrayIndex];
        } else {
          if (!current[key]) {
            if (key === "series") {
              current[key] = [];
            } else {
              current[key] = {};
            }
          }
          current = current[key];
        }
      }
    });
  });
  return result;
}

// node_modules/@meta2d/chart-diagram/src/highcharts.js
function highcharts(pen) {
  var _a;
  const Highcharts = globalThis.Highcharts;
  if (!Highcharts) {
    return;
  }
  if (typeof pen.highcharts === "string") {
    try {
      pen.highcharts = JSON.parse(pen.highcharts.option);
    } catch (e) {
    }
  }
  if (!pen.highcharts) {
    return;
  }
  if (!pen.onDestroy) {
    pen.onDestroy = destory2;
    pen.onMove = move2;
    pen.onResize = resize2;
    pen.onRotate = move2;
    pen.onValue = value2;
    pen.onBeforeValue = beforeValue2;
    pen.onRenderPenRaw = onRenderPenRaw2;
  }
  if (!pen.calculative.singleton) {
    pen.calculative.singleton = {};
  }
  const path = new Path2D();
  const worldRect = pen.calculative.worldRect;
  if (!pen.calculative.singleton.div) {
    const div = document.createElement("div");
    div.style.position = "absolute";
    div.style.outline = "none";
    div.style.left = "-9999px";
    div.style.top = "-9999px";
    div.style.width = worldRect.width + "px";
    div.style.height = worldRect.height + "px";
    div.style.minWidth = "100px";
    div.style.minHeight = "100px";
    div.id = pen.id;
    document.body.appendChild(div);
    pen.calculative.singleton.div = div;
    setTimeout(() => {
      pen.calculative.singleton.highchart = Highcharts.chart(pen.id, pen.highcharts.option);
      const xml = pen.calculative.singleton.highchart.getSVG();
      const image = new Image();
      image.src = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(xml)));
      pen.calculative.img = image;
    });
    (_a = pen.calculative.canvas.externalElements) == null ? void 0 : _a.parentElement.appendChild(div);
    setElemPosition(pen, div);
  }
  if (pen.calculative.patchFlags && pen.calculative.singleton.div) {
    setElemPosition(pen, pen.calculative.singleton.div);
  }
  return path;
}
function destory2(pen) {
  if (pen.calculative.singleton && pen.calculative.singleton.div) {
    pen.calculative.singleton.div.remove();
    pen.calculative.singleton.highchart.destroy();
    delete pen.calculative.singleton.div;
    delete pen.calculative.singleton.highchart;
  }
}
function move2(pen) {
  if (!pen.calculative.singleton.div) {
    return;
  }
  setElemPosition(pen, pen.calculative.singleton.div);
}
function resize2(pen) {
  if (!pen.calculative.singleton.div) {
    return;
  }
  setElemPosition(pen, pen.calculative.singleton.div);
  setTimeout(() => {
    pen.calculative.singleton.highchart.reflow();
  }, 100);
}
function value2(pen) {
  if (!pen.calculative.singleton.div) {
    return;
  }
  setElemPosition(pen, pen.calculative.singleton.div);
}
function beforeValue2(pen, value4) {
  if (value4.highcharts) {
    const chart = pen.calculative.singleton.highchart;
    chart.update(value4.highcharts.option);
    return value4;
  } else if (!value4.dataX && !value4.dataY) {
    return value4;
  }
  const highcharts2 = pen.highcharts;
  const max = highcharts2.max;
  let x = value4.dataX;
  let y = value4.dataY;
  const length = highcharts2.option.series.length;
  if (!value4.overwrite) {
    let xs = [];
    let ys = null;
    let isCategory = false;
    if (x) {
      if (!Array.isArray(x)) {
        x = [x];
      }
      const xAxis = highcharts2.option.xAxis;
      const xData = Array.isArray(xAxis) ? xAxis[0].categories : xAxis.categories;
      if (xData) {
        xData.push(...x);
        xData.splice(0, xData.length - max);
        isCategory = true;
      }
      xs = [...x];
    }
    if (y) {
      if (length === 1) {
        if (!Array.isArray(y)) {
          y = [y];
        }
        ys = [y];
      } else {
        ys = [];
        highcharts2.option.series.forEach((serie, index) => {
          if (!Array.isArray(y[index])) {
            y[index] = [y[index]];
          }
          ys.push(y[index]);
        });
      }
    }
    if (ys) {
      const chart = pen.calculative.singleton.highchart;
      chart.series.forEach((serie, index) => {
        ys[index].forEach((y2, index2) => {
          let shift = false;
          if (max && serie.data.length >= max) {
            shift = true;
          }
          const point = isCategory || xs[index2] == void 0 ? y2 : [xs[index2], y2];
          serie.addPoint(point, true, shift);
        });
      });
    }
  } else {
    if (x) {
      highcharts2.option.xAxis.categories = x;
      highcharts2.option.xAxis.categories.splice(0, highcharts2.option.xAxis.categories.length - max);
    }
    if (y) {
      if (length === 1) {
        highcharts2.option.series[0].data = y;
        highcharts2.option.series[0].data.splice(0, highcharts2.option.series[0].data.length - max);
      } else {
        highcharts2.option.series.forEach((serie, index) => {
          serie.data = y[index];
          serie.data.splice(0, serie.data.length - max);
        });
      }
    }
    const chart = pen.calculative.singleton.highchart;
    chart.update(highcharts2.option);
  }
  delete value4.dataX;
  delete value4.dataY;
  delete value4.overwrite;
  return Object.assign(value4, { highcharts: highcharts2 });
}
function onRenderPenRaw2(pen) {
  var _a;
  if (!((_a = pen.calculative) == null ? void 0 : _a.singleton)) {
    return;
  }
  const xml = pen.calculative.singleton.highchart.getSVG();
  const image = new Image();
  image.src = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(xml)));
  pen.calculative.img = image;
}

// node_modules/@meta2d/chart-diagram/src/LightningChart.js
function lightningCharts(pen) {
  let lightningChart = globalThis.lcjs;
  if (!pen.lightningCharts || !lightningChart) {
    return;
  }
  if (typeof pen.lightningCharts === "string") {
    try {
      pen.lightningCharts = JSON.parse(pen.lightningCharts);
    } catch (e) {
    }
  }
  if (!pen.lightningCharts) {
    return;
  }
  if (!pen.onDestroy) {
    pen.onDestroy = destory3;
    pen.onMove = move3;
    pen.onResize = resize3;
    pen.onRotate = move3;
    pen.onValue = value3;
    pen.onRenderPenRaw = onRenderPenRaw3;
  }
  const path = new Path2D();
  const worldRect = pen.calculative.worldRect;
  if (!pen.calculative.singleton) {
    pen.calculative.singleton = {};
  }
  if (!pen.calculative.singleton.div) {
    const div = document.createElement("div");
    div.style.position = "absolute";
    div.style.outline = "none";
    div.style.left = "-9999px";
    div.style.top = "-9999px";
    div.style.width = worldRect.width + "px";
    div.style.height = worldRect.height + "px";
    div.id = pen.id;
    document.body.appendChild(div);
    pen.calculative.singleton.div = div;
    setTimeout(() => {
      setLightningCharts(pen);
    }, 100);
    setTimeout(() => {
      pen.calculative.canvas.externalElements && pen.calculative.canvas.externalElements.parentElement.appendChild(div);
      setElemPosition(pen, div);
      const img = new Image();
      img.src = pen.calculative.singleton.div.children[0].toDataURL();
      pen.calculative.img = img;
    }, 400);
  }
  if (pen.calculative.patchFlags && pen.calculative.singleton.div) {
    setElemPosition(pen, pen.calculative.singleton.div);
  }
  return path;
}
function colorRgb(bcolor) {
  let color = bcolor.toLowerCase();
  const pattern = /^#([0-9|a-f]{3}|[0-9|a-f]{6})$/;
  const pattern2 = /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;
  if (color && pattern.test(color)) {
    if (color.length == 4) {
      color = "#" + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
    }
    var colorNew = [];
    for (var i = 1; i < 7; i += 2) {
      colorNew.push(parseInt("0x" + color.slice(i, i + 2)));
    }
    return colorNew;
  } else if (color && pattern2.test(color)) {
    const first = color.match(/\(([^)]*)\)/)[1];
    let arr = first.split(",").map((item) => {
      return parseInt(item);
    });
    return arr;
  }
  return color;
}
function setLightningCharts(pen) {
  const { lightningChart, PieChartTypes, LegendBoxBuilders, SliceLabelFormatters, Themes, GaugeChartTypes, SolidLine, SolidFill, ColorRGBA, UIOrigins, emptyLine, AutoCursorModes, AxisScrollStrategies, AxisTickStrategies, UIElementBuilders } = lcjs;
  const data = pen.lightningCharts.option.data;
  const title = pen.lightningCharts.option.title || "Title";
  const theme = Themes[pen.lightningCharts.option.theme || "lightNew"];
  pen.calculative.singleton.lightningChart = lightningChart();
  switch (pen.lightningCharts.option.type) {
    case "line":
      const charts = pen.calculative.singleton.lightningChart.ChartXY({
        container: pen.id
      }).setTitle(title);
      data.forEach((item) => {
        charts.addLineSeries().setName(item.name).add(item.data);
      });
      break;
    case "bar":
      const lc = pen.calculative.singleton.lightningChart;
      let barChart;
      {
        barChart = (options) => {
          const figureThickness = 10;
          const figureGap = figureThickness * 0.25;
          const groupGap = figureGap * 3;
          const groups = [];
          const categories2 = [];
          const chart2 = lc.ChartXY(options).setTitle(title).setAutoCursorMode(AutoCursorModes.onHover).setMouseInteractions(false).setPadding({ bottom: 30 });
          const axisX = chart2.getDefaultAxisX().setMouseInteractions(false).setScrollStrategy(void 0).setTickStrategy(AxisTickStrategies.Empty);
          const axisY = chart2.getDefaultAxisY().setMouseInteractions(false).setTitle(pen.lightningCharts.option.yTitle).setInterval(0, 70).setScrollStrategy(AxisScrollStrategies.fitting);
          chart2.setAutoCursor((cursor) => cursor.disposePointMarker().disposeTickMarkerX().disposeTickMarkerY().setGridStrokeXStyle(emptyLine).setGridStrokeYStyle(emptyLine).setResultTable((table) => {
            table.setOrigin(UIOrigins.CenterBottom);
          }));
          const createSeriesForCategory = (category) => {
            const series = chart2.addRectangleSeries();
            series.setCursorResultTableFormatter((builder, series2, figure) => {
              let entry = {
                name: category.name,
                value: category.data[category.figures.indexOf(figure)]
              };
              return builder.addRow("Department:", entry.name).addRow("# of employees:", String(entry.value));
            });
            return series;
          };
          const legendBox = chart2.addLegendBox(LegendBoxBuilders.VerticalLegendBox).setAutoDispose({
            type: "max-width",
            maxWidth: 0.2
          });
          const redraw = () => {
            let x = 0;
            for (let groupIndex = 0; groupIndex < groups.length; groupIndex++) {
              const group = groups[groupIndex];
              const xStart = x;
              for (const category of categories2) {
                const value4 = category.data[groupIndex];
                if (value4 !== void 0) {
                  const figure = category.figures[groupIndex];
                  figure.setDimensions({
                    x,
                    y: 0,
                    width: figureThickness,
                    height: value4
                  });
                  x += figureThickness + figureGap;
                }
              }
              group.tick.setValue((xStart + x - figureGap) / 2);
              x += groupGap;
            }
            axisX.setInterval(-(groupGap + figureGap), x);
          };
          const addGroups = (names) => {
            for (const name of names)
              groups.push({
                name,
                tick: axisX.addCustomTick(UIElementBuilders.AxisTick).setGridStrokeLength(0).setTextFormatter((_) => name)
              });
          };
          const addCategory = (entry) => {
            const series = createSeriesForCategory(entry).setName(entry.name);
            entry.figures = entry.data.map((value4) => series.add({ x: 0, y: 0, width: 0, height: 0 }));
            legendBox.add(series);
            categories2.push(entry);
            redraw();
          };
          return {
            addCategory,
            addGroups
          };
        };
      }
      const chart = barChart({
        theme,
        container: pen.id
      });
      chart.addGroups(pen.lightningCharts.option.groups);
      const categories = pen.lightningCharts.option.categories;
      data.forEach((data2, i) => chart.addCategory({
        name: categories[i],
        data: data2
      }));
      break;
    case "pie":
      const pie = pen.calculative.singleton.lightningChart.Pie({
        theme,
        container: pen.id
      }).setTitle(title).setAnimationsEnabled(true).setMultipleSliceExplosion(true);
      const slices = data.map((item) => pie.addSlice(item.name, item.value));
      pie.setInnerRadius(pen.lightningCharts.option.innerRadius || 0).setLabelFormatter(SliceLabelFormatters.NamePlusRelativeValue);
      pie.addLegendBox(LegendBoxBuilders.VerticalLegendBox).setAutoDispose({
        type: "max-width",
        maxWidth: 0.3
      }).add(pie);
      break;
    case "gauge":
      const gauge = pen.calculative.singleton.lightningChart.Gauge({
        theme,
        container: pen.id
      }).setTitle(title).setThickness(20).setAngleInterval(pen.lightningCharts.option.startAngle || 225, pen.lightningCharts.option.endAngle || -45);
      let colorArry = colorRgb(pen.lightningCharts.option.background);
      const slice = gauge.getDefaultSlice().setInterval(pen.lightningCharts.option.min || 0, pen.lightningCharts.option.max || 100).setValue(data).setFillStyle(new SolidFill({
        color: ColorRGBA(colorArry[0], colorArry[1], colorArry[2])
      }));
      break;
  }
}
function destory3(pen) {
  if (pen.calculative.singleton && pen.calculative.singleton.div) {
    pen.calculative.singleton.div.remove();
    delete pen.calculative.singleton.div;
    delete pen.calculative.singleton.lightningChart;
  }
}
function move3(pen) {
  if (!pen.calculative.singleton.div) {
    return;
  }
  setElemPosition(pen, pen.calculative.singleton.div);
}
function resize3(pen) {
  if (!pen.calculative.singleton.div) {
    return;
  }
  setElemPosition(pen, pen.calculative.singleton.div);
}
function value3(pen) {
  if (!pen.calculative.singleton.div) {
    return;
  }
  setLightningCharts(pen);
  setElemPosition(pen, pen.calculative.singleton.div);
}
function onRenderPenRaw3(pen) {
  var _a;
  if (!((_a = pen.calculative) == null ? void 0 : _a.singleton)) {
    return;
  }
  const img = new Image();
  img.src = pen.calculative.singleton.div.children[0].toDataURL();
  pen.calculative.img = img;
}

// node_modules/@meta2d/chart-diagram/src/register.js
function register2(_echarts) {
  _echarts && (globalThis.echarts = _echarts);
  register({ echarts });
}
function registerHighcharts(_highcharts) {
  _highcharts && (globalThis.Highcharts = _highcharts);
  register({ highcharts });
}
function registerLightningChart(_lightningCharts) {
  _lightningCharts && (globalThis.lcjs = _lightningCharts);
  register({ lightningCharts });
}
export {
  ReplaceMode,
  echarts,
  highcharts,
  initEvent,
  lightningCharts,
  register2 as register,
  registerHighcharts,
  registerLightningChart,
  setEchartsOption
};
//# sourceMappingURL=@meta2d_chart-diagram.js.map
