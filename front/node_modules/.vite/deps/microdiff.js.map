{
  "version": 3,
  "sources": ["../../microdiff/dist/index.js"],
  "sourcesContent": ["const richTypes = { Date: true, RegExp: true, String: true, Number: true };\nexport default function diff(obj, newObj, options = { cyclesFix: true }, _stack = []) {\n    let diffs = [];\n    const isObjArray = Array.isArray(obj);\n    for (const key in obj) {\n        const objKey = obj[key];\n        const path = isObjArray ? +key : key;\n        if (!(key in newObj)) {\n            diffs.push({\n                type: \"REMOVE\",\n                path: [path],\n                oldValue: obj[key],\n            });\n            continue;\n        }\n        const newObjKey = newObj[key];\n        const areCompatibleObjects = typeof objKey === \"object\" &&\n            typeof newObjKey === \"object\" &&\n            Array.isArray(objKey) === Array.isArray(newObjKey);\n        if (objKey &&\n            newObjKey &&\n            areCompatibleObjects &&\n            !richTypes[Object.getPrototypeOf(objKey)?.constructor?.name] &&\n            (!options.cyclesFix || !_stack.includes(objKey))) {\n            diffs.push.apply(diffs, diff(objKey, newObjKey, options, options.cyclesFix ? _stack.concat([objKey]) : []).map((difference) => {\n                difference.path.unshift(path);\n                return difference;\n            }));\n        }\n        else if (objKey !== newObjKey &&\n            // treat NaN values as equivalent\n            !(Number.isNaN(objKey) && Number.isNaN(newObjKey)) &&\n            !(areCompatibleObjects &&\n                (isNaN(objKey)\n                    ? objKey + \"\" === newObjKey + \"\"\n                    : +objKey === +newObjKey))) {\n            diffs.push({\n                path: [path],\n                type: \"CHANGE\",\n                value: newObjKey,\n                oldValue: objKey,\n            });\n        }\n    }\n    const isNewObjArray = Array.isArray(newObj);\n    for (const key in newObj) {\n        if (!(key in obj)) {\n            diffs.push({\n                type: \"CREATE\",\n                path: [isNewObjArray ? +key : key],\n                value: newObj[key],\n            });\n        }\n    }\n    return diffs;\n}\n"],
  "mappings": ";;;AAAA,IAAM,YAAY,EAAE,MAAM,MAAM,QAAQ,MAAM,QAAQ,MAAM,QAAQ,KAAK;AAC1D,SAAR,KAAsB,KAAK,QAAQ,UAAU,EAAE,WAAW,KAAK,GAAG,SAAS,CAAC,GAAG;AADtF;AAEI,MAAI,QAAQ,CAAC;AACb,QAAM,aAAa,MAAM,QAAQ,GAAG;AACpC,aAAW,OAAO,KAAK;AACnB,UAAM,SAAS,IAAI,GAAG;AACtB,UAAM,OAAO,aAAa,CAAC,MAAM;AACjC,QAAI,EAAE,OAAO,SAAS;AAClB,YAAM,KAAK;AAAA,QACP,MAAM;AAAA,QACN,MAAM,CAAC,IAAI;AAAA,QACX,UAAU,IAAI,GAAG;AAAA,MACrB,CAAC;AACD;AAAA,IACJ;AACA,UAAM,YAAY,OAAO,GAAG;AAC5B,UAAM,uBAAuB,OAAO,WAAW,YAC3C,OAAO,cAAc,YACrB,MAAM,QAAQ,MAAM,MAAM,MAAM,QAAQ,SAAS;AACrD,QAAI,UACA,aACA,wBACA,CAAC,WAAU,kBAAO,eAAe,MAAM,MAA5B,mBAA+B,gBAA/B,mBAA4C,IAAI,MAC1D,CAAC,QAAQ,aAAa,CAAC,OAAO,SAAS,MAAM,IAAI;AAClD,YAAM,KAAK,MAAM,OAAO,KAAK,QAAQ,WAAW,SAAS,QAAQ,YAAY,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,eAAe;AAC3H,mBAAW,KAAK,QAAQ,IAAI;AAC5B,eAAO;AAAA,MACX,CAAC,CAAC;AAAA,IACN,WACS,WAAW;AAAA,IAEhB,EAAE,OAAO,MAAM,MAAM,KAAK,OAAO,MAAM,SAAS,MAChD,EAAE,yBACG,MAAM,MAAM,IACP,SAAS,OAAO,YAAY,KAC5B,CAAC,WAAW,CAAC,aAAa;AACpC,YAAM,KAAK;AAAA,QACP,MAAM,CAAC,IAAI;AAAA,QACX,MAAM;AAAA,QACN,OAAO;AAAA,QACP,UAAU;AAAA,MACd,CAAC;AAAA,IACL;AAAA,EACJ;AACA,QAAM,gBAAgB,MAAM,QAAQ,MAAM;AAC1C,aAAW,OAAO,QAAQ;AACtB,QAAI,EAAE,OAAO,MAAM;AACf,YAAM,KAAK;AAAA,QACP,MAAM;AAAA,QACN,MAAM,CAAC,gBAAgB,CAAC,MAAM,GAAG;AAAA,QACjC,OAAO,OAAO,GAAG;AAAA,MACrB,CAAC;AAAA,IACL;AAAA,EACJ;AACA,SAAO;AACX;",
  "names": []
}
