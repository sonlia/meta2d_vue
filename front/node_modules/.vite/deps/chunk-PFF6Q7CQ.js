import {
  __commonJS,
  __publicField,
  __require,
  __toESM
} from "./chunk-USJHI7ER.js";

// node_modules/mqtt/dist/mqtt.min.js
var require_mqtt_min = __commonJS({
  "node_modules/mqtt/dist/mqtt.min.js"(exports, module) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).mqtt = e();
      }
    }(function() {
      return function() {
        return function e(t, r, n) {
          function i(s2, a) {
            if (!r[s2]) {
              if (!t[s2]) {
                var l = "function" == typeof __require && __require;
                if (!a && l)
                  return l(s2, true);
                if (o)
                  return o(s2, true);
                var u = new Error("Cannot find module '" + s2 + "'");
                throw u.code = "MODULE_NOT_FOUND", u;
              }
              var c = r[s2] = { exports: {} };
              t[s2][0].call(c.exports, function(e2) {
                return i(t[s2][1][e2] || e2);
              }, c, c.exports, e, t, r, n);
            }
            return r[s2].exports;
          }
          for (var o = "function" == typeof __require && __require, s = 0; s < n.length; s++)
            i(n[s]);
          return i;
        };
      }()({ 1: [function(e, t, r) {
        (function(r2, n) {
          (function() {
            "use strict";
            const i = e("events").EventEmitter, o = e("./store"), s = e("./topic-alias-recv"), a = e("./topic-alias-send"), l = e("mqtt-packet"), u = e("./default-message-id-provider"), c = e("readable-stream").Writable, h = e("inherits"), f = e("reinterval"), p = e("rfdc/default"), d = e("./validations"), g = e("xtend"), y = e("debug")("mqttjs:client"), b = r2 ? r2.nextTick : function(e2) {
              setTimeout(e2, 0);
            }, m = n.setImmediate || function(e2) {
              b(e2);
            }, v = { keepalive: 60, reschedulePings: true, protocolId: "MQTT", protocolVersion: 4, reconnectPeriod: 1e3, connectTimeout: 3e4, clean: true, resubscribe: true }, w = { 0: "", 1: "Unacceptable protocol version", 2: "Identifier rejected", 3: "Server unavailable", 4: "Bad username or password", 5: "Not authorized", 16: "No matching subscribers", 17: "No subscription existed", 128: "Unspecified error", 129: "Malformed Packet", 130: "Protocol Error", 131: "Implementation specific error", 132: "Unsupported Protocol Version", 133: "Client Identifier not valid", 134: "Bad User Name or Password", 135: "Not authorized", 136: "Server unavailable", 137: "Server busy", 138: "Banned", 139: "Server shutting down", 140: "Bad authentication method", 141: "Keep Alive timeout", 142: "Session taken over", 143: "Topic Filter invalid", 144: "Topic Name invalid", 145: "Packet identifier in use", 146: "Packet Identifier not found", 147: "Receive Maximum exceeded", 148: "Topic Alias invalid", 149: "Packet too large", 150: "Message rate too high", 151: "Quota exceeded", 152: "Administrative action", 153: "Payload format invalid", 154: "Retain not supported", 155: "QoS not supported", 156: "Use another server", 157: "Server moved", 158: "Shared Subscriptions not supported", 159: "Connection rate exceeded", 160: "Maximum connect time", 161: "Subscription Identifiers not supported", 162: "Wildcard Subscriptions not supported" };
            function _(e2, t2) {
              let r3;
              t2.properties && (r3 = t2.properties.topicAlias);
              let n2 = t2.topic.toString();
              if (0 === n2.length) {
                if (void 0 === r3)
                  return new Error("Unregistered Topic Alias");
                if (void 0 === (n2 = e2.topicAliasSend.getTopicByAlias(r3)))
                  return new Error("Unregistered Topic Alias");
                t2.topic = n2;
              }
              r3 && delete t2.properties.topicAlias;
            }
            function k(e2, t2, r3) {
              y("sendPacket :: packet: %O", t2), y("sendPacket :: emitting `packetsend`"), e2.emit("packetsend", t2), y("sendPacket :: writing to stream");
              const n2 = l.writeToStream(t2, e2.stream, e2.options);
              y("sendPacket :: writeToStream result %s", n2), !n2 && r3 && r3 !== E ? (y("sendPacket :: handle events on `drain` once through callback."), e2.stream.once("drain", r3)) : r3 && (y("sendPacket :: invoking cb"), r3());
            }
            function S(e2, t2, r3, n2) {
              y("storeAndSend :: store packet with cmd %s to outgoingStore", t2.cmd);
              let i2, o2 = t2;
              if ("publish" === o2.cmd && (o2 = p(t2), i2 = _(e2, o2)))
                return r3 && r3(i2);
              e2.outgoingStore.put(o2, function(i3) {
                if (i3)
                  return r3 && r3(i3);
                n2(), k(e2, t2, r3);
              });
            }
            function E(e2) {
              y("nop ::", e2);
            }
            function C(e2, t2) {
              let r3;
              const n2 = this;
              if (!(this instanceof C))
                return new C(e2, t2);
              for (r3 in this.options = t2 || {}, v)
                void 0 === this.options[r3] ? this.options[r3] = v[r3] : this.options[r3] = t2[r3];
              y("MqttClient :: options.protocol", t2.protocol), y("MqttClient :: options.protocolVersion", t2.protocolVersion), y("MqttClient :: options.username", t2.username), y("MqttClient :: options.keepalive", t2.keepalive), y("MqttClient :: options.reconnectPeriod", t2.reconnectPeriod), y("MqttClient :: options.rejectUnauthorized", t2.rejectUnauthorized), y("MqttClient :: options.topicAliasMaximum", t2.topicAliasMaximum), this.options.clientId = "string" == typeof t2.clientId ? t2.clientId : "mqttjs_" + Math.random().toString(16).substr(2, 8), y("MqttClient :: clientId", this.options.clientId), this.options.customHandleAcks = 5 === t2.protocolVersion && t2.customHandleAcks ? t2.customHandleAcks : function() {
                arguments[3](0);
              }, this.streamBuilder = e2, this.messageIdProvider = void 0 === this.options.messageIdProvider ? new u() : this.options.messageIdProvider, this.outgoingStore = t2.outgoingStore || new o(), this.incomingStore = t2.incomingStore || new o(), this.queueQoSZero = void 0 === t2.queueQoSZero || t2.queueQoSZero, this._resubscribeTopics = {}, this.messageIdToTopic = {}, this.pingTimer = null, this.connected = false, this.disconnecting = false, this.queue = [], this.connackTimer = null, this.reconnectTimer = null, this._storeProcessing = false, this._packetIdsDuringStoreProcessing = {}, this._storeProcessingQueue = [], this.outgoing = {}, this._firstConnection = true, t2.topicAliasMaximum > 0 && (t2.topicAliasMaximum > 65535 ? y("MqttClient :: options.topicAliasMaximum is out of range") : this.topicAliasRecv = new s(t2.topicAliasMaximum)), this.on("connect", function() {
                const e3 = this.queue;
                y("connect :: sending queued packets"), function t3() {
                  const r4 = e3.shift();
                  y("deliver :: entry %o", r4);
                  let i2 = null;
                  if (!r4)
                    return void n2._resubscribe();
                  i2 = r4.packet, y("deliver :: call _sendPacket for %o", i2);
                  let o2 = true;
                  i2.messageId && 0 !== i2.messageId && (n2.messageIdProvider.register(i2.messageId) || (o2 = false)), o2 ? n2._sendPacket(i2, function(e4) {
                    r4.cb && r4.cb(e4), t3();
                  }) : (y("messageId: %d has already used. The message is skipped and removed.", i2.messageId), t3());
                }();
              }), this.on("close", function() {
                y("close :: connected set to `false`"), this.connected = false, y("close :: clearing connackTimer"), clearTimeout(this.connackTimer), y("close :: clearing ping timer"), null !== n2.pingTimer && (n2.pingTimer.clear(), n2.pingTimer = null), this.topicAliasRecv && this.topicAliasRecv.clear(), y("close :: calling _setupReconnect"), this._setupReconnect();
              }), i.call(this), y("MqttClient :: setting up stream"), this._setupStream();
            }
            h(C, i), C.prototype._setupStream = function() {
              const e2 = this, t2 = new c(), r3 = l.parser(this.options);
              let n2 = null;
              const i2 = [];
              function o2() {
                if (i2.length)
                  b(s2);
                else {
                  const e3 = n2;
                  n2 = null, e3();
                }
              }
              function s2() {
                y("work :: getting next packet in queue");
                const t3 = i2.shift();
                if (t3)
                  y("work :: packet pulled from queue"), e2._handlePacket(t3, o2);
                else {
                  y("work :: no packets in queue");
                  const e3 = n2;
                  n2 = null, y("work :: done flag is %s", !!e3), e3 && e3();
                }
              }
              y("_setupStream :: calling method to clear reconnect"), this._clearReconnect(), y("_setupStream :: using streamBuilder provided to client to create stream"), this.stream = this.streamBuilder(this), r3.on("packet", function(e3) {
                y("parser :: on packet push to packets array."), i2.push(e3);
              }), t2._write = function(e3, t3, i3) {
                n2 = i3, y("writable stream :: parsing buffer"), r3.parse(e3), s2();
              }, y("_setupStream :: pipe stream to writable stream"), this.stream.pipe(t2), this.stream.on("error", function(t3) {
                y("streamErrorHandler :: error", t3.message), t3.code ? (y("streamErrorHandler :: emitting error"), e2.emit("error", t3)) : E(t3);
              }), this.stream.on("close", function() {
                var t3;
                y("(%s)stream :: on close", e2.options.clientId), (t3 = e2.outgoing) && (y("flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function"), Object.keys(t3).forEach(function(e3) {
                  t3[e3].volatile && "function" == typeof t3[e3].cb && (t3[e3].cb(new Error("Connection closed")), delete t3[e3]);
                })), y("stream: emit close to MqttClient"), e2.emit("close");
              }), y("_setupStream: sending packet `connect`");
              const a2 = Object.create(this.options);
              if (a2.cmd = "connect", this.topicAliasRecv && (a2.properties || (a2.properties = {}), this.topicAliasRecv && (a2.properties.topicAliasMaximum = this.topicAliasRecv.max)), k(this, a2), r3.on("error", this.emit.bind(this, "error")), this.options.properties) {
                if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData)
                  return e2.end(() => this.emit("error", new Error("Packet has no Authentication Method"))), this;
                if (this.options.properties.authenticationMethod && this.options.authPacket && "object" == typeof this.options.authPacket) {
                  k(this, g({ cmd: "auth", reasonCode: 0 }, this.options.authPacket));
                }
              }
              this.stream.setMaxListeners(1e3), clearTimeout(this.connackTimer), this.connackTimer = setTimeout(function() {
                y("!!connectTimeout hit!! Calling _cleanUp with force `true`"), e2._cleanUp(true);
              }, this.options.connectTimeout);
            }, C.prototype._handlePacket = function(e2, t2) {
              const r3 = this.options;
              if (5 === r3.protocolVersion && r3.properties && r3.properties.maximumPacketSize && r3.properties.maximumPacketSize < e2.length)
                return this.emit("error", new Error("exceeding packets size " + e2.cmd)), this.end({ reasonCode: 149, properties: { reasonString: "Maximum packet size was exceeded" } }), this;
              switch (y("_handlePacket :: emitting packetreceive"), this.emit("packetreceive", e2), e2.cmd) {
                case "publish":
                  this._handlePublish(e2, t2);
                  break;
                case "puback":
                case "pubrec":
                case "pubcomp":
                case "suback":
                case "unsuback":
                  this._handleAck(e2), t2();
                  break;
                case "pubrel":
                  this._handlePubrel(e2, t2);
                  break;
                case "connack":
                  this._handleConnack(e2), t2();
                  break;
                case "auth":
                  this._handleAuth(e2), t2();
                  break;
                case "pingresp":
                  this._handlePingresp(e2), t2();
                  break;
                case "disconnect":
                  this._handleDisconnect(e2), t2();
              }
            }, C.prototype._checkDisconnecting = function(e2) {
              return this.disconnecting && (e2 && e2 !== E ? e2(new Error("client disconnecting")) : this.emit("error", new Error("client disconnecting"))), this.disconnecting;
            }, C.prototype.publish = function(e2, t2, r3, n2) {
              y("publish :: message `%s` to topic `%s`", t2, e2);
              const i2 = this.options;
              "function" == typeof r3 && (n2 = r3, r3 = null);
              if (r3 = g({ qos: 0, retain: false, dup: false }, r3), this._checkDisconnecting(n2))
                return this;
              const o2 = this, s2 = function() {
                let s3 = 0;
                if ((1 === r3.qos || 2 === r3.qos) && null === (s3 = o2._nextId()))
                  return y("No messageId left"), false;
                const a2 = { cmd: "publish", topic: e2, payload: t2, qos: r3.qos, retain: r3.retain, messageId: s3, dup: r3.dup };
                switch (5 === i2.protocolVersion && (a2.properties = r3.properties), y("publish :: qos", r3.qos), r3.qos) {
                  case 1:
                  case 2:
                    o2.outgoing[a2.messageId] = { volatile: false, cb: n2 || E }, y("MqttClient:publish: packet cmd: %s", a2.cmd), o2._sendPacket(a2, void 0, r3.cbStorePut);
                    break;
                  default:
                    y("MqttClient:publish: packet cmd: %s", a2.cmd), o2._sendPacket(a2, n2, r3.cbStorePut);
                }
                return true;
              };
              return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !s2()) && this._storeProcessingQueue.push({ invoke: s2, cbStorePut: r3.cbStorePut, callback: n2 }), this;
            }, C.prototype.subscribe = function() {
              const e2 = this, t2 = new Array(arguments.length);
              for (let e3 = 0; e3 < arguments.length; e3++)
                t2[e3] = arguments[e3];
              const r3 = [];
              let n2 = t2.shift();
              const i2 = n2.resubscribe;
              let o2 = t2.pop() || E, s2 = t2.pop();
              const a2 = this.options.protocolVersion;
              delete n2.resubscribe, "string" == typeof n2 && (n2 = [n2]), "function" != typeof o2 && (s2 = o2, o2 = E);
              const l2 = d.validateTopics(n2);
              if (null !== l2)
                return m(o2, new Error("Invalid topic " + l2)), this;
              if (this._checkDisconnecting(o2))
                return y("subscribe: discconecting true"), this;
              const u2 = { qos: 0 };
              if (5 === a2 && (u2.nl = false, u2.rap = false, u2.rh = 0), s2 = g(u2, s2), Array.isArray(n2) ? n2.forEach(function(t3) {
                if (y("subscribe: array topic %s", t3), !Object.prototype.hasOwnProperty.call(e2._resubscribeTopics, t3) || e2._resubscribeTopics[t3].qos < s2.qos || i2) {
                  const e3 = { topic: t3, qos: s2.qos };
                  5 === a2 && (e3.nl = s2.nl, e3.rap = s2.rap, e3.rh = s2.rh, e3.properties = s2.properties), y("subscribe: pushing topic `%s` and qos `%s` to subs list", e3.topic, e3.qos), r3.push(e3);
                }
              }) : Object.keys(n2).forEach(function(t3) {
                if (y("subscribe: object topic %s", t3), !Object.prototype.hasOwnProperty.call(e2._resubscribeTopics, t3) || e2._resubscribeTopics[t3].qos < n2[t3].qos || i2) {
                  const e3 = { topic: t3, qos: n2[t3].qos };
                  5 === a2 && (e3.nl = n2[t3].nl, e3.rap = n2[t3].rap, e3.rh = n2[t3].rh, e3.properties = s2.properties), y("subscribe: pushing `%s` to subs list", e3), r3.push(e3);
                }
              }), !r3.length)
                return o2(null, []), this;
              const c2 = function() {
                const t3 = e2._nextId();
                if (null === t3)
                  return y("No messageId left"), false;
                const n3 = { cmd: "subscribe", subscriptions: r3, qos: 1, retain: false, dup: false, messageId: t3 };
                if (s2.properties && (n3.properties = s2.properties), e2.options.resubscribe) {
                  y("subscribe :: resubscribe true");
                  const t4 = [];
                  r3.forEach(function(r4) {
                    if (e2.options.reconnectPeriod > 0) {
                      const n4 = { qos: r4.qos };
                      5 === a2 && (n4.nl = r4.nl || false, n4.rap = r4.rap || false, n4.rh = r4.rh || 0, n4.properties = r4.properties), e2._resubscribeTopics[r4.topic] = n4, t4.push(r4.topic);
                    }
                  }), e2.messageIdToTopic[n3.messageId] = t4;
                }
                return e2.outgoing[n3.messageId] = { volatile: true, cb: function(e3, t4) {
                  if (!e3) {
                    const e4 = t4.granted;
                    for (let t5 = 0; t5 < e4.length; t5 += 1)
                      r3[t5].qos = e4[t5];
                  }
                  o2(e3, r3);
                } }, y("subscribe :: call _sendPacket"), e2._sendPacket(n3), true;
              };
              return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !c2()) && this._storeProcessingQueue.push({ invoke: c2, callback: o2 }), this;
            }, C.prototype.unsubscribe = function() {
              const e2 = this, t2 = new Array(arguments.length);
              for (let e3 = 0; e3 < arguments.length; e3++)
                t2[e3] = arguments[e3];
              let r3 = t2.shift(), n2 = t2.pop() || E, i2 = t2.pop();
              "string" == typeof r3 && (r3 = [r3]), "function" != typeof n2 && (i2 = n2, n2 = E);
              const o2 = d.validateTopics(r3);
              if (null !== o2)
                return m(n2, new Error("Invalid topic " + o2)), this;
              if (e2._checkDisconnecting(n2))
                return this;
              const s2 = function() {
                const t3 = e2._nextId();
                if (null === t3)
                  return y("No messageId left"), false;
                const o3 = { cmd: "unsubscribe", qos: 1, messageId: t3 };
                return "string" == typeof r3 ? o3.unsubscriptions = [r3] : Array.isArray(r3) && (o3.unsubscriptions = r3), e2.options.resubscribe && o3.unsubscriptions.forEach(function(t4) {
                  delete e2._resubscribeTopics[t4];
                }), "object" == typeof i2 && i2.properties && (o3.properties = i2.properties), e2.outgoing[o3.messageId] = { volatile: true, cb: n2 }, y("unsubscribe: call _sendPacket"), e2._sendPacket(o3), true;
              };
              return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !s2()) && this._storeProcessingQueue.push({ invoke: s2, callback: n2 }), this;
            }, C.prototype.end = function(e2, t2, r3) {
              const n2 = this;
              function i2() {
                y("end :: (%s) :: finish :: calling _cleanUp with force %s", n2.options.clientId, e2), n2._cleanUp(e2, () => {
                  y("end :: finish :: calling process.nextTick on closeStores"), b((function() {
                    y("end :: closeStores: closing incoming and outgoing stores"), n2.disconnected = true, n2.incomingStore.close(function(e3) {
                      n2.outgoingStore.close(function(t3) {
                        if (y("end :: closeStores: emitting end"), n2.emit("end"), r3) {
                          const n3 = e3 || t3;
                          y("end :: closeStores: invoking callback with args"), r3(n3);
                        }
                      });
                    }), n2._deferredReconnect && n2._deferredReconnect();
                  }).bind(n2));
                }, t2);
              }
              return y("end :: (%s)", this.options.clientId), null != e2 && "boolean" == typeof e2 || (r3 = t2 || E, t2 = e2, e2 = false, "object" != typeof t2 && (r3 = t2, t2 = null, "function" != typeof r3 && (r3 = E))), "object" != typeof t2 && (r3 = t2, t2 = null), y("end :: cb? %s", !!r3), r3 = r3 || E, this.disconnecting ? (r3(), this) : (this._clearReconnect(), this.disconnecting = true, !e2 && Object.keys(this.outgoing).length > 0 ? (y("end :: (%s) :: calling finish in 10ms once outgoing is empty", n2.options.clientId), this.once("outgoingEmpty", setTimeout.bind(null, i2, 10))) : (y("end :: (%s) :: immediately calling finish", n2.options.clientId), i2()), this);
            }, C.prototype.removeOutgoingMessage = function(e2) {
              const t2 = this.outgoing[e2] ? this.outgoing[e2].cb : null;
              return delete this.outgoing[e2], this.outgoingStore.del({ messageId: e2 }, function() {
                t2(new Error("Message removed"));
              }), this;
            }, C.prototype.reconnect = function(e2) {
              y("client reconnect");
              const t2 = this, r3 = function() {
                e2 ? (t2.options.incomingStore = e2.incomingStore, t2.options.outgoingStore = e2.outgoingStore) : (t2.options.incomingStore = null, t2.options.outgoingStore = null), t2.incomingStore = t2.options.incomingStore || new o(), t2.outgoingStore = t2.options.outgoingStore || new o(), t2.disconnecting = false, t2.disconnected = false, t2._deferredReconnect = null, t2._reconnect();
              };
              return this.disconnecting && !this.disconnected ? this._deferredReconnect = r3 : r3(), this;
            }, C.prototype._reconnect = function() {
              y("_reconnect: emitting reconnect to client"), this.emit("reconnect"), this.connected ? (this.end(() => {
                this._setupStream();
              }), y("client already connected. disconnecting first.")) : (y("_reconnect: calling _setupStream"), this._setupStream());
            }, C.prototype._setupReconnect = function() {
              const e2 = this;
              !e2.disconnecting && !e2.reconnectTimer && e2.options.reconnectPeriod > 0 ? (this.reconnecting || (y("_setupReconnect :: emit `offline` state"), this.emit("offline"), y("_setupReconnect :: set `reconnecting` to `true`"), this.reconnecting = true), y("_setupReconnect :: setting reconnectTimer for %d ms", e2.options.reconnectPeriod), e2.reconnectTimer = setInterval(function() {
                y("reconnectTimer :: reconnect triggered!"), e2._reconnect();
              }, e2.options.reconnectPeriod)) : y("_setupReconnect :: doing nothing...");
            }, C.prototype._clearReconnect = function() {
              y("_clearReconnect : clearing reconnect timer"), this.reconnectTimer && (clearInterval(this.reconnectTimer), this.reconnectTimer = null);
            }, C.prototype._cleanUp = function(e2, t2) {
              const r3 = arguments[2];
              if (t2 && (y("_cleanUp :: done callback provided for on stream close"), this.stream.on("close", t2)), y("_cleanUp :: forced? %s", e2), e2)
                0 === this.options.reconnectPeriod && this.options.clean && (n2 = this.outgoing) && (y("flush: queue exists? %b", !!n2), Object.keys(n2).forEach(function(e3) {
                  "function" == typeof n2[e3].cb && (n2[e3].cb(new Error("Connection closed")), delete n2[e3]);
                })), y("_cleanUp :: (%s) :: destroying stream", this.options.clientId), this.stream.destroy();
              else {
                const e3 = g({ cmd: "disconnect" }, r3);
                y("_cleanUp :: (%s) :: call _sendPacket with disconnect packet", this.options.clientId), this._sendPacket(e3, m.bind(null, this.stream.end.bind(this.stream)));
              }
              var n2;
              this.disconnecting || (y("_cleanUp :: client not disconnecting. Clearing and resetting reconnect."), this._clearReconnect(), this._setupReconnect()), null !== this.pingTimer && (y("_cleanUp :: clearing pingTimer"), this.pingTimer.clear(), this.pingTimer = null), t2 && !this.connected && (y("_cleanUp :: (%s) :: removing stream `done` callback `close` listener", this.options.clientId), this.stream.removeListener("close", t2), t2());
            }, C.prototype._sendPacket = function(e2, t2, r3) {
              y("_sendPacket :: (%s) ::  start", this.options.clientId), r3 = r3 || E, t2 = t2 || E;
              const n2 = function(e3, t3) {
                if (5 === e3.options.protocolVersion && "publish" === t3.cmd) {
                  let r4;
                  t3.properties && (r4 = t3.properties.topicAlias);
                  const n3 = t3.topic.toString();
                  if (e3.topicAliasSend)
                    if (r4) {
                      if (0 !== n3.length && (y("applyTopicAlias :: register topic: %s - alias: %d", n3, r4), !e3.topicAliasSend.put(n3, r4)))
                        return y("applyTopicAlias :: error out of range. topic: %s - alias: %d", n3, r4), new Error("Sending Topic Alias out of range");
                    } else
                      0 !== n3.length && (e3.options.autoAssignTopicAlias ? (r4 = e3.topicAliasSend.getAliasByTopic(n3)) ? (t3.topic = "", t3.properties = { ...t3.properties, topicAlias: r4 }, y("applyTopicAlias :: auto assign(use) topic: %s - alias: %d", n3, r4)) : (r4 = e3.topicAliasSend.getLruAlias(), e3.topicAliasSend.put(n3, r4), t3.properties = { ...t3.properties, topicAlias: r4 }, y("applyTopicAlias :: auto assign topic: %s - alias: %d", n3, r4)) : e3.options.autoUseTopicAlias && (r4 = e3.topicAliasSend.getAliasByTopic(n3)) && (t3.topic = "", t3.properties = { ...t3.properties, topicAlias: r4 }, y("applyTopicAlias :: auto use topic: %s - alias: %d", n3, r4)));
                  else if (r4)
                    return y("applyTopicAlias :: error out of range. topic: %s - alias: %d", n3, r4), new Error("Sending Topic Alias out of range");
                }
              }(this, e2);
              if (n2)
                t2(n2);
              else {
                if (!this.connected)
                  return "auth" === e2.cmd ? (this._shiftPingInterval(), void k(this, e2, t2)) : (y("_sendPacket :: client not connected. Storing packet offline."), void this._storePacket(e2, t2, r3));
                switch (this._shiftPingInterval(), e2.cmd) {
                  case "publish":
                    break;
                  case "pubrel":
                    return void S(this, e2, t2, r3);
                  default:
                    return void k(this, e2, t2);
                }
                switch (e2.qos) {
                  case 2:
                  case 1:
                    S(this, e2, t2, r3);
                    break;
                  case 0:
                  default:
                    k(this, e2, t2);
                }
                y("_sendPacket :: (%s) ::  end", this.options.clientId);
              }
            }, C.prototype._storePacket = function(e2, t2, r3) {
              y("_storePacket :: packet: %o", e2), y("_storePacket :: cb? %s", !!t2), r3 = r3 || E;
              let n2 = e2;
              if ("publish" === n2.cmd) {
                const r4 = _(this, n2 = p(e2));
                if (r4)
                  return t2 && t2(r4);
              }
              0 === (n2.qos || 0) && this.queueQoSZero || "publish" !== n2.cmd ? this.queue.push({ packet: n2, cb: t2 }) : n2.qos > 0 ? (t2 = this.outgoing[n2.messageId] ? this.outgoing[n2.messageId].cb : null, this.outgoingStore.put(n2, function(e3) {
                if (e3)
                  return t2 && t2(e3);
                r3();
              })) : t2 && t2(new Error("No connection to broker"));
            }, C.prototype._setupPingTimer = function() {
              y("_setupPingTimer :: keepalive %d (seconds)", this.options.keepalive);
              const e2 = this;
              !this.pingTimer && this.options.keepalive && (this.pingResp = true, this.pingTimer = f(function() {
                e2._checkPing();
              }, 1e3 * this.options.keepalive));
            }, C.prototype._shiftPingInterval = function() {
              this.pingTimer && this.options.keepalive && this.options.reschedulePings && this.pingTimer.reschedule(1e3 * this.options.keepalive);
            }, C.prototype._checkPing = function() {
              y("_checkPing :: checking ping..."), this.pingResp ? (y("_checkPing :: ping response received. Clearing flag and sending `pingreq`"), this.pingResp = false, this._sendPacket({ cmd: "pingreq" })) : (y("_checkPing :: calling _cleanUp with force true"), this._cleanUp(true));
            }, C.prototype._handlePingresp = function() {
              this.pingResp = true;
            }, C.prototype._handleConnack = function(e2) {
              y("_handleConnack");
              const t2 = this.options, r3 = 5 === t2.protocolVersion ? e2.reasonCode : e2.returnCode;
              if (clearTimeout(this.connackTimer), delete this.topicAliasSend, e2.properties) {
                if (e2.properties.topicAliasMaximum) {
                  if (e2.properties.topicAliasMaximum > 65535)
                    return void this.emit("error", new Error("topicAliasMaximum from broker is out of range"));
                  e2.properties.topicAliasMaximum > 0 && (this.topicAliasSend = new a(e2.properties.topicAliasMaximum));
                }
                e2.properties.serverKeepAlive && t2.keepalive && (t2.keepalive = e2.properties.serverKeepAlive, this._shiftPingInterval()), e2.properties.maximumPacketSize && (t2.properties || (t2.properties = {}), t2.properties.maximumPacketSize = e2.properties.maximumPacketSize);
              }
              if (0 === r3)
                this.reconnecting = false, this._onConnect(e2);
              else if (r3 > 0) {
                const e3 = new Error("Connection refused: " + w[r3]);
                e3.code = r3, this.emit("error", e3);
              }
            }, C.prototype._handleAuth = function(e2) {
              const t2 = this.options.protocolVersion, r3 = 5 === t2 ? e2.reasonCode : e2.returnCode;
              if (5 !== t2) {
                const e3 = new Error("Protocol error: Auth packets are only supported in MQTT 5. Your version:" + t2);
                return e3.code = r3, void this.emit("error", e3);
              }
              const n2 = this;
              this.handleAuth(e2, function(e3, t3) {
                if (e3)
                  n2.emit("error", e3);
                else if (24 === r3)
                  n2.reconnecting = false, n2._sendPacket(t3);
                else {
                  const t4 = new Error("Connection refused: " + w[r3]);
                  e3.code = r3, n2.emit("error", t4);
                }
              });
            }, C.prototype.handleAuth = function(e2, t2) {
              t2();
            }, C.prototype._handlePublish = function(e2, t2) {
              y("_handlePublish: packet %o", e2), t2 = void 0 !== t2 ? t2 : E;
              let r3 = e2.topic.toString();
              const n2 = e2.payload, i2 = e2.qos, o2 = e2.messageId, s2 = this, a2 = this.options, l2 = [0, 16, 128, 131, 135, 144, 145, 151, 153];
              if (5 === this.options.protocolVersion) {
                let t3;
                if (e2.properties && (t3 = e2.properties.topicAlias), void 0 !== t3)
                  if (0 === r3.length) {
                    if (!(t3 > 0 && t3 <= 65535))
                      return y("_handlePublish :: topic alias out of range. alias: %d", t3), void this.emit("error", new Error("Received Topic Alias is out of range"));
                    {
                      const e3 = this.topicAliasRecv.getTopicByAlias(t3);
                      if (!e3)
                        return y("_handlePublish :: unregistered topic alias. alias: %d", t3), void this.emit("error", new Error("Received unregistered Topic Alias"));
                      y("_handlePublish :: topic complemented by alias. topic: %s - alias: %d", r3 = e3, t3);
                    }
                  } else {
                    if (!this.topicAliasRecv.put(r3, t3))
                      return y("_handlePublish :: topic alias out of range. alias: %d", t3), void this.emit("error", new Error("Received Topic Alias is out of range"));
                    y("_handlePublish :: registered topic: %s - alias: %d", r3, t3);
                  }
              }
              switch (y("_handlePublish: qos %d", i2), i2) {
                case 2:
                  a2.customHandleAcks(r3, n2, e2, function(r4, n3) {
                    return r4 instanceof Error || (n3 = r4, r4 = null), r4 ? s2.emit("error", r4) : -1 === l2.indexOf(n3) ? s2.emit("error", new Error("Wrong reason code for pubrec")) : void (n3 ? s2._sendPacket({ cmd: "pubrec", messageId: o2, reasonCode: n3 }, t2) : s2.incomingStore.put(e2, function() {
                      s2._sendPacket({ cmd: "pubrec", messageId: o2 }, t2);
                    }));
                  });
                  break;
                case 1:
                  a2.customHandleAcks(r3, n2, e2, function(i3, a3) {
                    return i3 instanceof Error || (a3 = i3, i3 = null), i3 ? s2.emit("error", i3) : -1 === l2.indexOf(a3) ? s2.emit("error", new Error("Wrong reason code for puback")) : (a3 || s2.emit("message", r3, n2, e2), void s2.handleMessage(e2, function(e3) {
                      if (e3)
                        return t2 && t2(e3);
                      s2._sendPacket({ cmd: "puback", messageId: o2, reasonCode: a3 }, t2);
                    }));
                  });
                  break;
                case 0:
                  this.emit("message", r3, n2, e2), this.handleMessage(e2, t2);
                  break;
                default:
                  y("_handlePublish: unknown QoS. Doing nothing.");
              }
            }, C.prototype.handleMessage = function(e2, t2) {
              t2();
            }, C.prototype._handleAck = function(e2) {
              const t2 = e2.messageId, r3 = e2.cmd;
              let n2 = null;
              const i2 = this.outgoing[t2] ? this.outgoing[t2].cb : null, o2 = this;
              let s2;
              if (i2) {
                switch (y("_handleAck :: packet type", r3), r3) {
                  case "pubcomp":
                  case "puback": {
                    const r4 = e2.reasonCode;
                    r4 && r4 > 0 && 16 !== r4 && ((s2 = new Error("Publish error: " + w[r4])).code = r4, i2(s2, e2)), delete this.outgoing[t2], this.outgoingStore.del(e2, i2), this.messageIdProvider.deallocate(t2), this._invokeStoreProcessingQueue();
                    break;
                  }
                  case "pubrec": {
                    n2 = { cmd: "pubrel", qos: 2, messageId: t2 };
                    const r4 = e2.reasonCode;
                    r4 && r4 > 0 && 16 !== r4 ? ((s2 = new Error("Publish error: " + w[r4])).code = r4, i2(s2, e2)) : this._sendPacket(n2);
                    break;
                  }
                  case "suback":
                    delete this.outgoing[t2], this.messageIdProvider.deallocate(t2);
                    for (let r4 = 0; r4 < e2.granted.length; r4++)
                      if (0 != (128 & e2.granted[r4])) {
                        const e3 = this.messageIdToTopic[t2];
                        e3 && e3.forEach(function(e4) {
                          delete o2._resubscribeTopics[e4];
                        });
                      }
                    this._invokeStoreProcessingQueue(), i2(null, e2);
                    break;
                  case "unsuback":
                    delete this.outgoing[t2], this.messageIdProvider.deallocate(t2), this._invokeStoreProcessingQueue(), i2(null);
                    break;
                  default:
                    o2.emit("error", new Error("unrecognized packet type"));
                }
                this.disconnecting && 0 === Object.keys(this.outgoing).length && this.emit("outgoingEmpty");
              } else
                y("_handleAck :: Server sent an ack in error. Ignoring.");
            }, C.prototype._handlePubrel = function(e2, t2) {
              y("handling pubrel packet"), t2 = void 0 !== t2 ? t2 : E;
              const r3 = this, n2 = { cmd: "pubcomp", messageId: e2.messageId };
              r3.incomingStore.get(e2, function(e3, i2) {
                e3 ? r3._sendPacket(n2, t2) : (r3.emit("message", i2.topic, i2.payload, i2), r3.handleMessage(i2, function(e4) {
                  if (e4)
                    return t2(e4);
                  r3.incomingStore.del(i2, E), r3._sendPacket(n2, t2);
                }));
              });
            }, C.prototype._handleDisconnect = function(e2) {
              this.emit("disconnect", e2);
            }, C.prototype._nextId = function() {
              return this.messageIdProvider.allocate();
            }, C.prototype.getLastMessageId = function() {
              return this.messageIdProvider.getLastAllocated();
            }, C.prototype._resubscribe = function() {
              y("_resubscribe");
              const e2 = Object.keys(this._resubscribeTopics);
              if (!this._firstConnection && (this.options.clean || 5 === this.options.protocolVersion && !this.connackPacket.sessionPresent) && e2.length > 0)
                if (this.options.resubscribe)
                  if (5 === this.options.protocolVersion) {
                    y("_resubscribe: protocolVersion 5");
                    for (let t2 = 0; t2 < e2.length; t2++) {
                      const r3 = {};
                      r3[e2[t2]] = this._resubscribeTopics[e2[t2]], r3.resubscribe = true, this.subscribe(r3, { properties: r3[e2[t2]].properties });
                    }
                  } else
                    this._resubscribeTopics.resubscribe = true, this.subscribe(this._resubscribeTopics);
                else
                  this._resubscribeTopics = {};
              this._firstConnection = false;
            }, C.prototype._onConnect = function(e2) {
              if (this.disconnected)
                return void this.emit("connect", e2);
              const t2 = this;
              this.connackPacket = e2, this.messageIdProvider.clear(), this._setupPingTimer(), this.connected = true, function r3() {
                let n2 = t2.outgoingStore.createStream();
                function i2() {
                  t2._storeProcessing = false, t2._packetIdsDuringStoreProcessing = {};
                }
                function o2() {
                  n2.destroy(), n2 = null, t2._flushStoreProcessingQueue(), i2();
                }
                t2.once("close", o2), n2.on("error", function(e3) {
                  i2(), t2._flushStoreProcessingQueue(), t2.removeListener("close", o2), t2.emit("error", e3);
                }), n2.on("end", function() {
                  let n3 = true;
                  for (const e3 in t2._packetIdsDuringStoreProcessing)
                    if (!t2._packetIdsDuringStoreProcessing[e3]) {
                      n3 = false;
                      break;
                    }
                  n3 ? (i2(), t2.removeListener("close", o2), t2._invokeAllStoreProcessingQueue(), t2.emit("connect", e2)) : r3();
                }), function e3() {
                  if (!n2)
                    return;
                  t2._storeProcessing = true;
                  const r4 = n2.read(1);
                  let i3;
                  r4 ? t2._packetIdsDuringStoreProcessing[r4.messageId] ? e3() : t2.disconnecting || t2.reconnectTimer ? n2.destroy && n2.destroy() : (i3 = t2.outgoing[r4.messageId] ? t2.outgoing[r4.messageId].cb : null, t2.outgoing[r4.messageId] = { volatile: false, cb: function(t3, r5) {
                    i3 && i3(t3, r5), e3();
                  } }, t2._packetIdsDuringStoreProcessing[r4.messageId] = true, t2.messageIdProvider.register(r4.messageId) ? t2._sendPacket(r4) : y("messageId: %d has already used.", r4.messageId)) : n2.once("readable", e3);
                }();
              }();
            }, C.prototype._invokeStoreProcessingQueue = function() {
              if (this._storeProcessingQueue.length > 0) {
                const e2 = this._storeProcessingQueue[0];
                if (e2 && e2.invoke())
                  return this._storeProcessingQueue.shift(), true;
              }
              return false;
            }, C.prototype._invokeAllStoreProcessingQueue = function() {
              for (; this._invokeStoreProcessingQueue(); )
                ;
            }, C.prototype._flushStoreProcessingQueue = function() {
              for (const e2 of this._storeProcessingQueue)
                e2.cbStorePut && e2.cbStorePut(new Error("Connection closed")), e2.callback && e2.callback(new Error("Connection closed"));
              this._storeProcessingQueue.splice(0);
            }, t.exports = C;
          }).call(this);
        }).call(this, e("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, { "./default-message-id-provider": 7, "./store": 8, "./topic-alias-recv": 9, "./topic-alias-send": 10, "./validations": 11, _process: 50, debug: 18, events: 22, inherits: 24, "mqtt-packet": 40, "readable-stream": 69, reinterval: 70, "rfdc/default": 71, xtend: 81 }], 2: [function(e, t, r) {
        "use strict";
        const { Buffer: n } = e("buffer"), i = e("readable-stream").Transform, o = e("duplexify");
        let s, a, l, u = false;
        t.exports = function(e2, t2) {
          if (t2.hostname = t2.hostname || t2.host, !t2.hostname)
            throw new Error("Could not determine host. Specify host manually.");
          const r2 = "MQIsdp" === t2.protocolId && 3 === t2.protocolVersion ? "mqttv3.1" : "mqtt";
          !function(e3) {
            e3.hostname || (e3.hostname = "localhost"), e3.path || (e3.path = "/"), e3.wsOptions || (e3.wsOptions = {});
          }(t2);
          const c = function(e3, t3) {
            const r3 = "alis" === e3.protocol ? "wss" : "ws";
            let n2 = r3 + "://" + e3.hostname + e3.path;
            return e3.port && 80 !== e3.port && 443 !== e3.port && (n2 = r3 + "://" + e3.hostname + ":" + e3.port + e3.path), "function" == typeof e3.transformWsUrl && (n2 = e3.transformWsUrl(n2, e3, t3)), n2;
          }(t2, e2);
          return (s = t2.my).connectSocket({ url: c, protocols: r2 }), a = function() {
            const e3 = new i();
            return e3._write = function(e4, t3, r3) {
              s.sendSocketMessage({ data: e4.buffer, success: function() {
                r3();
              }, fail: function() {
                r3(new Error());
              } });
            }, e3._flush = function(e4) {
              s.closeSocket({ success: function() {
                e4();
              } });
            }, e3;
          }(), l = o.obj(), u || (u = true, s.onSocketOpen(function() {
            l.setReadable(a), l.setWritable(a), l.emit("connect");
          }), s.onSocketMessage(function(e3) {
            if ("string" == typeof e3.data) {
              const t3 = n.from(e3.data, "base64");
              a.push(t3);
            } else {
              const t3 = new FileReader();
              t3.addEventListener("load", function() {
                let e4 = t3.result;
                e4 = e4 instanceof ArrayBuffer ? n.from(e4) : n.from(e4, "utf8"), a.push(e4);
              }), t3.readAsArrayBuffer(e3.data);
            }
          }), s.onSocketClose(function() {
            l.end(), l.destroy();
          }), s.onSocketError(function(e3) {
            l.destroy(e3);
          })), l;
        };
      }, { buffer: 17, duplexify: 20, "readable-stream": 69 }], 3: [function(e, t, r) {
        "use strict";
        const n = e("net"), i = e("debug")("mqttjs:tcp");
        t.exports = function(e2, t2) {
          t2.port = t2.port || 1883, t2.hostname = t2.hostname || t2.host || "localhost";
          const r2 = t2.port, o = t2.hostname;
          return i("port %d and host %s", r2, o), n.createConnection(r2, o);
        };
      }, { debug: 18, net: 16 }], 4: [function(e, t, r) {
        "use strict";
        const n = e("tls"), i = e("net"), o = e("debug")("mqttjs:tls");
        t.exports = function(e2, t2) {
          t2.port = t2.port || 8883, t2.host = t2.hostname || t2.host || "localhost", 0 === i.isIP(t2.host) && (t2.servername = t2.host), t2.rejectUnauthorized = false !== t2.rejectUnauthorized, delete t2.path, o("port %d host %s rejectUnauthorized %b", t2.port, t2.host, t2.rejectUnauthorized);
          const r2 = n.connect(t2);
          function s(n2) {
            t2.rejectUnauthorized && e2.emit("error", n2), r2.end();
          }
          return r2.on("secureConnect", function() {
            t2.rejectUnauthorized && !r2.authorized ? r2.emit("error", new Error("TLS not authorized")) : r2.removeListener("error", s);
          }), r2.on("error", s), r2;
        };
      }, { debug: 18, net: 16, tls: 16 }], 5: [function(e, t, r) {
        (function(r2) {
          (function() {
            "use strict";
            const { Buffer: n } = e("buffer"), i = e("ws"), o = e("debug")("mqttjs:ws"), s = e("duplexify"), a = e("readable-stream").Transform, l = ["rejectUnauthorized", "ca", "cert", "key", "pfx", "passphrase"], u = void 0 !== r2 && "browser" === r2.title || "function" == typeof __webpack_require__;
            function c(e2, t2) {
              let r3 = e2.protocol + "://" + e2.hostname + ":" + e2.port + e2.path;
              return "function" == typeof e2.transformWsUrl && (r3 = e2.transformWsUrl(r3, e2, t2)), r3;
            }
            function h(e2) {
              const t2 = e2;
              return e2.hostname || (t2.hostname = "localhost"), e2.port || ("wss" === e2.protocol ? t2.port = 443 : t2.port = 80), e2.path || (t2.path = "/"), e2.wsOptions || (t2.wsOptions = {}), u || "wss" !== e2.protocol || l.forEach(function(r3) {
                Object.prototype.hasOwnProperty.call(e2, r3) && !Object.prototype.hasOwnProperty.call(e2.wsOptions, r3) && (t2.wsOptions[r3] = e2[r3]);
              }), t2;
            }
            t.exports = u ? function(e2, t2) {
              let r3;
              o("browserStreamBuilder");
              const i2 = function(e3) {
                const t3 = h(e3);
                if (t3.hostname || (t3.hostname = t3.host), !t3.hostname) {
                  if ("undefined" == typeof document)
                    throw new Error("Could not determine host. Specify host manually.");
                  const e4 = new URL(document.URL);
                  t3.hostname = e4.hostname, t3.port || (t3.port = e4.port);
                }
                return void 0 === t3.objectMode && (t3.objectMode = !(true === t3.binary || void 0 === t3.binary)), t3;
              }(t2).browserBufferSize || 524288, l2 = t2.browserBufferTimeout || 1e3, u2 = !t2.objectMode, f = function(e3, t3) {
                const r4 = "MQIsdp" === t3.protocolId && 3 === t3.protocolVersion ? "mqttv3.1" : "mqtt", n2 = c(t3, e3), i3 = new WebSocket(n2, [r4]);
                return i3.binaryType = "arraybuffer", i3;
              }(e2, t2), p = function(e3, t3, r4) {
                const n2 = new a({ objectModeMode: e3.objectMode });
                return n2._write = t3, n2._flush = r4, n2;
              }(t2, function e3(t3, r4, o2) {
                f.bufferedAmount > i2 && setTimeout(e3, l2, t3, r4, o2), u2 && "string" == typeof t3 && (t3 = n.from(t3, "utf8"));
                try {
                  f.send(t3);
                } catch (e4) {
                  return o2(e4);
                }
                o2();
              }, function(e3) {
                f.close(), e3();
              });
              t2.objectMode || (p._writev = v), p.on("close", () => {
                f.close();
              });
              const d = void 0 !== f.addEventListener;
              function g() {
                r3.setReadable(p), r3.setWritable(p), r3.emit("connect");
              }
              function y() {
                r3.end(), r3.destroy();
              }
              function b(e3) {
                r3.destroy(e3);
              }
              function m(e3) {
                let t3 = e3.data;
                t3 = t3 instanceof ArrayBuffer ? n.from(t3) : n.from(t3, "utf8"), p.push(t3);
              }
              function v(e3, t3) {
                const r4 = new Array(e3.length);
                for (let t4 = 0; t4 < e3.length; t4++)
                  "string" == typeof e3[t4].chunk ? r4[t4] = n.from(e3[t4], "utf8") : r4[t4] = e3[t4].chunk;
                this._write(n.concat(r4), "binary", t3);
              }
              return f.readyState === f.OPEN ? r3 = p : (r3 = r3 = s(void 0, void 0, t2), t2.objectMode || (r3._writev = v), d ? f.addEventListener("open", g) : f.onopen = g), r3.socket = f, d ? (f.addEventListener("close", y), f.addEventListener("error", b), f.addEventListener("message", m)) : (f.onclose = y, f.onerror = b, f.onmessage = m), r3;
            } : function(e2, t2) {
              o("streamBuilder");
              const r3 = h(t2), n2 = c(r3, e2), s2 = function(e3, t3, r4) {
                o("createWebSocket"), o("protocol: " + r4.protocolId + " " + r4.protocolVersion);
                const n3 = "MQIsdp" === r4.protocolId && 3 === r4.protocolVersion ? "mqttv3.1" : "mqtt";
                return o("creating new Websocket for url: " + t3 + " and protocol: " + n3), new i(t3, [n3], r4.wsOptions);
              }(0, n2, r3), a2 = i.createWebSocketStream(s2, r3.wsOptions);
              return a2.url = n2, s2.on("close", () => {
                a2.destroy();
              }), a2;
            };
          }).call(this);
        }).call(this, e("_process"));
      }, { _process: 50, buffer: 17, debug: 18, duplexify: 20, "readable-stream": 69, ws: 80 }], 6: [function(e, t, r) {
        "use strict";
        const { Buffer: n } = e("buffer"), i = e("readable-stream").Transform, o = e("duplexify");
        let s, a, l;
        t.exports = function(e2, t2) {
          if (t2.hostname = t2.hostname || t2.host, !t2.hostname)
            throw new Error("Could not determine host. Specify host manually.");
          const r2 = "MQIsdp" === t2.protocolId && 3 === t2.protocolVersion ? "mqttv3.1" : "mqtt";
          !function(e3) {
            e3.hostname || (e3.hostname = "localhost"), e3.path || (e3.path = "/"), e3.wsOptions || (e3.wsOptions = {});
          }(t2);
          const u = function(e3, t3) {
            const r3 = "wxs" === e3.protocol ? "wss" : "ws";
            let n2 = r3 + "://" + e3.hostname + e3.path;
            return e3.port && 80 !== e3.port && 443 !== e3.port && (n2 = r3 + "://" + e3.hostname + ":" + e3.port + e3.path), "function" == typeof e3.transformWsUrl && (n2 = e3.transformWsUrl(n2, e3, t3)), n2;
          }(t2, e2);
          s = wx.connectSocket({ url: u, protocols: [r2] }), a = function() {
            const e3 = new i();
            return e3._write = function(e4, t3, r3) {
              s.send({ data: e4.buffer, success: function() {
                r3();
              }, fail: function(e5) {
                r3(new Error(e5));
              } });
            }, e3._flush = function(e4) {
              s.close({ success: function() {
                e4();
              } });
            }, e3;
          }(), (l = o.obj())._destroy = function(e3, t3) {
            s.close({ success: function() {
              t3 && t3(e3);
            } });
          };
          const c = l.destroy;
          return l.destroy = (function() {
            l.destroy = c;
            const e3 = this;
            setTimeout(function() {
              s.close({ fail: function() {
                e3._destroy(new Error());
              } });
            }, 0);
          }).bind(l), s.onOpen(function() {
            l.setReadable(a), l.setWritable(a), l.emit("connect");
          }), s.onMessage(function(e3) {
            let t3 = e3.data;
            t3 = t3 instanceof ArrayBuffer ? n.from(t3) : n.from(t3, "utf8"), a.push(t3);
          }), s.onClose(function() {
            l.end(), l.destroy();
          }), s.onError(function(e3) {
            l.destroy(new Error(e3.errMsg));
          }), l;
        };
      }, { buffer: 17, duplexify: 20, "readable-stream": 69 }], 7: [function(e, t, r) {
        "use strict";
        function n() {
          if (!(this instanceof n))
            return new n();
          this.nextId = Math.max(1, Math.floor(65535 * Math.random()));
        }
        n.prototype.allocate = function() {
          const e2 = this.nextId++;
          return 65536 === this.nextId && (this.nextId = 1), e2;
        }, n.prototype.getLastAllocated = function() {
          return 1 === this.nextId ? 65535 : this.nextId - 1;
        }, n.prototype.register = function(e2) {
          return true;
        }, n.prototype.deallocate = function(e2) {
        }, n.prototype.clear = function() {
        }, t.exports = n;
      }, {}], 8: [function(e, t, r) {
        "use strict";
        const n = e("xtend"), i = e("readable-stream").Readable, o = { objectMode: true }, s = { clean: true };
        function a(e2) {
          if (!(this instanceof a))
            return new a(e2);
          this.options = e2 || {}, this.options = n(s, e2), this._inflights = /* @__PURE__ */ new Map();
        }
        a.prototype.put = function(e2, t2) {
          return this._inflights.set(e2.messageId, e2), t2 && t2(), this;
        }, a.prototype.createStream = function() {
          const e2 = new i(o), t2 = [];
          let r2 = false, n2 = 0;
          return this._inflights.forEach(function(e3, r3) {
            t2.push(e3);
          }), e2._read = function() {
            !r2 && n2 < t2.length ? this.push(t2[n2++]) : this.push(null);
          }, e2.destroy = function() {
            if (r2)
              return;
            const e3 = this;
            r2 = true, setTimeout(function() {
              e3.emit("close");
            }, 0);
          }, e2;
        }, a.prototype.del = function(e2, t2) {
          return (e2 = this._inflights.get(e2.messageId)) ? (this._inflights.delete(e2.messageId), t2(null, e2)) : t2 && t2(new Error("missing packet")), this;
        }, a.prototype.get = function(e2, t2) {
          return (e2 = this._inflights.get(e2.messageId)) ? t2(null, e2) : t2 && t2(new Error("missing packet")), this;
        }, a.prototype.close = function(e2) {
          this.options.clean && (this._inflights = null), e2 && e2();
        }, t.exports = a;
      }, { "readable-stream": 69, xtend: 81 }], 9: [function(e, t, r) {
        "use strict";
        function n(e2) {
          if (!(this instanceof n))
            return new n(e2);
          this.aliasToTopic = {}, this.max = e2;
        }
        n.prototype.put = function(e2, t2) {
          return !(0 === t2 || t2 > this.max) && (this.aliasToTopic[t2] = e2, this.length = Object.keys(this.aliasToTopic).length, true);
        }, n.prototype.getTopicByAlias = function(e2) {
          return this.aliasToTopic[e2];
        }, n.prototype.clear = function() {
          this.aliasToTopic = {};
        }, t.exports = n;
      }, {}], 10: [function(e, t, r) {
        "use strict";
        const n = e("lru-cache"), i = e("number-allocator").NumberAllocator;
        function o(e2) {
          if (!(this instanceof o))
            return new o(e2);
          e2 > 0 && (this.aliasToTopic = new n({ max: e2 }), this.topicToAlias = {}, this.numberAllocator = new i(1, e2), this.max = e2, this.length = 0);
        }
        o.prototype.put = function(e2, t2) {
          if (0 === t2 || t2 > this.max)
            return false;
          const r2 = this.aliasToTopic.get(t2);
          return r2 && delete this.topicToAlias[r2], this.aliasToTopic.set(t2, e2), this.topicToAlias[e2] = t2, this.numberAllocator.use(t2), this.length = this.aliasToTopic.length, true;
        }, o.prototype.getTopicByAlias = function(e2) {
          return this.aliasToTopic.get(e2);
        }, o.prototype.getAliasByTopic = function(e2) {
          const t2 = this.topicToAlias[e2];
          return void 0 !== t2 && this.aliasToTopic.get(t2), t2;
        }, o.prototype.clear = function() {
          this.aliasToTopic.reset(), this.topicToAlias = {}, this.numberAllocator.clear(), this.length = 0;
        }, o.prototype.getLruAlias = function() {
          const e2 = this.numberAllocator.firstVacant();
          return e2 || this.aliasToTopic.keys()[this.aliasToTopic.length - 1];
        }, t.exports = o;
      }, { "lru-cache": 37, "number-allocator": 46 }], 11: [function(e, t, r) {
        "use strict";
        function n(e2) {
          const t2 = e2.split("/");
          for (let e3 = 0; e3 < t2.length; e3++)
            if ("+" !== t2[e3]) {
              if ("#" === t2[e3])
                return e3 === t2.length - 1;
              if (-1 !== t2[e3].indexOf("+") || -1 !== t2[e3].indexOf("#"))
                return false;
            }
          return true;
        }
        t.exports = { validateTopics: function(e2) {
          if (0 === e2.length)
            return "empty_topic_list";
          for (let t2 = 0; t2 < e2.length; t2++)
            if (!n(e2[t2]))
              return e2[t2];
          return null;
        } };
      }, {}], 12: [function(e, t, r) {
        (function(r2) {
          (function() {
            "use strict";
            const n = e("../client"), i = e("../store"), o = e("url"), s = e("xtend"), a = e("debug")("mqttjs"), l = {};
            function u(e2, t2) {
              if (a("connecting to an MQTT broker..."), "object" != typeof e2 || t2 || (t2 = e2, e2 = null), t2 = t2 || {}, e2) {
                const r4 = o.parse(e2, true);
                if (null != r4.port && (r4.port = Number(r4.port)), null === (t2 = s(r4, t2)).protocol)
                  throw new Error("Missing protocol");
                t2.protocol = t2.protocol.replace(/:$/, "");
              }
              if (function(e3) {
                let t3;
                e3.auth && ((t3 = e3.auth.match(/^(.+):(.+)$/)) ? (e3.username = t3[1], e3.password = t3[2]) : e3.username = e3.auth);
              }(t2), t2.query && "string" == typeof t2.query.clientId && (t2.clientId = t2.query.clientId), t2.cert && t2.key) {
                if (!t2.protocol)
                  throw new Error("Missing secure protocol key");
                if (-1 === ["mqtts", "wss", "wxs", "alis"].indexOf(t2.protocol))
                  switch (t2.protocol) {
                    case "mqtt":
                      t2.protocol = "mqtts";
                      break;
                    case "ws":
                      t2.protocol = "wss";
                      break;
                    case "wx":
                      t2.protocol = "wxs";
                      break;
                    case "ali":
                      t2.protocol = "alis";
                      break;
                    default:
                      throw new Error('Unknown protocol for secure connection: "' + t2.protocol + '"!');
                  }
              }
              if (!l[t2.protocol]) {
                const e3 = -1 !== ["mqtts", "wss"].indexOf(t2.protocol);
                t2.protocol = ["mqtt", "mqtts", "ws", "wss", "wx", "wxs", "ali", "alis"].filter(function(t3, r4) {
                  return (!e3 || r4 % 2 != 0) && "function" == typeof l[t3];
                })[0];
              }
              if (false === t2.clean && !t2.clientId)
                throw new Error("Missing clientId for unclean clients");
              t2.protocol && (t2.defaultProtocol = t2.protocol);
              const r3 = new n(function(e3) {
                return t2.servers && (e3._reconnectCount && e3._reconnectCount !== t2.servers.length || (e3._reconnectCount = 0), t2.host = t2.servers[e3._reconnectCount].host, t2.port = t2.servers[e3._reconnectCount].port, t2.protocol = t2.servers[e3._reconnectCount].protocol ? t2.servers[e3._reconnectCount].protocol : t2.defaultProtocol, t2.hostname = t2.host, e3._reconnectCount++), a("calling streambuilder for", t2.protocol), l[t2.protocol](e3, t2);
              }, t2);
              return r3.on("error", function() {
              }), r3;
            }
            void 0 !== r2 && "browser" !== r2.title || "function" != typeof __webpack_require__ ? (l.mqtt = e("./tcp"), l.tcp = e("./tcp"), l.ssl = e("./tls"), l.tls = e("./tls"), l.mqtts = e("./tls")) : (l.wx = e("./wx"), l.wxs = e("./wx"), l.ali = e("./ali"), l.alis = e("./ali")), l.ws = e("./ws"), l.wss = e("./ws"), t.exports = u, t.exports.connect = u, t.exports.MqttClient = n, t.exports.Store = i;
          }).call(this);
        }).call(this, e("_process"));
      }, { "../client": 1, "../store": 8, "./ali": 2, "./tcp": 3, "./tls": 4, "./ws": 5, "./wx": 6, _process: 50, debug: 18, url: 76, xtend: 81 }], 13: [function(e, t, r) {
        "use strict";
        r.byteLength = function(e2) {
          var t2 = u(e2), r2 = t2[0], n2 = t2[1];
          return 3 * (r2 + n2) / 4 - n2;
        }, r.toByteArray = function(e2) {
          var t2, r2, n2 = u(e2), s2 = n2[0], a2 = n2[1], l2 = new o(function(e3, t3, r3) {
            return 3 * (t3 + r3) / 4 - r3;
          }(0, s2, a2)), c2 = 0, h = a2 > 0 ? s2 - 4 : s2;
          for (r2 = 0; r2 < h; r2 += 4)
            t2 = i[e2.charCodeAt(r2)] << 18 | i[e2.charCodeAt(r2 + 1)] << 12 | i[e2.charCodeAt(r2 + 2)] << 6 | i[e2.charCodeAt(r2 + 3)], l2[c2++] = t2 >> 16 & 255, l2[c2++] = t2 >> 8 & 255, l2[c2++] = 255 & t2;
          2 === a2 && (t2 = i[e2.charCodeAt(r2)] << 2 | i[e2.charCodeAt(r2 + 1)] >> 4, l2[c2++] = 255 & t2);
          1 === a2 && (t2 = i[e2.charCodeAt(r2)] << 10 | i[e2.charCodeAt(r2 + 1)] << 4 | i[e2.charCodeAt(r2 + 2)] >> 2, l2[c2++] = t2 >> 8 & 255, l2[c2++] = 255 & t2);
          return l2;
        }, r.fromByteArray = function(e2) {
          for (var t2, r2 = e2.length, i2 = r2 % 3, o2 = [], s2 = 0, a2 = r2 - i2; s2 < a2; s2 += 16383)
            o2.push(c(e2, s2, s2 + 16383 > a2 ? a2 : s2 + 16383));
          1 === i2 ? (t2 = e2[r2 - 1], o2.push(n[t2 >> 2] + n[t2 << 4 & 63] + "==")) : 2 === i2 && (t2 = (e2[r2 - 2] << 8) + e2[r2 - 1], o2.push(n[t2 >> 10] + n[t2 >> 4 & 63] + n[t2 << 2 & 63] + "="));
          return o2.join("");
        };
        for (var n = [], i = [], o = "undefined" != typeof Uint8Array ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, l = s.length; a < l; ++a)
          n[a] = s[a], i[s.charCodeAt(a)] = a;
        function u(e2) {
          var t2 = e2.length;
          if (t2 % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var r2 = e2.indexOf("=");
          return -1 === r2 && (r2 = t2), [r2, r2 === t2 ? 0 : 4 - r2 % 4];
        }
        function c(e2, t2, r2) {
          for (var i2, o2, s2 = [], a2 = t2; a2 < r2; a2 += 3)
            i2 = (e2[a2] << 16 & 16711680) + (e2[a2 + 1] << 8 & 65280) + (255 & e2[a2 + 2]), s2.push(n[(o2 = i2) >> 18 & 63] + n[o2 >> 12 & 63] + n[o2 >> 6 & 63] + n[63 & o2]);
          return s2.join("");
        }
        i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63;
      }, {}], 14: [function(e, t, r) {
        "use strict";
        const { Buffer: n } = e("buffer"), i = Symbol.for("BufferList");
        function o(e2) {
          if (!(this instanceof o))
            return new o(e2);
          o._init.call(this, e2);
        }
        o._init = function(e2) {
          Object.defineProperty(this, i, { value: true }), this._bufs = [], this.length = 0, e2 && this.append(e2);
        }, o.prototype._new = function(e2) {
          return new o(e2);
        }, o.prototype._offset = function(e2) {
          if (0 === e2)
            return [0, 0];
          let t2 = 0;
          for (let r2 = 0; r2 < this._bufs.length; r2++) {
            const n2 = t2 + this._bufs[r2].length;
            if (e2 < n2 || r2 === this._bufs.length - 1)
              return [r2, e2 - t2];
            t2 = n2;
          }
        }, o.prototype._reverseOffset = function(e2) {
          const t2 = e2[0];
          let r2 = e2[1];
          for (let e3 = 0; e3 < t2; e3++)
            r2 += this._bufs[e3].length;
          return r2;
        }, o.prototype.get = function(e2) {
          if (e2 > this.length || e2 < 0)
            return;
          const t2 = this._offset(e2);
          return this._bufs[t2[0]][t2[1]];
        }, o.prototype.slice = function(e2, t2) {
          return "number" == typeof e2 && e2 < 0 && (e2 += this.length), "number" == typeof t2 && t2 < 0 && (t2 += this.length), this.copy(null, 0, e2, t2);
        }, o.prototype.copy = function(e2, t2, r2, i2) {
          if (("number" != typeof r2 || r2 < 0) && (r2 = 0), ("number" != typeof i2 || i2 > this.length) && (i2 = this.length), r2 >= this.length)
            return e2 || n.alloc(0);
          if (i2 <= 0)
            return e2 || n.alloc(0);
          const o2 = !!e2, s = this._offset(r2), a = i2 - r2;
          let l = a, u = o2 && t2 || 0, c = s[1];
          if (0 === r2 && i2 === this.length) {
            if (!o2)
              return 1 === this._bufs.length ? this._bufs[0] : n.concat(this._bufs, this.length);
            for (let t3 = 0; t3 < this._bufs.length; t3++)
              this._bufs[t3].copy(e2, u), u += this._bufs[t3].length;
            return e2;
          }
          if (l <= this._bufs[s[0]].length - c)
            return o2 ? this._bufs[s[0]].copy(e2, t2, c, c + l) : this._bufs[s[0]].slice(c, c + l);
          o2 || (e2 = n.allocUnsafe(a));
          for (let t3 = s[0]; t3 < this._bufs.length; t3++) {
            const r3 = this._bufs[t3].length - c;
            if (!(l > r3)) {
              this._bufs[t3].copy(e2, u, c, c + l), u += r3;
              break;
            }
            this._bufs[t3].copy(e2, u, c), u += r3, l -= r3, c && (c = 0);
          }
          return e2.length > u ? e2.slice(0, u) : e2;
        }, o.prototype.shallowSlice = function(e2, t2) {
          if (e2 = e2 || 0, t2 = "number" != typeof t2 ? this.length : t2, e2 < 0 && (e2 += this.length), t2 < 0 && (t2 += this.length), e2 === t2)
            return this._new();
          const r2 = this._offset(e2), n2 = this._offset(t2), i2 = this._bufs.slice(r2[0], n2[0] + 1);
          return 0 === n2[1] ? i2.pop() : i2[i2.length - 1] = i2[i2.length - 1].slice(0, n2[1]), 0 !== r2[1] && (i2[0] = i2[0].slice(r2[1])), this._new(i2);
        }, o.prototype.toString = function(e2, t2, r2) {
          return this.slice(t2, r2).toString(e2);
        }, o.prototype.consume = function(e2) {
          if (e2 = Math.trunc(e2), Number.isNaN(e2) || e2 <= 0)
            return this;
          for (; this._bufs.length; ) {
            if (!(e2 >= this._bufs[0].length)) {
              this._bufs[0] = this._bufs[0].slice(e2), this.length -= e2;
              break;
            }
            e2 -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift();
          }
          return this;
        }, o.prototype.duplicate = function() {
          const e2 = this._new();
          for (let t2 = 0; t2 < this._bufs.length; t2++)
            e2.append(this._bufs[t2]);
          return e2;
        }, o.prototype.append = function(e2) {
          if (null == e2)
            return this;
          if (e2.buffer)
            this._appendBuffer(n.from(e2.buffer, e2.byteOffset, e2.byteLength));
          else if (Array.isArray(e2))
            for (let t2 = 0; t2 < e2.length; t2++)
              this.append(e2[t2]);
          else if (this._isBufferList(e2))
            for (let t2 = 0; t2 < e2._bufs.length; t2++)
              this.append(e2._bufs[t2]);
          else
            "number" == typeof e2 && (e2 = e2.toString()), this._appendBuffer(n.from(e2));
          return this;
        }, o.prototype._appendBuffer = function(e2) {
          this._bufs.push(e2), this.length += e2.length;
        }, o.prototype.indexOf = function(e2, t2, r2) {
          if (void 0 === r2 && "string" == typeof t2 && (r2 = t2, t2 = void 0), "function" == typeof e2 || Array.isArray(e2))
            throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
          if ("number" == typeof e2 ? e2 = n.from([e2]) : "string" == typeof e2 ? e2 = n.from(e2, r2) : this._isBufferList(e2) ? e2 = e2.slice() : Array.isArray(e2.buffer) ? e2 = n.from(e2.buffer, e2.byteOffset, e2.byteLength) : n.isBuffer(e2) || (e2 = n.from(e2)), t2 = Number(t2 || 0), isNaN(t2) && (t2 = 0), t2 < 0 && (t2 = this.length + t2), t2 < 0 && (t2 = 0), 0 === e2.length)
            return t2 > this.length ? this.length : t2;
          const i2 = this._offset(t2);
          let o2 = i2[0], s = i2[1];
          for (; o2 < this._bufs.length; o2++) {
            const t3 = this._bufs[o2];
            for (; s < t3.length; ) {
              if (t3.length - s >= e2.length) {
                const r3 = t3.indexOf(e2, s);
                if (-1 !== r3)
                  return this._reverseOffset([o2, r3]);
                s = t3.length - e2.length + 1;
              } else {
                const t4 = this._reverseOffset([o2, s]);
                if (this._match(t4, e2))
                  return t4;
                s++;
              }
            }
            s = 0;
          }
          return -1;
        }, o.prototype._match = function(e2, t2) {
          if (this.length - e2 < t2.length)
            return false;
          for (let r2 = 0; r2 < t2.length; r2++)
            if (this.get(e2 + r2) !== t2[r2])
              return false;
          return true;
        }, function() {
          const e2 = { readDoubleBE: 8, readDoubleLE: 8, readFloatBE: 4, readFloatLE: 4, readInt32BE: 4, readInt32LE: 4, readUInt32BE: 4, readUInt32LE: 4, readInt16BE: 2, readInt16LE: 2, readUInt16BE: 2, readUInt16LE: 2, readInt8: 1, readUInt8: 1, readIntBE: null, readIntLE: null, readUIntBE: null, readUIntLE: null };
          for (const t2 in e2)
            !function(t3) {
              o.prototype[t3] = null === e2[t3] ? function(e3, r2) {
                return this.slice(e3, e3 + r2)[t3](0, r2);
              } : function(r2 = 0) {
                return this.slice(r2, r2 + e2[t3])[t3](0);
              };
            }(t2);
        }(), o.prototype._isBufferList = function(e2) {
          return e2 instanceof o || o.isBufferList(e2);
        }, o.isBufferList = function(e2) {
          return null != e2 && e2[i];
        }, t.exports = o;
      }, { buffer: 17 }], 15: [function(e, t, r) {
        "use strict";
        const n = e("readable-stream").Duplex, i = e("inherits"), o = e("./BufferList");
        function s(e2) {
          if (!(this instanceof s))
            return new s(e2);
          if ("function" == typeof e2) {
            this._callback = e2;
            const t2 = (function(e3) {
              this._callback && (this._callback(e3), this._callback = null);
            }).bind(this);
            this.on("pipe", function(e3) {
              e3.on("error", t2);
            }), this.on("unpipe", function(e3) {
              e3.removeListener("error", t2);
            }), e2 = null;
          }
          o._init.call(this, e2), n.call(this);
        }
        i(s, n), Object.assign(s.prototype, o.prototype), s.prototype._new = function(e2) {
          return new s(e2);
        }, s.prototype._write = function(e2, t2, r2) {
          this._appendBuffer(e2), "function" == typeof r2 && r2();
        }, s.prototype._read = function(e2) {
          if (!this.length)
            return this.push(null);
          e2 = Math.min(e2, this.length), this.push(this.slice(0, e2)), this.consume(e2);
        }, s.prototype.end = function(e2) {
          n.prototype.end.call(this, e2), this._callback && (this._callback(null, this.slice()), this._callback = null);
        }, s.prototype._destroy = function(e2, t2) {
          this._bufs.length = 0, this.length = 0, t2(e2);
        }, s.prototype._isBufferList = function(e2) {
          return e2 instanceof s || e2 instanceof o || s.isBufferList(e2);
        }, s.isBufferList = o.isBufferList, t.exports = s, t.exports.BufferListStream = s, t.exports.BufferList = o;
      }, { "./BufferList": 14, inherits: 24, "readable-stream": 69 }], 16: [function(e, t, r) {
      }, {}], 17: [function(e, t, r) {
        (function(t2) {
          (function() {
            "use strict";
            var t3 = e("base64-js"), n = e("ieee754");
            r.Buffer = s, r.SlowBuffer = function(e2) {
              +e2 != e2 && (e2 = 0);
              return s.alloc(+e2);
            }, r.INSPECT_MAX_BYTES = 50;
            var i = 2147483647;
            function o(e2) {
              if (e2 > i)
                throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
              var t4 = new Uint8Array(e2);
              return t4.__proto__ = s.prototype, t4;
            }
            function s(e2, t4, r2) {
              if ("number" == typeof e2) {
                if ("string" == typeof t4)
                  throw new TypeError('The "string" argument must be of type string. Received type number');
                return u(e2);
              }
              return a(e2, t4, r2);
            }
            function a(e2, t4, r2) {
              if ("string" == typeof e2)
                return function(e3, t5) {
                  "string" == typeof t5 && "" !== t5 || (t5 = "utf8");
                  if (!s.isEncoding(t5))
                    throw new TypeError("Unknown encoding: " + t5);
                  var r3 = 0 | f(e3, t5), n3 = o(r3), i3 = n3.write(e3, t5);
                  i3 !== r3 && (n3 = n3.slice(0, i3));
                  return n3;
                }(e2, t4);
              if (ArrayBuffer.isView(e2))
                return c(e2);
              if (null == e2)
                throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
              if (q(e2, ArrayBuffer) || e2 && q(e2.buffer, ArrayBuffer))
                return function(e3, t5, r3) {
                  if (t5 < 0 || e3.byteLength < t5)
                    throw new RangeError('"offset" is outside of buffer bounds');
                  if (e3.byteLength < t5 + (r3 || 0))
                    throw new RangeError('"length" is outside of buffer bounds');
                  var n3;
                  n3 = void 0 === t5 && void 0 === r3 ? new Uint8Array(e3) : void 0 === r3 ? new Uint8Array(e3, t5) : new Uint8Array(e3, t5, r3);
                  return n3.__proto__ = s.prototype, n3;
                }(e2, t4, r2);
              if ("number" == typeof e2)
                throw new TypeError('The "value" argument must not be of type number. Received type number');
              var n2 = e2.valueOf && e2.valueOf();
              if (null != n2 && n2 !== e2)
                return s.from(n2, t4, r2);
              var i2 = function(e3) {
                if (s.isBuffer(e3)) {
                  var t5 = 0 | h(e3.length), r3 = o(t5);
                  return 0 === r3.length ? r3 : (e3.copy(r3, 0, 0, t5), r3);
                }
                if (void 0 !== e3.length)
                  return "number" != typeof e3.length || D(e3.length) ? o(0) : c(e3);
                if ("Buffer" === e3.type && Array.isArray(e3.data))
                  return c(e3.data);
              }(e2);
              if (i2)
                return i2;
              if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e2[Symbol.toPrimitive])
                return s.from(e2[Symbol.toPrimitive]("string"), t4, r2);
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
            }
            function l(e2) {
              if ("number" != typeof e2)
                throw new TypeError('"size" argument must be of type number');
              if (e2 < 0)
                throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
            }
            function u(e2) {
              return l(e2), o(e2 < 0 ? 0 : 0 | h(e2));
            }
            function c(e2) {
              for (var t4 = e2.length < 0 ? 0 : 0 | h(e2.length), r2 = o(t4), n2 = 0; n2 < t4; n2 += 1)
                r2[n2] = 255 & e2[n2];
              return r2;
            }
            function h(e2) {
              if (e2 >= i)
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
              return 0 | e2;
            }
            function f(e2, t4) {
              if (s.isBuffer(e2))
                return e2.length;
              if (ArrayBuffer.isView(e2) || q(e2, ArrayBuffer))
                return e2.byteLength;
              if ("string" != typeof e2)
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e2);
              var r2 = e2.length, n2 = arguments.length > 2 && true === arguments[2];
              if (!n2 && 0 === r2)
                return 0;
              for (var i2 = false; ; )
                switch (t4) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return r2;
                  case "utf8":
                  case "utf-8":
                    return L(e2).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return 2 * r2;
                  case "hex":
                    return r2 >>> 1;
                  case "base64":
                    return j(e2).length;
                  default:
                    if (i2)
                      return n2 ? -1 : L(e2).length;
                    t4 = ("" + t4).toLowerCase(), i2 = true;
                }
            }
            function p(e2, t4, r2) {
              var n2 = e2[t4];
              e2[t4] = e2[r2], e2[r2] = n2;
            }
            function d(e2, t4, r2, n2, i2) {
              if (0 === e2.length)
                return -1;
              if ("string" == typeof r2 ? (n2 = r2, r2 = 0) : r2 > 2147483647 ? r2 = 2147483647 : r2 < -2147483648 && (r2 = -2147483648), D(r2 = +r2) && (r2 = i2 ? 0 : e2.length - 1), r2 < 0 && (r2 = e2.length + r2), r2 >= e2.length) {
                if (i2)
                  return -1;
                r2 = e2.length - 1;
              } else if (r2 < 0) {
                if (!i2)
                  return -1;
                r2 = 0;
              }
              if ("string" == typeof t4 && (t4 = s.from(t4, n2)), s.isBuffer(t4))
                return 0 === t4.length ? -1 : g(e2, t4, r2, n2, i2);
              if ("number" == typeof t4)
                return t4 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i2 ? Uint8Array.prototype.indexOf.call(e2, t4, r2) : Uint8Array.prototype.lastIndexOf.call(e2, t4, r2) : g(e2, [t4], r2, n2, i2);
              throw new TypeError("val must be string, number or Buffer");
            }
            function g(e2, t4, r2, n2, i2) {
              var o2, s2 = 1, a2 = e2.length, l2 = t4.length;
              if (void 0 !== n2 && ("ucs2" === (n2 = String(n2).toLowerCase()) || "ucs-2" === n2 || "utf16le" === n2 || "utf-16le" === n2)) {
                if (e2.length < 2 || t4.length < 2)
                  return -1;
                s2 = 2, a2 /= 2, l2 /= 2, r2 /= 2;
              }
              function u2(e3, t5) {
                return 1 === s2 ? e3[t5] : e3.readUInt16BE(t5 * s2);
              }
              if (i2) {
                var c2 = -1;
                for (o2 = r2; o2 < a2; o2++)
                  if (u2(e2, o2) === u2(t4, -1 === c2 ? 0 : o2 - c2)) {
                    if (-1 === c2 && (c2 = o2), o2 - c2 + 1 === l2)
                      return c2 * s2;
                  } else
                    -1 !== c2 && (o2 -= o2 - c2), c2 = -1;
              } else
                for (r2 + l2 > a2 && (r2 = a2 - l2), o2 = r2; o2 >= 0; o2--) {
                  for (var h2 = true, f2 = 0; f2 < l2; f2++)
                    if (u2(e2, o2 + f2) !== u2(t4, f2)) {
                      h2 = false;
                      break;
                    }
                  if (h2)
                    return o2;
                }
              return -1;
            }
            function y(e2, t4, r2, n2) {
              r2 = Number(r2) || 0;
              var i2 = e2.length - r2;
              n2 ? (n2 = Number(n2)) > i2 && (n2 = i2) : n2 = i2;
              var o2 = t4.length;
              n2 > o2 / 2 && (n2 = o2 / 2);
              for (var s2 = 0; s2 < n2; ++s2) {
                var a2 = parseInt(t4.substr(2 * s2, 2), 16);
                if (D(a2))
                  return s2;
                e2[r2 + s2] = a2;
              }
              return s2;
            }
            function b(e2, t4, r2, n2) {
              return U(L(t4, e2.length - r2), e2, r2, n2);
            }
            function m(e2, t4, r2, n2) {
              return U(function(e3) {
                for (var t5 = [], r3 = 0; r3 < e3.length; ++r3)
                  t5.push(255 & e3.charCodeAt(r3));
                return t5;
              }(t4), e2, r2, n2);
            }
            function v(e2, t4, r2, n2) {
              return m(e2, t4, r2, n2);
            }
            function w(e2, t4, r2, n2) {
              return U(j(t4), e2, r2, n2);
            }
            function _(e2, t4, r2, n2) {
              return U(function(e3, t5) {
                for (var r3, n3, i2, o2 = [], s2 = 0; s2 < e3.length && !((t5 -= 2) < 0); ++s2)
                  r3 = e3.charCodeAt(s2), n3 = r3 >> 8, i2 = r3 % 256, o2.push(i2), o2.push(n3);
                return o2;
              }(t4, e2.length - r2), e2, r2, n2);
            }
            function k(e2, r2, n2) {
              return 0 === r2 && n2 === e2.length ? t3.fromByteArray(e2) : t3.fromByteArray(e2.slice(r2, n2));
            }
            function S(e2, t4, r2) {
              r2 = Math.min(e2.length, r2);
              for (var n2 = [], i2 = t4; i2 < r2; ) {
                var o2, s2, a2, l2, u2 = e2[i2], c2 = null, h2 = u2 > 239 ? 4 : u2 > 223 ? 3 : u2 > 191 ? 2 : 1;
                if (i2 + h2 <= r2)
                  switch (h2) {
                    case 1:
                      u2 < 128 && (c2 = u2);
                      break;
                    case 2:
                      128 == (192 & (o2 = e2[i2 + 1])) && (l2 = (31 & u2) << 6 | 63 & o2) > 127 && (c2 = l2);
                      break;
                    case 3:
                      o2 = e2[i2 + 1], s2 = e2[i2 + 2], 128 == (192 & o2) && 128 == (192 & s2) && (l2 = (15 & u2) << 12 | (63 & o2) << 6 | 63 & s2) > 2047 && (l2 < 55296 || l2 > 57343) && (c2 = l2);
                      break;
                    case 4:
                      o2 = e2[i2 + 1], s2 = e2[i2 + 2], a2 = e2[i2 + 3], 128 == (192 & o2) && 128 == (192 & s2) && 128 == (192 & a2) && (l2 = (15 & u2) << 18 | (63 & o2) << 12 | (63 & s2) << 6 | 63 & a2) > 65535 && l2 < 1114112 && (c2 = l2);
                  }
                null === c2 ? (c2 = 65533, h2 = 1) : c2 > 65535 && (c2 -= 65536, n2.push(c2 >>> 10 & 1023 | 55296), c2 = 56320 | 1023 & c2), n2.push(c2), i2 += h2;
              }
              return function(e3) {
                var t5 = e3.length;
                if (t5 <= E)
                  return String.fromCharCode.apply(String, e3);
                var r3 = "", n3 = 0;
                for (; n3 < t5; )
                  r3 += String.fromCharCode.apply(String, e3.slice(n3, n3 += E));
                return r3;
              }(n2);
            }
            r.kMaxLength = i, s.TYPED_ARRAY_SUPPORT = function() {
              try {
                var e2 = new Uint8Array(1);
                return e2.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                  return 42;
                } }, 42 === e2.foo();
              } catch (e3) {
                return false;
              }
            }(), s.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s.prototype, "parent", { enumerable: true, get: function() {
              if (s.isBuffer(this))
                return this.buffer;
            } }), Object.defineProperty(s.prototype, "offset", { enumerable: true, get: function() {
              if (s.isBuffer(this))
                return this.byteOffset;
            } }), "undefined" != typeof Symbol && null != Symbol.species && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false }), s.poolSize = 8192, s.from = function(e2, t4, r2) {
              return a(e2, t4, r2);
            }, s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, s.alloc = function(e2, t4, r2) {
              return function(e3, t5, r3) {
                return l(e3), e3 <= 0 ? o(e3) : void 0 !== t5 ? "string" == typeof r3 ? o(e3).fill(t5, r3) : o(e3).fill(t5) : o(e3);
              }(e2, t4, r2);
            }, s.allocUnsafe = function(e2) {
              return u(e2);
            }, s.allocUnsafeSlow = function(e2) {
              return u(e2);
            }, s.isBuffer = function(e2) {
              return null != e2 && true === e2._isBuffer && e2 !== s.prototype;
            }, s.compare = function(e2, t4) {
              if (q(e2, Uint8Array) && (e2 = s.from(e2, e2.offset, e2.byteLength)), q(t4, Uint8Array) && (t4 = s.from(t4, t4.offset, t4.byteLength)), !s.isBuffer(e2) || !s.isBuffer(t4))
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
              if (e2 === t4)
                return 0;
              for (var r2 = e2.length, n2 = t4.length, i2 = 0, o2 = Math.min(r2, n2); i2 < o2; ++i2)
                if (e2[i2] !== t4[i2]) {
                  r2 = e2[i2], n2 = t4[i2];
                  break;
                }
              return r2 < n2 ? -1 : n2 < r2 ? 1 : 0;
            }, s.isEncoding = function(e2) {
              switch (String(e2).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            }, s.concat = function(e2, t4) {
              if (!Array.isArray(e2))
                throw new TypeError('"list" argument must be an Array of Buffers');
              if (0 === e2.length)
                return s.alloc(0);
              var r2;
              if (void 0 === t4)
                for (t4 = 0, r2 = 0; r2 < e2.length; ++r2)
                  t4 += e2[r2].length;
              var n2 = s.allocUnsafe(t4), i2 = 0;
              for (r2 = 0; r2 < e2.length; ++r2) {
                var o2 = e2[r2];
                if (q(o2, Uint8Array) && (o2 = s.from(o2)), !s.isBuffer(o2))
                  throw new TypeError('"list" argument must be an Array of Buffers');
                o2.copy(n2, i2), i2 += o2.length;
              }
              return n2;
            }, s.byteLength = f, s.prototype._isBuffer = true, s.prototype.swap16 = function() {
              var e2 = this.length;
              if (e2 % 2 != 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              for (var t4 = 0; t4 < e2; t4 += 2)
                p(this, t4, t4 + 1);
              return this;
            }, s.prototype.swap32 = function() {
              var e2 = this.length;
              if (e2 % 4 != 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              for (var t4 = 0; t4 < e2; t4 += 4)
                p(this, t4, t4 + 3), p(this, t4 + 1, t4 + 2);
              return this;
            }, s.prototype.swap64 = function() {
              var e2 = this.length;
              if (e2 % 8 != 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              for (var t4 = 0; t4 < e2; t4 += 8)
                p(this, t4, t4 + 7), p(this, t4 + 1, t4 + 6), p(this, t4 + 2, t4 + 5), p(this, t4 + 3, t4 + 4);
              return this;
            }, s.prototype.toString = function() {
              var e2 = this.length;
              return 0 === e2 ? "" : 0 === arguments.length ? S(this, 0, e2) : (function(e3, t4, r2) {
                var n2 = false;
                if ((void 0 === t4 || t4 < 0) && (t4 = 0), t4 > this.length)
                  return "";
                if ((void 0 === r2 || r2 > this.length) && (r2 = this.length), r2 <= 0)
                  return "";
                if ((r2 >>>= 0) <= (t4 >>>= 0))
                  return "";
                for (e3 || (e3 = "utf8"); ; )
                  switch (e3) {
                    case "hex":
                      return x(this, t4, r2);
                    case "utf8":
                    case "utf-8":
                      return S(this, t4, r2);
                    case "ascii":
                      return C(this, t4, r2);
                    case "latin1":
                    case "binary":
                      return T(this, t4, r2);
                    case "base64":
                      return k(this, t4, r2);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return A(this, t4, r2);
                    default:
                      if (n2)
                        throw new TypeError("Unknown encoding: " + e3);
                      e3 = (e3 + "").toLowerCase(), n2 = true;
                  }
              }).apply(this, arguments);
            }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(e2) {
              if (!s.isBuffer(e2))
                throw new TypeError("Argument must be a Buffer");
              return this === e2 || 0 === s.compare(this, e2);
            }, s.prototype.inspect = function() {
              var e2 = "", t4 = r.INSPECT_MAX_BYTES;
              return e2 = this.toString("hex", 0, t4).replace(/(.{2})/g, "$1 ").trim(), this.length > t4 && (e2 += " ... "), "<Buffer " + e2 + ">";
            }, s.prototype.compare = function(e2, t4, r2, n2, i2) {
              if (q(e2, Uint8Array) && (e2 = s.from(e2, e2.offset, e2.byteLength)), !s.isBuffer(e2))
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e2);
              if (void 0 === t4 && (t4 = 0), void 0 === r2 && (r2 = e2 ? e2.length : 0), void 0 === n2 && (n2 = 0), void 0 === i2 && (i2 = this.length), t4 < 0 || r2 > e2.length || n2 < 0 || i2 > this.length)
                throw new RangeError("out of range index");
              if (n2 >= i2 && t4 >= r2)
                return 0;
              if (n2 >= i2)
                return -1;
              if (t4 >= r2)
                return 1;
              if (t4 >>>= 0, r2 >>>= 0, n2 >>>= 0, i2 >>>= 0, this === e2)
                return 0;
              for (var o2 = i2 - n2, a2 = r2 - t4, l2 = Math.min(o2, a2), u2 = this.slice(n2, i2), c2 = e2.slice(t4, r2), h2 = 0; h2 < l2; ++h2)
                if (u2[h2] !== c2[h2]) {
                  o2 = u2[h2], a2 = c2[h2];
                  break;
                }
              return o2 < a2 ? -1 : a2 < o2 ? 1 : 0;
            }, s.prototype.includes = function(e2, t4, r2) {
              return -1 !== this.indexOf(e2, t4, r2);
            }, s.prototype.indexOf = function(e2, t4, r2) {
              return d(this, e2, t4, r2, true);
            }, s.prototype.lastIndexOf = function(e2, t4, r2) {
              return d(this, e2, t4, r2, false);
            }, s.prototype.write = function(e2, t4, r2, n2) {
              if (void 0 === t4)
                n2 = "utf8", r2 = this.length, t4 = 0;
              else if (void 0 === r2 && "string" == typeof t4)
                n2 = t4, r2 = this.length, t4 = 0;
              else {
                if (!isFinite(t4))
                  throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                t4 >>>= 0, isFinite(r2) ? (r2 >>>= 0, void 0 === n2 && (n2 = "utf8")) : (n2 = r2, r2 = void 0);
              }
              var i2 = this.length - t4;
              if ((void 0 === r2 || r2 > i2) && (r2 = i2), e2.length > 0 && (r2 < 0 || t4 < 0) || t4 > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
              n2 || (n2 = "utf8");
              for (var o2 = false; ; )
                switch (n2) {
                  case "hex":
                    return y(this, e2, t4, r2);
                  case "utf8":
                  case "utf-8":
                    return b(this, e2, t4, r2);
                  case "ascii":
                    return m(this, e2, t4, r2);
                  case "latin1":
                  case "binary":
                    return v(this, e2, t4, r2);
                  case "base64":
                    return w(this, e2, t4, r2);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return _(this, e2, t4, r2);
                  default:
                    if (o2)
                      throw new TypeError("Unknown encoding: " + n2);
                    n2 = ("" + n2).toLowerCase(), o2 = true;
                }
            }, s.prototype.toJSON = function() {
              return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
            };
            var E = 4096;
            function C(e2, t4, r2) {
              var n2 = "";
              r2 = Math.min(e2.length, r2);
              for (var i2 = t4; i2 < r2; ++i2)
                n2 += String.fromCharCode(127 & e2[i2]);
              return n2;
            }
            function T(e2, t4, r2) {
              var n2 = "";
              r2 = Math.min(e2.length, r2);
              for (var i2 = t4; i2 < r2; ++i2)
                n2 += String.fromCharCode(e2[i2]);
              return n2;
            }
            function x(e2, t4, r2) {
              var n2 = e2.length;
              (!t4 || t4 < 0) && (t4 = 0), (!r2 || r2 < 0 || r2 > n2) && (r2 = n2);
              for (var i2 = "", o2 = t4; o2 < r2; ++o2)
                i2 += N(e2[o2]);
              return i2;
            }
            function A(e2, t4, r2) {
              for (var n2 = e2.slice(t4, r2), i2 = "", o2 = 0; o2 < n2.length; o2 += 2)
                i2 += String.fromCharCode(n2[o2] + 256 * n2[o2 + 1]);
              return i2;
            }
            function I(e2, t4, r2) {
              if (e2 % 1 != 0 || e2 < 0)
                throw new RangeError("offset is not uint");
              if (e2 + t4 > r2)
                throw new RangeError("Trying to access beyond buffer length");
            }
            function P(e2, t4, r2, n2, i2, o2) {
              if (!s.isBuffer(e2))
                throw new TypeError('"buffer" argument must be a Buffer instance');
              if (t4 > i2 || t4 < o2)
                throw new RangeError('"value" argument is out of bounds');
              if (r2 + n2 > e2.length)
                throw new RangeError("Index out of range");
            }
            function O(e2, t4, r2, n2, i2, o2) {
              if (r2 + n2 > e2.length)
                throw new RangeError("Index out of range");
              if (r2 < 0)
                throw new RangeError("Index out of range");
            }
            function B(e2, t4, r2, i2, o2) {
              return t4 = +t4, r2 >>>= 0, o2 || O(e2, 0, r2, 4), n.write(e2, t4, r2, i2, 23, 4), r2 + 4;
            }
            function R(e2, t4, r2, i2, o2) {
              return t4 = +t4, r2 >>>= 0, o2 || O(e2, 0, r2, 8), n.write(e2, t4, r2, i2, 52, 8), r2 + 8;
            }
            s.prototype.slice = function(e2, t4) {
              var r2 = this.length;
              e2 = ~~e2, t4 = void 0 === t4 ? r2 : ~~t4, e2 < 0 ? (e2 += r2) < 0 && (e2 = 0) : e2 > r2 && (e2 = r2), t4 < 0 ? (t4 += r2) < 0 && (t4 = 0) : t4 > r2 && (t4 = r2), t4 < e2 && (t4 = e2);
              var n2 = this.subarray(e2, t4);
              return n2.__proto__ = s.prototype, n2;
            }, s.prototype.readUIntLE = function(e2, t4, r2) {
              e2 >>>= 0, t4 >>>= 0, r2 || I(e2, t4, this.length);
              for (var n2 = this[e2], i2 = 1, o2 = 0; ++o2 < t4 && (i2 *= 256); )
                n2 += this[e2 + o2] * i2;
              return n2;
            }, s.prototype.readUIntBE = function(e2, t4, r2) {
              e2 >>>= 0, t4 >>>= 0, r2 || I(e2, t4, this.length);
              for (var n2 = this[e2 + --t4], i2 = 1; t4 > 0 && (i2 *= 256); )
                n2 += this[e2 + --t4] * i2;
              return n2;
            }, s.prototype.readUInt8 = function(e2, t4) {
              return e2 >>>= 0, t4 || I(e2, 1, this.length), this[e2];
            }, s.prototype.readUInt16LE = function(e2, t4) {
              return e2 >>>= 0, t4 || I(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
            }, s.prototype.readUInt16BE = function(e2, t4) {
              return e2 >>>= 0, t4 || I(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
            }, s.prototype.readUInt32LE = function(e2, t4) {
              return e2 >>>= 0, t4 || I(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
            }, s.prototype.readUInt32BE = function(e2, t4) {
              return e2 >>>= 0, t4 || I(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
            }, s.prototype.readIntLE = function(e2, t4, r2) {
              e2 >>>= 0, t4 >>>= 0, r2 || I(e2, t4, this.length);
              for (var n2 = this[e2], i2 = 1, o2 = 0; ++o2 < t4 && (i2 *= 256); )
                n2 += this[e2 + o2] * i2;
              return n2 >= (i2 *= 128) && (n2 -= Math.pow(2, 8 * t4)), n2;
            }, s.prototype.readIntBE = function(e2, t4, r2) {
              e2 >>>= 0, t4 >>>= 0, r2 || I(e2, t4, this.length);
              for (var n2 = t4, i2 = 1, o2 = this[e2 + --n2]; n2 > 0 && (i2 *= 256); )
                o2 += this[e2 + --n2] * i2;
              return o2 >= (i2 *= 128) && (o2 -= Math.pow(2, 8 * t4)), o2;
            }, s.prototype.readInt8 = function(e2, t4) {
              return e2 >>>= 0, t4 || I(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
            }, s.prototype.readInt16LE = function(e2, t4) {
              e2 >>>= 0, t4 || I(e2, 2, this.length);
              var r2 = this[e2] | this[e2 + 1] << 8;
              return 32768 & r2 ? 4294901760 | r2 : r2;
            }, s.prototype.readInt16BE = function(e2, t4) {
              e2 >>>= 0, t4 || I(e2, 2, this.length);
              var r2 = this[e2 + 1] | this[e2] << 8;
              return 32768 & r2 ? 4294901760 | r2 : r2;
            }, s.prototype.readInt32LE = function(e2, t4) {
              return e2 >>>= 0, t4 || I(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
            }, s.prototype.readInt32BE = function(e2, t4) {
              return e2 >>>= 0, t4 || I(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
            }, s.prototype.readFloatLE = function(e2, t4) {
              return e2 >>>= 0, t4 || I(e2, 4, this.length), n.read(this, e2, true, 23, 4);
            }, s.prototype.readFloatBE = function(e2, t4) {
              return e2 >>>= 0, t4 || I(e2, 4, this.length), n.read(this, e2, false, 23, 4);
            }, s.prototype.readDoubleLE = function(e2, t4) {
              return e2 >>>= 0, t4 || I(e2, 8, this.length), n.read(this, e2, true, 52, 8);
            }, s.prototype.readDoubleBE = function(e2, t4) {
              return e2 >>>= 0, t4 || I(e2, 8, this.length), n.read(this, e2, false, 52, 8);
            }, s.prototype.writeUIntLE = function(e2, t4, r2, n2) {
              (e2 = +e2, t4 >>>= 0, r2 >>>= 0, n2) || P(this, e2, t4, r2, Math.pow(2, 8 * r2) - 1, 0);
              var i2 = 1, o2 = 0;
              for (this[t4] = 255 & e2; ++o2 < r2 && (i2 *= 256); )
                this[t4 + o2] = e2 / i2 & 255;
              return t4 + r2;
            }, s.prototype.writeUIntBE = function(e2, t4, r2, n2) {
              (e2 = +e2, t4 >>>= 0, r2 >>>= 0, n2) || P(this, e2, t4, r2, Math.pow(2, 8 * r2) - 1, 0);
              var i2 = r2 - 1, o2 = 1;
              for (this[t4 + i2] = 255 & e2; --i2 >= 0 && (o2 *= 256); )
                this[t4 + i2] = e2 / o2 & 255;
              return t4 + r2;
            }, s.prototype.writeUInt8 = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 1, 255, 0), this[t4] = 255 & e2, t4 + 1;
            }, s.prototype.writeUInt16LE = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 2, 65535, 0), this[t4] = 255 & e2, this[t4 + 1] = e2 >>> 8, t4 + 2;
            }, s.prototype.writeUInt16BE = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 2, 65535, 0), this[t4] = e2 >>> 8, this[t4 + 1] = 255 & e2, t4 + 2;
            }, s.prototype.writeUInt32LE = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 4, 4294967295, 0), this[t4 + 3] = e2 >>> 24, this[t4 + 2] = e2 >>> 16, this[t4 + 1] = e2 >>> 8, this[t4] = 255 & e2, t4 + 4;
            }, s.prototype.writeUInt32BE = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 4, 4294967295, 0), this[t4] = e2 >>> 24, this[t4 + 1] = e2 >>> 16, this[t4 + 2] = e2 >>> 8, this[t4 + 3] = 255 & e2, t4 + 4;
            }, s.prototype.writeIntLE = function(e2, t4, r2, n2) {
              if (e2 = +e2, t4 >>>= 0, !n2) {
                var i2 = Math.pow(2, 8 * r2 - 1);
                P(this, e2, t4, r2, i2 - 1, -i2);
              }
              var o2 = 0, s2 = 1, a2 = 0;
              for (this[t4] = 255 & e2; ++o2 < r2 && (s2 *= 256); )
                e2 < 0 && 0 === a2 && 0 !== this[t4 + o2 - 1] && (a2 = 1), this[t4 + o2] = (e2 / s2 >> 0) - a2 & 255;
              return t4 + r2;
            }, s.prototype.writeIntBE = function(e2, t4, r2, n2) {
              if (e2 = +e2, t4 >>>= 0, !n2) {
                var i2 = Math.pow(2, 8 * r2 - 1);
                P(this, e2, t4, r2, i2 - 1, -i2);
              }
              var o2 = r2 - 1, s2 = 1, a2 = 0;
              for (this[t4 + o2] = 255 & e2; --o2 >= 0 && (s2 *= 256); )
                e2 < 0 && 0 === a2 && 0 !== this[t4 + o2 + 1] && (a2 = 1), this[t4 + o2] = (e2 / s2 >> 0) - a2 & 255;
              return t4 + r2;
            }, s.prototype.writeInt8 = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 1, 127, -128), e2 < 0 && (e2 = 255 + e2 + 1), this[t4] = 255 & e2, t4 + 1;
            }, s.prototype.writeInt16LE = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 2, 32767, -32768), this[t4] = 255 & e2, this[t4 + 1] = e2 >>> 8, t4 + 2;
            }, s.prototype.writeInt16BE = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 2, 32767, -32768), this[t4] = e2 >>> 8, this[t4 + 1] = 255 & e2, t4 + 2;
            }, s.prototype.writeInt32LE = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 4, 2147483647, -2147483648), this[t4] = 255 & e2, this[t4 + 1] = e2 >>> 8, this[t4 + 2] = e2 >>> 16, this[t4 + 3] = e2 >>> 24, t4 + 4;
            }, s.prototype.writeInt32BE = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 4, 2147483647, -2147483648), e2 < 0 && (e2 = 4294967295 + e2 + 1), this[t4] = e2 >>> 24, this[t4 + 1] = e2 >>> 16, this[t4 + 2] = e2 >>> 8, this[t4 + 3] = 255 & e2, t4 + 4;
            }, s.prototype.writeFloatLE = function(e2, t4, r2) {
              return B(this, e2, t4, true, r2);
            }, s.prototype.writeFloatBE = function(e2, t4, r2) {
              return B(this, e2, t4, false, r2);
            }, s.prototype.writeDoubleLE = function(e2, t4, r2) {
              return R(this, e2, t4, true, r2);
            }, s.prototype.writeDoubleBE = function(e2, t4, r2) {
              return R(this, e2, t4, false, r2);
            }, s.prototype.copy = function(e2, t4, r2, n2) {
              if (!s.isBuffer(e2))
                throw new TypeError("argument should be a Buffer");
              if (r2 || (r2 = 0), n2 || 0 === n2 || (n2 = this.length), t4 >= e2.length && (t4 = e2.length), t4 || (t4 = 0), n2 > 0 && n2 < r2 && (n2 = r2), n2 === r2)
                return 0;
              if (0 === e2.length || 0 === this.length)
                return 0;
              if (t4 < 0)
                throw new RangeError("targetStart out of bounds");
              if (r2 < 0 || r2 >= this.length)
                throw new RangeError("Index out of range");
              if (n2 < 0)
                throw new RangeError("sourceEnd out of bounds");
              n2 > this.length && (n2 = this.length), e2.length - t4 < n2 - r2 && (n2 = e2.length - t4 + r2);
              var i2 = n2 - r2;
              if (this === e2 && "function" == typeof Uint8Array.prototype.copyWithin)
                this.copyWithin(t4, r2, n2);
              else if (this === e2 && r2 < t4 && t4 < n2)
                for (var o2 = i2 - 1; o2 >= 0; --o2)
                  e2[o2 + t4] = this[o2 + r2];
              else
                Uint8Array.prototype.set.call(e2, this.subarray(r2, n2), t4);
              return i2;
            }, s.prototype.fill = function(e2, t4, r2, n2) {
              if ("string" == typeof e2) {
                if ("string" == typeof t4 ? (n2 = t4, t4 = 0, r2 = this.length) : "string" == typeof r2 && (n2 = r2, r2 = this.length), void 0 !== n2 && "string" != typeof n2)
                  throw new TypeError("encoding must be a string");
                if ("string" == typeof n2 && !s.isEncoding(n2))
                  throw new TypeError("Unknown encoding: " + n2);
                if (1 === e2.length) {
                  var i2 = e2.charCodeAt(0);
                  ("utf8" === n2 && i2 < 128 || "latin1" === n2) && (e2 = i2);
                }
              } else
                "number" == typeof e2 && (e2 &= 255);
              if (t4 < 0 || this.length < t4 || this.length < r2)
                throw new RangeError("Out of range index");
              if (r2 <= t4)
                return this;
              var o2;
              if (t4 >>>= 0, r2 = void 0 === r2 ? this.length : r2 >>> 0, e2 || (e2 = 0), "number" == typeof e2)
                for (o2 = t4; o2 < r2; ++o2)
                  this[o2] = e2;
              else {
                var a2 = s.isBuffer(e2) ? e2 : s.from(e2, n2), l2 = a2.length;
                if (0 === l2)
                  throw new TypeError('The value "' + e2 + '" is invalid for argument "value"');
                for (o2 = 0; o2 < r2 - t4; ++o2)
                  this[o2 + t4] = a2[o2 % l2];
              }
              return this;
            };
            var M = /[^+/0-9A-Za-z-_]/g;
            function N(e2) {
              return e2 < 16 ? "0" + e2.toString(16) : e2.toString(16);
            }
            function L(e2, t4) {
              var r2;
              t4 = t4 || 1 / 0;
              for (var n2 = e2.length, i2 = null, o2 = [], s2 = 0; s2 < n2; ++s2) {
                if ((r2 = e2.charCodeAt(s2)) > 55295 && r2 < 57344) {
                  if (!i2) {
                    if (r2 > 56319) {
                      (t4 -= 3) > -1 && o2.push(239, 191, 189);
                      continue;
                    }
                    if (s2 + 1 === n2) {
                      (t4 -= 3) > -1 && o2.push(239, 191, 189);
                      continue;
                    }
                    i2 = r2;
                    continue;
                  }
                  if (r2 < 56320) {
                    (t4 -= 3) > -1 && o2.push(239, 191, 189), i2 = r2;
                    continue;
                  }
                  r2 = 65536 + (i2 - 55296 << 10 | r2 - 56320);
                } else
                  i2 && (t4 -= 3) > -1 && o2.push(239, 191, 189);
                if (i2 = null, r2 < 128) {
                  if ((t4 -= 1) < 0)
                    break;
                  o2.push(r2);
                } else if (r2 < 2048) {
                  if ((t4 -= 2) < 0)
                    break;
                  o2.push(r2 >> 6 | 192, 63 & r2 | 128);
                } else if (r2 < 65536) {
                  if ((t4 -= 3) < 0)
                    break;
                  o2.push(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128);
                } else {
                  if (!(r2 < 1114112))
                    throw new Error("Invalid code point");
                  if ((t4 -= 4) < 0)
                    break;
                  o2.push(r2 >> 18 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128);
                }
              }
              return o2;
            }
            function j(e2) {
              return t3.toByteArray(function(e3) {
                if ((e3 = (e3 = e3.split("=")[0]).trim().replace(M, "")).length < 2)
                  return "";
                for (; e3.length % 4 != 0; )
                  e3 += "=";
                return e3;
              }(e2));
            }
            function U(e2, t4, r2, n2) {
              for (var i2 = 0; i2 < n2 && !(i2 + r2 >= t4.length || i2 >= e2.length); ++i2)
                t4[i2 + r2] = e2[i2];
              return i2;
            }
            function q(e2, t4) {
              return e2 instanceof t4 || null != e2 && null != e2.constructor && null != e2.constructor.name && e2.constructor.name === t4.name;
            }
            function D(e2) {
              return e2 != e2;
            }
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { "base64-js": 13, buffer: 17, ieee754: 23 }], 18: [function(e, t, r) {
        (function(n) {
          (function() {
            r.formatArgs = function(e2) {
              if (e2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e2[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors)
                return;
              const r2 = "color: " + this.color;
              e2.splice(1, 0, r2, "color: inherit");
              let n2 = 0, i2 = 0;
              e2[0].replace(/%[a-zA-Z%]/g, (e3) => {
                "%%" !== e3 && "%c" === e3 && (i2 = ++n2);
              }), e2.splice(i2, 0, r2);
            }, r.save = function(e2) {
              try {
                e2 ? r.storage.setItem("debug", e2) : r.storage.removeItem("debug");
              } catch (e3) {
              }
            }, r.load = function() {
              let e2;
              try {
                e2 = r.storage.getItem("debug");
              } catch (e3) {
              }
              !e2 && void 0 !== n && "env" in n && (e2 = n.env.DEBUG);
              return e2;
            }, r.useColors = function() {
              if ("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs))
                return true;
              if ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
                return false;
              return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
            }, r.storage = function() {
              try {
                return localStorage;
              } catch (e2) {
              }
            }(), r.destroy = (() => {
              let e2 = false;
              return () => {
                e2 || (e2 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
              };
            })(), r.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], r.log = console.debug || console.log || (() => {
            }), t.exports = e("./common")(r);
            const { formatters: i } = t.exports;
            i.j = function(e2) {
              try {
                return JSON.stringify(e2);
              } catch (e3) {
                return "[UnexpectedJSONParseError]: " + e3.message;
              }
            };
          }).call(this);
        }).call(this, e("_process"));
      }, { "./common": 19, _process: 50 }], 19: [function(e, t, r) {
        t.exports = function(t2) {
          function r2(e2) {
            let t3, i2, o, s = null;
            function a(...e3) {
              if (!a.enabled)
                return;
              const n2 = a, i3 = Number(/* @__PURE__ */ new Date()), o2 = i3 - (t3 || i3);
              n2.diff = o2, n2.prev = t3, n2.curr = i3, t3 = i3, e3[0] = r2.coerce(e3[0]), "string" != typeof e3[0] && e3.unshift("%O");
              let s2 = 0;
              e3[0] = e3[0].replace(/%([a-zA-Z%])/g, (t4, i4) => {
                if ("%%" === t4)
                  return "%";
                s2++;
                const o3 = r2.formatters[i4];
                if ("function" == typeof o3) {
                  const r3 = e3[s2];
                  t4 = o3.call(n2, r3), e3.splice(s2, 1), s2--;
                }
                return t4;
              }), r2.formatArgs.call(n2, e3), (n2.log || r2.log).apply(n2, e3);
            }
            return a.namespace = e2, a.useColors = r2.useColors(), a.color = r2.selectColor(e2), a.extend = n, a.destroy = r2.destroy, Object.defineProperty(a, "enabled", { enumerable: true, configurable: false, get: () => null !== s ? s : (i2 !== r2.namespaces && (i2 = r2.namespaces, o = r2.enabled(e2)), o), set: (e3) => {
              s = e3;
            } }), "function" == typeof r2.init && r2.init(a), a;
          }
          function n(e2, t3) {
            const n2 = r2(this.namespace + (void 0 === t3 ? ":" : t3) + e2);
            return n2.log = this.log, n2;
          }
          function i(e2) {
            return e2.toString().substring(2, e2.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          return r2.debug = r2, r2.default = r2, r2.coerce = function(e2) {
            return e2 instanceof Error ? e2.stack || e2.message : e2;
          }, r2.disable = function() {
            const e2 = [...r2.names.map(i), ...r2.skips.map(i).map((e3) => "-" + e3)].join(",");
            return r2.enable(""), e2;
          }, r2.enable = function(e2) {
            let t3;
            r2.save(e2), r2.namespaces = e2, r2.names = [], r2.skips = [];
            const n2 = ("string" == typeof e2 ? e2 : "").split(/[\s,]+/), i2 = n2.length;
            for (t3 = 0; t3 < i2; t3++)
              n2[t3] && ("-" === (e2 = n2[t3].replace(/\*/g, ".*?"))[0] ? r2.skips.push(new RegExp("^" + e2.substr(1) + "$")) : r2.names.push(new RegExp("^" + e2 + "$")));
          }, r2.enabled = function(e2) {
            if ("*" === e2[e2.length - 1])
              return true;
            let t3, n2;
            for (t3 = 0, n2 = r2.skips.length; t3 < n2; t3++)
              if (r2.skips[t3].test(e2))
                return false;
            for (t3 = 0, n2 = r2.names.length; t3 < n2; t3++)
              if (r2.names[t3].test(e2))
                return true;
            return false;
          }, r2.humanize = e("ms"), r2.destroy = function() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }, Object.keys(t2).forEach((e2) => {
            r2[e2] = t2[e2];
          }), r2.names = [], r2.skips = [], r2.formatters = {}, r2.selectColor = function(e2) {
            let t3 = 0;
            for (let r3 = 0; r3 < e2.length; r3++)
              t3 = (t3 << 5) - t3 + e2.charCodeAt(r3), t3 |= 0;
            return r2.colors[Math.abs(t3) % r2.colors.length];
          }, r2.enable(r2.load()), r2;
        };
      }, { ms: 45 }], 20: [function(e, t, r) {
        (function(r2, n) {
          (function() {
            var i = e("readable-stream"), o = e("end-of-stream"), s = e("inherits"), a = e("stream-shift"), l = n.from && n.from !== Uint8Array.from ? n.from([0]) : new n([0]), u = function(e2, t2) {
              e2._corked ? e2.once("uncork", t2) : t2();
            }, c = function(e2, t2) {
              return function(r3) {
                r3 ? function(e3, t3) {
                  e3._autoDestroy && e3.destroy(t3);
                }(e2, "premature close" === r3.message ? null : r3) : t2 && !e2._ended && e2.end();
              };
            }, h = function() {
            }, f = function(e2, t2, r3) {
              if (!(this instanceof f))
                return new f(e2, t2, r3);
              i.Duplex.call(this, r3), this._writable = null, this._readable = null, this._readable2 = null, this._autoDestroy = !r3 || false !== r3.autoDestroy, this._forwardDestroy = !r3 || false !== r3.destroy, this._forwardEnd = !r3 || false !== r3.end, this._corked = 1, this._ondrain = null, this._drained = false, this._forwarding = false, this._unwrite = null, this._unread = null, this._ended = false, this.destroyed = false, e2 && this.setWritable(e2), t2 && this.setReadable(t2);
            };
            s(f, i.Duplex), f.obj = function(e2, t2, r3) {
              return r3 || (r3 = {}), r3.objectMode = true, r3.highWaterMark = 16, new f(e2, t2, r3);
            }, f.prototype.cork = function() {
              1 == ++this._corked && this.emit("cork");
            }, f.prototype.uncork = function() {
              this._corked && 0 == --this._corked && this.emit("uncork");
            }, f.prototype.setWritable = function(e2) {
              if (this._unwrite && this._unwrite(), this.destroyed)
                e2 && e2.destroy && e2.destroy();
              else if (null !== e2 && false !== e2) {
                var t2 = this, n2 = o(e2, { writable: true, readable: false }, c(this, this._forwardEnd)), i2 = function() {
                  var e3 = t2._ondrain;
                  t2._ondrain = null, e3 && e3();
                };
                this._unwrite && r2.nextTick(i2), this._writable = e2, this._writable.on("drain", i2), this._unwrite = function() {
                  t2._writable.removeListener("drain", i2), n2();
                }, this.uncork();
              } else
                this.end();
            }, f.prototype.setReadable = function(e2) {
              if (this._unread && this._unread(), this.destroyed)
                e2 && e2.destroy && e2.destroy();
              else {
                if (null === e2 || false === e2)
                  return this.push(null), void this.resume();
                var t2, r3 = this, n2 = o(e2, { writable: false, readable: true }, c(this)), s2 = function() {
                  r3._forward();
                }, a2 = function() {
                  r3.push(null);
                };
                this._drained = true, this._readable = e2, this._readable2 = e2._readableState ? e2 : (t2 = e2, new i.Readable({ objectMode: true, highWaterMark: 16 }).wrap(t2)), this._readable2.on("readable", s2), this._readable2.on("end", a2), this._unread = function() {
                  r3._readable2.removeListener("readable", s2), r3._readable2.removeListener("end", a2), n2();
                }, this._forward();
              }
            }, f.prototype._read = function() {
              this._drained = true, this._forward();
            }, f.prototype._forward = function() {
              if (!this._forwarding && this._readable2 && this._drained) {
                var e2;
                for (this._forwarding = true; this._drained && null !== (e2 = a(this._readable2)); )
                  this.destroyed || (this._drained = this.push(e2));
                this._forwarding = false;
              }
            }, f.prototype.destroy = function(e2, t2) {
              if (t2 || (t2 = h), this.destroyed)
                return t2(null);
              this.destroyed = true;
              var n2 = this;
              r2.nextTick(function() {
                n2._destroy(e2), t2(null);
              });
            }, f.prototype._destroy = function(e2) {
              if (e2) {
                var t2 = this._ondrain;
                this._ondrain = null, t2 ? t2(e2) : this.emit("error", e2);
              }
              this._forwardDestroy && (this._readable && this._readable.destroy && this._readable.destroy(), this._writable && this._writable.destroy && this._writable.destroy()), this.emit("close");
            }, f.prototype._write = function(e2, t2, r3) {
              if (!this.destroyed)
                return this._corked ? u(this, this._write.bind(this, e2, t2, r3)) : e2 === l ? this._finish(r3) : this._writable ? void (false === this._writable.write(e2) ? this._ondrain = r3 : this.destroyed || r3()) : r3();
            }, f.prototype._finish = function(e2) {
              var t2 = this;
              this.emit("preend"), u(this, function() {
                var r3, n2;
                r3 = t2._forwardEnd && t2._writable, n2 = function() {
                  false === t2._writableState.prefinished && (t2._writableState.prefinished = true), t2.emit("prefinish"), u(t2, e2);
                }, r3 ? r3._writableState && r3._writableState.finished ? n2() : r3._writableState ? r3.end(n2) : (r3.end(), n2()) : n2();
              });
            }, f.prototype.end = function(e2, t2, r3) {
              return "function" == typeof e2 ? this.end(null, null, e2) : "function" == typeof t2 ? this.end(e2, null, t2) : (this._ended = true, e2 && this.write(e2), this._writableState.ending || this._writableState.destroyed || this.write(l), i.Writable.prototype.end.call(this, r3));
            }, t.exports = f;
          }).call(this);
        }).call(this, e("_process"), e("buffer").Buffer);
      }, { _process: 50, buffer: 17, "end-of-stream": 21, inherits: 24, "readable-stream": 69, "stream-shift": 74 }], 21: [function(e, t, r) {
        (function(r2) {
          (function() {
            var n = e("once"), i = function() {
            }, o = function(e2, t2, s) {
              if ("function" == typeof t2)
                return o(e2, null, t2);
              t2 || (t2 = {}), s = n(s || i);
              var a = e2._writableState, l = e2._readableState, u = t2.readable || false !== t2.readable && e2.readable, c = t2.writable || false !== t2.writable && e2.writable, h = false, f = function() {
                e2.writable || p();
              }, p = function() {
                c = false, u || s.call(e2);
              }, d = function() {
                u = false, c || s.call(e2);
              }, g = function(t3) {
                s.call(e2, t3 ? new Error("exited with error code: " + t3) : null);
              }, y = function(t3) {
                s.call(e2, t3);
              }, b = function() {
                r2.nextTick(m);
              }, m = function() {
                if (!h)
                  return (!u || l && l.ended && !l.destroyed) && (!c || a && a.ended && !a.destroyed) ? void 0 : s.call(e2, new Error("premature close"));
              }, v = function() {
                e2.req.on("finish", p);
              };
              return !function(e3) {
                return e3.setHeader && "function" == typeof e3.abort;
              }(e2) ? c && !a && (e2.on("end", f), e2.on("close", f)) : (e2.on("complete", p), e2.on("abort", b), e2.req ? v() : e2.on("request", v)), function(e3) {
                return e3.stdio && Array.isArray(e3.stdio) && 3 === e3.stdio.length;
              }(e2) && e2.on("exit", g), e2.on("end", d), e2.on("finish", p), false !== t2.error && e2.on("error", y), e2.on("close", b), function() {
                h = true, e2.removeListener("complete", p), e2.removeListener("abort", b), e2.removeListener("request", v), e2.req && e2.req.removeListener("finish", p), e2.removeListener("end", f), e2.removeListener("close", f), e2.removeListener("finish", p), e2.removeListener("exit", g), e2.removeListener("end", d), e2.removeListener("error", y), e2.removeListener("close", b);
              };
            };
            t.exports = o;
          }).call(this);
        }).call(this, e("_process"));
      }, { _process: 50, once: 48 }], 22: [function(e, t, r) {
        var n = Object.create || function(e2) {
          var t2 = function() {
          };
          return t2.prototype = e2, new t2();
        }, i = Object.keys || function(e2) {
          var t2 = [];
          for (var r2 in e2)
            Object.prototype.hasOwnProperty.call(e2, r2) && t2.push(r2);
          return r2;
        }, o = Function.prototype.bind || function(e2) {
          var t2 = this;
          return function() {
            return t2.apply(e2, arguments);
          };
        };
        function s() {
          this._events && Object.prototype.hasOwnProperty.call(this, "_events") || (this._events = n(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }
        t.exports = s, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._maxListeners = void 0;
        var a, l = 10;
        try {
          var u = {};
          Object.defineProperty && Object.defineProperty(u, "x", { value: 0 }), a = 0 === u.x;
        } catch (e2) {
          a = false;
        }
        function c(e2) {
          return void 0 === e2._maxListeners ? s.defaultMaxListeners : e2._maxListeners;
        }
        function h(e2, t2, r2, i2) {
          var o2, s2, a2;
          if ("function" != typeof r2)
            throw new TypeError('"listener" argument must be a function');
          if ((s2 = e2._events) ? (s2.newListener && (e2.emit("newListener", t2, r2.listener ? r2.listener : r2), s2 = e2._events), a2 = s2[t2]) : (s2 = e2._events = n(null), e2._eventsCount = 0), a2) {
            if ("function" == typeof a2 ? a2 = s2[t2] = i2 ? [r2, a2] : [a2, r2] : i2 ? a2.unshift(r2) : a2.push(r2), !a2.warned && (o2 = c(e2)) && o2 > 0 && a2.length > o2) {
              a2.warned = true;
              var l2 = new Error("Possible EventEmitter memory leak detected. " + a2.length + ' "' + String(t2) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
              l2.name = "MaxListenersExceededWarning", l2.emitter = e2, l2.type = t2, l2.count = a2.length, "object" == typeof console && console.warn && console.warn("%s: %s", l2.name, l2.message);
            }
          } else
            a2 = s2[t2] = r2, ++e2._eventsCount;
          return e2;
        }
        function f() {
          if (!this.fired)
            switch (this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length) {
              case 0:
                return this.listener.call(this.target);
              case 1:
                return this.listener.call(this.target, arguments[0]);
              case 2:
                return this.listener.call(this.target, arguments[0], arguments[1]);
              case 3:
                return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);
              default:
                for (var e2 = new Array(arguments.length), t2 = 0; t2 < e2.length; ++t2)
                  e2[t2] = arguments[t2];
                this.listener.apply(this.target, e2);
            }
        }
        function p(e2, t2, r2) {
          var n2 = { fired: false, wrapFn: void 0, target: e2, type: t2, listener: r2 }, i2 = o.call(f, n2);
          return i2.listener = r2, n2.wrapFn = i2, i2;
        }
        function d(e2, t2, r2) {
          var n2 = e2._events;
          if (!n2)
            return [];
          var i2 = n2[t2];
          return i2 ? "function" == typeof i2 ? r2 ? [i2.listener || i2] : [i2] : r2 ? function(e3) {
            for (var t3 = new Array(e3.length), r3 = 0; r3 < t3.length; ++r3)
              t3[r3] = e3[r3].listener || e3[r3];
            return t3;
          }(i2) : y(i2, i2.length) : [];
        }
        function g(e2) {
          var t2 = this._events;
          if (t2) {
            var r2 = t2[e2];
            if ("function" == typeof r2)
              return 1;
            if (r2)
              return r2.length;
          }
          return 0;
        }
        function y(e2, t2) {
          for (var r2 = new Array(t2), n2 = 0; n2 < t2; ++n2)
            r2[n2] = e2[n2];
          return r2;
        }
        a ? Object.defineProperty(s, "defaultMaxListeners", { enumerable: true, get: function() {
          return l;
        }, set: function(e2) {
          if ("number" != typeof e2 || e2 < 0 || e2 != e2)
            throw new TypeError('"defaultMaxListeners" must be a positive number');
          l = e2;
        } }) : s.defaultMaxListeners = l, s.prototype.setMaxListeners = function(e2) {
          if ("number" != typeof e2 || e2 < 0 || isNaN(e2))
            throw new TypeError('"n" argument must be a positive number');
          return this._maxListeners = e2, this;
        }, s.prototype.getMaxListeners = function() {
          return c(this);
        }, s.prototype.emit = function(e2) {
          var t2, r2, n2, i2, o2, s2, a2 = "error" === e2;
          if (s2 = this._events)
            a2 = a2 && null == s2.error;
          else if (!a2)
            return false;
          if (a2) {
            if (arguments.length > 1 && (t2 = arguments[1]), t2 instanceof Error)
              throw t2;
            var l2 = new Error('Unhandled "error" event. (' + t2 + ")");
            throw l2.context = t2, l2;
          }
          if (!(r2 = s2[e2]))
            return false;
          var u2 = "function" == typeof r2;
          switch (n2 = arguments.length) {
            case 1:
              !function(e3, t3, r3) {
                if (t3)
                  e3.call(r3);
                else
                  for (var n3 = e3.length, i3 = y(e3, n3), o3 = 0; o3 < n3; ++o3)
                    i3[o3].call(r3);
              }(r2, u2, this);
              break;
            case 2:
              !function(e3, t3, r3, n3) {
                if (t3)
                  e3.call(r3, n3);
                else
                  for (var i3 = e3.length, o3 = y(e3, i3), s3 = 0; s3 < i3; ++s3)
                    o3[s3].call(r3, n3);
              }(r2, u2, this, arguments[1]);
              break;
            case 3:
              !function(e3, t3, r3, n3, i3) {
                if (t3)
                  e3.call(r3, n3, i3);
                else
                  for (var o3 = e3.length, s3 = y(e3, o3), a3 = 0; a3 < o3; ++a3)
                    s3[a3].call(r3, n3, i3);
              }(r2, u2, this, arguments[1], arguments[2]);
              break;
            case 4:
              !function(e3, t3, r3, n3, i3, o3) {
                if (t3)
                  e3.call(r3, n3, i3, o3);
                else
                  for (var s3 = e3.length, a3 = y(e3, s3), l3 = 0; l3 < s3; ++l3)
                    a3[l3].call(r3, n3, i3, o3);
              }(r2, u2, this, arguments[1], arguments[2], arguments[3]);
              break;
            default:
              for (i2 = new Array(n2 - 1), o2 = 1; o2 < n2; o2++)
                i2[o2 - 1] = arguments[o2];
              !function(e3, t3, r3, n3) {
                if (t3)
                  e3.apply(r3, n3);
                else
                  for (var i3 = e3.length, o3 = y(e3, i3), s3 = 0; s3 < i3; ++s3)
                    o3[s3].apply(r3, n3);
              }(r2, u2, this, i2);
          }
          return true;
        }, s.prototype.addListener = function(e2, t2) {
          return h(this, e2, t2, false);
        }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(e2, t2) {
          return h(this, e2, t2, true);
        }, s.prototype.once = function(e2, t2) {
          if ("function" != typeof t2)
            throw new TypeError('"listener" argument must be a function');
          return this.on(e2, p(this, e2, t2)), this;
        }, s.prototype.prependOnceListener = function(e2, t2) {
          if ("function" != typeof t2)
            throw new TypeError('"listener" argument must be a function');
          return this.prependListener(e2, p(this, e2, t2)), this;
        }, s.prototype.removeListener = function(e2, t2) {
          var r2, i2, o2, s2, a2;
          if ("function" != typeof t2)
            throw new TypeError('"listener" argument must be a function');
          if (!(i2 = this._events))
            return this;
          if (!(r2 = i2[e2]))
            return this;
          if (r2 === t2 || r2.listener === t2)
            0 == --this._eventsCount ? this._events = n(null) : (delete i2[e2], i2.removeListener && this.emit("removeListener", e2, r2.listener || t2));
          else if ("function" != typeof r2) {
            for (o2 = -1, s2 = r2.length - 1; s2 >= 0; s2--)
              if (r2[s2] === t2 || r2[s2].listener === t2) {
                a2 = r2[s2].listener, o2 = s2;
                break;
              }
            if (o2 < 0)
              return this;
            0 === o2 ? r2.shift() : function(e3, t3) {
              for (var r3 = t3, n2 = r3 + 1, i3 = e3.length; n2 < i3; r3 += 1, n2 += 1)
                e3[r3] = e3[n2];
              e3.pop();
            }(r2, o2), 1 === r2.length && (i2[e2] = r2[0]), i2.removeListener && this.emit("removeListener", e2, a2 || t2);
          }
          return this;
        }, s.prototype.removeAllListeners = function(e2) {
          var t2, r2, o2;
          if (!(r2 = this._events))
            return this;
          if (!r2.removeListener)
            return 0 === arguments.length ? (this._events = n(null), this._eventsCount = 0) : r2[e2] && (0 == --this._eventsCount ? this._events = n(null) : delete r2[e2]), this;
          if (0 === arguments.length) {
            var s2, a2 = i(r2);
            for (o2 = 0; o2 < a2.length; ++o2)
              "removeListener" !== (s2 = a2[o2]) && this.removeAllListeners(s2);
            return this.removeAllListeners("removeListener"), this._events = n(null), this._eventsCount = 0, this;
          }
          if ("function" == typeof (t2 = r2[e2]))
            this.removeListener(e2, t2);
          else if (t2)
            for (o2 = t2.length - 1; o2 >= 0; o2--)
              this.removeListener(e2, t2[o2]);
          return this;
        }, s.prototype.listeners = function(e2) {
          return d(this, e2, true);
        }, s.prototype.rawListeners = function(e2) {
          return d(this, e2, false);
        }, s.listenerCount = function(e2, t2) {
          return "function" == typeof e2.listenerCount ? e2.listenerCount(t2) : g.call(e2, t2);
        }, s.prototype.listenerCount = g, s.prototype.eventNames = function() {
          return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
        };
      }, {}], 23: [function(e, t, r) {
        r.read = function(e2, t2, r2, n, i) {
          var o, s, a = 8 * i - n - 1, l = (1 << a) - 1, u = l >> 1, c = -7, h = r2 ? i - 1 : 0, f = r2 ? -1 : 1, p = e2[t2 + h];
          for (h += f, o = p & (1 << -c) - 1, p >>= -c, c += a; c > 0; o = 256 * o + e2[t2 + h], h += f, c -= 8)
            ;
          for (s = o & (1 << -c) - 1, o >>= -c, c += n; c > 0; s = 256 * s + e2[t2 + h], h += f, c -= 8)
            ;
          if (0 === o)
            o = 1 - u;
          else {
            if (o === l)
              return s ? NaN : 1 / 0 * (p ? -1 : 1);
            s += Math.pow(2, n), o -= u;
          }
          return (p ? -1 : 1) * s * Math.pow(2, o - n);
        }, r.write = function(e2, t2, r2, n, i, o) {
          var s, a, l, u = 8 * o - i - 1, c = (1 << u) - 1, h = c >> 1, f = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = n ? 0 : o - 1, d = n ? 1 : -1, g = t2 < 0 || 0 === t2 && 1 / t2 < 0 ? 1 : 0;
          for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (a = isNaN(t2) ? 1 : 0, s = c) : (s = Math.floor(Math.log(t2) / Math.LN2), t2 * (l = Math.pow(2, -s)) < 1 && (s--, l *= 2), (t2 += s + h >= 1 ? f / l : f * Math.pow(2, 1 - h)) * l >= 2 && (s++, l /= 2), s + h >= c ? (a = 0, s = c) : s + h >= 1 ? (a = (t2 * l - 1) * Math.pow(2, i), s += h) : (a = t2 * Math.pow(2, h - 1) * Math.pow(2, i), s = 0)); i >= 8; e2[r2 + p] = 255 & a, p += d, a /= 256, i -= 8)
            ;
          for (s = s << i | a, u += i; u > 0; e2[r2 + p] = 255 & s, p += d, s /= 256, u -= 8)
            ;
          e2[r2 + p - d] |= 128 * g;
        };
      }, {}], 24: [function(e, t, r) {
        "function" == typeof Object.create ? t.exports = function(e2, t2) {
          t2 && (e2.super_ = t2, e2.prototype = Object.create(t2.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } }));
        } : t.exports = function(e2, t2) {
          if (t2) {
            e2.super_ = t2;
            var r2 = function() {
            };
            r2.prototype = t2.prototype, e2.prototype = new r2(), e2.prototype.constructor = e2;
          }
        };
      }, {}], 25: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        var n = function() {
          function e2(e3, t2) {
            this.color = true, this.key = void 0, this.value = void 0, this.parent = void 0, this.brother = void 0, this.leftChild = void 0, this.rightChild = void 0, this.key = e3, this.value = t2;
          }
          return e2.prototype.rotateLeft = function() {
            var e3 = this.parent, t2 = this.brother, r2 = this.leftChild, n2 = this.rightChild;
            if (!n2)
              throw new Error("unknown error");
            var i = n2.leftChild, o = n2.rightChild;
            return e3 && (e3.leftChild === this ? e3.leftChild = n2 : e3.rightChild === this && (e3.rightChild = n2)), n2.parent = e3, n2.brother = t2, n2.leftChild = this, n2.rightChild = o, t2 && (t2.brother = n2), this.parent = n2, this.brother = o, this.leftChild = r2, this.rightChild = i, o && (o.parent = n2, o.brother = this), r2 && (r2.parent = this, r2.brother = i), i && (i.parent = this, i.brother = r2), n2;
          }, e2.prototype.rotateRight = function() {
            var e3 = this.parent, t2 = this.brother, r2 = this.leftChild;
            if (!r2)
              throw new Error("unknown error");
            var n2 = this.rightChild, i = r2.leftChild, o = r2.rightChild;
            return e3 && (e3.leftChild === this ? e3.leftChild = r2 : e3.rightChild === this && (e3.rightChild = r2)), r2.parent = e3, r2.brother = t2, r2.leftChild = i, r2.rightChild = this, t2 && (t2.brother = r2), i && (i.parent = r2, i.brother = this), this.parent = r2, this.brother = i, this.leftChild = o, this.rightChild = n2, o && (o.parent = this, o.brother = n2), n2 && (n2.parent = this, n2.brother = o), r2;
          }, e2.prototype.remove = function() {
            if (this.leftChild || this.rightChild)
              throw new Error("can only remove leaf node");
            this.parent && (this === this.parent.leftChild ? this.parent.leftChild = void 0 : this === this.parent.rightChild && (this.parent.rightChild = void 0)), this.brother && (this.brother.brother = void 0), this.key = void 0, this.value = void 0, this.parent = void 0, this.brother = void 0;
          }, e2.TreeNodeColorType = { red: true, black: false }, e2;
        }();
        Object.freeze(n), r.default = n;
      }, {}], 26: [function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o, s = { label: 0, sent: function() {
            if (1 & i2[0])
              throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
            return this;
          }), o;
          function a(o2) {
            return function(a2) {
              return function(o3) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; s; )
                  try {
                    if (r2 = 1, n2 && (i2 = 2 & o3[0] ? n2.return : o3[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o3[1])).done)
                      return i2;
                    switch (n2 = 0, i2 && (o3 = [2 & o3[0], i2.value]), o3[0]) {
                      case 0:
                      case 1:
                        i2 = o3;
                        break;
                      case 4:
                        return s.label++, { value: o3[1], done: false };
                      case 5:
                        s.label++, n2 = o3[1], o3 = [0];
                        continue;
                      case 7:
                        o3 = s.ops.pop(), s.trys.pop();
                        continue;
                      default:
                        if (!(i2 = (i2 = s.trys).length > 0 && i2[i2.length - 1]) && (6 === o3[0] || 2 === o3[0])) {
                          s = 0;
                          continue;
                        }
                        if (3 === o3[0] && (!i2 || o3[1] > i2[0] && o3[1] < i2[3])) {
                          s.label = o3[1];
                          break;
                        }
                        if (6 === o3[0] && s.label < i2[1]) {
                          s.label = i2[1], i2 = o3;
                          break;
                        }
                        if (i2 && s.label < i2[2]) {
                          s.label = i2[2], s.ops.push(o3);
                          break;
                        }
                        i2[2] && s.ops.pop(), s.trys.pop();
                        continue;
                    }
                    o3 = t2.call(e2, s);
                  } catch (e3) {
                    o3 = [6, e3], n2 = 0;
                  } finally {
                    r2 = i2 = 0;
                  }
                if (5 & o3[0])
                  throw o3[1];
                return { value: o3[0] ? o3[1] : void 0, done: true };
              }([o2, a2]);
            };
          }
        };
        function i(e2) {
          var t2 = this;
          void 0 === e2 && (e2 = []);
          var r2 = [], o = 0, s = 0, a = 0, l = 0, u = 0, c = 0;
          this.size = function() {
            return c;
          }, this.empty = function() {
            return 0 === c;
          }, this.clear = function() {
            o = a = s = l = u = c = 0, f.call(this, i.bucketSize), c = 0;
          }, this.front = function() {
            return r2[o][s];
          }, this.back = function() {
            return r2[a][l];
          }, this.forEach = function(e3) {
            if (!this.empty()) {
              var t3 = 0;
              if (o !== a) {
                for (u2 = s; u2 < i.bucketSize; ++u2)
                  e3(r2[o][u2], t3++);
                for (u2 = o + 1; u2 < a; ++u2)
                  for (var n2 = 0; n2 < i.bucketSize; ++n2)
                    e3(r2[u2][n2], t3++);
                for (u2 = 0; u2 <= l; ++u2)
                  e3(r2[a][u2], t3++);
              } else
                for (var u2 = s; u2 <= l; ++u2)
                  e3(r2[o][u2], t3++);
            }
          };
          var h = function(e3) {
            var t3 = o * i.bucketSize + s, r3 = t3 + e3, n2 = a * i.bucketSize + l;
            if (r3 < t3 || r3 > n2)
              throw new Error("pos should more than 0 and less than queue's size");
            return { curNodeBucketIndex: Math.floor(r3 / i.bucketSize), curNodePointerIndex: r3 % i.bucketSize };
          };
          this.getElementByPos = function(e3) {
            var t3 = h(e3), n2 = t3.curNodeBucketIndex, i2 = t3.curNodePointerIndex;
            return r2[n2][i2];
          }, this.eraseElementByPos = function(e3) {
            var t3 = this;
            if (e3 < 0 || e3 > c)
              throw new Error("pos should more than 0 and less than queue's size");
            if (0 === e3)
              this.popFront();
            else if (e3 === this.size())
              this.popBack();
            else {
              for (var r3 = [], n2 = e3 + 1; n2 < c; ++n2)
                r3.push(this.getElementByPos(n2));
              this.cut(e3), this.popBack(), r3.forEach(function(e4) {
                return t3.pushBack(e4);
              });
            }
          }, this.eraseElementByValue = function(e3) {
            if (!this.empty()) {
              var t3 = [];
              this.forEach(function(r4) {
                r4 !== e3 && t3.push(r4);
              });
              for (var r3 = t3.length, n2 = 0; n2 < r3; ++n2)
                this.setElementByPos(n2, t3[n2]);
              this.cut(r3 - 1);
            }
          };
          var f = function(e3) {
            for (var t3 = [], n2 = e3 * i.sigma, h2 = Math.max(Math.ceil(n2 / i.bucketSize), 2), f2 = 0; f2 < h2; ++f2)
              t3.push(new Array(i.bucketSize));
            var p = Math.ceil(e3 / i.bucketSize), d = Math.floor(h2 / 2) - Math.floor(p / 2), g = d, y = 0;
            if (this.size())
              for (f2 = 0; f2 < p; ++f2) {
                for (var b = 0; b < i.bucketSize; ++b)
                  if (t3[d + f2][b] = this.front(), this.popFront(), this.empty()) {
                    g = d + f2, y = b;
                    break;
                  }
                if (this.empty())
                  break;
              }
            r2 = t3, o = d, s = 0, a = g, l = y, u = h2, c = e3;
          };
          this.pushBack = function(e3) {
            this.empty() || (a === u - 1 && l === i.bucketSize - 1 && f.call(this, this.size()), l < i.bucketSize - 1 ? ++l : a < u - 1 && (++a, l = 0)), ++c, r2[a][l] = e3;
          }, this.popBack = function() {
            this.empty() || (1 !== this.size() && (l > 0 ? --l : o < a && (--a, l = i.bucketSize - 1)), c > 0 && --c);
          }, this.setElementByPos = function(e3, t3) {
            var n2 = h(e3), i2 = n2.curNodeBucketIndex, o2 = n2.curNodePointerIndex;
            r2[i2][o2] = t3;
          }, this.insert = function(e3, t3, r3) {
            var n2 = this;
            if (void 0 === r3 && (r3 = 1), 0 === e3)
              for (; r3--; )
                this.pushFront(t3);
            else if (e3 === this.size())
              for (; r3--; )
                this.pushBack(t3);
            else {
              for (var i2 = [], o2 = e3; o2 < c; ++o2)
                i2.push(this.getElementByPos(o2));
              this.cut(e3 - 1);
              for (o2 = 0; o2 < r3; ++o2)
                this.pushBack(t3);
              i2.forEach(function(e4) {
                return n2.pushBack(e4);
              });
            }
          }, this.find = function(e3) {
            if (o === a) {
              for (var t3 = s; t3 <= l; ++t3)
                if (r2[o][t3] === e3)
                  return true;
              return false;
            }
            for (t3 = s; t3 < i.bucketSize; ++t3)
              if (r2[o][t3] === e3)
                return true;
            for (t3 = o + 1; t3 < a; ++t3)
              for (var n2 = 0; n2 < i.bucketSize; ++n2)
                if (r2[t3][n2] === e3)
                  return true;
            for (t3 = 0; t3 <= l; ++t3)
              if (r2[a][t3] === e3)
                return true;
            return false;
          }, this.reverse = function() {
            for (var e3 = 0, t3 = c - 1; e3 < t3; ) {
              var r3 = this.getElementByPos(e3);
              this.setElementByPos(e3, this.getElementByPos(t3)), this.setElementByPos(t3, r3), ++e3, --t3;
            }
          }, this.unique = function() {
            if (!this.empty()) {
              var e3 = [], t3 = this.front();
              this.forEach(function(r4, n2) {
                0 !== n2 && r4 === t3 || (e3.push(r4), t3 = r4);
              });
              for (var r3 = 0; r3 < c; ++r3)
                this.setElementByPos(r3, e3[r3]);
              this.cut(e3.length - 1);
            }
          }, this.sort = function(e3) {
            var t3 = [];
            this.forEach(function(e4) {
              t3.push(e4);
            }), t3.sort(e3);
            for (var r3 = 0; r3 < c; ++r3)
              this.setElementByPos(r3, t3[r3]);
          }, this.pushFront = function(e3) {
            this.empty() || (0 === o && 0 === s && f.call(this, this.size()), s > 0 ? --s : o > 0 && (--o, s = i.bucketSize - 1)), ++c, r2[o][s] = e3;
          }, this.popFront = function() {
            this.empty() || (1 !== this.size() && (s < i.bucketSize - 1 ? ++s : o < a && (++o, s = 0)), c > 0 && --c);
          }, this.shrinkToFit = function() {
            var e3 = this, t3 = [];
            this.forEach(function(e4) {
              t3.push(e4);
            });
            var n2 = t3.length;
            r2 = [];
            for (var o2 = Math.ceil(n2 / i.bucketSize), s2 = 0; s2 < o2; ++s2)
              r2.push(new Array(i.bucketSize));
            this.clear(), t3.forEach(function(t4) {
              return e3.pushBack(t4);
            });
          }, this.cut = function(e3) {
            if (e3 < 0)
              this.clear();
            else {
              var t3 = h(e3), r3 = t3.curNodeBucketIndex, n2 = t3.curNodePointerIndex;
              a = r3, l = n2, c = e3 + 1;
            }
          }, this[Symbol.iterator] = function() {
            return function() {
              var e3, t3;
              return n(this, function(n2) {
                switch (n2.label) {
                  case 0:
                    if (0 === c)
                      return [2];
                    if (o !== a)
                      return [3, 5];
                    t3 = s, n2.label = 1;
                  case 1:
                    return t3 <= l ? [4, r2[o][t3]] : [3, 4];
                  case 2:
                    n2.sent(), n2.label = 3;
                  case 3:
                    return ++t3, [3, 1];
                  case 4:
                    return [2];
                  case 5:
                    t3 = s, n2.label = 6;
                  case 6:
                    return t3 < i.bucketSize ? [4, r2[o][t3]] : [3, 9];
                  case 7:
                    n2.sent(), n2.label = 8;
                  case 8:
                    return ++t3, [3, 6];
                  case 9:
                    t3 = o + 1, n2.label = 10;
                  case 10:
                    if (!(t3 < a))
                      return [3, 15];
                    e3 = 0, n2.label = 11;
                  case 11:
                    return e3 < i.bucketSize ? [4, r2[t3][e3]] : [3, 14];
                  case 12:
                    n2.sent(), n2.label = 13;
                  case 13:
                    return ++e3, [3, 11];
                  case 14:
                    return ++t3, [3, 10];
                  case 15:
                    t3 = 0, n2.label = 16;
                  case 16:
                    return t3 <= l ? [4, r2[a][t3]] : [3, 19];
                  case 17:
                    n2.sent(), n2.label = 18;
                  case 18:
                    return ++t3, [3, 16];
                  case 19:
                    return [2];
                }
              });
            }();
          }, function() {
            var n2 = i.bucketSize;
            e2.size ? n2 = e2.size() : e2.length && (n2 = e2.length);
            var s2 = n2 * i.sigma;
            u = Math.ceil(s2 / i.bucketSize), u = Math.max(u, 3);
            for (var l2 = 0; l2 < u; ++l2)
              r2.push(new Array(i.bucketSize));
            var c2 = Math.ceil(n2 / i.bucketSize);
            o = Math.floor(u / 2) - Math.floor(c2 / 2), a = o, e2.forEach(function(e3) {
              return t2.pushBack(e3);
            });
          }(), Object.freeze(this);
        }
        Object.defineProperty(r, "__esModule", { value: true }), i.sigma = 3, i.bucketSize = 5e3, Object.freeze(i), r.default = i;
      }, {}], 27: [function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o2, s2 = { label: 0, sent: function() {
            if (1 & i2[0])
              throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function a2(o3) {
            return function(a3) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; s2; )
                  try {
                    if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                      return i2;
                    switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                      case 0:
                      case 1:
                        i2 = o4;
                        break;
                      case 4:
                        return s2.label++, { value: o4[1], done: false };
                      case 5:
                        s2.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = s2.ops.pop(), s2.trys.pop();
                        continue;
                      default:
                        if (!(i2 = (i2 = s2.trys).length > 0 && i2[i2.length - 1]) && (6 === o4[0] || 2 === o4[0])) {
                          s2 = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                          s2.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && s2.label < i2[1]) {
                          s2.label = i2[1], i2 = o4;
                          break;
                        }
                        if (i2 && s2.label < i2[2]) {
                          s2.label = i2[2], s2.ops.push(o4);
                          break;
                        }
                        i2[2] && s2.ops.pop(), s2.trys.pop();
                        continue;
                    }
                    o4 = t2.call(e2, s2);
                  } catch (e3) {
                    o4 = [6, e3], n2 = 0;
                  } finally {
                    r2 = i2 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, a3]);
            };
          }
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(r, "__esModule", { value: true });
        var o = e("../LinkList/LinkList"), s = e("../Map/Map");
        function a(e2, t2, r2) {
          var l = this;
          if (void 0 === e2 && (e2 = []), void 0 === t2 && (t2 = a.initSize), r2 = r2 || function(e3) {
            var t3, r3, n2 = 0, o2 = "";
            if ("number" == typeof e3)
              n2 = ((n2 = Math.floor(e3)) << 5) - n2, n2 &= n2;
            else {
              o2 = "string" != typeof e3 ? JSON.stringify(e3) : e3;
              try {
                for (var s2 = i(o2), a2 = s2.next(); !a2.done; a2 = s2.next()) {
                  n2 = (n2 << 5) - n2 + a2.value.charCodeAt(0), n2 &= n2;
                }
              } catch (e4) {
                t3 = { error: e4 };
              } finally {
                try {
                  a2 && !a2.done && (r3 = s2.return) && r3.call(s2);
                } finally {
                  if (t3)
                    throw t3.error;
                }
              }
            }
            return n2 ^= n2 >>> 16;
          }, 0 != (t2 & t2 - 1))
            throw new Error("initBucketNum must be 2 to the power of n");
          var u = 0, c = [], h = Math.max(a.initSize, Math.min(a.maxSize, t2));
          this.size = function() {
            return u;
          }, this.empty = function() {
            return 0 === u;
          }, this.clear = function() {
            u = 0, h = t2, c = [];
          }, this.forEach = function(e3) {
            var t3 = 0;
            c.forEach(function(r3) {
              r3.forEach(function(r4) {
                e3(r4, t3++);
              });
            });
          };
          this.setElement = function(e3, t3) {
            var n2, l2;
            if (null === e3 || void 0 === e3)
              throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");
            if (null !== t3 && void 0 !== t3) {
              var f = r2(e3) & h - 1;
              if (c[f]) {
                var p = c[f].size();
                if (c[f] instanceof o.default) {
                  try {
                    for (var d = i(c[f]), g = d.next(); !g.done; g = d.next()) {
                      var y = g.value;
                      if (y.key === e3)
                        return void (y.value = t3);
                    }
                  } catch (e4) {
                    n2 = { error: e4 };
                  } finally {
                    try {
                      g && !g.done && (l2 = d.return) && l2.call(d);
                    } finally {
                      if (n2)
                        throw n2.error;
                    }
                  }
                  c[f].pushBack({ key: e3, value: t3 }), c[f].size() >= a.treeifyThreshold && (c[f] = new s.default(c[f]));
                } else
                  c[f].setElement(e3, t3);
                var b = c[f].size();
                u += b - p;
              } else
                ++u, c[f] = new o.default([{ key: e3, value: t3 }]);
              u > h * a.sigma && (function(e4) {
                if (!(e4 >= a.maxSize)) {
                  h = 2 * e4;
                  var t4 = [];
                  c.forEach(function(n3, i2) {
                    if (!n3.empty()) {
                      if (n3 instanceof o.default && 1 === n3.size()) {
                        var l3 = n3.front(), u2 = l3.key, f2 = l3.value;
                        t4[r2(u2) & h - 1] = new o.default([{ key: u2, value: f2 }]);
                      } else if (n3 instanceof s.default) {
                        var p2 = new o.default(), d2 = new o.default();
                        n3.forEach(function(t5) {
                          0 == (r2(t5.key) & e4) ? p2.pushBack(t5) : d2.pushBack(t5);
                        }), p2.size() > a.untreeifyThreshold ? t4[i2] = new s.default(p2) : p2.size() && (t4[i2] = p2), d2.size() > a.untreeifyThreshold ? t4[i2 + e4] = new s.default(d2) : d2.size() && (t4[i2 + e4] = d2);
                      } else {
                        var g2 = new o.default(), y2 = new o.default();
                        n3.forEach(function(t5) {
                          0 == (r2(t5.key) & e4) ? g2.pushBack(t5) : y2.pushBack(t5);
                        }), g2.size() && (t4[i2] = g2), y2.size() && (t4[i2 + e4] = y2);
                      }
                      c[i2].clear();
                    }
                  }), c = t4;
                }
              }).call(this, h);
            } else
              this.eraseElementByKey(e3);
          }, this.getElementByKey = function(e3) {
            var t3, n2, o2 = r2(e3) & h - 1;
            if (c[o2]) {
              if (c[o2] instanceof s.default)
                return c[o2].getElementByKey(e3);
              try {
                for (var a2 = i(c[o2]), l2 = a2.next(); !l2.done; l2 = a2.next()) {
                  var u2 = l2.value;
                  if (u2.key === e3)
                    return u2.value;
                }
              } catch (e4) {
                t3 = { error: e4 };
              } finally {
                try {
                  l2 && !l2.done && (n2 = a2.return) && n2.call(a2);
                } finally {
                  if (t3)
                    throw t3.error;
                }
              }
            }
          }, this.eraseElementByKey = function(e3) {
            var t3, n2, l2 = r2(e3) & h - 1;
            if (c[l2]) {
              var f = c[l2].size();
              if (c[l2] instanceof s.default)
                c[l2].eraseElementByKey(e3), c[l2].size() <= a.untreeifyThreshold && (c[l2] = new o.default(c[l2]));
              else {
                var p = -1;
                try {
                  for (var d = i(c[l2]), g = d.next(); !g.done; g = d.next()) {
                    if (++p, g.value.key === e3) {
                      c[l2].eraseElementByPos(p);
                      break;
                    }
                  }
                } catch (e4) {
                  t3 = { error: e4 };
                } finally {
                  try {
                    g && !g.done && (n2 = d.return) && n2.call(d);
                  } finally {
                    if (t3)
                      throw t3.error;
                  }
                }
              }
              var y = c[l2].size();
              u += y - f;
            }
          }, this.find = function(e3) {
            var t3, n2, o2 = r2(e3) & h - 1;
            if (!c[o2])
              return false;
            if (c[o2] instanceof s.default)
              return c[o2].find(e3);
            try {
              for (var a2 = i(c[o2]), l2 = a2.next(); !l2.done; l2 = a2.next()) {
                if (l2.value.key === e3)
                  return true;
              }
            } catch (e4) {
              t3 = { error: e4 };
            } finally {
              try {
                l2 && !l2.done && (n2 = a2.return) && n2.call(a2);
              } finally {
                if (t3)
                  throw t3.error;
              }
            }
            return false;
          }, this[Symbol.iterator] = function() {
            return function() {
              var e3, t3, r3, o2, s2, a2;
              return n(this, function(n2) {
                switch (n2.label) {
                  case 0:
                    e3 = 0, n2.label = 1;
                  case 1:
                    if (!(e3 < h))
                      return [3, 10];
                    for (; e3 < h && !c[e3]; )
                      ++e3;
                    if (e3 >= h)
                      return [3, 10];
                    n2.label = 2;
                  case 2:
                    n2.trys.push([2, 7, 8, 9]), s2 = void 0, t3 = i(c[e3]), r3 = t3.next(), n2.label = 3;
                  case 3:
                    return r3.done ? [3, 6] : [4, r3.value];
                  case 4:
                    n2.sent(), n2.label = 5;
                  case 5:
                    return r3 = t3.next(), [3, 3];
                  case 6:
                    return [3, 9];
                  case 7:
                    return o2 = n2.sent(), s2 = { error: o2 }, [3, 9];
                  case 8:
                    try {
                      r3 && !r3.done && (a2 = t3.return) && a2.call(t3);
                    } finally {
                      if (s2)
                        throw s2.error;
                    }
                    return [7];
                  case 9:
                    return ++e3, [3, 1];
                  case 10:
                    return [2];
                }
              });
            }();
          }, e2.forEach(function(e3) {
            var t3 = e3.key, r3 = e3.value;
            return l.setElement(t3, r3);
          }), Object.freeze(this);
        }
        a.initSize = 16, a.maxSize = 1 << 30, a.sigma = 0.75, a.treeifyThreshold = 8, a.untreeifyThreshold = 6, a.minTreeifySize = 64, Object.freeze(a), r.default = a;
      }, { "../LinkList/LinkList": 29, "../Map/Map": 30 }], 28: [function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o2, s2 = { label: 0, sent: function() {
            if (1 & i2[0])
              throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function a2(o3) {
            return function(a3) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; s2; )
                  try {
                    if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                      return i2;
                    switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                      case 0:
                      case 1:
                        i2 = o4;
                        break;
                      case 4:
                        return s2.label++, { value: o4[1], done: false };
                      case 5:
                        s2.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = s2.ops.pop(), s2.trys.pop();
                        continue;
                      default:
                        if (!(i2 = (i2 = s2.trys).length > 0 && i2[i2.length - 1]) && (6 === o4[0] || 2 === o4[0])) {
                          s2 = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                          s2.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && s2.label < i2[1]) {
                          s2.label = i2[1], i2 = o4;
                          break;
                        }
                        if (i2 && s2.label < i2[2]) {
                          s2.label = i2[2], s2.ops.push(o4);
                          break;
                        }
                        i2[2] && s2.ops.pop(), s2.trys.pop();
                        continue;
                    }
                    o4 = t2.call(e2, s2);
                  } catch (e3) {
                    o4 = [6, e3], n2 = 0;
                  } finally {
                    r2 = i2 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, a3]);
            };
          }
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(r, "__esModule", { value: true });
        var o = e("../Set/Set"), s = e("../LinkList/LinkList");
        function a(e2, t2, r2) {
          var l = this;
          if (void 0 === e2 && (e2 = []), void 0 === t2 && (t2 = a.initSize), r2 = r2 || function(e3) {
            var t3 = 0, r3 = "";
            if ("number" == typeof e3)
              t3 = ((t3 = Math.floor(e3)) << 5) - t3, t3 &= t3;
            else {
              r3 = "string" != typeof e3 ? JSON.stringify(e3) : e3;
              for (var n2 = 0; n2 < r3.length; n2++) {
                t3 = (t3 << 5) - t3 + r3.charCodeAt(n2), t3 &= t3;
              }
            }
            return t3 ^= t3 >>> 16;
          }, 0 != (t2 & t2 - 1))
            throw new Error("initBucketNum must be 2 to the power of n");
          var u = 0, c = [], h = Math.max(a.initSize, Math.min(a.maxSize, t2));
          this.size = function() {
            return u;
          }, this.empty = function() {
            return 0 === u;
          }, this.clear = function() {
            u = 0, h = t2, c = [];
          }, this.forEach = function(e3) {
            var t3 = 0;
            c.forEach(function(r3) {
              r3.forEach(function(r4) {
                e3(r4, t3++);
              });
            });
          };
          this.insert = function(e3) {
            if (null === e3 || void 0 === e3)
              throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");
            var t3 = r2(e3) & h - 1;
            if (c[t3]) {
              var n2 = c[t3].size();
              if (c[t3] instanceof s.default) {
                if (c[t3].find(e3))
                  return;
                c[t3].pushBack(e3), c[t3].size() >= a.treeifyThreshold && (c[t3] = new o.default(c[t3]));
              } else
                c[t3].insert(e3);
              var i2 = c[t3].size();
              u += i2 - n2;
            } else
              c[t3] = new s.default([e3]), ++u;
            u > h * a.sigma && (function(e4) {
              if (!(e4 >= a.maxSize)) {
                h = 2 * e4;
                var t4 = [];
                c.forEach(function(n3, i3) {
                  if (!n3.empty()) {
                    if (n3 instanceof s.default && 1 === n3.size()) {
                      var l2 = n3.front();
                      if (void 0 === l2)
                        throw new Error("unknown error");
                      t4[r2(l2) & h - 1] = new s.default([l2]);
                    } else if (n3 instanceof o.default) {
                      var u2 = new s.default(), f = new s.default();
                      n3.forEach(function(t5) {
                        0 == (r2(t5) & e4) ? u2.pushBack(t5) : f.pushBack(t5);
                      }), u2.size() > a.untreeifyThreshold ? t4[i3] = new o.default(u2) : u2.size() && (t4[i3] = u2), f.size() > a.untreeifyThreshold ? t4[i3 + e4] = new o.default(f) : f.size() && (t4[i3 + e4] = f);
                    } else {
                      var p = new s.default(), d = new s.default();
                      n3.forEach(function(t5) {
                        0 == (r2(t5) & e4) ? p.pushBack(t5) : d.pushBack(t5);
                      }), p.size() && (t4[i3] = p), d.size() && (t4[i3 + e4] = d);
                    }
                    c[i3].clear();
                  }
                }), c = t4;
              }
            }).call(this, h);
          }, this.eraseElementByValue = function(e3) {
            var t3 = r2(e3) & h - 1;
            if (c[t3]) {
              var n2 = c[t3].size();
              c[t3].eraseElementByValue(e3), c[t3] instanceof o.default && c[t3].size() <= a.untreeifyThreshold && (c[t3] = new s.default(c[t3]));
              var i2 = c[t3].size();
              u += i2 - n2;
            }
          }, this.find = function(e3) {
            var t3 = r2(e3) & h - 1;
            return !!c[t3] && c[t3].find(e3);
          }, this[Symbol.iterator] = function() {
            return function() {
              var e3, t3, r3, o2, s2, a2;
              return n(this, function(n2) {
                switch (n2.label) {
                  case 0:
                    e3 = 0, n2.label = 1;
                  case 1:
                    if (!(e3 < h))
                      return [3, 10];
                    for (; e3 < h && !c[e3]; )
                      ++e3;
                    if (e3 >= h)
                      return [3, 10];
                    n2.label = 2;
                  case 2:
                    n2.trys.push([2, 7, 8, 9]), s2 = void 0, t3 = i(c[e3]), r3 = t3.next(), n2.label = 3;
                  case 3:
                    return r3.done ? [3, 6] : [4, r3.value];
                  case 4:
                    n2.sent(), n2.label = 5;
                  case 5:
                    return r3 = t3.next(), [3, 3];
                  case 6:
                    return [3, 9];
                  case 7:
                    return o2 = n2.sent(), s2 = { error: o2 }, [3, 9];
                  case 8:
                    try {
                      r3 && !r3.done && (a2 = t3.return) && a2.call(t3);
                    } finally {
                      if (s2)
                        throw s2.error;
                    }
                    return [7];
                  case 9:
                    return ++e3, [3, 1];
                  case 10:
                    return [2];
                }
              });
            }();
          }, e2.forEach(function(e3) {
            return l.insert(e3);
          }), Object.freeze(this);
        }
        a.initSize = 16, a.maxSize = 1 << 30, a.sigma = 0.75, a.treeifyThreshold = 8, a.untreeifyThreshold = 6, a.minTreeifySize = 64, Object.freeze(a), r.default = a;
      }, { "../LinkList/LinkList": 29, "../Set/Set": 33 }], 29: [function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o2, s = { label: 0, sent: function() {
            if (1 & i2[0])
              throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function a(o3) {
            return function(a2) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; s; )
                  try {
                    if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                      return i2;
                    switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                      case 0:
                      case 1:
                        i2 = o4;
                        break;
                      case 4:
                        return s.label++, { value: o4[1], done: false };
                      case 5:
                        s.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = s.ops.pop(), s.trys.pop();
                        continue;
                      default:
                        if (!(i2 = (i2 = s.trys).length > 0 && i2[i2.length - 1]) && (6 === o4[0] || 2 === o4[0])) {
                          s = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                          s.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && s.label < i2[1]) {
                          s.label = i2[1], i2 = o4;
                          break;
                        }
                        if (i2 && s.label < i2[2]) {
                          s.label = i2[2], s.ops.push(o4);
                          break;
                        }
                        i2[2] && s.ops.pop(), s.trys.pop();
                        continue;
                    }
                    o4 = t2.call(e2, s);
                  } catch (e3) {
                    o4 = [6, e3], n2 = 0;
                  } finally {
                    r2 = i2 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, a2]);
            };
          }
        };
        Object.defineProperty(r, "__esModule", { value: true });
        var i = function() {
          return function(e2) {
            this.value = void 0, this.pre = void 0, this.next = void 0, this.value = e2;
          };
        }();
        function o(e2) {
          var t2 = this;
          void 0 === e2 && (e2 = []);
          var r2 = 0, o2 = void 0, s = void 0;
          this.size = function() {
            return r2;
          }, this.empty = function() {
            return 0 === r2;
          }, this.clear = function() {
            o2 = s = void 0, r2 = 0;
          }, this.front = function() {
            return null === o2 || void 0 === o2 ? void 0 : o2.value;
          }, this.back = function() {
            return null === s || void 0 === s ? void 0 : s.value;
          }, this.forEach = function(e3) {
            for (var t3 = o2, r3 = 0; t3; ) {
              if (void 0 === t3.value)
                throw new Error("unknown error");
              e3(t3.value, r3++), t3 = t3.next;
            }
          }, this.getElementByPos = function(e3) {
            if (e3 < 0 || e3 >= r2)
              throw new Error("pos must more then 0 and less then the list length");
            for (var t3 = o2; e3-- && t3; )
              t3 = t3.next;
            if (!t3 || void 0 === t3.value)
              throw new Error("unknown error");
            return t3.value;
          }, this.eraseElementByPos = function(e3) {
            if (e3 < 0 || e3 >= r2)
              throw new Error("erase pos must more then 0 and less then the list length");
            if (0 === e3)
              this.popFront();
            else if (e3 === r2 - 1)
              this.popBack();
            else {
              for (var t3 = o2; e3--; ) {
                if (!(null === t3 || void 0 === t3 ? void 0 : t3.next))
                  throw new Error("unknown error");
                t3 = t3.next;
              }
              if (!t3 || !t3.pre || !t3.next)
                throw new Error("unknown error");
              var n2 = t3.pre, i2 = t3.next;
              i2.pre = n2, n2.next = i2, r2 > 0 && --r2;
            }
          }, this.eraseElementByValue = function(e3) {
            for (; o2 && o2.value === e3; )
              this.popFront();
            for (; s && s.value === e3; )
              this.popBack();
            if (o2)
              for (var t3 = o2; t3; ) {
                if (t3.value === e3) {
                  var n2 = t3.pre, i2 = t3.next;
                  i2 && (i2.pre = n2), n2 && (n2.next = i2), r2 > 0 && --r2;
                }
                t3 = t3.next;
              }
          }, this.pushBack = function(e3) {
            if (null === e3 || void 0 === e3)
              throw new Error("you can't push null or undefined here");
            ++r2;
            var t3 = new i(e3);
            s ? (s.next = t3, t3.pre = s, s = t3) : o2 = s = t3;
          }, this.popBack = function() {
            s && (r2 > 0 && --r2, s && (o2 === s ? o2 = s = void 0 : (s = s.pre) && (s.next = void 0)));
          }, this.setElementByPos = function(e3, t3) {
            if (null === t3 || void 0 === t3)
              throw new Error("you can't set null or undefined here");
            if (e3 < 0 || e3 >= r2)
              throw new Error("pos must more then 0 and less then the list length");
            for (var n2 = o2; e3--; ) {
              if (!n2)
                throw new Error("unknown error");
              n2 = n2.next;
            }
            n2 && (n2.value = t3);
          }, this.insert = function(e3, t3, n2) {
            if (void 0 === n2 && (n2 = 1), null === t3 || void 0 === t3)
              throw new Error("you can't insert null or undefined here");
            if (e3 < 0 || e3 > r2)
              throw new Error("insert pos must more then 0 and less then or equal to the list length");
            if (n2 < 0)
              throw new Error("insert size must more than 0");
            if (0 === e3)
              for (; n2--; )
                this.pushFront(t3);
            else if (e3 === r2)
              for (; n2--; )
                this.pushBack(t3);
            else {
              for (var s2 = o2, a = 1; a < e3; ++a) {
                if (!(null === s2 || void 0 === s2 ? void 0 : s2.next))
                  throw new Error("unknown error");
                s2 = null === s2 || void 0 === s2 ? void 0 : s2.next;
              }
              if (!s2)
                throw new Error("unknown error");
              var l = s2.next;
              for (r2 += n2; n2--; )
                s2.next = new i(t3), s2.next.pre = s2, s2 = s2.next;
              s2.next = l, l && (l.pre = s2);
            }
          }, this.find = function(e3) {
            for (var t3 = o2; t3; ) {
              if (t3.value === e3)
                return true;
              t3 = t3.next;
            }
            return false;
          }, this.reverse = function() {
            for (var e3 = o2, t3 = s, n2 = 0; e3 && t3 && 2 * n2 < r2; ) {
              var i2 = e3.value;
              e3.value = t3.value, t3.value = i2, e3 = e3.next, t3 = t3.pre, ++n2;
            }
          }, this.unique = function() {
            for (var e3 = o2; e3; ) {
              for (var t3 = e3; t3 && t3.next && t3.value === t3.next.value; )
                t3 = t3.next, r2 > 0 && --r2;
              e3.next = t3.next, e3.next && (e3.next.pre = e3), e3 = e3.next;
            }
          }, this.sort = function(e3) {
            var t3 = [];
            this.forEach(function(e4) {
              t3.push(e4);
            }), t3.sort(e3);
            var r3 = o2;
            t3.forEach(function(e4) {
              r3 && (r3.value = e4, r3 = r3.next);
            });
          }, this.pushFront = function(e3) {
            if (null === e3 || void 0 === e3)
              throw new Error("you can't push null or undefined here");
            ++r2;
            var t3 = new i(e3);
            o2 ? (t3.next = o2, o2.pre = t3, o2 = t3) : o2 = s = t3;
          }, this.popFront = function() {
            o2 && (r2 > 0 && --r2, o2 && (o2 === s ? o2 = s = void 0 : (o2 = o2.next) && (o2.pre = void 0)));
          }, this.merge = function(e3) {
            var t3 = this, n2 = o2;
            e3.forEach(function(e4) {
              for (; n2 && void 0 !== n2.value && n2.value <= e4; )
                n2 = n2.next;
              if (void 0 === n2)
                t3.pushBack(e4), n2 = s;
              else if (n2 === o2)
                t3.pushFront(e4), n2 = o2;
              else {
                ++r2;
                var a = n2.pre;
                a && (a.next = new i(e4), a.next.pre = a, a.next.next = n2, n2 && (n2.pre = a.next));
              }
            });
          }, this[Symbol.iterator] = function() {
            return function() {
              var e3;
              return n(this, function(t3) {
                switch (t3.label) {
                  case 0:
                    e3 = o2, t3.label = 1;
                  case 1:
                    if (void 0 === e3)
                      return [3, 3];
                    if (!e3.value)
                      throw new Error("unknown error");
                    return [4, e3.value];
                  case 2:
                    return t3.sent(), e3 = e3.next, [3, 1];
                  case 3:
                    return [2];
                }
              });
            }();
          }, e2.forEach(function(e3) {
            return t2.pushBack(e3);
          }), Object.freeze(this);
        }
        Object.freeze(o), r.default = o;
      }, {}], 30: [function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o2, s2 = { label: 0, sent: function() {
            if (1 & i2[0])
              throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function a(o3) {
            return function(a2) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; s2; )
                  try {
                    if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                      return i2;
                    switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                      case 0:
                      case 1:
                        i2 = o4;
                        break;
                      case 4:
                        return s2.label++, { value: o4[1], done: false };
                      case 5:
                        s2.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = s2.ops.pop(), s2.trys.pop();
                        continue;
                      default:
                        if (!(i2 = (i2 = s2.trys).length > 0 && i2[i2.length - 1]) && (6 === o4[0] || 2 === o4[0])) {
                          s2 = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                          s2.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && s2.label < i2[1]) {
                          s2.label = i2[1], i2 = o4;
                          break;
                        }
                        if (i2 && s2.label < i2[2]) {
                          s2.label = i2[2], s2.ops.push(o4);
                          break;
                        }
                        i2[2] && s2.ops.pop(), s2.trys.pop();
                        continue;
                    }
                    o4 = t2.call(e2, s2);
                  } catch (e3) {
                    o4 = [6, e3], n2 = 0;
                  } finally {
                    r2 = i2 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, a2]);
            };
          }
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(r, "__esModule", { value: true });
        var o = e("../Base/TreeNode");
        function s(e2, t2) {
          var r2 = this;
          void 0 === e2 && (e2 = []), t2 = t2 || function(e3, t3) {
            return e3 < t3 ? -1 : e3 > t3 ? 1 : 0;
          };
          var s2 = 0, a = new o.default();
          a.color = o.default.TreeNodeColorType.black, this.size = function() {
            return s2;
          }, this.empty = function() {
            return 0 === s2;
          }, this.clear = function() {
            s2 = 0, a.key = a.value = void 0, a.leftChild = a.rightChild = a.brother = void 0;
          };
          var l = function(e3) {
            if (!e3 || void 0 === e3.key)
              throw new Error("unknown error");
            return e3.leftChild ? l(e3.leftChild) : e3;
          }, u = function(e3) {
            if (!e3 || void 0 === e3.key)
              throw new Error("unknown error");
            return e3.rightChild ? u(e3.rightChild) : e3;
          };
          this.front = function() {
            if (!this.empty()) {
              var e3 = l(a);
              if (void 0 === e3.key || void 0 === e3.value)
                throw new Error("unknown error");
              return { key: e3.key, value: e3.value };
            }
          }, this.back = function() {
            if (!this.empty()) {
              var e3 = u(a);
              if (void 0 === e3.key || void 0 === e3.value)
                throw new Error("unknown error");
              return { key: e3.key, value: e3.value };
            }
          }, this.forEach = function(e3) {
            var t3, r3, n2 = 0;
            try {
              for (var o2 = i(this), s3 = o2.next(); !s3.done; s3 = o2.next()) {
                e3(s3.value, n2++);
              }
            } catch (e4) {
              t3 = { error: e4 };
            } finally {
              try {
                s3 && !s3.done && (r3 = o2.return) && r3.call(o2);
              } finally {
                if (t3)
                  throw t3.error;
              }
            }
          }, this.getElementByPos = function(e3) {
            var t3, r3;
            if (e3 < 0 || e3 >= this.size())
              throw new Error("pos must more than 0 and less than set's size");
            var n2 = 0;
            try {
              for (var o2 = i(this), s3 = o2.next(); !s3.done; s3 = o2.next()) {
                var a2 = s3.value;
                if (n2 === e3)
                  return a2;
                ++n2;
              }
            } catch (e4) {
              t3 = { error: e4 };
            } finally {
              try {
                s3 && !s3.done && (r3 = o2.return) && r3.call(o2);
              } finally {
                if (t3)
                  throw t3.error;
              }
            }
            throw new Error("unknown Error");
          };
          var c = function(e3, r3) {
            if (e3 && void 0 !== e3.key && void 0 !== e3.value) {
              var n2 = t2(e3.key, r3);
              return 0 === n2 ? { key: e3.key, value: e3.value } : n2 < 0 ? c(e3.rightChild, r3) : c(e3.leftChild, r3) || { key: e3.key, value: e3.value };
            }
          };
          this.lowerBound = function(e3) {
            return c(a, e3);
          };
          var h = function(e3, r3) {
            if (e3 && void 0 !== e3.key && void 0 !== e3.value)
              return t2(e3.key, r3) <= 0 ? h(e3.rightChild, r3) : h(e3.leftChild, r3) || { key: e3.key, value: e3.value };
          };
          this.upperBound = function(e3) {
            return h(a, e3);
          };
          var f = function(e3, r3) {
            if (e3 && void 0 !== e3.key && void 0 !== e3.value) {
              var n2 = t2(e3.key, r3);
              return 0 === n2 ? { key: e3.key, value: e3.value } : n2 > 0 ? f(e3.leftChild, r3) : f(e3.rightChild, r3) || { key: e3.key, value: e3.value };
            }
          };
          this.reverseLowerBound = function(e3) {
            return f(a, e3);
          };
          var p = function(e3, r3) {
            if (e3 && void 0 !== e3.key && void 0 !== e3.value)
              return t2(e3.key, r3) >= 0 ? p(e3.leftChild, r3) : p(e3.rightChild, r3) || { key: e3.key, value: e3.value };
          };
          this.reverseUpperBound = function(e3) {
            return p(a, e3);
          };
          var d = function(e3) {
            var t3 = e3.parent;
            if (!t3) {
              if (e3 === a)
                return;
              throw new Error("unknown error");
            }
            if (e3.color !== o.default.TreeNodeColorType.red) {
              var r3 = e3.brother;
              if (!r3)
                throw new Error("unknown error");
              if (e3 === t3.leftChild) {
                if (r3.color === o.default.TreeNodeColorType.red) {
                  r3.color = o.default.TreeNodeColorType.black, t3.color = o.default.TreeNodeColorType.red;
                  var n2 = t3.rotateLeft();
                  a === t3 && (a = n2), d(e3);
                } else if (r3.color === o.default.TreeNodeColorType.black)
                  if (r3.rightChild && r3.rightChild.color === o.default.TreeNodeColorType.red) {
                    r3.color = t3.color, t3.color = o.default.TreeNodeColorType.black, r3.rightChild && (r3.rightChild.color = o.default.TreeNodeColorType.black);
                    n2 = t3.rotateLeft();
                    a === t3 && (a = n2), e3.color = o.default.TreeNodeColorType.black;
                  } else if (r3.rightChild && r3.rightChild.color !== o.default.TreeNodeColorType.black || !r3.leftChild || r3.leftChild.color !== o.default.TreeNodeColorType.red)
                    r3.leftChild && r3.leftChild.color !== o.default.TreeNodeColorType.black || r3.rightChild && r3.rightChild.color !== o.default.TreeNodeColorType.black || (r3.color = o.default.TreeNodeColorType.red, d(t3));
                  else {
                    r3.color = o.default.TreeNodeColorType.red, r3.leftChild && (r3.leftChild.color = o.default.TreeNodeColorType.black);
                    n2 = r3.rotateRight();
                    a === r3 && (a = n2), d(e3);
                  }
              } else if (e3 === t3.rightChild) {
                if (r3.color === o.default.TreeNodeColorType.red) {
                  r3.color = o.default.TreeNodeColorType.black, t3.color = o.default.TreeNodeColorType.red;
                  n2 = t3.rotateRight();
                  a === t3 && (a = n2), d(e3);
                } else if (r3.color === o.default.TreeNodeColorType.black)
                  if (r3.leftChild && r3.leftChild.color === o.default.TreeNodeColorType.red) {
                    r3.color = t3.color, t3.color = o.default.TreeNodeColorType.black, r3.leftChild && (r3.leftChild.color = o.default.TreeNodeColorType.black);
                    n2 = t3.rotateRight();
                    a === t3 && (a = n2), e3.color = o.default.TreeNodeColorType.black;
                  } else if (r3.leftChild && r3.leftChild.color !== o.default.TreeNodeColorType.black || !r3.rightChild || r3.rightChild.color !== o.default.TreeNodeColorType.red)
                    r3.leftChild && r3.leftChild.color !== o.default.TreeNodeColorType.black || r3.rightChild && r3.rightChild.color !== o.default.TreeNodeColorType.black || (r3.color = o.default.TreeNodeColorType.red, d(t3));
                  else {
                    r3.color = o.default.TreeNodeColorType.red, r3.rightChild && (r3.rightChild.color = o.default.TreeNodeColorType.black);
                    n2 = r3.rotateLeft();
                    a === r3 && (a = n2), d(e3);
                  }
              }
            } else
              e3.color = o.default.TreeNodeColorType.black;
          }, g = function(e3) {
            for (var t3 = e3; t3.leftChild || t3.rightChild; ) {
              if (t3.rightChild) {
                t3 = l(t3.rightChild);
                var r3 = e3.key;
                e3.key = t3.key, t3.key = r3;
                var n2 = e3.value;
                e3.value = t3.value, t3.value = n2, e3 = t3;
              }
              if (t3.leftChild) {
                t3 = u(t3.leftChild);
                r3 = e3.key;
                e3.key = t3.key, t3.key = r3;
                n2 = e3.value;
                e3.value = t3.value, t3.value = n2, e3 = t3;
              }
            }
            d(t3), t3 && t3.remove(), --s2, a.color = o.default.TreeNodeColorType.black;
          }, y = function(e3, t3) {
            return !(!e3 || void 0 === e3.key) && (!!y(e3.leftChild, t3) || (!!t3(e3) || y(e3.rightChild, t3)));
          };
          this.eraseElementByPos = function(e3) {
            if (e3 < 0 || e3 >= s2)
              throw new Error("pos must more than 0 and less than set's size");
            var t3 = 0;
            y(a, function(r3) {
              return e3 === t3 ? (g(r3), true) : (++t3, false);
            });
          }, this.eraseElementByKey = function(e3) {
            if (!this.empty()) {
              var r3 = v(a, e3);
              void 0 !== r3 && void 0 !== r3.key && 0 === t2(r3.key, e3) && g(r3);
            }
          };
          var b = function(e3, r3) {
            if (!e3 || void 0 === e3.key)
              throw new Error("unknown error");
            var n2 = t2(r3, e3.key);
            return n2 < 0 ? e3.leftChild ? b(e3.leftChild, r3) : (e3.leftChild = new o.default(), e3.leftChild.parent = e3, e3.leftChild.brother = e3.rightChild, e3.rightChild && (e3.rightChild.brother = e3.leftChild), e3.leftChild) : n2 > 0 ? e3.rightChild ? b(e3.rightChild, r3) : (e3.rightChild = new o.default(), e3.rightChild.parent = e3, e3.rightChild.brother = e3.leftChild, e3.leftChild && (e3.leftChild.brother = e3.rightChild), e3.rightChild) : e3;
          }, m = function(e3) {
            var t3 = e3.parent;
            if (!t3) {
              if (e3 === a)
                return;
              throw new Error("unknown error");
            }
            if (t3.color !== o.default.TreeNodeColorType.black && t3.color === o.default.TreeNodeColorType.red) {
              var r3 = t3.brother, n2 = t3.parent;
              if (!n2)
                throw new Error("unknown error");
              if (r3 && r3.color === o.default.TreeNodeColorType.red)
                r3.color = t3.color = o.default.TreeNodeColorType.black, n2.color = o.default.TreeNodeColorType.red, m(n2);
              else if (!r3 || r3.color === o.default.TreeNodeColorType.black) {
                if (t3 === n2.leftChild) {
                  if (e3 === t3.leftChild) {
                    t3.color = o.default.TreeNodeColorType.black, n2.color = o.default.TreeNodeColorType.red;
                    var i2 = n2.rotateRight();
                    n2 === a && (a = i2);
                  } else if (e3 === t3.rightChild) {
                    i2 = t3.rotateLeft();
                    n2 === a && (a = i2), m(t3);
                  }
                } else if (t3 === n2.rightChild) {
                  if (e3 === t3.leftChild) {
                    i2 = t3.rotateRight();
                    n2 === a && (a = i2), m(t3);
                  } else if (e3 === t3.rightChild) {
                    t3.color = o.default.TreeNodeColorType.black, n2.color = o.default.TreeNodeColorType.red;
                    i2 = n2.rotateLeft();
                    n2 === a && (a = i2);
                  }
                }
              }
            }
          };
          this.setElement = function(e3, r3) {
            if (null === e3 || void 0 === e3)
              throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");
            if (null !== r3 && void 0 !== r3) {
              if (this.empty())
                return ++s2, a.key = e3, a.value = r3, void (a.color = o.default.TreeNodeColorType.black);
              var n2 = b(a, e3);
              void 0 === n2.key || 0 !== t2(n2.key, e3) ? (++s2, n2.key = e3, n2.value = r3, m(n2), a.color = o.default.TreeNodeColorType.black) : n2.value = r3;
            } else
              this.eraseElementByKey(e3);
          };
          var v = function(e3, r3) {
            if (e3 && void 0 !== e3.key) {
              var n2 = t2(r3, e3.key);
              return n2 < 0 ? v(e3.leftChild, r3) : n2 > 0 ? v(e3.rightChild, r3) : e3;
            }
          };
          this.find = function(e3) {
            return !!v(a, e3);
          }, this.getElementByKey = function(e3) {
            var t3 = v(a, e3);
            if (void 0 === (null === t3 || void 0 === t3 ? void 0 : t3.key) || void 0 === (null === t3 || void 0 === t3 ? void 0 : t3.value))
              throw new Error("unknown error");
            return t3.value;
          }, this.union = function(e3) {
            var t3 = this;
            e3.forEach(function(e4) {
              var r3 = e4.key, n2 = e4.value;
              return t3.setElement(r3, n2);
            });
          }, this.getHeight = function() {
            if (this.empty())
              return 0;
            var e3 = function(t3) {
              return t3 ? Math.max(e3(t3.leftChild), e3(t3.rightChild)) + 1 : 1;
            };
            return e3(a);
          };
          var w = function(e3) {
            return n(this, function(t3) {
              switch (t3.label) {
                case 0:
                  return e3 && void 0 !== e3.key && void 0 !== e3.value ? [5, i(w(e3.leftChild))] : [2];
                case 1:
                  return t3.sent(), [4, { key: e3.key, value: e3.value }];
                case 2:
                  return t3.sent(), [5, i(w(e3.rightChild))];
                case 3:
                  return t3.sent(), [2];
              }
            });
          };
          this[Symbol.iterator] = function() {
            return w(a);
          }, e2.forEach(function(e3) {
            var t3 = e3.key, n2 = e3.value;
            return r2.setElement(t3, n2);
          }), Object.freeze(this);
        }
        Object.freeze(s), r.default = s;
      }, { "../Base/TreeNode": 25 }], 31: [function(e, t, r) {
        "use strict";
        function n(e2, t2) {
          void 0 === e2 && (e2 = []), t2 = t2 || function(e3, t3) {
            return e3 > t3 ? -1 : e3 < t3 ? 1 : 0;
          };
          var r2 = [];
          e2.forEach(function(e3) {
            return r2.push(e3);
          });
          var n2 = r2.length, i = function(e3, t3) {
            if (e3 < 0 || e3 >= n2)
              throw new Error("unknown error");
            if (t3 < 0 || t3 >= n2)
              throw new Error("unknown error");
            var i2 = r2[e3];
            r2[e3] = r2[t3], r2[t3] = i2;
          }, o = function(e3) {
            if (e3 < 0 || e3 >= n2)
              throw new Error("unknown error");
            var o2 = 2 * e3 + 1, s = 2 * e3 + 2;
            o2 < n2 && t2(r2[e3], r2[o2]) > 0 && i(e3, o2), s < n2 && t2(r2[e3], r2[s]) > 0 && i(e3, s);
          };
          !function() {
            for (var e3 = Math.floor((n2 - 1) / 2); e3 >= 0; --e3)
              for (var o2 = e3, s = 2 * o2 + 1; s < n2; ) {
                var a = s + 1, l = s;
                if (a < n2 && t2(r2[s], r2[a]) > 0 && (l = a), t2(r2[o2], r2[l]) <= 0)
                  break;
                i(o2, l), s = 2 * (o2 = l) + 1;
              }
          }(), this.size = function() {
            return n2;
          }, this.empty = function() {
            return 0 === n2;
          }, this.clear = function() {
            n2 = 0, r2.length = 0;
          }, this.push = function(e3) {
            if (r2.push(e3), 1 !== ++n2)
              for (var i2 = n2 - 1; i2 > 0; ) {
                var s = Math.floor((i2 - 1) / 2);
                if (t2(r2[s], e3) <= 0)
                  break;
                o(s), i2 = s;
              }
          }, this.pop = function() {
            if (!this.empty())
              if (1 !== this.size()) {
                var e3 = r2[n2 - 1];
                --n2;
                for (var i2 = 0; i2 < this.size(); ) {
                  var o2 = 2 * i2 + 1, s = 2 * i2 + 2;
                  if (o2 >= this.size())
                    break;
                  var a = o2;
                  if (s < this.size() && t2(r2[o2], r2[s]) > 0 && (a = s), t2(r2[a], e3) >= 0)
                    break;
                  r2[i2] = r2[a], i2 = a;
                }
                r2[i2] = e3;
              } else
                --n2;
          }, this.top = function() {
            return r2[0];
          }, Object.freeze(this);
        }
        Object.defineProperty(r, "__esModule", { value: true }), Object.freeze(n), r.default = n;
      }, {}], 32: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        var n = e("../LinkList/LinkList");
        function i(e2) {
          void 0 === e2 && (e2 = []);
          var t2 = new n.default(e2);
          this.size = function() {
            return t2.size();
          }, this.empty = function() {
            return t2.empty();
          }, this.clear = function() {
            t2.clear();
          }, this.push = function(e3) {
            t2.pushBack(e3);
          }, this.pop = function() {
            t2.popFront();
          }, this.front = function() {
            return t2.front();
          }, Object.freeze(this);
        }
        Object.freeze(i), r.default = i;
      }, { "../LinkList/LinkList": 29 }], 33: [function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o2, s2 = { label: 0, sent: function() {
            if (1 & i2[0])
              throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function a(o3) {
            return function(a2) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; s2; )
                  try {
                    if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                      return i2;
                    switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                      case 0:
                      case 1:
                        i2 = o4;
                        break;
                      case 4:
                        return s2.label++, { value: o4[1], done: false };
                      case 5:
                        s2.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = s2.ops.pop(), s2.trys.pop();
                        continue;
                      default:
                        if (!(i2 = (i2 = s2.trys).length > 0 && i2[i2.length - 1]) && (6 === o4[0] || 2 === o4[0])) {
                          s2 = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                          s2.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && s2.label < i2[1]) {
                          s2.label = i2[1], i2 = o4;
                          break;
                        }
                        if (i2 && s2.label < i2[2]) {
                          s2.label = i2[2], s2.ops.push(o4);
                          break;
                        }
                        i2[2] && s2.ops.pop(), s2.trys.pop();
                        continue;
                    }
                    o4 = t2.call(e2, s2);
                  } catch (e3) {
                    o4 = [6, e3], n2 = 0;
                  } finally {
                    r2 = i2 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, a2]);
            };
          }
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(r, "__esModule", { value: true });
        var o = e("../Base/TreeNode");
        function s(e2, t2) {
          var r2 = this;
          void 0 === e2 && (e2 = []), t2 = t2 || function(e3, t3) {
            return e3 < t3 ? -1 : e3 > t3 ? 1 : 0;
          };
          var s2 = 0, a = new o.default();
          a.color = o.default.TreeNodeColorType.black, this.size = function() {
            return s2;
          }, this.empty = function() {
            return 0 === s2;
          }, this.clear = function() {
            s2 = 0, a.key = void 0, a.leftChild = a.rightChild = a.brother = a.parent = void 0, a.color = o.default.TreeNodeColorType.black;
          };
          var l = function(e3) {
            if (!e3 || void 0 === e3.key)
              throw new Error("unknown error");
            return e3.leftChild ? l(e3.leftChild) : e3;
          }, u = function(e3) {
            if (!e3 || void 0 === e3.key)
              throw new Error("unknown error");
            return e3.rightChild ? u(e3.rightChild) : e3;
          };
          this.front = function() {
            if (!this.empty())
              return l(a).key;
          }, this.back = function() {
            if (!this.empty())
              return u(a).key;
          }, this.forEach = function(e3) {
            var t3, r3, n2 = 0;
            try {
              for (var o2 = i(this), s3 = o2.next(); !s3.done; s3 = o2.next()) {
                e3(s3.value, n2++);
              }
            } catch (e4) {
              t3 = { error: e4 };
            } finally {
              try {
                s3 && !s3.done && (r3 = o2.return) && r3.call(o2);
              } finally {
                if (t3)
                  throw t3.error;
              }
            }
          }, this.getElementByPos = function(e3) {
            var t3, r3;
            if (e3 < 0 || e3 >= this.size())
              throw new Error("pos must more than 0 and less than set's size");
            var n2 = 0;
            try {
              for (var o2 = i(this), s3 = o2.next(); !s3.done; s3 = o2.next()) {
                var a2 = s3.value;
                if (n2 === e3)
                  return a2;
                ++n2;
              }
            } catch (e4) {
              t3 = { error: e4 };
            } finally {
              try {
                s3 && !s3.done && (r3 = o2.return) && r3.call(o2);
              } finally {
                if (t3)
                  throw t3.error;
              }
            }
            throw new Error("unknown error");
          };
          var c = function(e3) {
            var t3 = e3.parent;
            if (!t3) {
              if (e3 === a)
                return;
              throw new Error("unknown error");
            }
            if (e3.color !== o.default.TreeNodeColorType.red) {
              var r3 = e3.brother;
              if (!r3)
                throw new Error("unknown error");
              if (e3 === t3.leftChild) {
                if (r3.color === o.default.TreeNodeColorType.red) {
                  r3.color = o.default.TreeNodeColorType.black, t3.color = o.default.TreeNodeColorType.red;
                  var n2 = t3.rotateLeft();
                  a === t3 && (a = n2), c(e3);
                } else if (r3.color === o.default.TreeNodeColorType.black)
                  if (r3.rightChild && r3.rightChild.color === o.default.TreeNodeColorType.red) {
                    r3.color = t3.color, t3.color = o.default.TreeNodeColorType.black, r3.rightChild && (r3.rightChild.color = o.default.TreeNodeColorType.black);
                    n2 = t3.rotateLeft();
                    a === t3 && (a = n2), e3.color = o.default.TreeNodeColorType.black;
                  } else if (r3.rightChild && r3.rightChild.color !== o.default.TreeNodeColorType.black || !r3.leftChild || r3.leftChild.color !== o.default.TreeNodeColorType.red)
                    r3.leftChild && r3.leftChild.color !== o.default.TreeNodeColorType.black || r3.rightChild && r3.rightChild.color !== o.default.TreeNodeColorType.black || (r3.color = o.default.TreeNodeColorType.red, c(t3));
                  else {
                    r3.color = o.default.TreeNodeColorType.red, r3.leftChild && (r3.leftChild.color = o.default.TreeNodeColorType.black);
                    n2 = r3.rotateRight();
                    a === r3 && (a = n2), c(e3);
                  }
              } else if (e3 === t3.rightChild) {
                if (r3.color === o.default.TreeNodeColorType.red) {
                  r3.color = o.default.TreeNodeColorType.black, t3.color = o.default.TreeNodeColorType.red;
                  n2 = t3.rotateRight();
                  a === t3 && (a = n2), c(e3);
                } else if (r3.color === o.default.TreeNodeColorType.black)
                  if (r3.leftChild && r3.leftChild.color === o.default.TreeNodeColorType.red) {
                    r3.color = t3.color, t3.color = o.default.TreeNodeColorType.black, r3.leftChild && (r3.leftChild.color = o.default.TreeNodeColorType.black);
                    n2 = t3.rotateRight();
                    a === t3 && (a = n2), e3.color = o.default.TreeNodeColorType.black;
                  } else if (r3.leftChild && r3.leftChild.color !== o.default.TreeNodeColorType.black || !r3.rightChild || r3.rightChild.color !== o.default.TreeNodeColorType.red)
                    r3.leftChild && r3.leftChild.color !== o.default.TreeNodeColorType.black || r3.rightChild && r3.rightChild.color !== o.default.TreeNodeColorType.black || (r3.color = o.default.TreeNodeColorType.red, c(t3));
                  else {
                    r3.color = o.default.TreeNodeColorType.red, r3.rightChild && (r3.rightChild.color = o.default.TreeNodeColorType.black);
                    n2 = r3.rotateLeft();
                    a === r3 && (a = n2), c(e3);
                  }
              }
            } else
              e3.color = o.default.TreeNodeColorType.black;
          }, h = function(e3) {
            for (var t3 = e3; t3.leftChild || t3.rightChild; ) {
              if (t3.rightChild) {
                t3 = l(t3.rightChild);
                var r3 = e3.key;
                e3.key = t3.key, t3.key = r3, e3 = t3;
              }
              if (t3.leftChild) {
                t3 = u(t3.leftChild);
                r3 = e3.key;
                e3.key = t3.key, t3.key = r3, e3 = t3;
              }
            }
            c(t3), t3 && t3.remove(), --s2, a.color = o.default.TreeNodeColorType.black;
          }, f = function(e3, t3) {
            return !(!e3 || void 0 === e3.key) && (!!f(e3.leftChild, t3) || (!!t3(e3) || f(e3.rightChild, t3)));
          };
          this.eraseElementByPos = function(e3) {
            if (e3 < 0 || e3 >= s2)
              throw new Error("pos must more than 0 and less than set's size");
            var t3 = 0;
            f(a, function(r3) {
              return e3 === t3 ? (h(r3), true) : (++t3, false);
            });
          }, this.eraseElementByValue = function(e3) {
            if (!this.empty()) {
              var r3 = g(a, e3);
              void 0 !== r3 && void 0 !== r3.key && 0 === t2(r3.key, e3) && h(r3);
            }
          };
          var p = function(e3, r3) {
            if (!e3 || void 0 === e3.key)
              throw new Error("unknown error");
            var n2 = t2(r3, e3.key);
            return n2 < 0 ? e3.leftChild ? p(e3.leftChild, r3) : (e3.leftChild = new o.default(), e3.leftChild.parent = e3, e3.leftChild.brother = e3.rightChild, e3.rightChild && (e3.rightChild.brother = e3.leftChild), e3.leftChild) : n2 > 0 ? e3.rightChild ? p(e3.rightChild, r3) : (e3.rightChild = new o.default(), e3.rightChild.parent = e3, e3.rightChild.brother = e3.leftChild, e3.leftChild && (e3.leftChild.brother = e3.rightChild), e3.rightChild) : e3;
          }, d = function(e3) {
            var t3 = e3.parent;
            if (!t3) {
              if (e3 === a)
                return;
              throw new Error("unknown error");
            }
            if (t3.color !== o.default.TreeNodeColorType.black && t3.color === o.default.TreeNodeColorType.red) {
              var r3 = t3.brother, n2 = t3.parent;
              if (!n2)
                throw new Error("unknown error");
              if (r3 && r3.color === o.default.TreeNodeColorType.red)
                r3.color = t3.color = o.default.TreeNodeColorType.black, n2.color = o.default.TreeNodeColorType.red, d(n2);
              else if (!r3 || r3.color === o.default.TreeNodeColorType.black) {
                if (t3 === n2.leftChild) {
                  if (e3 === t3.leftChild) {
                    t3.color = o.default.TreeNodeColorType.black, n2.color = o.default.TreeNodeColorType.red;
                    var i2 = n2.rotateRight();
                    n2 === a && (a = i2);
                  } else if (e3 === t3.rightChild) {
                    i2 = t3.rotateLeft();
                    n2 === a && (a = i2), d(t3);
                  }
                } else if (t3 === n2.rightChild) {
                  if (e3 === t3.leftChild) {
                    i2 = t3.rotateRight();
                    n2 === a && (a = i2), d(t3);
                  } else if (e3 === t3.rightChild) {
                    t3.color = o.default.TreeNodeColorType.black, n2.color = o.default.TreeNodeColorType.red;
                    i2 = n2.rotateLeft();
                    n2 === a && (a = i2);
                  }
                }
              }
            }
          };
          this.insert = function(e3) {
            if (null === e3 || void 0 === e3)
              throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");
            if (this.empty())
              return ++s2, a.key = e3, void (a.color = o.default.TreeNodeColorType.black);
            var r3 = p(a, e3);
            void 0 !== r3.key && 0 === t2(r3.key, e3) || (++s2, r3.key = e3, d(r3), a.color = o.default.TreeNodeColorType.black);
          };
          var g = function(e3, r3) {
            if (e3 && void 0 !== e3.key) {
              var n2 = t2(r3, e3.key);
              return n2 < 0 ? g(e3.leftChild, r3) : n2 > 0 ? g(e3.rightChild, r3) : e3;
            }
          };
          this.find = function(e3) {
            var r3 = g(a, e3);
            return void 0 !== r3 && void 0 !== r3.key && 0 === t2(r3.key, e3);
          };
          var y = function(e3, r3) {
            if (e3 && void 0 !== e3.key) {
              var n2 = t2(e3.key, r3);
              if (0 === n2)
                return e3.key;
              if (n2 < 0)
                return y(e3.rightChild, r3);
              var i2 = y(e3.leftChild, r3);
              return void 0 !== i2 ? i2 : e3.key;
            }
          };
          this.lowerBound = function(e3) {
            return y(a, e3);
          };
          var b = function(e3, r3) {
            if (e3 && void 0 !== e3.key) {
              if (t2(e3.key, r3) <= 0)
                return b(e3.rightChild, r3);
              var n2 = b(e3.leftChild, r3);
              return void 0 !== n2 ? n2 : e3.key;
            }
          };
          this.upperBound = function(e3) {
            return b(a, e3);
          };
          var m = function(e3, r3) {
            if (e3 && void 0 !== e3.key) {
              var n2 = t2(e3.key, r3);
              if (0 === n2)
                return e3.key;
              if (n2 > 0)
                return m(e3.leftChild, r3);
              var i2 = m(e3.rightChild, r3);
              return void 0 !== i2 ? i2 : e3.key;
            }
          };
          this.reverseLowerBound = function(e3) {
            return m(a, e3);
          };
          var v = function(e3, r3) {
            if (e3 && void 0 !== e3.key) {
              if (t2(e3.key, r3) >= 0)
                return v(e3.leftChild, r3);
              var n2 = v(e3.rightChild, r3);
              return void 0 !== n2 ? n2 : e3.key;
            }
          };
          this.reverseUpperBound = function(e3) {
            return v(a, e3);
          }, this.union = function(e3) {
            var t3 = this;
            e3.forEach(function(e4) {
              return t3.insert(e4);
            });
          }, this.getHeight = function() {
            if (this.empty())
              return 0;
            var e3 = function(t3) {
              return t3 ? Math.max(e3(t3.leftChild), e3(t3.rightChild)) + 1 : 1;
            };
            return e3(a);
          };
          var w = function(e3) {
            return n(this, function(t3) {
              switch (t3.label) {
                case 0:
                  return e3 && void 0 !== e3.key ? [5, i(w(e3.leftChild))] : [2];
                case 1:
                  return t3.sent(), [4, e3.key];
                case 2:
                  return t3.sent(), [5, i(w(e3.rightChild))];
                case 3:
                  return t3.sent(), [2];
              }
            });
          };
          this[Symbol.iterator] = function() {
            return w(a);
          }, e2.forEach(function(e3) {
            return r2.insert(e3);
          }), Object.freeze(this);
        }
        Object.freeze(s), r.default = s;
      }, { "../Base/TreeNode": 25 }], 34: [function(e, t, r) {
        "use strict";
        function n(e2) {
          var t2 = this;
          void 0 === e2 && (e2 = []);
          var r2 = 0, n2 = [];
          this.size = function() {
            return r2;
          }, this.empty = function() {
            return 0 === r2;
          }, this.clear = function() {
            r2 = 0, n2.length = 0;
          }, this.push = function(e3) {
            n2.push(e3), ++r2;
          }, this.pop = function() {
            n2.pop(), r2 > 0 && --r2;
          }, this.top = function() {
            return n2[r2 - 1];
          }, e2.forEach(function(e3) {
            return t2.push(e3);
          }), Object.freeze(this);
        }
        Object.defineProperty(r, "__esModule", { value: true }), Object.freeze(n), r.default = n;
      }, {}], 35: [function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o2, s2 = { label: 0, sent: function() {
            if (1 & i2[0])
              throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function a2(o3) {
            return function(a3) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; s2; )
                  try {
                    if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                      return i2;
                    switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                      case 0:
                      case 1:
                        i2 = o4;
                        break;
                      case 4:
                        return s2.label++, { value: o4[1], done: false };
                      case 5:
                        s2.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = s2.ops.pop(), s2.trys.pop();
                        continue;
                      default:
                        if (!(i2 = (i2 = s2.trys).length > 0 && i2[i2.length - 1]) && (6 === o4[0] || 2 === o4[0])) {
                          s2 = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                          s2.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && s2.label < i2[1]) {
                          s2.label = i2[1], i2 = o4;
                          break;
                        }
                        if (i2 && s2.label < i2[2]) {
                          s2.label = i2[2], s2.ops.push(o4);
                          break;
                        }
                        i2[2] && s2.ops.pop(), s2.trys.pop();
                        continue;
                    }
                    o4 = t2.call(e2, s2);
                  } catch (e3) {
                    o4 = [6, e3], n2 = 0;
                  } finally {
                    r2 = i2 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, a3]);
            };
          }
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), s2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              s2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return s2;
        }, o = this && this.__spreadArray || function(e2, t2, r2) {
          if (r2 || 2 === arguments.length)
            for (var n2, i2 = 0, o2 = t2.length; i2 < o2; i2++)
              !n2 && i2 in t2 || (n2 || (n2 = Array.prototype.slice.call(t2, 0, i2)), n2[i2] = t2[i2]);
          return e2.concat(n2 || Array.prototype.slice.call(t2));
        }, s = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        function a(e2) {
          var t2 = this;
          void 0 === e2 && (e2 = []);
          var r2 = 0, a2 = [];
          this.size = function() {
            return r2;
          }, this.empty = function() {
            return 0 === r2;
          }, this.clear = function() {
            r2 = 0, a2.length = 0;
          }, this.front = function() {
            if (!this.empty())
              return a2[0];
          }, this.back = function() {
            if (!this.empty())
              return a2[r2 - 1];
          }, this.forEach = function(e3) {
            a2.forEach(e3);
          }, this.getElementByPos = function(e3) {
            if (e3 < 0 || e3 >= r2)
              throw new Error("pos must more than 0 and less than vector's size");
            return a2[e3];
          }, this.eraseElementByPos = function(e3) {
            if (e3 < 0 || e3 >= r2)
              throw new Error("pos must more than 0 and less than vector's size");
            for (var t3 = e3; t3 < r2 - 1; ++t3)
              a2[t3] = a2[t3 + 1];
            this.popBack();
          }, this.eraseElementByValue = function(e3) {
            var t3 = [];
            this.forEach(function(r3) {
              r3 !== e3 && t3.push(r3);
            }), t3.forEach(function(e4, t4) {
              a2[t4] = e4;
            });
            for (var n2 = t3.length; r2 > n2; )
              this.popBack();
          }, this.pushBack = function(e3) {
            a2.push(e3), ++r2;
          }, this.popBack = function() {
            a2.pop(), r2 > 0 && --r2;
          }, this.setElementByPos = function(e3, t3) {
            if (e3 < 0 || e3 >= r2)
              throw new Error("pos must more than 0 and less than vector's size");
            a2[e3] = t3;
          }, this.insert = function(e3, t3, n2) {
            if (void 0 === n2 && (n2 = 1), e3 < 0 || e3 > r2)
              throw new Error("pos must more than 0 and less than or equal to vector's size");
            a2.splice.apply(a2, o([e3, 0], i(new Array(n2).fill(t3)), false)), r2 += n2;
          }, this.find = function(e3) {
            return a2.includes(e3);
          }, this.reverse = function() {
            a2.reverse();
          }, this.unique = function() {
            var e3, t3 = [];
            this.forEach(function(r3, n3) {
              0 !== n3 && r3 === e3 || (t3.push(r3), e3 = r3);
            }), t3.forEach(function(e4, t4) {
              a2[t4] = e4;
            });
            for (var n2 = t3.length; r2 > n2; )
              this.popBack();
          }, this.sort = function(e3) {
            a2.sort(e3);
          }, this[Symbol.iterator] = function() {
            return function() {
              return n(this, function(e3) {
                switch (e3.label) {
                  case 0:
                    return [5, s(a2)];
                  case 1:
                    return [2, e3.sent()];
                }
              });
            }();
          }, e2.forEach(function(e3) {
            return t2.pushBack(e3);
          }), Object.freeze(this);
        }
        Object.defineProperty(r, "__esModule", { value: true }), Object.freeze(a), r.default = a;
      }, {}], 36: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.HashMap = r.HashSet = r.Map = r.Set = r.PriorityQueue = r.Deque = r.LinkList = r.Queue = r.Stack = r.Vector = void 0;
        var n = e("./Vector/Vector");
        r.Vector = n.default;
        var i = e("./Stack/Stack");
        r.Stack = i.default;
        var o = e("./Queue/Queue");
        r.Queue = o.default;
        var s = e("./LinkList/LinkList");
        r.LinkList = s.default;
        var a = e("./Deque/Deque");
        r.Deque = a.default;
        var l = e("./PriorityQueue/PriorityQueue");
        r.PriorityQueue = l.default;
        var u = e("./Set/Set");
        r.Set = u.default;
        var c = e("./Map/Map");
        r.Map = c.default;
        var h = e("./HashSet/HashSet");
        r.HashSet = h.default;
        var f = e("./HashMap/HashMap");
        r.HashMap = f.default;
      }, { "./Deque/Deque": 26, "./HashMap/HashMap": 27, "./HashSet/HashSet": 28, "./LinkList/LinkList": 29, "./Map/Map": 30, "./PriorityQueue/PriorityQueue": 31, "./Queue/Queue": 32, "./Set/Set": 33, "./Stack/Stack": 34, "./Vector/Vector": 35 }], 37: [function(e, t, r) {
        "use strict";
        const n = e("yallist"), i = Symbol("max"), o = Symbol("length"), s = Symbol("lengthCalculator"), a = Symbol("allowStale"), l = Symbol("maxAge"), u = Symbol("dispose"), c = Symbol("noDisposeOnSet"), h = Symbol("lruList"), f = Symbol("cache"), p = Symbol("updateAgeOnGet"), d = () => 1;
        const g = (e2, t2, r2) => {
          const n2 = e2[f].get(t2);
          if (n2) {
            const t3 = n2.value;
            if (y(e2, t3)) {
              if (m(e2, n2), !e2[a])
                return;
            } else
              r2 && (e2[p] && (n2.value.now = Date.now()), e2[h].unshiftNode(n2));
            return t3.value;
          }
        }, y = (e2, t2) => {
          if (!t2 || !t2.maxAge && !e2[l])
            return false;
          const r2 = Date.now() - t2.now;
          return t2.maxAge ? r2 > t2.maxAge : e2[l] && r2 > e2[l];
        }, b = (e2) => {
          if (e2[o] > e2[i])
            for (let t2 = e2[h].tail; e2[o] > e2[i] && null !== t2; ) {
              const r2 = t2.prev;
              m(e2, t2), t2 = r2;
            }
        }, m = (e2, t2) => {
          if (t2) {
            const r2 = t2.value;
            e2[u] && e2[u](r2.key, r2.value), e2[o] -= r2.length, e2[f].delete(r2.key), e2[h].removeNode(t2);
          }
        };
        class v {
          constructor(e2, t2, r2, n2, i2) {
            this.key = e2, this.value = t2, this.length = r2, this.now = n2, this.maxAge = i2 || 0;
          }
        }
        const w = (e2, t2, r2, n2) => {
          let i2 = r2.value;
          y(e2, i2) && (m(e2, r2), e2[a] || (i2 = void 0)), i2 && t2.call(n2, i2.value, i2.key, e2);
        };
        t.exports = class {
          constructor(e2) {
            if ("number" == typeof e2 && (e2 = { max: e2 }), e2 || (e2 = {}), e2.max && ("number" != typeof e2.max || e2.max < 0))
              throw new TypeError("max must be a non-negative number");
            this[i] = e2.max || 1 / 0;
            const t2 = e2.length || d;
            if (this[s] = "function" != typeof t2 ? d : t2, this[a] = e2.stale || false, e2.maxAge && "number" != typeof e2.maxAge)
              throw new TypeError("maxAge must be a number");
            this[l] = e2.maxAge || 0, this[u] = e2.dispose, this[c] = e2.noDisposeOnSet || false, this[p] = e2.updateAgeOnGet || false, this.reset();
          }
          set max(e2) {
            if ("number" != typeof e2 || e2 < 0)
              throw new TypeError("max must be a non-negative number");
            this[i] = e2 || 1 / 0, b(this);
          }
          get max() {
            return this[i];
          }
          set allowStale(e2) {
            this[a] = !!e2;
          }
          get allowStale() {
            return this[a];
          }
          set maxAge(e2) {
            if ("number" != typeof e2)
              throw new TypeError("maxAge must be a non-negative number");
            this[l] = e2, b(this);
          }
          get maxAge() {
            return this[l];
          }
          set lengthCalculator(e2) {
            "function" != typeof e2 && (e2 = d), e2 !== this[s] && (this[s] = e2, this[o] = 0, this[h].forEach((e3) => {
              e3.length = this[s](e3.value, e3.key), this[o] += e3.length;
            })), b(this);
          }
          get lengthCalculator() {
            return this[s];
          }
          get length() {
            return this[o];
          }
          get itemCount() {
            return this[h].length;
          }
          rforEach(e2, t2) {
            t2 = t2 || this;
            for (let r2 = this[h].tail; null !== r2; ) {
              const n2 = r2.prev;
              w(this, e2, r2, t2), r2 = n2;
            }
          }
          forEach(e2, t2) {
            t2 = t2 || this;
            for (let r2 = this[h].head; null !== r2; ) {
              const n2 = r2.next;
              w(this, e2, r2, t2), r2 = n2;
            }
          }
          keys() {
            return this[h].toArray().map((e2) => e2.key);
          }
          values() {
            return this[h].toArray().map((e2) => e2.value);
          }
          reset() {
            this[u] && this[h] && this[h].length && this[h].forEach((e2) => this[u](e2.key, e2.value)), this[f] = /* @__PURE__ */ new Map(), this[h] = new n(), this[o] = 0;
          }
          dump() {
            return this[h].map((e2) => !y(this, e2) && { k: e2.key, v: e2.value, e: e2.now + (e2.maxAge || 0) }).toArray().filter((e2) => e2);
          }
          dumpLru() {
            return this[h];
          }
          set(e2, t2, r2) {
            if ((r2 = r2 || this[l]) && "number" != typeof r2)
              throw new TypeError("maxAge must be a number");
            const n2 = r2 ? Date.now() : 0, a2 = this[s](t2, e2);
            if (this[f].has(e2)) {
              if (a2 > this[i])
                return m(this, this[f].get(e2)), false;
              const s2 = this[f].get(e2).value;
              return this[u] && (this[c] || this[u](e2, s2.value)), s2.now = n2, s2.maxAge = r2, s2.value = t2, this[o] += a2 - s2.length, s2.length = a2, this.get(e2), b(this), true;
            }
            const p2 = new v(e2, t2, a2, n2, r2);
            return p2.length > this[i] ? (this[u] && this[u](e2, t2), false) : (this[o] += p2.length, this[h].unshift(p2), this[f].set(e2, this[h].head), b(this), true);
          }
          has(e2) {
            if (!this[f].has(e2))
              return false;
            const t2 = this[f].get(e2).value;
            return !y(this, t2);
          }
          get(e2) {
            return g(this, e2, true);
          }
          peek(e2) {
            return g(this, e2, false);
          }
          pop() {
            const e2 = this[h].tail;
            return e2 ? (m(this, e2), e2.value) : null;
          }
          del(e2) {
            m(this, this[f].get(e2));
          }
          load(e2) {
            this.reset();
            const t2 = Date.now();
            for (let r2 = e2.length - 1; r2 >= 0; r2--) {
              const n2 = e2[r2], i2 = n2.e || 0;
              if (0 === i2)
                this.set(n2.k, n2.v);
              else {
                const e3 = i2 - t2;
                e3 > 0 && this.set(n2.k, n2.v, e3);
              }
            }
          }
          prune() {
            this[f].forEach((e2, t2) => g(this, t2, false));
          }
        };
      }, { yallist: 83 }], 38: [function(e, t, r) {
        (function(e2) {
          (function() {
            const r2 = t.exports;
            r2.types = { 0: "reserved", 1: "connect", 2: "connack", 3: "publish", 4: "puback", 5: "pubrec", 6: "pubrel", 7: "pubcomp", 8: "subscribe", 9: "suback", 10: "unsubscribe", 11: "unsuback", 12: "pingreq", 13: "pingresp", 14: "disconnect", 15: "auth" }, r2.codes = {};
            for (const e3 in r2.types) {
              const t2 = r2.types[e3];
              r2.codes[t2] = e3;
            }
            r2.CMD_SHIFT = 4, r2.CMD_MASK = 240, r2.DUP_MASK = 8, r2.QOS_MASK = 3, r2.QOS_SHIFT = 1, r2.RETAIN_MASK = 1, r2.VARBYTEINT_MASK = 127, r2.VARBYTEINT_FIN_MASK = 128, r2.VARBYTEINT_MAX = 268435455, r2.SESSIONPRESENT_MASK = 1, r2.SESSIONPRESENT_HEADER = e2.from([r2.SESSIONPRESENT_MASK]), r2.CONNACK_HEADER = e2.from([r2.codes.connack << r2.CMD_SHIFT]), r2.USERNAME_MASK = 128, r2.PASSWORD_MASK = 64, r2.WILL_RETAIN_MASK = 32, r2.WILL_QOS_MASK = 24, r2.WILL_QOS_SHIFT = 3, r2.WILL_FLAG_MASK = 4, r2.CLEAN_SESSION_MASK = 2, r2.CONNECT_HEADER = e2.from([r2.codes.connect << r2.CMD_SHIFT]), r2.properties = { sessionExpiryInterval: 17, willDelayInterval: 24, receiveMaximum: 33, maximumPacketSize: 39, topicAliasMaximum: 34, requestResponseInformation: 25, requestProblemInformation: 23, userProperties: 38, authenticationMethod: 21, authenticationData: 22, payloadFormatIndicator: 1, messageExpiryInterval: 2, contentType: 3, responseTopic: 8, correlationData: 9, maximumQoS: 36, retainAvailable: 37, assignedClientIdentifier: 18, reasonString: 31, wildcardSubscriptionAvailable: 40, subscriptionIdentifiersAvailable: 41, sharedSubscriptionAvailable: 42, serverKeepAlive: 19, responseInformation: 26, serverReference: 28, topicAlias: 35, subscriptionIdentifier: 11 }, r2.propertiesCodes = {};
            for (const e3 in r2.properties) {
              const t2 = r2.properties[e3];
              r2.propertiesCodes[t2] = e3;
            }
            function n(t2) {
              return [0, 1, 2].map((n2) => [0, 1].map((i) => [0, 1].map((o) => {
                const s = e2.alloc(1);
                return s.writeUInt8(r2.codes[t2] << r2.CMD_SHIFT | (i ? r2.DUP_MASK : 0) | n2 << r2.QOS_SHIFT | o, 0, true), s;
              })));
            }
            r2.propertiesTypes = { sessionExpiryInterval: "int32", willDelayInterval: "int32", receiveMaximum: "int16", maximumPacketSize: "int32", topicAliasMaximum: "int16", requestResponseInformation: "byte", requestProblemInformation: "byte", userProperties: "pair", authenticationMethod: "string", authenticationData: "binary", payloadFormatIndicator: "byte", messageExpiryInterval: "int32", contentType: "string", responseTopic: "string", correlationData: "binary", maximumQoS: "int8", retainAvailable: "byte", assignedClientIdentifier: "string", reasonString: "string", wildcardSubscriptionAvailable: "byte", subscriptionIdentifiersAvailable: "byte", sharedSubscriptionAvailable: "byte", serverKeepAlive: "int16", responseInformation: "string", serverReference: "string", topicAlias: "int16", subscriptionIdentifier: "var" }, r2.PUBLISH_HEADER = n("publish"), r2.SUBSCRIBE_HEADER = n("subscribe"), r2.SUBSCRIBE_OPTIONS_QOS_MASK = 3, r2.SUBSCRIBE_OPTIONS_NL_MASK = 1, r2.SUBSCRIBE_OPTIONS_NL_SHIFT = 2, r2.SUBSCRIBE_OPTIONS_RAP_MASK = 1, r2.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3, r2.SUBSCRIBE_OPTIONS_RH_MASK = 3, r2.SUBSCRIBE_OPTIONS_RH_SHIFT = 4, r2.SUBSCRIBE_OPTIONS_RH = [0, 16, 32], r2.SUBSCRIBE_OPTIONS_NL = 4, r2.SUBSCRIBE_OPTIONS_RAP = 8, r2.SUBSCRIBE_OPTIONS_QOS = [0, 1, 2], r2.UNSUBSCRIBE_HEADER = n("unsubscribe"), r2.ACKS = { unsuback: n("unsuback"), puback: n("puback"), pubcomp: n("pubcomp"), pubrel: n("pubrel"), pubrec: n("pubrec") }, r2.SUBACK_HEADER = e2.from([r2.codes.suback << r2.CMD_SHIFT]), r2.VERSION3 = e2.from([3]), r2.VERSION4 = e2.from([4]), r2.VERSION5 = e2.from([5]), r2.VERSION131 = e2.from([131]), r2.VERSION132 = e2.from([132]), r2.QOS = [0, 1, 2].map((t2) => e2.from([t2])), r2.EMPTY = { pingreq: e2.from([r2.codes.pingreq << 4, 0]), pingresp: e2.from([r2.codes.pingresp << 4, 0]), disconnect: e2.from([r2.codes.disconnect << 4, 0]) };
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { buffer: 17 }], 39: [function(e, t, r) {
        (function(r2) {
          (function() {
            const n = e("./writeToStream"), i = e("events");
            class o extends i {
              constructor() {
                super(), this._array = new Array(20), this._i = 0;
              }
              write(e2) {
                return this._array[this._i++] = e2, true;
              }
              concat() {
                let e2 = 0;
                const t2 = new Array(this._array.length), n2 = this._array;
                let i2, o2 = 0;
                for (i2 = 0; i2 < n2.length && void 0 !== n2[i2]; i2++)
                  "string" != typeof n2[i2] ? t2[i2] = n2[i2].length : t2[i2] = r2.byteLength(n2[i2]), e2 += t2[i2];
                const s = r2.allocUnsafe(e2);
                for (i2 = 0; i2 < n2.length && void 0 !== n2[i2]; i2++)
                  "string" != typeof n2[i2] ? (n2[i2].copy(s, o2), o2 += t2[i2]) : (s.write(n2[i2], o2), o2 += t2[i2]);
                return s;
              }
            }
            t.exports = function(e2, t2) {
              const r3 = new o();
              return n(e2, r3, t2), r3.concat();
            };
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { "./writeToStream": 44, buffer: 17, events: 22 }], 40: [function(e, t, r) {
        r.parser = e("./parser").parser, r.generate = e("./generate"), r.writeToStream = e("./writeToStream");
      }, { "./generate": 39, "./parser": 43, "./writeToStream": 44 }], 41: [function(e, t, r) {
        (function(e2) {
          (function() {
            const r2 = 65536, n = {}, i = e2.isBuffer(e2.from([1, 2]).subarray(0, 1));
            function o(t2) {
              const r3 = e2.allocUnsafe(2);
              return r3.writeUInt8(t2 >> 8, 0), r3.writeUInt8(255 & t2, 1), r3;
            }
            t.exports = { cache: n, generateCache: function() {
              for (let e3 = 0; e3 < r2; e3++)
                n[e3] = o(e3);
            }, generateNumber: o, genBufVariableByteInt: function(t2) {
              let r3 = 0, n2 = 0;
              const o2 = e2.allocUnsafe(4);
              do {
                r3 = t2 % 128 | 0, (t2 = t2 / 128 | 0) > 0 && (r3 |= 128), o2.writeUInt8(r3, n2++);
              } while (t2 > 0 && n2 < 4);
              return t2 > 0 && (n2 = 0), i ? o2.subarray(0, n2) : o2.slice(0, n2);
            }, generate4ByteBuffer: function(t2) {
              const r3 = e2.allocUnsafe(4);
              return r3.writeUInt32BE(t2, 0), r3;
            } };
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { buffer: 17 }], 42: [function(e, t, r) {
        t.exports = class {
          constructor() {
            this.cmd = null, this.retain = false, this.qos = 0, this.dup = false, this.length = -1, this.topic = null, this.payload = null;
          }
        };
      }, {}], 43: [function(e, t, r) {
        const n = e("bl"), i = e("events"), o = e("./packet"), s = e("./constants"), a = e("debug")("mqtt-packet:parser");
        class l extends i {
          constructor() {
            super(), this.parser = this.constructor.parser;
          }
          static parser(e2) {
            return this instanceof l ? (this.settings = e2 || {}, this._states = ["_parseHeader", "_parseLength", "_parsePayload", "_newPacket"], this._resetState(), this) : new l().parser(e2);
          }
          _resetState() {
            a("_resetState: resetting packet, error, _list, and _stateCounter"), this.packet = new o(), this.error = null, this._list = n(), this._stateCounter = 0;
          }
          parse(e2) {
            for (this.error && this._resetState(), this._list.append(e2), a("parse: current state: %s", this._states[this._stateCounter]); (-1 !== this.packet.length || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error; )
              this._stateCounter++, a("parse: state complete. _stateCounter is now: %d", this._stateCounter), a("parse: packet.length: %d, buffer list length: %d", this.packet.length, this._list.length), this._stateCounter >= this._states.length && (this._stateCounter = 0);
            return a("parse: exited while loop. packet: %d, buffer list length: %d", this.packet.length, this._list.length), this._list.length;
          }
          _parseHeader() {
            const e2 = this._list.readUInt8(0);
            return this.packet.cmd = s.types[e2 >> s.CMD_SHIFT], this.packet.retain = 0 != (e2 & s.RETAIN_MASK), this.packet.qos = e2 >> s.QOS_SHIFT & s.QOS_MASK, this.packet.dup = 0 != (e2 & s.DUP_MASK), a("_parseHeader: packet: %o", this.packet), this._list.consume(1), true;
          }
          _parseLength() {
            const e2 = this._parseVarByteNum(true);
            return e2 && (this.packet.length = e2.value, this._list.consume(e2.bytes)), a("_parseLength %d", e2.value), !!e2;
          }
          _parsePayload() {
            a("_parsePayload: payload %O", this._list);
            let e2 = false;
            if (0 === this.packet.length || this._list.length >= this.packet.length) {
              switch (this._pos = 0, this.packet.cmd) {
                case "connect":
                  this._parseConnect();
                  break;
                case "connack":
                  this._parseConnack();
                  break;
                case "publish":
                  this._parsePublish();
                  break;
                case "puback":
                case "pubrec":
                case "pubrel":
                case "pubcomp":
                  this._parseConfirmation();
                  break;
                case "subscribe":
                  this._parseSubscribe();
                  break;
                case "suback":
                  this._parseSuback();
                  break;
                case "unsubscribe":
                  this._parseUnsubscribe();
                  break;
                case "unsuback":
                  this._parseUnsuback();
                  break;
                case "pingreq":
                case "pingresp":
                  break;
                case "disconnect":
                  this._parseDisconnect();
                  break;
                case "auth":
                  this._parseAuth();
                  break;
                default:
                  this._emitError(new Error("Not supported"));
              }
              e2 = true;
            }
            return a("_parsePayload complete result: %s", e2), e2;
          }
          _parseConnect() {
            let e2, t2, r2, n2;
            a("_parseConnect");
            const i2 = {}, o2 = this.packet, l2 = this._parseString();
            if (null === l2)
              return this._emitError(new Error("Cannot parse protocolId"));
            if ("MQTT" !== l2 && "MQIsdp" !== l2)
              return this._emitError(new Error("Invalid protocolId"));
            if (o2.protocolId = l2, this._pos >= this._list.length)
              return this._emitError(new Error("Packet too short"));
            if (o2.protocolVersion = this._list.readUInt8(this._pos), o2.protocolVersion >= 128 && (o2.bridgeMode = true, o2.protocolVersion = o2.protocolVersion - 128), 3 !== o2.protocolVersion && 4 !== o2.protocolVersion && 5 !== o2.protocolVersion)
              return this._emitError(new Error("Invalid protocol version"));
            if (this._pos++, this._pos >= this._list.length)
              return this._emitError(new Error("Packet too short"));
            if (i2.username = this._list.readUInt8(this._pos) & s.USERNAME_MASK, i2.password = this._list.readUInt8(this._pos) & s.PASSWORD_MASK, i2.will = this._list.readUInt8(this._pos) & s.WILL_FLAG_MASK, i2.will && (o2.will = {}, o2.will.retain = 0 != (this._list.readUInt8(this._pos) & s.WILL_RETAIN_MASK), o2.will.qos = (this._list.readUInt8(this._pos) & s.WILL_QOS_MASK) >> s.WILL_QOS_SHIFT), o2.clean = 0 != (this._list.readUInt8(this._pos) & s.CLEAN_SESSION_MASK), this._pos++, o2.keepalive = this._parseNum(), -1 === o2.keepalive)
              return this._emitError(new Error("Packet too short"));
            if (5 === o2.protocolVersion) {
              const e3 = this._parseProperties();
              Object.getOwnPropertyNames(e3).length && (o2.properties = e3);
            }
            const u = this._parseString();
            if (null === u)
              return this._emitError(new Error("Packet too short"));
            if (o2.clientId = u, a("_parseConnect: packet.clientId: %s", o2.clientId), i2.will) {
              if (5 === o2.protocolVersion) {
                const e3 = this._parseProperties();
                Object.getOwnPropertyNames(e3).length && (o2.will.properties = e3);
              }
              if (null === (e2 = this._parseString()))
                return this._emitError(new Error("Cannot parse will topic"));
              if (o2.will.topic = e2, a("_parseConnect: packet.will.topic: %s", o2.will.topic), null === (t2 = this._parseBuffer()))
                return this._emitError(new Error("Cannot parse will payload"));
              o2.will.payload = t2, a("_parseConnect: packet.will.paylaod: %s", o2.will.payload);
            }
            if (i2.username) {
              if (null === (n2 = this._parseString()))
                return this._emitError(new Error("Cannot parse username"));
              o2.username = n2, a("_parseConnect: packet.username: %s", o2.username);
            }
            if (i2.password) {
              if (null === (r2 = this._parseBuffer()))
                return this._emitError(new Error("Cannot parse password"));
              o2.password = r2;
            }
            return this.settings = o2, a("_parseConnect: complete"), o2;
          }
          _parseConnack() {
            a("_parseConnack");
            const e2 = this.packet;
            if (this._list.length < 1)
              return null;
            if (e2.sessionPresent = !!(this._list.readUInt8(this._pos++) & s.SESSIONPRESENT_MASK), 5 === this.settings.protocolVersion)
              this._list.length >= 2 ? e2.reasonCode = this._list.readUInt8(this._pos++) : e2.reasonCode = 0;
            else {
              if (this._list.length < 2)
                return null;
              e2.returnCode = this._list.readUInt8(this._pos++);
            }
            if (-1 === e2.returnCode || -1 === e2.reasonCode)
              return this._emitError(new Error("Cannot parse return code"));
            if (5 === this.settings.protocolVersion) {
              const t2 = this._parseProperties();
              Object.getOwnPropertyNames(t2).length && (e2.properties = t2);
            }
            a("_parseConnack: complete");
          }
          _parsePublish() {
            a("_parsePublish");
            const e2 = this.packet;
            if (e2.topic = this._parseString(), null === e2.topic)
              return this._emitError(new Error("Cannot parse topic"));
            if (!(e2.qos > 0) || this._parseMessageId()) {
              if (5 === this.settings.protocolVersion) {
                const t2 = this._parseProperties();
                Object.getOwnPropertyNames(t2).length && (e2.properties = t2);
              }
              e2.payload = this._list.slice(this._pos, e2.length), a("_parsePublish: payload from buffer list: %o", e2.payload);
            }
          }
          _parseSubscribe() {
            a("_parseSubscribe");
            const e2 = this.packet;
            let t2, r2, n2, i2, o2, l2, u;
            if (1 !== e2.qos)
              return this._emitError(new Error("Wrong subscribe header"));
            if (e2.subscriptions = [], this._parseMessageId()) {
              if (5 === this.settings.protocolVersion) {
                const t3 = this._parseProperties();
                Object.getOwnPropertyNames(t3).length && (e2.properties = t3);
              }
              for (; this._pos < e2.length; ) {
                if (null === (t2 = this._parseString()))
                  return this._emitError(new Error("Cannot parse topic"));
                if (this._pos >= e2.length)
                  return this._emitError(new Error("Malformed Subscribe Payload"));
                n2 = (r2 = this._parseByte()) & s.SUBSCRIBE_OPTIONS_QOS_MASK, l2 = 0 != (r2 >> s.SUBSCRIBE_OPTIONS_NL_SHIFT & s.SUBSCRIBE_OPTIONS_NL_MASK), o2 = 0 != (r2 >> s.SUBSCRIBE_OPTIONS_RAP_SHIFT & s.SUBSCRIBE_OPTIONS_RAP_MASK), i2 = r2 >> s.SUBSCRIBE_OPTIONS_RH_SHIFT & s.SUBSCRIBE_OPTIONS_RH_MASK, u = { topic: t2, qos: n2 }, 5 === this.settings.protocolVersion ? (u.nl = l2, u.rap = o2, u.rh = i2) : this.settings.bridgeMode && (u.rh = 0, u.rap = true, u.nl = true), a("_parseSubscribe: push subscription `%s` to subscription", u), e2.subscriptions.push(u);
              }
            }
          }
          _parseSuback() {
            a("_parseSuback");
            const e2 = this.packet;
            if (this.packet.granted = [], this._parseMessageId()) {
              if (5 === this.settings.protocolVersion) {
                const t2 = this._parseProperties();
                Object.getOwnPropertyNames(t2).length && (e2.properties = t2);
              }
              for (; this._pos < this.packet.length; )
                this.packet.granted.push(this._list.readUInt8(this._pos++));
            }
          }
          _parseUnsubscribe() {
            a("_parseUnsubscribe");
            const e2 = this.packet;
            if (e2.unsubscriptions = [], this._parseMessageId()) {
              if (5 === this.settings.protocolVersion) {
                const t2 = this._parseProperties();
                Object.getOwnPropertyNames(t2).length && (e2.properties = t2);
              }
              for (; this._pos < e2.length; ) {
                const t2 = this._parseString();
                if (null === t2)
                  return this._emitError(new Error("Cannot parse topic"));
                a("_parseUnsubscribe: push topic `%s` to unsubscriptions", t2), e2.unsubscriptions.push(t2);
              }
            }
          }
          _parseUnsuback() {
            a("_parseUnsuback");
            const e2 = this.packet;
            if (!this._parseMessageId())
              return this._emitError(new Error("Cannot parse messageId"));
            if (5 === this.settings.protocolVersion) {
              const t2 = this._parseProperties();
              for (Object.getOwnPropertyNames(t2).length && (e2.properties = t2), e2.granted = []; this._pos < this.packet.length; )
                this.packet.granted.push(this._list.readUInt8(this._pos++));
            }
          }
          _parseConfirmation() {
            a("_parseConfirmation: packet.cmd: `%s`", this.packet.cmd);
            const e2 = this.packet;
            if (this._parseMessageId(), 5 === this.settings.protocolVersion && (e2.length > 2 ? (e2.reasonCode = this._parseByte(), a("_parseConfirmation: packet.reasonCode `%d`", e2.reasonCode)) : e2.reasonCode = 0, e2.length > 3)) {
              const t2 = this._parseProperties();
              Object.getOwnPropertyNames(t2).length && (e2.properties = t2);
            }
            return true;
          }
          _parseDisconnect() {
            const e2 = this.packet;
            if (a("_parseDisconnect"), 5 === this.settings.protocolVersion) {
              this._list.length > 0 ? e2.reasonCode = this._parseByte() : e2.reasonCode = 0;
              const t2 = this._parseProperties();
              Object.getOwnPropertyNames(t2).length && (e2.properties = t2);
            }
            return a("_parseDisconnect result: true"), true;
          }
          _parseAuth() {
            a("_parseAuth");
            const e2 = this.packet;
            if (5 !== this.settings.protocolVersion)
              return this._emitError(new Error("Not supported auth packet for this version MQTT"));
            e2.reasonCode = this._parseByte();
            const t2 = this._parseProperties();
            return Object.getOwnPropertyNames(t2).length && (e2.properties = t2), a("_parseAuth: result: true"), true;
          }
          _parseMessageId() {
            const e2 = this.packet;
            return e2.messageId = this._parseNum(), null === e2.messageId ? (this._emitError(new Error("Cannot parse messageId")), false) : (a("_parseMessageId: packet.messageId %d", e2.messageId), true);
          }
          _parseString(e2) {
            const t2 = this._parseNum(), r2 = t2 + this._pos;
            if (-1 === t2 || r2 > this._list.length || r2 > this.packet.length)
              return null;
            const n2 = this._list.toString("utf8", this._pos, r2);
            return this._pos += t2, a("_parseString: result: %s", n2), n2;
          }
          _parseStringPair() {
            return a("_parseStringPair"), { name: this._parseString(), value: this._parseString() };
          }
          _parseBuffer() {
            const e2 = this._parseNum(), t2 = e2 + this._pos;
            if (-1 === e2 || t2 > this._list.length || t2 > this.packet.length)
              return null;
            const r2 = this._list.slice(this._pos, t2);
            return this._pos += e2, a("_parseBuffer: result: %o", r2), r2;
          }
          _parseNum() {
            if (this._list.length - this._pos < 2)
              return -1;
            const e2 = this._list.readUInt16BE(this._pos);
            return this._pos += 2, a("_parseNum: result: %s", e2), e2;
          }
          _parse4ByteNum() {
            if (this._list.length - this._pos < 4)
              return -1;
            const e2 = this._list.readUInt32BE(this._pos);
            return this._pos += 4, a("_parse4ByteNum: result: %s", e2), e2;
          }
          _parseVarByteNum(e2) {
            a("_parseVarByteNum");
            let t2, r2 = 0, n2 = 1, i2 = 0, o2 = false;
            const l2 = this._pos ? this._pos : 0;
            for (; r2 < 4 && l2 + r2 < this._list.length; ) {
              if (i2 += n2 * ((t2 = this._list.readUInt8(l2 + r2++)) & s.VARBYTEINT_MASK), n2 *= 128, 0 == (t2 & s.VARBYTEINT_FIN_MASK)) {
                o2 = true;
                break;
              }
              if (this._list.length <= r2)
                break;
            }
            return !o2 && 4 === r2 && this._list.length >= r2 && this._emitError(new Error("Invalid variable byte integer")), l2 && (this._pos += r2), a("_parseVarByteNum: result: %o", o2 = !!o2 && (e2 ? { bytes: r2, value: i2 } : i2)), o2;
          }
          _parseByte() {
            let e2;
            return this._pos < this._list.length && (e2 = this._list.readUInt8(this._pos), this._pos++), a("_parseByte: result: %o", e2), e2;
          }
          _parseByType(e2) {
            switch (a("_parseByType: type: %s", e2), e2) {
              case "byte":
                return 0 !== this._parseByte();
              case "int8":
                return this._parseByte();
              case "int16":
                return this._parseNum();
              case "int32":
                return this._parse4ByteNum();
              case "var":
                return this._parseVarByteNum();
              case "string":
                return this._parseString();
              case "pair":
                return this._parseStringPair();
              case "binary":
                return this._parseBuffer();
            }
          }
          _parseProperties() {
            a("_parseProperties");
            const e2 = this._parseVarByteNum(), t2 = this._pos + e2, r2 = {};
            for (; this._pos < t2; ) {
              const e3 = this._parseByte();
              if (!e3)
                return this._emitError(new Error("Cannot parse property code type")), false;
              const t3 = s.propertiesCodes[e3];
              if (!t3)
                return this._emitError(new Error("Unknown property")), false;
              if ("userProperties" !== t3)
                r2[t3] ? Array.isArray(r2[t3]) ? r2[t3].push(this._parseByType(s.propertiesTypes[t3])) : (r2[t3] = [r2[t3]], r2[t3].push(this._parseByType(s.propertiesTypes[t3]))) : r2[t3] = this._parseByType(s.propertiesTypes[t3]);
              else {
                r2[t3] || (r2[t3] = /* @__PURE__ */ Object.create(null));
                const e4 = this._parseByType(s.propertiesTypes[t3]);
                if (r2[t3][e4.name])
                  if (Array.isArray(r2[t3][e4.name]))
                    r2[t3][e4.name].push(e4.value);
                  else {
                    const n2 = r2[t3][e4.name];
                    r2[t3][e4.name] = [n2], r2[t3][e4.name].push(e4.value);
                  }
                else
                  r2[t3][e4.name] = e4.value;
              }
            }
            return r2;
          }
          _newPacket() {
            return a("_newPacket"), this.packet && (this._list.consume(this.packet.length), a("_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d", this.packet.cmd, this.packet.payload, this.packet.length), this.emit("packet", this.packet)), a("_newPacket: new packet"), this.packet = new o(), this._pos = 0, true;
          }
          _emitError(e2) {
            a("_emitError"), this.error = e2, this.emit("error", e2);
          }
        }
        t.exports = l;
      }, { "./constants": 38, "./packet": 42, bl: 15, debug: 18, events: 22 }], 44: [function(e, t, r) {
        (function(r2) {
          (function() {
            const n = e("./constants"), i = r2.allocUnsafe(0), o = r2.from([0]), s = e("./numbers"), a = e("process-nextick-args").nextTick, l = e("debug")("mqtt-packet:writeToStream"), u = s.cache, c = s.generateNumber, h = s.generateCache, f = s.genBufVariableByteInt, p = s.generate4ByteBuffer;
            let d = k, g = true;
            function y(e2, t2, s2) {
              switch (l("generate called"), t2.cork && (t2.cork(), a(b, t2)), g && (g = false, h()), l("generate: packet.cmd: %s", e2.cmd), e2.cmd) {
                case "connect":
                  return function(e3, t3, i2) {
                    const o2 = e3 || {}, s3 = o2.protocolId || "MQTT";
                    let a2 = o2.protocolVersion || 4;
                    const l2 = o2.will;
                    let u2 = o2.clean;
                    const c2 = o2.keepalive || 0, h2 = o2.clientId || "", f2 = o2.username, p2 = o2.password, g2 = o2.properties;
                    void 0 === u2 && (u2 = true);
                    let y2 = 0;
                    if (!s3 || "string" != typeof s3 && !r2.isBuffer(s3))
                      return t3.emit("error", new Error("Invalid protocolId")), false;
                    y2 += s3.length + 2;
                    if (3 !== a2 && 4 !== a2 && 5 !== a2)
                      return t3.emit("error", new Error("Invalid protocol version")), false;
                    y2 += 1;
                    if (("string" == typeof h2 || r2.isBuffer(h2)) && (h2 || a2 >= 4) && (h2 || u2))
                      y2 += r2.byteLength(h2) + 2;
                    else {
                      if (a2 < 4)
                        return t3.emit("error", new Error("clientId must be supplied before 3.1.1")), false;
                      if (1 * u2 == 0)
                        return t3.emit("error", new Error("clientId must be given if cleanSession set to 0")), false;
                    }
                    if ("number" != typeof c2 || c2 < 0 || c2 > 65535 || c2 % 1 != 0)
                      return t3.emit("error", new Error("Invalid keepalive")), false;
                    y2 += 2;
                    if (y2 += 1, 5 === a2) {
                      var b2 = C(t3, g2);
                      if (!b2)
                        return false;
                      y2 += b2.length;
                    }
                    if (l2) {
                      if ("object" != typeof l2)
                        return t3.emit("error", new Error("Invalid will")), false;
                      if (!l2.topic || "string" != typeof l2.topic)
                        return t3.emit("error", new Error("Invalid will topic")), false;
                      if (y2 += r2.byteLength(l2.topic) + 2, y2 += 2, l2.payload) {
                        if (!(l2.payload.length >= 0))
                          return t3.emit("error", new Error("Invalid will payload")), false;
                        "string" == typeof l2.payload ? y2 += r2.byteLength(l2.payload) : y2 += l2.payload.length;
                      }
                      var m2 = {};
                      if (5 === a2) {
                        if (!(m2 = C(t3, l2.properties)))
                          return false;
                        y2 += m2.length;
                      }
                    }
                    let _2 = false;
                    if (null != f2) {
                      if (!P(f2))
                        return t3.emit("error", new Error("Invalid username")), false;
                      _2 = true, y2 += r2.byteLength(f2) + 2;
                    }
                    if (null != p2) {
                      if (!_2)
                        return t3.emit("error", new Error("Username is required to use password")), false;
                      if (!P(p2))
                        return t3.emit("error", new Error("Invalid password")), false;
                      y2 += I(p2) + 2;
                    }
                    t3.write(n.CONNECT_HEADER), v(t3, y2), E(t3, s3), o2.bridgeMode && (a2 += 128);
                    t3.write(131 === a2 ? n.VERSION131 : 132 === a2 ? n.VERSION132 : 4 === a2 ? n.VERSION4 : 5 === a2 ? n.VERSION5 : n.VERSION3);
                    let k2 = 0;
                    k2 |= null != f2 ? n.USERNAME_MASK : 0, k2 |= null != p2 ? n.PASSWORD_MASK : 0, k2 |= l2 && l2.retain ? n.WILL_RETAIN_MASK : 0, k2 |= l2 && l2.qos ? l2.qos << n.WILL_QOS_SHIFT : 0, k2 |= l2 ? n.WILL_FLAG_MASK : 0, k2 |= u2 ? n.CLEAN_SESSION_MASK : 0, t3.write(r2.from([k2])), d(t3, c2), 5 === a2 && b2.write();
                    E(t3, h2), l2 && (5 === a2 && m2.write(), w(t3, l2.topic), E(t3, l2.payload));
                    null != f2 && E(t3, f2);
                    null != p2 && E(t3, p2);
                    return true;
                  }(e2, t2);
                case "connack":
                  return function(e3, t3, i2) {
                    const s3 = i2 ? i2.protocolVersion : 4, a2 = e3 || {}, l2 = 5 === s3 ? a2.reasonCode : a2.returnCode, u2 = a2.properties;
                    let c2 = 2;
                    if ("number" != typeof l2)
                      return t3.emit("error", new Error("Invalid return code")), false;
                    let h2 = null;
                    if (5 === s3) {
                      if (!(h2 = C(t3, u2)))
                        return false;
                      c2 += h2.length;
                    }
                    t3.write(n.CONNACK_HEADER), v(t3, c2), t3.write(a2.sessionPresent ? n.SESSIONPRESENT_HEADER : o), t3.write(r2.from([l2])), null != h2 && h2.write();
                    return true;
                  }(e2, t2, s2);
                case "publish":
                  return function(e3, t3, o2) {
                    l("publish: packet: %o", e3);
                    const s3 = o2 ? o2.protocolVersion : 4, a2 = e3 || {}, u2 = a2.qos || 0, c2 = a2.retain ? n.RETAIN_MASK : 0, h2 = a2.topic, f2 = a2.payload || i, p2 = a2.messageId, g2 = a2.properties;
                    let y2 = 0;
                    if ("string" == typeof h2)
                      y2 += r2.byteLength(h2) + 2;
                    else {
                      if (!r2.isBuffer(h2))
                        return t3.emit("error", new Error("Invalid topic")), false;
                      y2 += h2.length + 2;
                    }
                    r2.isBuffer(f2) ? y2 += f2.length : y2 += r2.byteLength(f2);
                    if (u2 && "number" != typeof p2)
                      return t3.emit("error", new Error("Invalid messageId")), false;
                    u2 && (y2 += 2);
                    let b2 = null;
                    if (5 === s3) {
                      if (!(b2 = C(t3, g2)))
                        return false;
                      y2 += b2.length;
                    }
                    t3.write(n.PUBLISH_HEADER[u2][a2.dup ? 1 : 0][c2 ? 1 : 0]), v(t3, y2), d(t3, I(h2)), t3.write(h2), u2 > 0 && d(t3, p2);
                    null != b2 && b2.write();
                    return l("publish: payload: %o", f2), t3.write(f2);
                  }(e2, t2, s2);
                case "puback":
                case "pubrec":
                case "pubrel":
                case "pubcomp":
                  return function(e3, t3, i2) {
                    const o2 = i2 ? i2.protocolVersion : 4, s3 = e3 || {}, a2 = s3.cmd || "puback", l2 = s3.messageId, u2 = s3.dup && "pubrel" === a2 ? n.DUP_MASK : 0;
                    let c2 = 0;
                    const h2 = s3.reasonCode, f2 = s3.properties;
                    let p2 = 5 === o2 ? 3 : 2;
                    "pubrel" === a2 && (c2 = 1);
                    if ("number" != typeof l2)
                      return t3.emit("error", new Error("Invalid messageId")), false;
                    let g2 = null;
                    if (5 === o2 && "object" == typeof f2) {
                      if (!(g2 = T(t3, f2, i2, p2)))
                        return false;
                      p2 += g2.length;
                    }
                    t3.write(n.ACKS[a2][c2][u2][0]), v(t3, p2), d(t3, l2), 5 === o2 && t3.write(r2.from([h2]));
                    null !== g2 && g2.write();
                    return true;
                  }(e2, t2, s2);
                case "subscribe":
                  return function(e3, t3, i2) {
                    l("subscribe: packet: ");
                    const o2 = i2 ? i2.protocolVersion : 4, s3 = e3 || {}, a2 = s3.dup ? n.DUP_MASK : 0, u2 = s3.messageId, c2 = s3.subscriptions, h2 = s3.properties;
                    let f2 = 0;
                    if ("number" != typeof u2)
                      return t3.emit("error", new Error("Invalid messageId")), false;
                    f2 += 2;
                    let p2 = null;
                    if (5 === o2) {
                      if (!(p2 = C(t3, h2)))
                        return false;
                      f2 += p2.length;
                    }
                    if ("object" != typeof c2 || !c2.length)
                      return t3.emit("error", new Error("Invalid subscriptions")), false;
                    for (let e4 = 0; e4 < c2.length; e4 += 1) {
                      const n2 = c2[e4].topic, i3 = c2[e4].qos;
                      if ("string" != typeof n2)
                        return t3.emit("error", new Error("Invalid subscriptions - invalid topic")), false;
                      if ("number" != typeof i3)
                        return t3.emit("error", new Error("Invalid subscriptions - invalid qos")), false;
                      if (5 === o2) {
                        const r3 = c2[e4].nl || false;
                        if ("boolean" != typeof r3)
                          return t3.emit("error", new Error("Invalid subscriptions - invalid No Local")), false;
                        const n3 = c2[e4].rap || false;
                        if ("boolean" != typeof n3)
                          return t3.emit("error", new Error("Invalid subscriptions - invalid Retain as Published")), false;
                        const i4 = c2[e4].rh || 0;
                        if ("number" != typeof i4 || i4 > 2)
                          return t3.emit("error", new Error("Invalid subscriptions - invalid Retain Handling")), false;
                      }
                      f2 += r2.byteLength(n2) + 2 + 1;
                    }
                    l("subscribe: writing to stream: %o", n.SUBSCRIBE_HEADER), t3.write(n.SUBSCRIBE_HEADER[1][a2 ? 1 : 0][0]), v(t3, f2), d(t3, u2), null !== p2 && p2.write();
                    let g2 = true;
                    for (const e4 of c2) {
                      const i3 = e4.topic, s5 = e4.qos, a3 = +e4.nl, l2 = +e4.rap, u3 = e4.rh;
                      let c3;
                      w(t3, i3), c3 = n.SUBSCRIBE_OPTIONS_QOS[s5], 5 === o2 && (c3 |= a3 ? n.SUBSCRIBE_OPTIONS_NL : 0, c3 |= l2 ? n.SUBSCRIBE_OPTIONS_RAP : 0, c3 |= u3 ? n.SUBSCRIBE_OPTIONS_RH[u3] : 0), g2 = t3.write(r2.from([c3]));
                    }
                    return g2;
                  }(e2, t2, s2);
                case "suback":
                  return function(e3, t3, i2) {
                    const o2 = i2 ? i2.protocolVersion : 4, s3 = e3 || {}, a2 = s3.messageId, l2 = s3.granted, u2 = s3.properties;
                    let c2 = 0;
                    if ("number" != typeof a2)
                      return t3.emit("error", new Error("Invalid messageId")), false;
                    c2 += 2;
                    if ("object" != typeof l2 || !l2.length)
                      return t3.emit("error", new Error("Invalid qos vector")), false;
                    for (let e4 = 0; e4 < l2.length; e4 += 1) {
                      if ("number" != typeof l2[e4])
                        return t3.emit("error", new Error("Invalid qos vector")), false;
                      c2 += 1;
                    }
                    let h2 = null;
                    if (5 === o2) {
                      if (!(h2 = T(t3, u2, i2, c2)))
                        return false;
                      c2 += h2.length;
                    }
                    t3.write(n.SUBACK_HEADER), v(t3, c2), d(t3, a2), null !== h2 && h2.write();
                    return t3.write(r2.from(l2));
                  }(e2, t2, s2);
                case "unsubscribe":
                  return function(e3, t3, i2) {
                    const o2 = i2 ? i2.protocolVersion : 4, s3 = e3 || {}, a2 = s3.messageId, l2 = s3.dup ? n.DUP_MASK : 0, u2 = s3.unsubscriptions, c2 = s3.properties;
                    let h2 = 0;
                    if ("number" != typeof a2)
                      return t3.emit("error", new Error("Invalid messageId")), false;
                    h2 += 2;
                    if ("object" != typeof u2 || !u2.length)
                      return t3.emit("error", new Error("Invalid unsubscriptions")), false;
                    for (let e4 = 0; e4 < u2.length; e4 += 1) {
                      if ("string" != typeof u2[e4])
                        return t3.emit("error", new Error("Invalid unsubscriptions")), false;
                      h2 += r2.byteLength(u2[e4]) + 2;
                    }
                    let f2 = null;
                    if (5 === o2) {
                      if (!(f2 = C(t3, c2)))
                        return false;
                      h2 += f2.length;
                    }
                    t3.write(n.UNSUBSCRIBE_HEADER[1][l2 ? 1 : 0][0]), v(t3, h2), d(t3, a2), null !== f2 && f2.write();
                    let p2 = true;
                    for (let e4 = 0; e4 < u2.length; e4++)
                      p2 = w(t3, u2[e4]);
                    return p2;
                  }(e2, t2, s2);
                case "unsuback":
                  return function(e3, t3, i2) {
                    const o2 = i2 ? i2.protocolVersion : 4, s3 = e3 || {}, a2 = s3.messageId, l2 = s3.dup ? n.DUP_MASK : 0, u2 = s3.granted, c2 = s3.properties, h2 = s3.cmd;
                    let f2 = 2;
                    if ("number" != typeof a2)
                      return t3.emit("error", new Error("Invalid messageId")), false;
                    if (5 === o2) {
                      if ("object" != typeof u2 || !u2.length)
                        return t3.emit("error", new Error("Invalid qos vector")), false;
                      for (let e4 = 0; e4 < u2.length; e4 += 1) {
                        if ("number" != typeof u2[e4])
                          return t3.emit("error", new Error("Invalid qos vector")), false;
                        f2 += 1;
                      }
                    }
                    let p2 = null;
                    if (5 === o2) {
                      if (!(p2 = T(t3, c2, i2, f2)))
                        return false;
                      f2 += p2.length;
                    }
                    t3.write(n.ACKS[h2][0][l2][0]), v(t3, f2), d(t3, a2), null !== p2 && p2.write();
                    5 === o2 && t3.write(r2.from(u2));
                    return true;
                  }(e2, t2, s2);
                case "pingreq":
                case "pingresp":
                  return function(e3, t3, r3) {
                    return t3.write(n.EMPTY[e3.cmd]);
                  }(e2, t2);
                case "disconnect":
                  return function(e3, t3, i2) {
                    const o2 = i2 ? i2.protocolVersion : 4, s3 = e3 || {}, a2 = s3.reasonCode, l2 = s3.properties;
                    let u2 = 5 === o2 ? 1 : 0, c2 = null;
                    if (5 === o2) {
                      if (!(c2 = T(t3, l2, i2, u2)))
                        return false;
                      u2 += c2.length;
                    }
                    t3.write(r2.from([n.codes.disconnect << 4])), v(t3, u2), 5 === o2 && t3.write(r2.from([a2]));
                    null !== c2 && c2.write();
                    return true;
                  }(e2, t2, s2);
                case "auth":
                  return function(e3, t3, i2) {
                    const o2 = i2 ? i2.protocolVersion : 4, s3 = e3 || {}, a2 = s3.reasonCode, l2 = s3.properties;
                    let u2 = 5 === o2 ? 1 : 0;
                    5 !== o2 && t3.emit("error", new Error("Invalid mqtt version for auth packet"));
                    const c2 = T(t3, l2, i2, u2);
                    if (!c2)
                      return false;
                    u2 += c2.length, t3.write(r2.from([n.codes.auth << 4])), v(t3, u2), t3.write(r2.from([a2])), null !== c2 && c2.write();
                    return true;
                  }(e2, t2, s2);
                default:
                  return t2.emit("error", new Error("Unknown command")), false;
              }
            }
            function b(e2) {
              e2.uncork();
            }
            Object.defineProperty(y, "cacheNumbers", { get: () => d === k, set(e2) {
              e2 ? (u && 0 !== Object.keys(u).length || (g = true), d = k) : (g = false, d = S);
            } });
            const m = {};
            function v(e2, t2) {
              if (t2 > n.VARBYTEINT_MAX)
                return e2.emit("error", new Error(`Invalid variable byte integer: ${t2}`)), false;
              let r3 = m[t2];
              return r3 || (r3 = f(t2), t2 < 16384 && (m[t2] = r3)), l("writeVarByteInt: writing to stream: %o", r3), e2.write(r3);
            }
            function w(e2, t2) {
              const n2 = r2.byteLength(t2);
              return d(e2, n2), l("writeString: %s", t2), e2.write(t2, "utf8");
            }
            function _(e2, t2, r3) {
              w(e2, t2), w(e2, r3);
            }
            function k(e2, t2) {
              return l("writeNumberCached: number: %d", t2), l("writeNumberCached: %o", u[t2]), e2.write(u[t2]);
            }
            function S(e2, t2) {
              const r3 = c(t2);
              return l("writeNumberGenerated: %o", r3), e2.write(r3);
            }
            function E(e2, t2) {
              "string" == typeof t2 ? w(e2, t2) : t2 ? (d(e2, t2.length), e2.write(t2)) : d(e2, 0);
            }
            function C(e2, t2) {
              if ("object" != typeof t2 || null != t2.length)
                return { length: 1, write() {
                  A(e2, {}, 0);
                } };
              let i2 = 0;
              function o2(t3, i3) {
                let o3 = 0;
                switch (n.propertiesTypes[t3]) {
                  case "byte":
                    if ("boolean" != typeof i3)
                      return e2.emit("error", new Error(`Invalid ${t3}: ${i3}`)), false;
                    o3 += 2;
                    break;
                  case "int8":
                    if ("number" != typeof i3 || i3 < 0 || i3 > 255)
                      return e2.emit("error", new Error(`Invalid ${t3}: ${i3}`)), false;
                    o3 += 2;
                    break;
                  case "binary":
                    if (i3 && null === i3)
                      return e2.emit("error", new Error(`Invalid ${t3}: ${i3}`)), false;
                    o3 += 1 + r2.byteLength(i3) + 2;
                    break;
                  case "int16":
                    if ("number" != typeof i3 || i3 < 0 || i3 > 65535)
                      return e2.emit("error", new Error(`Invalid ${t3}: ${i3}`)), false;
                    o3 += 3;
                    break;
                  case "int32":
                    if ("number" != typeof i3 || i3 < 0 || i3 > 4294967295)
                      return e2.emit("error", new Error(`Invalid ${t3}: ${i3}`)), false;
                    o3 += 5;
                    break;
                  case "var":
                    if ("number" != typeof i3 || i3 < 0 || i3 > 268435455)
                      return e2.emit("error", new Error(`Invalid ${t3}: ${i3}`)), false;
                    o3 += 1 + r2.byteLength(f(i3));
                    break;
                  case "string":
                    if ("string" != typeof i3)
                      return e2.emit("error", new Error(`Invalid ${t3}: ${i3}`)), false;
                    o3 += 3 + r2.byteLength(i3.toString());
                    break;
                  case "pair":
                    if ("object" != typeof i3)
                      return e2.emit("error", new Error(`Invalid ${t3}: ${i3}`)), false;
                    o3 += Object.getOwnPropertyNames(i3).reduce((e3, t4) => {
                      const n2 = i3[t4];
                      return Array.isArray(n2) ? e3 += n2.reduce((e4, n3) => e4 += 3 + r2.byteLength(t4.toString()) + 2 + r2.byteLength(n3.toString()), 0) : e3 += 3 + r2.byteLength(t4.toString()) + 2 + r2.byteLength(i3[t4].toString()), e3;
                    }, 0);
                    break;
                  default:
                    return e2.emit("error", new Error(`Invalid property ${t3}: ${i3}`)), false;
                }
                return o3;
              }
              if (t2)
                for (const e3 in t2) {
                  let r3 = 0, n2 = 0;
                  const s2 = t2[e3];
                  if (Array.isArray(s2))
                    for (let t3 = 0; t3 < s2.length; t3++) {
                      if (!(n2 = o2(e3, s2[t3])))
                        return false;
                      r3 += n2;
                    }
                  else {
                    if (!(n2 = o2(e3, s2)))
                      return false;
                    r3 = n2;
                  }
                  if (!r3)
                    return false;
                  i2 += r3;
                }
              return { length: r2.byteLength(f(i2)) + i2, write() {
                A(e2, t2, i2);
              } };
            }
            function T(e2, t2, r3, n2) {
              const i2 = ["reasonString", "userProperties"], o2 = r3 && r3.properties && r3.properties.maximumPacketSize ? r3.properties.maximumPacketSize : 0;
              let s2 = C(e2, t2);
              if (o2)
                for (; n2 + s2.length > o2; ) {
                  const r4 = i2.shift();
                  if (!r4 || !t2[r4])
                    return false;
                  delete t2[r4], s2 = C(e2, t2);
                }
              return s2;
            }
            function x(e2, t2, i2) {
              switch (n.propertiesTypes[t2]) {
                case "byte":
                  e2.write(r2.from([n.properties[t2]])), e2.write(r2.from([+i2]));
                  break;
                case "int8":
                  e2.write(r2.from([n.properties[t2]])), e2.write(r2.from([i2]));
                  break;
                case "binary":
                  e2.write(r2.from([n.properties[t2]])), E(e2, i2);
                  break;
                case "int16":
                  e2.write(r2.from([n.properties[t2]])), d(e2, i2);
                  break;
                case "int32":
                  e2.write(r2.from([n.properties[t2]])), function(e3, t3) {
                    const r3 = p(t3);
                    l("write4ByteNumber: %o", r3), e3.write(r3);
                  }(e2, i2);
                  break;
                case "var":
                  e2.write(r2.from([n.properties[t2]])), v(e2, i2);
                  break;
                case "string":
                  e2.write(r2.from([n.properties[t2]])), w(e2, i2);
                  break;
                case "pair":
                  Object.getOwnPropertyNames(i2).forEach((o2) => {
                    const s2 = i2[o2];
                    Array.isArray(s2) ? s2.forEach((i3) => {
                      e2.write(r2.from([n.properties[t2]])), _(e2, o2.toString(), i3.toString());
                    }) : (e2.write(r2.from([n.properties[t2]])), _(e2, o2.toString(), s2.toString()));
                  });
                  break;
                default:
                  return e2.emit("error", new Error(`Invalid property ${t2} value: ${i2}`)), false;
              }
            }
            function A(e2, t2, r3) {
              v(e2, r3);
              for (const r4 in t2)
                if (Object.prototype.hasOwnProperty.call(t2, r4) && null !== t2[r4]) {
                  const n2 = t2[r4];
                  if (Array.isArray(n2))
                    for (let t3 = 0; t3 < n2.length; t3++)
                      x(e2, r4, n2[t3]);
                  else
                    x(e2, r4, n2);
                }
            }
            function I(e2) {
              return e2 ? e2 instanceof r2 ? e2.length : r2.byteLength(e2) : 0;
            }
            function P(e2) {
              return "string" == typeof e2 || e2 instanceof r2;
            }
            t.exports = y;
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { "./constants": 38, "./numbers": 41, buffer: 17, debug: 18, "process-nextick-args": 49 }], 45: [function(e, t, r) {
        var n = 1e3, i = 60 * n, o = 60 * i, s = 24 * o, a = 7 * s, l = 365.25 * s;
        function u(e2, t2, r2, n2) {
          var i2 = t2 >= 1.5 * r2;
          return Math.round(e2 / r2) + " " + n2 + (i2 ? "s" : "");
        }
        t.exports = function(e2, t2) {
          t2 = t2 || {};
          var r2 = typeof e2;
          if ("string" === r2 && e2.length > 0)
            return function(e3) {
              if ((e3 = String(e3)).length > 100)
                return;
              var t3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e3);
              if (!t3)
                return;
              var r3 = parseFloat(t3[1]);
              switch ((t3[2] || "ms").toLowerCase()) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                  return r3 * l;
                case "weeks":
                case "week":
                case "w":
                  return r3 * a;
                case "days":
                case "day":
                case "d":
                  return r3 * s;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                  return r3 * o;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                  return r3 * i;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                  return r3 * n;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                  return r3;
                default:
                  return;
              }
            }(e2);
          if ("number" === r2 && isFinite(e2))
            return t2.long ? function(e3) {
              var t3 = Math.abs(e3);
              if (t3 >= s)
                return u(e3, t3, s, "day");
              if (t3 >= o)
                return u(e3, t3, o, "hour");
              if (t3 >= i)
                return u(e3, t3, i, "minute");
              if (t3 >= n)
                return u(e3, t3, n, "second");
              return e3 + " ms";
            }(e2) : function(e3) {
              var t3 = Math.abs(e3);
              if (t3 >= s)
                return Math.round(e3 / s) + "d";
              if (t3 >= o)
                return Math.round(e3 / o) + "h";
              if (t3 >= i)
                return Math.round(e3 / i) + "m";
              if (t3 >= n)
                return Math.round(e3 / n) + "s";
              return e3 + "ms";
            }(e2);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e2));
        };
      }, {}], 46: [function(e, t, r) {
        const n = e("./lib/number-allocator.js");
        t.exports.NumberAllocator = n;
      }, { "./lib/number-allocator.js": 47 }], 47: [function(e, t, r) {
        "use strict";
        const n = e("js-sdsl").Set, i = e("debug")("number-allocator:trace"), o = e("debug")("number-allocator:error");
        function s(e2, t2) {
          this.low = e2, this.high = t2;
        }
        function a(e2, t2) {
          if (!(this instanceof a))
            return new a(e2, t2);
          this.min = e2, this.max = t2, this.ss = new n([], (e3, t3) => e3.compare(t3)), i("Create"), this.clear();
        }
        s.prototype.equals = function(e2) {
          return this.low === e2.low && this.high === e2.high;
        }, s.prototype.compare = function(e2) {
          return this.low < e2.low && this.high < e2.low ? -1 : e2.low < this.low && e2.high < this.low ? 1 : 0;
        }, a.prototype.firstVacant = function() {
          return 0 === this.ss.size() ? null : this.ss.front().low;
        }, a.prototype.alloc = function() {
          if (0 === this.ss.size())
            return i("alloc():empty"), null;
          const e2 = this.ss.front(), t2 = e2.low;
          return t2 + 1 <= e2.high ? ++e2.low : this.ss.eraseElementByPos(0), i("alloc():" + t2), t2;
        }, a.prototype.use = function(e2) {
          const t2 = new s(e2, e2), r2 = this.ss.lowerBound(t2);
          if (r2) {
            if (r2.equals(t2))
              return this.ss.eraseElementByValue(r2), i("use():" + e2), true;
            if (r2.low > e2)
              return false;
            if (r2.low === e2)
              return ++r2.low, i("use():" + e2), true;
            if (r2.high === e2)
              return --r2.high, i("use():" + e2), true;
            const n2 = r2.low;
            return r2.low = e2 + 1, this.ss.insert(new s(n2, e2 - 1)), i("use():" + e2), true;
          }
          return i("use():failed"), false;
        }, a.prototype.free = function(e2) {
          if (e2 < this.min || e2 > this.max)
            return void o("free():" + e2 + " is out of range");
          const t2 = new s(e2, e2), r2 = this.ss.lowerBound(t2);
          if (r2) {
            if (r2.low <= e2 && e2 <= r2.high)
              return void o("free():" + e2 + " has already been vacant");
            if (r2 === this.ss.front())
              e2 + 1 === r2.low ? --r2.low : this.ss.insert(t2);
            else {
              const n2 = this.ss.reverseLowerBound(t2);
              n2.high + 1 === e2 ? e2 + 1 === r2.low ? (this.ss.eraseElementByValue(n2), r2.low = n2.low) : n2.high = e2 : e2 + 1 === r2.low ? r2.low = e2 : this.ss.insert(t2);
            }
          } else {
            if (r2 === this.ss.front())
              return void this.ss.insert(t2);
            const n2 = this.ss.reverseLowerBound(t2);
            n2.high + 1 === e2 ? n2.high = e2 : this.ss.insert(t2);
          }
          i("free():" + e2);
        }, a.prototype.clear = function() {
          i("clear()"), this.ss.clear(), this.ss.insert(new s(this.min, this.max));
        }, a.prototype.intervalCount = function() {
          return this.ss.size();
        }, a.prototype.dump = function() {
          console.log("length:" + this.ss.size());
          for (const e2 of this.ss)
            console.log(e2);
        }, t.exports = a;
      }, { debug: 18, "js-sdsl": 36 }], 48: [function(e, t, r) {
        var n = e("wrappy");
        function i(e2) {
          var t2 = function() {
            return t2.called ? t2.value : (t2.called = true, t2.value = e2.apply(this, arguments));
          };
          return t2.called = false, t2;
        }
        function o(e2) {
          var t2 = function() {
            if (t2.called)
              throw new Error(t2.onceError);
            return t2.called = true, t2.value = e2.apply(this, arguments);
          }, r2 = e2.name || "Function wrapped with `once`";
          return t2.onceError = r2 + " shouldn't be called more than once", t2.called = false, t2;
        }
        t.exports = n(i), t.exports.strict = n(o), i.proto = i(function() {
          Object.defineProperty(Function.prototype, "once", { value: function() {
            return i(this);
          }, configurable: true }), Object.defineProperty(Function.prototype, "onceStrict", { value: function() {
            return o(this);
          }, configurable: true });
        });
      }, { wrappy: 79 }], 49: [function(e, t, r) {
        (function(e2) {
          (function() {
            "use strict";
            void 0 === e2 || !e2.version || 0 === e2.version.indexOf("v0.") || 0 === e2.version.indexOf("v1.") && 0 !== e2.version.indexOf("v1.8.") ? t.exports = { nextTick: function(t2, r2, n, i) {
              if ("function" != typeof t2)
                throw new TypeError('"callback" argument must be a function');
              var o, s, a = arguments.length;
              switch (a) {
                case 0:
                case 1:
                  return e2.nextTick(t2);
                case 2:
                  return e2.nextTick(function() {
                    t2.call(null, r2);
                  });
                case 3:
                  return e2.nextTick(function() {
                    t2.call(null, r2, n);
                  });
                case 4:
                  return e2.nextTick(function() {
                    t2.call(null, r2, n, i);
                  });
                default:
                  for (o = new Array(a - 1), s = 0; s < o.length; )
                    o[s++] = arguments[s];
                  return e2.nextTick(function() {
                    t2.apply(null, o);
                  });
              }
            } } : t.exports = e2;
          }).call(this);
        }).call(this, e("_process"));
      }, { _process: 50 }], 50: [function(e, t, r) {
        var n, i, o = t.exports = {};
        function s() {
          throw new Error("setTimeout has not been defined");
        }
        function a() {
          throw new Error("clearTimeout has not been defined");
        }
        function l(e2) {
          if (n === setTimeout)
            return setTimeout(e2, 0);
          if ((n === s || !n) && setTimeout)
            return n = setTimeout, setTimeout(e2, 0);
          try {
            return n(e2, 0);
          } catch (t2) {
            try {
              return n.call(null, e2, 0);
            } catch (t3) {
              return n.call(this, e2, 0);
            }
          }
        }
        !function() {
          try {
            n = "function" == typeof setTimeout ? setTimeout : s;
          } catch (e2) {
            n = s;
          }
          try {
            i = "function" == typeof clearTimeout ? clearTimeout : a;
          } catch (e2) {
            i = a;
          }
        }();
        var u, c = [], h = false, f = -1;
        function p() {
          h && u && (h = false, u.length ? c = u.concat(c) : f = -1, c.length && d());
        }
        function d() {
          if (!h) {
            var e2 = l(p);
            h = true;
            for (var t2 = c.length; t2; ) {
              for (u = c, c = []; ++f < t2; )
                u && u[f].run();
              f = -1, t2 = c.length;
            }
            u = null, h = false, function(e3) {
              if (i === clearTimeout)
                return clearTimeout(e3);
              if ((i === a || !i) && clearTimeout)
                return i = clearTimeout, clearTimeout(e3);
              try {
                i(e3);
              } catch (t3) {
                try {
                  return i.call(null, e3);
                } catch (t4) {
                  return i.call(this, e3);
                }
              }
            }(e2);
          }
        }
        function g(e2, t2) {
          this.fun = e2, this.array = t2;
        }
        function y() {
        }
        o.nextTick = function(e2) {
          var t2 = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var r2 = 1; r2 < arguments.length; r2++)
              t2[r2 - 1] = arguments[r2];
          c.push(new g(e2, t2)), 1 !== c.length || h || l(d);
        }, g.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, o.title = "browser", o.browser = true, o.env = {}, o.argv = [], o.version = "", o.versions = {}, o.on = y, o.addListener = y, o.once = y, o.off = y, o.removeListener = y, o.removeAllListeners = y, o.emit = y, o.prependListener = y, o.prependOnceListener = y, o.listeners = function(e2) {
          return [];
        }, o.binding = function(e2) {
          throw new Error("process.binding is not supported");
        }, o.cwd = function() {
          return "/";
        }, o.chdir = function(e2) {
          throw new Error("process.chdir is not supported");
        }, o.umask = function() {
          return 0;
        };
      }, {}], 51: [function(e, t, r) {
        (function(e2) {
          (function() {
            !function(n) {
              var i = "object" == typeof r && r && !r.nodeType && r, o = "object" == typeof t && t && !t.nodeType && t, s = "object" == typeof e2 && e2;
              s.global !== s && s.window !== s && s.self !== s || (n = s);
              var a, l, u = 2147483647, c = 36, h = 1, f = 26, p = 38, d = 700, g = 72, y = 128, b = "-", m = /^xn--/, v = /[^\x20-\x7E]/, w = /[\x2E\u3002\uFF0E\uFF61]/g, _ = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, k = c - h, S = Math.floor, E = String.fromCharCode;
              function C(e3) {
                throw new RangeError(_[e3]);
              }
              function T(e3, t2) {
                for (var r2 = e3.length, n2 = []; r2--; )
                  n2[r2] = t2(e3[r2]);
                return n2;
              }
              function x(e3, t2) {
                var r2 = e3.split("@"), n2 = "";
                return r2.length > 1 && (n2 = r2[0] + "@", e3 = r2[1]), n2 + T((e3 = e3.replace(w, ".")).split("."), t2).join(".");
              }
              function A(e3) {
                for (var t2, r2, n2 = [], i2 = 0, o2 = e3.length; i2 < o2; )
                  (t2 = e3.charCodeAt(i2++)) >= 55296 && t2 <= 56319 && i2 < o2 ? 56320 == (64512 & (r2 = e3.charCodeAt(i2++))) ? n2.push(((1023 & t2) << 10) + (1023 & r2) + 65536) : (n2.push(t2), i2--) : n2.push(t2);
                return n2;
              }
              function I(e3) {
                return T(e3, function(e4) {
                  var t2 = "";
                  return e4 > 65535 && (t2 += E((e4 -= 65536) >>> 10 & 1023 | 55296), e4 = 56320 | 1023 & e4), t2 += E(e4);
                }).join("");
              }
              function P(e3, t2) {
                return e3 + 22 + 75 * (e3 < 26) - ((0 != t2) << 5);
              }
              function O(e3, t2, r2) {
                var n2 = 0;
                for (e3 = r2 ? S(e3 / d) : e3 >> 1, e3 += S(e3 / t2); e3 > k * f >> 1; n2 += c)
                  e3 = S(e3 / k);
                return S(n2 + (k + 1) * e3 / (e3 + p));
              }
              function B(e3) {
                var t2, r2, n2, i2, o2, s2, a2, l2, p2, d2, m2, v2 = [], w2 = e3.length, _2 = 0, k2 = y, E2 = g;
                for ((r2 = e3.lastIndexOf(b)) < 0 && (r2 = 0), n2 = 0; n2 < r2; ++n2)
                  e3.charCodeAt(n2) >= 128 && C("not-basic"), v2.push(e3.charCodeAt(n2));
                for (i2 = r2 > 0 ? r2 + 1 : 0; i2 < w2; ) {
                  for (o2 = _2, s2 = 1, a2 = c; i2 >= w2 && C("invalid-input"), ((l2 = (m2 = e3.charCodeAt(i2++)) - 48 < 10 ? m2 - 22 : m2 - 65 < 26 ? m2 - 65 : m2 - 97 < 26 ? m2 - 97 : c) >= c || l2 > S((u - _2) / s2)) && C("overflow"), _2 += l2 * s2, !(l2 < (p2 = a2 <= E2 ? h : a2 >= E2 + f ? f : a2 - E2)); a2 += c)
                    s2 > S(u / (d2 = c - p2)) && C("overflow"), s2 *= d2;
                  E2 = O(_2 - o2, t2 = v2.length + 1, 0 == o2), S(_2 / t2) > u - k2 && C("overflow"), k2 += S(_2 / t2), _2 %= t2, v2.splice(_2++, 0, k2);
                }
                return I(v2);
              }
              function R(e3) {
                var t2, r2, n2, i2, o2, s2, a2, l2, p2, d2, m2, v2, w2, _2, k2, T2 = [];
                for (v2 = (e3 = A(e3)).length, t2 = y, r2 = 0, o2 = g, s2 = 0; s2 < v2; ++s2)
                  (m2 = e3[s2]) < 128 && T2.push(E(m2));
                for (n2 = i2 = T2.length, i2 && T2.push(b); n2 < v2; ) {
                  for (a2 = u, s2 = 0; s2 < v2; ++s2)
                    (m2 = e3[s2]) >= t2 && m2 < a2 && (a2 = m2);
                  for (a2 - t2 > S((u - r2) / (w2 = n2 + 1)) && C("overflow"), r2 += (a2 - t2) * w2, t2 = a2, s2 = 0; s2 < v2; ++s2)
                    if ((m2 = e3[s2]) < t2 && ++r2 > u && C("overflow"), m2 == t2) {
                      for (l2 = r2, p2 = c; !(l2 < (d2 = p2 <= o2 ? h : p2 >= o2 + f ? f : p2 - o2)); p2 += c)
                        k2 = l2 - d2, _2 = c - d2, T2.push(E(P(d2 + k2 % _2, 0))), l2 = S(k2 / _2);
                      T2.push(E(P(l2, 0))), o2 = O(r2, w2, n2 == i2), r2 = 0, ++n2;
                    }
                  ++r2, ++t2;
                }
                return T2.join("");
              }
              if (a = { version: "1.4.1", ucs2: { decode: A, encode: I }, decode: B, encode: R, toASCII: function(e3) {
                return x(e3, function(e4) {
                  return v.test(e4) ? "xn--" + R(e4) : e4;
                });
              }, toUnicode: function(e3) {
                return x(e3, function(e4) {
                  return m.test(e4) ? B(e4.slice(4).toLowerCase()) : e4;
                });
              } }, i && o)
                if (t.exports == i)
                  o.exports = a;
                else
                  for (l in a)
                    a.hasOwnProperty(l) && (i[l] = a[l]);
              else
                n.punycode = a;
            }(this);
          }).call(this);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 52: [function(e, t, r) {
        "use strict";
        function n(e2, t2) {
          return Object.prototype.hasOwnProperty.call(e2, t2);
        }
        t.exports = function(e2, t2, r2, o) {
          t2 = t2 || "&", r2 = r2 || "=";
          var s = {};
          if ("string" != typeof e2 || 0 === e2.length)
            return s;
          var a = /\+/g;
          e2 = e2.split(t2);
          var l = 1e3;
          o && "number" == typeof o.maxKeys && (l = o.maxKeys);
          var u = e2.length;
          l > 0 && u > l && (u = l);
          for (var c = 0; c < u; ++c) {
            var h, f, p, d, g = e2[c].replace(a, "%20"), y = g.indexOf(r2);
            y >= 0 ? (h = g.substr(0, y), f = g.substr(y + 1)) : (h = g, f = ""), p = decodeURIComponent(h), d = decodeURIComponent(f), n(s, p) ? i(s[p]) ? s[p].push(d) : s[p] = [s[p], d] : s[p] = d;
          }
          return s;
        };
        var i = Array.isArray || function(e2) {
          return "[object Array]" === Object.prototype.toString.call(e2);
        };
      }, {}], 53: [function(e, t, r) {
        "use strict";
        var n = function(e2) {
          switch (typeof e2) {
            case "string":
              return e2;
            case "boolean":
              return e2 ? "true" : "false";
            case "number":
              return isFinite(e2) ? e2 : "";
            default:
              return "";
          }
        };
        t.exports = function(e2, t2, r2, a) {
          return t2 = t2 || "&", r2 = r2 || "=", null === e2 && (e2 = void 0), "object" == typeof e2 ? o(s(e2), function(s2) {
            var a2 = encodeURIComponent(n(s2)) + r2;
            return i(e2[s2]) ? o(e2[s2], function(e3) {
              return a2 + encodeURIComponent(n(e3));
            }).join(t2) : a2 + encodeURIComponent(n(e2[s2]));
          }).join(t2) : a ? encodeURIComponent(n(a)) + r2 + encodeURIComponent(n(e2)) : "";
        };
        var i = Array.isArray || function(e2) {
          return "[object Array]" === Object.prototype.toString.call(e2);
        };
        function o(e2, t2) {
          if (e2.map)
            return e2.map(t2);
          for (var r2 = [], n2 = 0; n2 < e2.length; n2++)
            r2.push(t2(e2[n2], n2));
          return r2;
        }
        var s = Object.keys || function(e2) {
          var t2 = [];
          for (var r2 in e2)
            Object.prototype.hasOwnProperty.call(e2, r2) && t2.push(r2);
          return t2;
        };
      }, {}], 54: [function(e, t, r) {
        "use strict";
        r.decode = r.parse = e("./decode"), r.encode = r.stringify = e("./encode");
      }, { "./decode": 52, "./encode": 53 }], 55: [function(e, t, r) {
        "use strict";
        var n = {};
        function i(e2, t2, r2) {
          r2 || (r2 = Error);
          var i2 = function(e3) {
            var r3, n2;
            function i3(r4, n3, i4) {
              return e3.call(this, function(e4, r5, n4) {
                return "string" == typeof t2 ? t2 : t2(e4, r5, n4);
              }(r4, n3, i4)) || this;
            }
            return n2 = e3, (r3 = i3).prototype = Object.create(n2.prototype), r3.prototype.constructor = r3, r3.__proto__ = n2, i3;
          }(r2);
          i2.prototype.name = r2.name, i2.prototype.code = e2, n[e2] = i2;
        }
        function o(e2, t2) {
          if (Array.isArray(e2)) {
            var r2 = e2.length;
            return e2 = e2.map(function(e3) {
              return String(e3);
            }), r2 > 2 ? "one of ".concat(t2, " ").concat(e2.slice(0, r2 - 1).join(", "), ", or ") + e2[r2 - 1] : 2 === r2 ? "one of ".concat(t2, " ").concat(e2[0], " or ").concat(e2[1]) : "of ".concat(t2, " ").concat(e2[0]);
          }
          return "of ".concat(t2, " ").concat(String(e2));
        }
        i("ERR_INVALID_OPT_VALUE", function(e2, t2) {
          return 'The value "' + t2 + '" is invalid for option "' + e2 + '"';
        }, TypeError), i("ERR_INVALID_ARG_TYPE", function(e2, t2, r2) {
          var n2, i2, s, a;
          if ("string" == typeof t2 && (i2 = "not ", t2.substr(!s || s < 0 ? 0 : +s, i2.length) === i2) ? (n2 = "must not be", t2 = t2.replace(/^not /, "")) : n2 = "must be", function(e3, t3, r3) {
            return (void 0 === r3 || r3 > e3.length) && (r3 = e3.length), e3.substring(r3 - t3.length, r3) === t3;
          }(e2, " argument"))
            a = "The ".concat(e2, " ").concat(n2, " ").concat(o(t2, "type"));
          else {
            var l = function(e3, t3, r3) {
              return "number" != typeof r3 && (r3 = 0), !(r3 + t3.length > e3.length) && -1 !== e3.indexOf(t3, r3);
            }(e2, ".") ? "property" : "argument";
            a = 'The "'.concat(e2, '" ').concat(l, " ").concat(n2, " ").concat(o(t2, "type"));
          }
          return a += ". Received type ".concat(typeof r2);
        }, TypeError), i("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), i("ERR_METHOD_NOT_IMPLEMENTED", function(e2) {
          return "The " + e2 + " method is not implemented";
        }), i("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), i("ERR_STREAM_DESTROYED", function(e2) {
          return "Cannot call " + e2 + " after a stream was destroyed";
        }), i("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), i("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), i("ERR_STREAM_WRITE_AFTER_END", "write after end"), i("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), i("ERR_UNKNOWN_ENCODING", function(e2) {
          return "Unknown encoding: " + e2;
        }, TypeError), i("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t.exports.codes = n;
      }, {}], 56: [function(e, t, r) {
        (function(r2) {
          (function() {
            "use strict";
            var n = Object.keys || function(e2) {
              var t2 = [];
              for (var r3 in e2)
                t2.push(r3);
              return t2;
            };
            t.exports = u;
            var i = e("./_stream_readable"), o = e("./_stream_writable");
            e("inherits")(u, i);
            for (var s = n(o.prototype), a = 0; a < s.length; a++) {
              var l = s[a];
              u.prototype[l] || (u.prototype[l] = o.prototype[l]);
            }
            function u(e2) {
              if (!(this instanceof u))
                return new u(e2);
              i.call(this, e2), o.call(this, e2), this.allowHalfOpen = true, e2 && (false === e2.readable && (this.readable = false), false === e2.writable && (this.writable = false), false === e2.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", c)));
            }
            function c() {
              this._writableState.ended || r2.nextTick(h, this);
            }
            function h(e2) {
              e2.end();
            }
            Object.defineProperty(u.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
              return this._writableState.highWaterMark;
            } }), Object.defineProperty(u.prototype, "writableBuffer", { enumerable: false, get: function() {
              return this._writableState && this._writableState.getBuffer();
            } }), Object.defineProperty(u.prototype, "writableLength", { enumerable: false, get: function() {
              return this._writableState.length;
            } }), Object.defineProperty(u.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed);
            }, set: function(e2) {
              void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e2, this._writableState.destroyed = e2);
            } });
          }).call(this);
        }).call(this, e("_process"));
      }, { "./_stream_readable": 58, "./_stream_writable": 60, _process: 50, inherits: 24 }], 57: [function(e, t, r) {
        "use strict";
        t.exports = i;
        var n = e("./_stream_transform");
        function i(e2) {
          if (!(this instanceof i))
            return new i(e2);
          n.call(this, e2);
        }
        e("inherits")(i, n), i.prototype._transform = function(e2, t2, r2) {
          r2(null, e2);
        };
      }, { "./_stream_transform": 59, inherits: 24 }], 58: [function(e, t, r) {
        (function(r2, n) {
          (function() {
            "use strict";
            var i;
            t.exports = C, C.ReadableState = E;
            e("events").EventEmitter;
            var o = function(e2, t2) {
              return e2.listeners(t2).length;
            }, s = e("./internal/streams/stream"), a = e("buffer").Buffer, l = n.Uint8Array || function() {
            };
            var u, c = e("util");
            u = c && c.debuglog ? c.debuglog("stream") : function() {
            };
            var h, f, p, d = e("./internal/streams/buffer_list"), g = e("./internal/streams/destroy"), y = e("./internal/streams/state").getHighWaterMark, b = e("../errors").codes, m = b.ERR_INVALID_ARG_TYPE, v = b.ERR_STREAM_PUSH_AFTER_EOF, w = b.ERR_METHOD_NOT_IMPLEMENTED, _ = b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
            e("inherits")(C, s);
            var k = g.errorOrDestroy, S = ["error", "close", "destroy", "pause", "resume"];
            function E(t2, r3, n2) {
              i = i || e("./_stream_duplex"), t2 = t2 || {}, "boolean" != typeof n2 && (n2 = r3 instanceof i), this.objectMode = !!t2.objectMode, n2 && (this.objectMode = this.objectMode || !!t2.readableObjectMode), this.highWaterMark = y(this, t2, "readableHighWaterMark", n2), this.buffer = new d(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== t2.emitClose, this.autoDestroy = !!t2.autoDestroy, this.destroyed = false, this.defaultEncoding = t2.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t2.encoding && (h || (h = e("string_decoder/").StringDecoder), this.decoder = new h(t2.encoding), this.encoding = t2.encoding);
            }
            function C(t2) {
              if (i = i || e("./_stream_duplex"), !(this instanceof C))
                return new C(t2);
              var r3 = this instanceof i;
              this._readableState = new E(t2, this, r3), this.readable = true, t2 && ("function" == typeof t2.read && (this._read = t2.read), "function" == typeof t2.destroy && (this._destroy = t2.destroy)), s.call(this);
            }
            function T(e2, t2, r3, n2, i2) {
              u("readableAddChunk", t2);
              var o2, s2 = e2._readableState;
              if (null === t2)
                s2.reading = false, function(e3, t3) {
                  if (u("onEofChunk"), t3.ended)
                    return;
                  if (t3.decoder) {
                    var r4 = t3.decoder.end();
                    r4 && r4.length && (t3.buffer.push(r4), t3.length += t3.objectMode ? 1 : r4.length);
                  }
                  t3.ended = true, t3.sync ? P(e3) : (t3.needReadable = false, t3.emittedReadable || (t3.emittedReadable = true, O(e3)));
                }(e2, s2);
              else if (i2 || (o2 = function(e3, t3) {
                var r4;
                n3 = t3, a.isBuffer(n3) || n3 instanceof l || "string" == typeof t3 || void 0 === t3 || e3.objectMode || (r4 = new m("chunk", ["string", "Buffer", "Uint8Array"], t3));
                var n3;
                return r4;
              }(s2, t2)), o2)
                k(e2, o2);
              else if (s2.objectMode || t2 && t2.length > 0)
                if ("string" == typeof t2 || s2.objectMode || Object.getPrototypeOf(t2) === a.prototype || (t2 = function(e3) {
                  return a.from(e3);
                }(t2)), n2)
                  s2.endEmitted ? k(e2, new _()) : x(e2, s2, t2, true);
                else if (s2.ended)
                  k(e2, new v());
                else {
                  if (s2.destroyed)
                    return false;
                  s2.reading = false, s2.decoder && !r3 ? (t2 = s2.decoder.write(t2), s2.objectMode || 0 !== t2.length ? x(e2, s2, t2, false) : B(e2, s2)) : x(e2, s2, t2, false);
                }
              else
                n2 || (s2.reading = false, B(e2, s2));
              return !s2.ended && (s2.length < s2.highWaterMark || 0 === s2.length);
            }
            function x(e2, t2, r3, n2) {
              t2.flowing && 0 === t2.length && !t2.sync ? (t2.awaitDrain = 0, e2.emit("data", r3)) : (t2.length += t2.objectMode ? 1 : r3.length, n2 ? t2.buffer.unshift(r3) : t2.buffer.push(r3), t2.needReadable && P(e2)), B(e2, t2);
            }
            Object.defineProperty(C.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._readableState && this._readableState.destroyed;
            }, set: function(e2) {
              this._readableState && (this._readableState.destroyed = e2);
            } }), C.prototype.destroy = g.destroy, C.prototype._undestroy = g.undestroy, C.prototype._destroy = function(e2, t2) {
              t2(e2);
            }, C.prototype.push = function(e2, t2) {
              var r3, n2 = this._readableState;
              return n2.objectMode ? r3 = true : "string" == typeof e2 && ((t2 = t2 || n2.defaultEncoding) !== n2.encoding && (e2 = a.from(e2, t2), t2 = ""), r3 = true), T(this, e2, t2, false, r3);
            }, C.prototype.unshift = function(e2) {
              return T(this, e2, null, true, false);
            }, C.prototype.isPaused = function() {
              return false === this._readableState.flowing;
            }, C.prototype.setEncoding = function(t2) {
              h || (h = e("string_decoder/").StringDecoder);
              var r3 = new h(t2);
              this._readableState.decoder = r3, this._readableState.encoding = this._readableState.decoder.encoding;
              for (var n2 = this._readableState.buffer.head, i2 = ""; null !== n2; )
                i2 += r3.write(n2.data), n2 = n2.next;
              return this._readableState.buffer.clear(), "" !== i2 && this._readableState.buffer.push(i2), this._readableState.length = i2.length, this;
            };
            var A = 1073741824;
            function I(e2, t2) {
              return e2 <= 0 || 0 === t2.length && t2.ended ? 0 : t2.objectMode ? 1 : e2 != e2 ? t2.flowing && t2.length ? t2.buffer.head.data.length : t2.length : (e2 > t2.highWaterMark && (t2.highWaterMark = function(e3) {
                return e3 >= A ? e3 = A : (e3--, e3 |= e3 >>> 1, e3 |= e3 >>> 2, e3 |= e3 >>> 4, e3 |= e3 >>> 8, e3 |= e3 >>> 16, e3++), e3;
              }(e2)), e2 <= t2.length ? e2 : t2.ended ? t2.length : (t2.needReadable = true, 0));
            }
            function P(e2) {
              var t2 = e2._readableState;
              u("emitReadable", t2.needReadable, t2.emittedReadable), t2.needReadable = false, t2.emittedReadable || (u("emitReadable", t2.flowing), t2.emittedReadable = true, r2.nextTick(O, e2));
            }
            function O(e2) {
              var t2 = e2._readableState;
              u("emitReadable_", t2.destroyed, t2.length, t2.ended), t2.destroyed || !t2.length && !t2.ended || (e2.emit("readable"), t2.emittedReadable = false), t2.needReadable = !t2.flowing && !t2.ended && t2.length <= t2.highWaterMark, j(e2);
            }
            function B(e2, t2) {
              t2.readingMore || (t2.readingMore = true, r2.nextTick(R, e2, t2));
            }
            function R(e2, t2) {
              for (; !t2.reading && !t2.ended && (t2.length < t2.highWaterMark || t2.flowing && 0 === t2.length); ) {
                var r3 = t2.length;
                if (u("maybeReadMore read 0"), e2.read(0), r3 === t2.length)
                  break;
              }
              t2.readingMore = false;
            }
            function M(e2) {
              var t2 = e2._readableState;
              t2.readableListening = e2.listenerCount("readable") > 0, t2.resumeScheduled && !t2.paused ? t2.flowing = true : e2.listenerCount("data") > 0 && e2.resume();
            }
            function N(e2) {
              u("readable nexttick read 0"), e2.read(0);
            }
            function L(e2, t2) {
              u("resume", t2.reading), t2.reading || e2.read(0), t2.resumeScheduled = false, e2.emit("resume"), j(e2), t2.flowing && !t2.reading && e2.read(0);
            }
            function j(e2) {
              var t2 = e2._readableState;
              for (u("flow", t2.flowing); t2.flowing && null !== e2.read(); )
                ;
            }
            function U(e2, t2) {
              return 0 === t2.length ? null : (t2.objectMode ? r3 = t2.buffer.shift() : !e2 || e2 >= t2.length ? (r3 = t2.decoder ? t2.buffer.join("") : 1 === t2.buffer.length ? t2.buffer.first() : t2.buffer.concat(t2.length), t2.buffer.clear()) : r3 = t2.buffer.consume(e2, t2.decoder), r3);
              var r3;
            }
            function q(e2) {
              var t2 = e2._readableState;
              u("endReadable", t2.endEmitted), t2.endEmitted || (t2.ended = true, r2.nextTick(D, t2, e2));
            }
            function D(e2, t2) {
              if (u("endReadableNT", e2.endEmitted, e2.length), !e2.endEmitted && 0 === e2.length && (e2.endEmitted = true, t2.readable = false, t2.emit("end"), e2.autoDestroy)) {
                var r3 = t2._writableState;
                (!r3 || r3.autoDestroy && r3.finished) && t2.destroy();
              }
            }
            function z(e2, t2) {
              for (var r3 = 0, n2 = e2.length; r3 < n2; r3++)
                if (e2[r3] === t2)
                  return r3;
              return -1;
            }
            C.prototype.read = function(e2) {
              u("read", e2), e2 = parseInt(e2, 10);
              var t2 = this._readableState, r3 = e2;
              if (0 !== e2 && (t2.emittedReadable = false), 0 === e2 && t2.needReadable && ((0 !== t2.highWaterMark ? t2.length >= t2.highWaterMark : t2.length > 0) || t2.ended))
                return u("read: emitReadable", t2.length, t2.ended), 0 === t2.length && t2.ended ? q(this) : P(this), null;
              if (0 === (e2 = I(e2, t2)) && t2.ended)
                return 0 === t2.length && q(this), null;
              var n2, i2 = t2.needReadable;
              return u("need readable", i2), (0 === t2.length || t2.length - e2 < t2.highWaterMark) && u("length less than watermark", i2 = true), t2.ended || t2.reading ? u("reading or ended", i2 = false) : i2 && (u("do read"), t2.reading = true, t2.sync = true, 0 === t2.length && (t2.needReadable = true), this._read(t2.highWaterMark), t2.sync = false, t2.reading || (e2 = I(r3, t2))), null === (n2 = e2 > 0 ? U(e2, t2) : null) ? (t2.needReadable = t2.length <= t2.highWaterMark, e2 = 0) : (t2.length -= e2, t2.awaitDrain = 0), 0 === t2.length && (t2.ended || (t2.needReadable = true), r3 !== e2 && t2.ended && q(this)), null !== n2 && this.emit("data", n2), n2;
            }, C.prototype._read = function(e2) {
              k(this, new w("_read()"));
            }, C.prototype.pipe = function(e2, t2) {
              var n2 = this, i2 = this._readableState;
              switch (i2.pipesCount) {
                case 0:
                  i2.pipes = e2;
                  break;
                case 1:
                  i2.pipes = [i2.pipes, e2];
                  break;
                default:
                  i2.pipes.push(e2);
              }
              i2.pipesCount += 1, u("pipe count=%d opts=%j", i2.pipesCount, t2);
              var s2 = (!t2 || false !== t2.end) && e2 !== r2.stdout && e2 !== r2.stderr ? l2 : y2;
              function a2(t3, r3) {
                u("onunpipe"), t3 === n2 && r3 && false === r3.hasUnpiped && (r3.hasUnpiped = true, u("cleanup"), e2.removeListener("close", d2), e2.removeListener("finish", g2), e2.removeListener("drain", c2), e2.removeListener("error", p2), e2.removeListener("unpipe", a2), n2.removeListener("end", l2), n2.removeListener("end", y2), n2.removeListener("data", f2), h2 = true, !i2.awaitDrain || e2._writableState && !e2._writableState.needDrain || c2());
              }
              function l2() {
                u("onend"), e2.end();
              }
              i2.endEmitted ? r2.nextTick(s2) : n2.once("end", s2), e2.on("unpipe", a2);
              var c2 = function(e3) {
                return function() {
                  var t3 = e3._readableState;
                  u("pipeOnDrain", t3.awaitDrain), t3.awaitDrain && t3.awaitDrain--, 0 === t3.awaitDrain && o(e3, "data") && (t3.flowing = true, j(e3));
                };
              }(n2);
              e2.on("drain", c2);
              var h2 = false;
              function f2(t3) {
                u("ondata");
                var r3 = e2.write(t3);
                u("dest.write", r3), false === r3 && ((1 === i2.pipesCount && i2.pipes === e2 || i2.pipesCount > 1 && -1 !== z(i2.pipes, e2)) && !h2 && (u("false write response, pause", i2.awaitDrain), i2.awaitDrain++), n2.pause());
              }
              function p2(t3) {
                u("onerror", t3), y2(), e2.removeListener("error", p2), 0 === o(e2, "error") && k(e2, t3);
              }
              function d2() {
                e2.removeListener("finish", g2), y2();
              }
              function g2() {
                u("onfinish"), e2.removeListener("close", d2), y2();
              }
              function y2() {
                u("unpipe"), n2.unpipe(e2);
              }
              return n2.on("data", f2), function(e3, t3, r3) {
                if ("function" == typeof e3.prependListener)
                  return e3.prependListener(t3, r3);
                e3._events && e3._events[t3] ? Array.isArray(e3._events[t3]) ? e3._events[t3].unshift(r3) : e3._events[t3] = [r3, e3._events[t3]] : e3.on(t3, r3);
              }(e2, "error", p2), e2.once("close", d2), e2.once("finish", g2), e2.emit("pipe", n2), i2.flowing || (u("pipe resume"), n2.resume()), e2;
            }, C.prototype.unpipe = function(e2) {
              var t2 = this._readableState, r3 = { hasUnpiped: false };
              if (0 === t2.pipesCount)
                return this;
              if (1 === t2.pipesCount)
                return e2 && e2 !== t2.pipes ? this : (e2 || (e2 = t2.pipes), t2.pipes = null, t2.pipesCount = 0, t2.flowing = false, e2 && e2.emit("unpipe", this, r3), this);
              if (!e2) {
                var n2 = t2.pipes, i2 = t2.pipesCount;
                t2.pipes = null, t2.pipesCount = 0, t2.flowing = false;
                for (var o2 = 0; o2 < i2; o2++)
                  n2[o2].emit("unpipe", this, { hasUnpiped: false });
                return this;
              }
              var s2 = z(t2.pipes, e2);
              return -1 === s2 ? this : (t2.pipes.splice(s2, 1), t2.pipesCount -= 1, 1 === t2.pipesCount && (t2.pipes = t2.pipes[0]), e2.emit("unpipe", this, r3), this);
            }, C.prototype.on = function(e2, t2) {
              var n2 = s.prototype.on.call(this, e2, t2), i2 = this._readableState;
              return "data" === e2 ? (i2.readableListening = this.listenerCount("readable") > 0, false !== i2.flowing && this.resume()) : "readable" === e2 && (i2.endEmitted || i2.readableListening || (i2.readableListening = i2.needReadable = true, i2.flowing = false, i2.emittedReadable = false, u("on readable", i2.length, i2.reading), i2.length ? P(this) : i2.reading || r2.nextTick(N, this))), n2;
            }, C.prototype.addListener = C.prototype.on, C.prototype.removeListener = function(e2, t2) {
              var n2 = s.prototype.removeListener.call(this, e2, t2);
              return "readable" === e2 && r2.nextTick(M, this), n2;
            }, C.prototype.removeAllListeners = function(e2) {
              var t2 = s.prototype.removeAllListeners.apply(this, arguments);
              return "readable" !== e2 && void 0 !== e2 || r2.nextTick(M, this), t2;
            }, C.prototype.resume = function() {
              var e2 = this._readableState;
              return e2.flowing || (u("resume"), e2.flowing = !e2.readableListening, function(e3, t2) {
                t2.resumeScheduled || (t2.resumeScheduled = true, r2.nextTick(L, e3, t2));
              }(this, e2)), e2.paused = false, this;
            }, C.prototype.pause = function() {
              return u("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (u("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
            }, C.prototype.wrap = function(e2) {
              var t2 = this, r3 = this._readableState, n2 = false;
              for (var i2 in e2.on("end", function() {
                if (u("wrapped end"), r3.decoder && !r3.ended) {
                  var e3 = r3.decoder.end();
                  e3 && e3.length && t2.push(e3);
                }
                t2.push(null);
              }), e2.on("data", function(i3) {
                (u("wrapped data"), r3.decoder && (i3 = r3.decoder.write(i3)), !r3.objectMode || null !== i3 && void 0 !== i3) && ((r3.objectMode || i3 && i3.length) && (t2.push(i3) || (n2 = true, e2.pause())));
              }), e2)
                void 0 === this[i2] && "function" == typeof e2[i2] && (this[i2] = function(t3) {
                  return function() {
                    return e2[t3].apply(e2, arguments);
                  };
                }(i2));
              for (var o2 = 0; o2 < S.length; o2++)
                e2.on(S[o2], this.emit.bind(this, S[o2]));
              return this._read = function(t3) {
                u("wrapped _read", t3), n2 && (n2 = false, e2.resume());
              }, this;
            }, "function" == typeof Symbol && (C.prototype[Symbol.asyncIterator] = function() {
              return void 0 === f && (f = e("./internal/streams/async_iterator")), f(this);
            }), Object.defineProperty(C.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
              return this._readableState.highWaterMark;
            } }), Object.defineProperty(C.prototype, "readableBuffer", { enumerable: false, get: function() {
              return this._readableState && this._readableState.buffer;
            } }), Object.defineProperty(C.prototype, "readableFlowing", { enumerable: false, get: function() {
              return this._readableState.flowing;
            }, set: function(e2) {
              this._readableState && (this._readableState.flowing = e2);
            } }), C._fromList = U, Object.defineProperty(C.prototype, "readableLength", { enumerable: false, get: function() {
              return this._readableState.length;
            } }), "function" == typeof Symbol && (C.from = function(t2, r3) {
              return void 0 === p && (p = e("./internal/streams/from")), p(C, t2, r3);
            });
          }).call(this);
        }).call(this, e("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, { "../errors": 55, "./_stream_duplex": 56, "./internal/streams/async_iterator": 61, "./internal/streams/buffer_list": 62, "./internal/streams/destroy": 63, "./internal/streams/from": 65, "./internal/streams/state": 67, "./internal/streams/stream": 68, _process: 50, buffer: 17, events: 22, inherits: 24, "string_decoder/": 75, util: 16 }], 59: [function(e, t, r) {
        "use strict";
        t.exports = u;
        var n = e("../errors").codes, i = n.ERR_METHOD_NOT_IMPLEMENTED, o = n.ERR_MULTIPLE_CALLBACK, s = n.ERR_TRANSFORM_ALREADY_TRANSFORMING, a = n.ERR_TRANSFORM_WITH_LENGTH_0, l = e("./_stream_duplex");
        function u(e2) {
          if (!(this instanceof u))
            return new u(e2);
          l.call(this, e2), this._transformState = { afterTransform: (function(e3, t2) {
            var r2 = this._transformState;
            r2.transforming = false;
            var n2 = r2.writecb;
            if (null === n2)
              return this.emit("error", new o());
            r2.writechunk = null, r2.writecb = null, null != t2 && this.push(t2), n2(e3);
            var i2 = this._readableState;
            i2.reading = false, (i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
          }).bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e2 && ("function" == typeof e2.transform && (this._transform = e2.transform), "function" == typeof e2.flush && (this._flush = e2.flush)), this.on("prefinish", c);
        }
        function c() {
          var e2 = this;
          "function" != typeof this._flush || this._readableState.destroyed ? h(this, null, null) : this._flush(function(t2, r2) {
            h(e2, t2, r2);
          });
        }
        function h(e2, t2, r2) {
          if (t2)
            return e2.emit("error", t2);
          if (null != r2 && e2.push(r2), e2._writableState.length)
            throw new a();
          if (e2._transformState.transforming)
            throw new s();
          return e2.push(null);
        }
        e("inherits")(u, l), u.prototype.push = function(e2, t2) {
          return this._transformState.needTransform = false, l.prototype.push.call(this, e2, t2);
        }, u.prototype._transform = function(e2, t2, r2) {
          r2(new i("_transform()"));
        }, u.prototype._write = function(e2, t2, r2) {
          var n2 = this._transformState;
          if (n2.writecb = r2, n2.writechunk = e2, n2.writeencoding = t2, !n2.transforming) {
            var i2 = this._readableState;
            (n2.needTransform || i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
          }
        }, u.prototype._read = function(e2) {
          var t2 = this._transformState;
          null === t2.writechunk || t2.transforming ? t2.needTransform = true : (t2.transforming = true, this._transform(t2.writechunk, t2.writeencoding, t2.afterTransform));
        }, u.prototype._destroy = function(e2, t2) {
          l.prototype._destroy.call(this, e2, function(e3) {
            t2(e3);
          });
        };
      }, { "../errors": 55, "./_stream_duplex": 56, inherits: 24 }], 60: [function(e, t, r) {
        (function(r2, n) {
          (function() {
            "use strict";
            function i(e2) {
              var t2 = this;
              this.next = null, this.entry = null, this.finish = function() {
                !function(e3, t3, r3) {
                  var n2 = e3.entry;
                  e3.entry = null;
                  for (; n2; ) {
                    var i2 = n2.callback;
                    t3.pendingcb--, i2(r3), n2 = n2.next;
                  }
                  t3.corkedRequestsFree.next = e3;
                }(t2, e2);
              };
            }
            var o;
            t.exports = C, C.WritableState = E;
            var s = { deprecate: e("util-deprecate") }, a = e("./internal/streams/stream"), l = e("buffer").Buffer, u = n.Uint8Array || function() {
            };
            var c, h = e("./internal/streams/destroy"), f = e("./internal/streams/state").getHighWaterMark, p = e("../errors").codes, d = p.ERR_INVALID_ARG_TYPE, g = p.ERR_METHOD_NOT_IMPLEMENTED, y = p.ERR_MULTIPLE_CALLBACK, b = p.ERR_STREAM_CANNOT_PIPE, m = p.ERR_STREAM_DESTROYED, v = p.ERR_STREAM_NULL_VALUES, w = p.ERR_STREAM_WRITE_AFTER_END, _ = p.ERR_UNKNOWN_ENCODING, k = h.errorOrDestroy;
            function S() {
            }
            function E(t2, n2, s2) {
              o = o || e("./_stream_duplex"), t2 = t2 || {}, "boolean" != typeof s2 && (s2 = n2 instanceof o), this.objectMode = !!t2.objectMode, s2 && (this.objectMode = this.objectMode || !!t2.writableObjectMode), this.highWaterMark = f(this, t2, "writableHighWaterMark", s2), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
              var a2 = false === t2.decodeStrings;
              this.decodeStrings = !a2, this.defaultEncoding = t2.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e2) {
                !function(e3, t3) {
                  var n3 = e3._writableState, i2 = n3.sync, o2 = n3.writecb;
                  if ("function" != typeof o2)
                    throw new y();
                  if (function(e4) {
                    e4.writing = false, e4.writecb = null, e4.length -= e4.writelen, e4.writelen = 0;
                  }(n3), t3)
                    !function(e4, t4, n4, i3, o3) {
                      --t4.pendingcb, n4 ? (r2.nextTick(o3, i3), r2.nextTick(O, e4, t4), e4._writableState.errorEmitted = true, k(e4, i3)) : (o3(i3), e4._writableState.errorEmitted = true, k(e4, i3), O(e4, t4));
                    }(e3, n3, i2, t3, o2);
                  else {
                    var s3 = I(n3) || e3.destroyed;
                    s3 || n3.corked || n3.bufferProcessing || !n3.bufferedRequest || A(e3, n3), i2 ? r2.nextTick(x, e3, n3, s3, o2) : x(e3, n3, s3, o2);
                  }
                }(n2, e2);
              }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== t2.emitClose, this.autoDestroy = !!t2.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new i(this);
            }
            function C(t2) {
              var r3 = this instanceof (o = o || e("./_stream_duplex"));
              if (!r3 && !c.call(C, this))
                return new C(t2);
              this._writableState = new E(t2, this, r3), this.writable = true, t2 && ("function" == typeof t2.write && (this._write = t2.write), "function" == typeof t2.writev && (this._writev = t2.writev), "function" == typeof t2.destroy && (this._destroy = t2.destroy), "function" == typeof t2.final && (this._final = t2.final)), a.call(this);
            }
            function T(e2, t2, r3, n2, i2, o2, s2) {
              t2.writelen = n2, t2.writecb = s2, t2.writing = true, t2.sync = true, t2.destroyed ? t2.onwrite(new m("write")) : r3 ? e2._writev(i2, t2.onwrite) : e2._write(i2, o2, t2.onwrite), t2.sync = false;
            }
            function x(e2, t2, r3, n2) {
              r3 || function(e3, t3) {
                0 === t3.length && t3.needDrain && (t3.needDrain = false, e3.emit("drain"));
              }(e2, t2), t2.pendingcb--, n2(), O(e2, t2);
            }
            function A(e2, t2) {
              t2.bufferProcessing = true;
              var r3 = t2.bufferedRequest;
              if (e2._writev && r3 && r3.next) {
                var n2 = t2.bufferedRequestCount, o2 = new Array(n2), s2 = t2.corkedRequestsFree;
                s2.entry = r3;
                for (var a2 = 0, l2 = true; r3; )
                  o2[a2] = r3, r3.isBuf || (l2 = false), r3 = r3.next, a2 += 1;
                o2.allBuffers = l2, T(e2, t2, true, t2.length, o2, "", s2.finish), t2.pendingcb++, t2.lastBufferedRequest = null, s2.next ? (t2.corkedRequestsFree = s2.next, s2.next = null) : t2.corkedRequestsFree = new i(t2), t2.bufferedRequestCount = 0;
              } else {
                for (; r3; ) {
                  var u2 = r3.chunk, c2 = r3.encoding, h2 = r3.callback;
                  if (T(e2, t2, false, t2.objectMode ? 1 : u2.length, u2, c2, h2), r3 = r3.next, t2.bufferedRequestCount--, t2.writing)
                    break;
                }
                null === r3 && (t2.lastBufferedRequest = null);
              }
              t2.bufferedRequest = r3, t2.bufferProcessing = false;
            }
            function I(e2) {
              return e2.ending && 0 === e2.length && null === e2.bufferedRequest && !e2.finished && !e2.writing;
            }
            function P(e2, t2) {
              e2._final(function(r3) {
                t2.pendingcb--, r3 && k(e2, r3), t2.prefinished = true, e2.emit("prefinish"), O(e2, t2);
              });
            }
            function O(e2, t2) {
              var n2 = I(t2);
              if (n2 && (function(e3, t3) {
                t3.prefinished || t3.finalCalled || ("function" != typeof e3._final || t3.destroyed ? (t3.prefinished = true, e3.emit("prefinish")) : (t3.pendingcb++, t3.finalCalled = true, r2.nextTick(P, e3, t3)));
              }(e2, t2), 0 === t2.pendingcb && (t2.finished = true, e2.emit("finish"), t2.autoDestroy))) {
                var i2 = e2._readableState;
                (!i2 || i2.autoDestroy && i2.endEmitted) && e2.destroy();
              }
              return n2;
            }
            e("inherits")(C, a), E.prototype.getBuffer = function() {
              for (var e2 = this.bufferedRequest, t2 = []; e2; )
                t2.push(e2), e2 = e2.next;
              return t2;
            }, function() {
              try {
                Object.defineProperty(E.prototype, "buffer", { get: s.deprecate(function() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
              } catch (e2) {
              }
            }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (c = Function.prototype[Symbol.hasInstance], Object.defineProperty(C, Symbol.hasInstance, { value: function(e2) {
              return !!c.call(this, e2) || this === C && (e2 && e2._writableState instanceof E);
            } })) : c = function(e2) {
              return e2 instanceof this;
            }, C.prototype.pipe = function() {
              k(this, new b());
            }, C.prototype.write = function(e2, t2, n2) {
              var i2, o2 = this._writableState, s2 = false, a2 = !o2.objectMode && (i2 = e2, l.isBuffer(i2) || i2 instanceof u);
              return a2 && !l.isBuffer(e2) && (e2 = function(e3) {
                return l.from(e3);
              }(e2)), "function" == typeof t2 && (n2 = t2, t2 = null), a2 ? t2 = "buffer" : t2 || (t2 = o2.defaultEncoding), "function" != typeof n2 && (n2 = S), o2.ending ? function(e3, t3) {
                var n3 = new w();
                k(e3, n3), r2.nextTick(t3, n3);
              }(this, n2) : (a2 || function(e3, t3, n3, i3) {
                var o3;
                return null === n3 ? o3 = new v() : "string" == typeof n3 || t3.objectMode || (o3 = new d("chunk", ["string", "Buffer"], n3)), !o3 || (k(e3, o3), r2.nextTick(i3, o3), false);
              }(this, o2, e2, n2)) && (o2.pendingcb++, s2 = function(e3, t3, r3, n3, i3, o3) {
                if (!r3) {
                  var s3 = function(e4, t4, r4) {
                    e4.objectMode || false === e4.decodeStrings || "string" != typeof t4 || (t4 = l.from(t4, r4));
                    return t4;
                  }(t3, n3, i3);
                  n3 !== s3 && (r3 = true, i3 = "buffer", n3 = s3);
                }
                var a3 = t3.objectMode ? 1 : n3.length;
                t3.length += a3;
                var u2 = t3.length < t3.highWaterMark;
                u2 || (t3.needDrain = true);
                if (t3.writing || t3.corked) {
                  var c2 = t3.lastBufferedRequest;
                  t3.lastBufferedRequest = { chunk: n3, encoding: i3, isBuf: r3, callback: o3, next: null }, c2 ? c2.next = t3.lastBufferedRequest : t3.bufferedRequest = t3.lastBufferedRequest, t3.bufferedRequestCount += 1;
                } else
                  T(e3, t3, false, a3, n3, i3, o3);
                return u2;
              }(this, o2, a2, e2, t2, n2)), s2;
            }, C.prototype.cork = function() {
              this._writableState.corked++;
            }, C.prototype.uncork = function() {
              var e2 = this._writableState;
              e2.corked && (e2.corked--, e2.writing || e2.corked || e2.bufferProcessing || !e2.bufferedRequest || A(this, e2));
            }, C.prototype.setDefaultEncoding = function(e2) {
              if ("string" == typeof e2 && (e2 = e2.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e2 + "").toLowerCase()) > -1))
                throw new _(e2);
              return this._writableState.defaultEncoding = e2, this;
            }, Object.defineProperty(C.prototype, "writableBuffer", { enumerable: false, get: function() {
              return this._writableState && this._writableState.getBuffer();
            } }), Object.defineProperty(C.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
              return this._writableState.highWaterMark;
            } }), C.prototype._write = function(e2, t2, r3) {
              r3(new g("_write()"));
            }, C.prototype._writev = null, C.prototype.end = function(e2, t2, n2) {
              var i2 = this._writableState;
              return "function" == typeof e2 ? (n2 = e2, e2 = null, t2 = null) : "function" == typeof t2 && (n2 = t2, t2 = null), null !== e2 && void 0 !== e2 && this.write(e2, t2), i2.corked && (i2.corked = 1, this.uncork()), i2.ending || function(e3, t3, n3) {
                t3.ending = true, O(e3, t3), n3 && (t3.finished ? r2.nextTick(n3) : e3.once("finish", n3));
                t3.ended = true, e3.writable = false;
              }(this, i2, n2), this;
            }, Object.defineProperty(C.prototype, "writableLength", { enumerable: false, get: function() {
              return this._writableState.length;
            } }), Object.defineProperty(C.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._writableState && this._writableState.destroyed;
            }, set: function(e2) {
              this._writableState && (this._writableState.destroyed = e2);
            } }), C.prototype.destroy = h.destroy, C.prototype._undestroy = h.undestroy, C.prototype._destroy = function(e2, t2) {
              t2(e2);
            };
          }).call(this);
        }).call(this, e("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, { "../errors": 55, "./_stream_duplex": 56, "./internal/streams/destroy": 63, "./internal/streams/state": 67, "./internal/streams/stream": 68, _process: 50, buffer: 17, inherits: 24, "util-deprecate": 78 }], 61: [function(e, t, r) {
        (function(r2) {
          (function() {
            "use strict";
            var n;
            function i(e2, t2, r3) {
              return t2 in e2 ? Object.defineProperty(e2, t2, { value: r3, enumerable: true, configurable: true, writable: true }) : e2[t2] = r3, e2;
            }
            var o = e("./end-of-stream"), s = Symbol("lastResolve"), a = Symbol("lastReject"), l = Symbol("error"), u = Symbol("ended"), c = Symbol("lastPromise"), h = Symbol("handlePromise"), f = Symbol("stream");
            function p(e2, t2) {
              return { value: e2, done: t2 };
            }
            function d(e2) {
              var t2 = e2[s];
              if (null !== t2) {
                var r3 = e2[f].read();
                null !== r3 && (e2[c] = null, e2[s] = null, e2[a] = null, t2(p(r3, false)));
              }
            }
            var g = Object.getPrototypeOf(function() {
            }), y = Object.setPrototypeOf((i(n = { get stream() {
              return this[f];
            }, next: function() {
              var e2 = this, t2 = this[l];
              if (null !== t2)
                return Promise.reject(t2);
              if (this[u])
                return Promise.resolve(p(void 0, true));
              if (this[f].destroyed)
                return new Promise(function(t3, n3) {
                  r2.nextTick(function() {
                    e2[l] ? n3(e2[l]) : t3(p(void 0, true));
                  });
                });
              var n2, i2 = this[c];
              if (i2)
                n2 = new Promise(function(e3, t3) {
                  return function(r3, n3) {
                    e3.then(function() {
                      t3[u] ? r3(p(void 0, true)) : t3[h](r3, n3);
                    }, n3);
                  };
                }(i2, this));
              else {
                var o2 = this[f].read();
                if (null !== o2)
                  return Promise.resolve(p(o2, false));
                n2 = new Promise(this[h]);
              }
              return this[c] = n2, n2;
            } }, Symbol.asyncIterator, function() {
              return this;
            }), i(n, "return", function() {
              var e2 = this;
              return new Promise(function(t2, r3) {
                e2[f].destroy(null, function(e3) {
                  e3 ? r3(e3) : t2(p(void 0, true));
                });
              });
            }), n), g);
            t.exports = function(e2) {
              var t2, n2 = Object.create(y, (i(t2 = {}, f, { value: e2, writable: true }), i(t2, s, { value: null, writable: true }), i(t2, a, { value: null, writable: true }), i(t2, l, { value: null, writable: true }), i(t2, u, { value: e2._readableState.endEmitted, writable: true }), i(t2, h, { value: function(e3, t3) {
                var r3 = n2[f].read();
                r3 ? (n2[c] = null, n2[s] = null, n2[a] = null, e3(p(r3, false))) : (n2[s] = e3, n2[a] = t3);
              }, writable: true }), t2));
              return n2[c] = null, o(e2, function(e3) {
                if (e3 && "ERR_STREAM_PREMATURE_CLOSE" !== e3.code) {
                  var t3 = n2[a];
                  return null !== t3 && (n2[c] = null, n2[s] = null, n2[a] = null, t3(e3)), void (n2[l] = e3);
                }
                var r3 = n2[s];
                null !== r3 && (n2[c] = null, n2[s] = null, n2[a] = null, r3(p(void 0, true))), n2[u] = true;
              }), e2.on("readable", (function(e3) {
                r2.nextTick(d, e3);
              }).bind(null, n2)), n2;
            };
          }).call(this);
        }).call(this, e("_process"));
      }, { "./end-of-stream": 64, _process: 50 }], 62: [function(e, t, r) {
        "use strict";
        function n(e2, t2) {
          var r2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), r2.push.apply(r2, n2);
          }
          return r2;
        }
        function i(e2, t2, r2) {
          return t2 in e2 ? Object.defineProperty(e2, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t2] = r2, e2;
        }
        function o(e2, t2) {
          for (var r2 = 0; r2 < t2.length; r2++) {
            var n2 = t2[r2];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
          }
        }
        var s = e("buffer").Buffer, a = e("util").inspect, l = a && a.custom || "inspect";
        t.exports = function() {
          function e2() {
            !function(e3, t3) {
              if (!(e3 instanceof t3))
                throw new TypeError("Cannot call a class as a function");
            }(this, e2), this.head = null, this.tail = null, this.length = 0;
          }
          var t2, r2, u;
          return t2 = e2, (r2 = [{ key: "push", value: function(e3) {
            var t3 = { data: e3, next: null };
            this.length > 0 ? this.tail.next = t3 : this.head = t3, this.tail = t3, ++this.length;
          } }, { key: "unshift", value: function(e3) {
            var t3 = { data: e3, next: this.head };
            0 === this.length && (this.tail = t3), this.head = t3, ++this.length;
          } }, { key: "shift", value: function() {
            if (0 !== this.length) {
              var e3 = this.head.data;
              return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e3;
            }
          } }, { key: "clear", value: function() {
            this.head = this.tail = null, this.length = 0;
          } }, { key: "join", value: function(e3) {
            if (0 === this.length)
              return "";
            for (var t3 = this.head, r3 = "" + t3.data; t3 = t3.next; )
              r3 += e3 + t3.data;
            return r3;
          } }, { key: "concat", value: function(e3) {
            if (0 === this.length)
              return s.alloc(0);
            for (var t3, r3, n2, i2 = s.allocUnsafe(e3 >>> 0), o2 = this.head, a2 = 0; o2; )
              t3 = o2.data, r3 = i2, n2 = a2, s.prototype.copy.call(t3, r3, n2), a2 += o2.data.length, o2 = o2.next;
            return i2;
          } }, { key: "consume", value: function(e3, t3) {
            var r3;
            return e3 < this.head.data.length ? (r3 = this.head.data.slice(0, e3), this.head.data = this.head.data.slice(e3)) : r3 = e3 === this.head.data.length ? this.shift() : t3 ? this._getString(e3) : this._getBuffer(e3), r3;
          } }, { key: "first", value: function() {
            return this.head.data;
          } }, { key: "_getString", value: function(e3) {
            var t3 = this.head, r3 = 1, n2 = t3.data;
            for (e3 -= n2.length; t3 = t3.next; ) {
              var i2 = t3.data, o2 = e3 > i2.length ? i2.length : e3;
              if (o2 === i2.length ? n2 += i2 : n2 += i2.slice(0, e3), 0 === (e3 -= o2)) {
                o2 === i2.length ? (++r3, t3.next ? this.head = t3.next : this.head = this.tail = null) : (this.head = t3, t3.data = i2.slice(o2));
                break;
              }
              ++r3;
            }
            return this.length -= r3, n2;
          } }, { key: "_getBuffer", value: function(e3) {
            var t3 = s.allocUnsafe(e3), r3 = this.head, n2 = 1;
            for (r3.data.copy(t3), e3 -= r3.data.length; r3 = r3.next; ) {
              var i2 = r3.data, o2 = e3 > i2.length ? i2.length : e3;
              if (i2.copy(t3, t3.length - e3, 0, o2), 0 === (e3 -= o2)) {
                o2 === i2.length ? (++n2, r3.next ? this.head = r3.next : this.head = this.tail = null) : (this.head = r3, r3.data = i2.slice(o2));
                break;
              }
              ++n2;
            }
            return this.length -= n2, t3;
          } }, { key: l, value: function(e3, t3) {
            return a(this, function(e4) {
              for (var t4 = 1; t4 < arguments.length; t4++) {
                var r3 = null != arguments[t4] ? arguments[t4] : {};
                t4 % 2 ? n(Object(r3), true).forEach(function(t5) {
                  i(e4, t5, r3[t5]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(r3)) : n(Object(r3)).forEach(function(t5) {
                  Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(r3, t5));
                });
              }
              return e4;
            }({}, t3, { depth: 0, customInspect: false }));
          } }]) && o(t2.prototype, r2), u && o(t2, u), e2;
        }();
      }, { buffer: 17, util: 16 }], 63: [function(e, t, r) {
        (function(e2) {
          (function() {
            "use strict";
            function r2(e3, t2) {
              i(e3, t2), n(e3);
            }
            function n(e3) {
              e3._writableState && !e3._writableState.emitClose || e3._readableState && !e3._readableState.emitClose || e3.emit("close");
            }
            function i(e3, t2) {
              e3.emit("error", t2);
            }
            t.exports = { destroy: function(t2, o) {
              var s = this, a = this._readableState && this._readableState.destroyed, l = this._writableState && this._writableState.destroyed;
              return a || l ? (o ? o(t2) : t2 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, e2.nextTick(i, this, t2)) : e2.nextTick(i, this, t2)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t2 || null, function(t3) {
                !o && t3 ? s._writableState ? s._writableState.errorEmitted ? e2.nextTick(n, s) : (s._writableState.errorEmitted = true, e2.nextTick(r2, s, t3)) : e2.nextTick(r2, s, t3) : o ? (e2.nextTick(n, s), o(t3)) : e2.nextTick(n, s);
              }), this);
            }, undestroy: function() {
              this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
            }, errorOrDestroy: function(e3, t2) {
              var r3 = e3._readableState, n2 = e3._writableState;
              r3 && r3.autoDestroy || n2 && n2.autoDestroy ? e3.destroy(t2) : e3.emit("error", t2);
            } };
          }).call(this);
        }).call(this, e("_process"));
      }, { _process: 50 }], 64: [function(e, t, r) {
        "use strict";
        var n = e("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
        function i() {
        }
        t.exports = function e2(t2, r2, o) {
          if ("function" == typeof r2)
            return e2(t2, null, r2);
          r2 || (r2 = {}), o = function(e3) {
            var t3 = false;
            return function() {
              if (!t3) {
                t3 = true;
                for (var r3 = arguments.length, n2 = new Array(r3), i2 = 0; i2 < r3; i2++)
                  n2[i2] = arguments[i2];
                e3.apply(this, n2);
              }
            };
          }(o || i);
          var s = r2.readable || false !== r2.readable && t2.readable, a = r2.writable || false !== r2.writable && t2.writable, l = function() {
            t2.writable || c();
          }, u = t2._writableState && t2._writableState.finished, c = function() {
            a = false, u = true, s || o.call(t2);
          }, h = t2._readableState && t2._readableState.endEmitted, f = function() {
            s = false, h = true, a || o.call(t2);
          }, p = function(e3) {
            o.call(t2, e3);
          }, d = function() {
            var e3;
            return s && !h ? (t2._readableState && t2._readableState.ended || (e3 = new n()), o.call(t2, e3)) : a && !u ? (t2._writableState && t2._writableState.ended || (e3 = new n()), o.call(t2, e3)) : void 0;
          }, g = function() {
            t2.req.on("finish", c);
          };
          return function(e3) {
            return e3.setHeader && "function" == typeof e3.abort;
          }(t2) ? (t2.on("complete", c), t2.on("abort", d), t2.req ? g() : t2.on("request", g)) : a && !t2._writableState && (t2.on("end", l), t2.on("close", l)), t2.on("end", f), t2.on("finish", c), false !== r2.error && t2.on("error", p), t2.on("close", d), function() {
            t2.removeListener("complete", c), t2.removeListener("abort", d), t2.removeListener("request", g), t2.req && t2.req.removeListener("finish", c), t2.removeListener("end", l), t2.removeListener("close", l), t2.removeListener("finish", c), t2.removeListener("end", f), t2.removeListener("error", p), t2.removeListener("close", d);
          };
        };
      }, { "../../../errors": 55 }], 65: [function(e, t, r) {
        t.exports = function() {
          throw new Error("Readable.from is not available in the browser");
        };
      }, {}], 66: [function(e, t, r) {
        "use strict";
        var n;
        var i = e("../../../errors").codes, o = i.ERR_MISSING_ARGS, s = i.ERR_STREAM_DESTROYED;
        function a(e2) {
          if (e2)
            throw e2;
        }
        function l(e2) {
          e2();
        }
        function u(e2, t2) {
          return e2.pipe(t2);
        }
        t.exports = function() {
          for (var t2 = arguments.length, r2 = new Array(t2), i2 = 0; i2 < t2; i2++)
            r2[i2] = arguments[i2];
          var c, h = function(e2) {
            return e2.length ? "function" != typeof e2[e2.length - 1] ? a : e2.pop() : a;
          }(r2);
          if (Array.isArray(r2[0]) && (r2 = r2[0]), r2.length < 2)
            throw new o("streams");
          var f = r2.map(function(t3, i3) {
            var o2 = i3 < r2.length - 1;
            return function(t4, r3, i4, o3) {
              o3 = function(e2) {
                var t5 = false;
                return function() {
                  t5 || (t5 = true, e2.apply(void 0, arguments));
                };
              }(o3);
              var a2 = false;
              t4.on("close", function() {
                a2 = true;
              }), void 0 === n && (n = e("./end-of-stream")), n(t4, { readable: r3, writable: i4 }, function(e2) {
                if (e2)
                  return o3(e2);
                a2 = true, o3();
              });
              var l2 = false;
              return function(e2) {
                if (!a2 && !l2)
                  return l2 = true, function(e3) {
                    return e3.setHeader && "function" == typeof e3.abort;
                  }(t4) ? t4.abort() : "function" == typeof t4.destroy ? t4.destroy() : void o3(e2 || new s("pipe"));
              };
            }(t3, o2, i3 > 0, function(e2) {
              c || (c = e2), e2 && f.forEach(l), o2 || (f.forEach(l), h(c));
            });
          });
          return r2.reduce(u);
        };
      }, { "../../../errors": 55, "./end-of-stream": 64 }], 67: [function(e, t, r) {
        "use strict";
        var n = e("../../../errors").codes.ERR_INVALID_OPT_VALUE;
        t.exports = { getHighWaterMark: function(e2, t2, r2, i) {
          var o = function(e3, t3, r3) {
            return null != e3.highWaterMark ? e3.highWaterMark : t3 ? e3[r3] : null;
          }(t2, i, r2);
          if (null != o) {
            if (!isFinite(o) || Math.floor(o) !== o || o < 0)
              throw new n(i ? r2 : "highWaterMark", o);
            return Math.floor(o);
          }
          return e2.objectMode ? 16 : 16384;
        } };
      }, { "../../../errors": 55 }], 68: [function(e, t, r) {
        t.exports = e("events").EventEmitter;
      }, { events: 22 }], 69: [function(e, t, r) {
        (r = t.exports = e("./lib/_stream_readable.js")).Stream = r, r.Readable = r, r.Writable = e("./lib/_stream_writable.js"), r.Duplex = e("./lib/_stream_duplex.js"), r.Transform = e("./lib/_stream_transform.js"), r.PassThrough = e("./lib/_stream_passthrough.js"), r.finished = e("./lib/internal/streams/end-of-stream.js"), r.pipeline = e("./lib/internal/streams/pipeline.js");
      }, { "./lib/_stream_duplex.js": 56, "./lib/_stream_passthrough.js": 57, "./lib/_stream_readable.js": 58, "./lib/_stream_transform.js": 59, "./lib/_stream_writable.js": 60, "./lib/internal/streams/end-of-stream.js": 64, "./lib/internal/streams/pipeline.js": 66 }], 70: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          if ("function" != typeof arguments[0])
            throw new Error("callback needed");
          if ("number" != typeof arguments[1])
            throw new Error("interval needed");
          var e2;
          if (arguments.length > 0) {
            e2 = new Array(arguments.length - 2);
            for (var t2 = 0; t2 < e2.length; t2++)
              e2[t2] = arguments[t2 + 2];
          }
          return new function(e3, t3, r2) {
            var n = this;
            this._callback = e3, this._args = r2, this._interval = setInterval(e3, t3, this._args), this.reschedule = function(e4) {
              e4 || (e4 = n._interval), n._interval && clearInterval(n._interval), n._interval = setInterval(n._callback, e4, n._args);
            }, this.clear = function() {
              n._interval && (clearInterval(n._interval), n._interval = void 0);
            }, this.destroy = function() {
              n._interval && clearInterval(n._interval), n._callback = void 0, n._interval = void 0, n._args = void 0;
            };
          }(arguments[0], arguments[1], e2);
        };
      }, {}], 71: [function(e, t, r) {
        "use strict";
        t.exports = e("./index.js")();
      }, { "./index.js": 72 }], 72: [function(e, t, r) {
        (function(e2) {
          (function() {
            "use strict";
            function r2(t2) {
              return t2 instanceof e2 ? e2.from(t2) : new t2.constructor(t2.buffer.slice(), t2.byteOffset, t2.length);
            }
            t.exports = function(e3) {
              return (e3 = e3 || {}).circles ? function(e4) {
                var t3 = [], n = [];
                return e4.proto ? function e5(o) {
                  if ("object" != typeof o || null === o)
                    return o;
                  if (o instanceof Date)
                    return new Date(o);
                  if (Array.isArray(o))
                    return i(o, e5);
                  if (o instanceof Map)
                    return new Map(i(Array.from(o), e5));
                  if (o instanceof Set)
                    return new Set(i(Array.from(o), e5));
                  var s = {};
                  for (var a in t3.push(o), n.push(s), o) {
                    var l = o[a];
                    if ("object" != typeof l || null === l)
                      s[a] = l;
                    else if (l instanceof Date)
                      s[a] = new Date(l);
                    else if (l instanceof Map)
                      s[a] = new Map(i(Array.from(l), e5));
                    else if (l instanceof Set)
                      s[a] = new Set(i(Array.from(l), e5));
                    else if (ArrayBuffer.isView(l))
                      s[a] = r2(l);
                    else {
                      var u = t3.indexOf(l);
                      s[a] = -1 !== u ? n[u] : e5(l);
                    }
                  }
                  return t3.pop(), n.pop(), s;
                } : function e5(o) {
                  if ("object" != typeof o || null === o)
                    return o;
                  if (o instanceof Date)
                    return new Date(o);
                  if (Array.isArray(o))
                    return i(o, e5);
                  if (o instanceof Map)
                    return new Map(i(Array.from(o), e5));
                  if (o instanceof Set)
                    return new Set(i(Array.from(o), e5));
                  var s = {};
                  for (var a in t3.push(o), n.push(s), o)
                    if (false !== Object.hasOwnProperty.call(o, a)) {
                      var l = o[a];
                      if ("object" != typeof l || null === l)
                        s[a] = l;
                      else if (l instanceof Date)
                        s[a] = new Date(l);
                      else if (l instanceof Map)
                        s[a] = new Map(i(Array.from(l), e5));
                      else if (l instanceof Set)
                        s[a] = new Set(i(Array.from(l), e5));
                      else if (ArrayBuffer.isView(l))
                        s[a] = r2(l);
                      else {
                        var u = t3.indexOf(l);
                        s[a] = -1 !== u ? n[u] : e5(l);
                      }
                    }
                  return t3.pop(), n.pop(), s;
                };
                function i(e5, i2) {
                  for (var o = Object.keys(e5), s = new Array(o.length), a = 0; a < o.length; a++) {
                    var l = o[a], u = e5[l];
                    if ("object" != typeof u || null === u)
                      s[l] = u;
                    else if (u instanceof Date)
                      s[l] = new Date(u);
                    else if (ArrayBuffer.isView(u))
                      s[l] = r2(u);
                    else {
                      var c = t3.indexOf(u);
                      s[l] = -1 !== c ? n[c] : i2(u);
                    }
                  }
                  return s;
                }
              }(e3) : e3.proto ? function e4(n) {
                if ("object" != typeof n || null === n)
                  return n;
                if (n instanceof Date)
                  return new Date(n);
                if (Array.isArray(n))
                  return t2(n, e4);
                if (n instanceof Map)
                  return new Map(t2(Array.from(n), e4));
                if (n instanceof Set)
                  return new Set(t2(Array.from(n), e4));
                var i = {};
                for (var o in n) {
                  var s = n[o];
                  "object" != typeof s || null === s ? i[o] = s : s instanceof Date ? i[o] = new Date(s) : s instanceof Map ? i[o] = new Map(t2(Array.from(s), e4)) : s instanceof Set ? i[o] = new Set(t2(Array.from(s), e4)) : ArrayBuffer.isView(s) ? i[o] = r2(s) : i[o] = e4(s);
                }
                return i;
              } : function e4(n) {
                if ("object" != typeof n || null === n)
                  return n;
                if (n instanceof Date)
                  return new Date(n);
                if (Array.isArray(n))
                  return t2(n, e4);
                if (n instanceof Map)
                  return new Map(t2(Array.from(n), e4));
                if (n instanceof Set)
                  return new Set(t2(Array.from(n), e4));
                var i = {};
                for (var o in n)
                  if (false !== Object.hasOwnProperty.call(n, o)) {
                    var s = n[o];
                    "object" != typeof s || null === s ? i[o] = s : s instanceof Date ? i[o] = new Date(s) : s instanceof Map ? i[o] = new Map(t2(Array.from(s), e4)) : s instanceof Set ? i[o] = new Set(t2(Array.from(s), e4)) : ArrayBuffer.isView(s) ? i[o] = r2(s) : i[o] = e4(s);
                  }
                return i;
              };
              function t2(e4, t3) {
                for (var n = Object.keys(e4), i = new Array(n.length), o = 0; o < n.length; o++) {
                  var s = n[o], a = e4[s];
                  "object" != typeof a || null === a ? i[s] = a : a instanceof Date ? i[s] = new Date(a) : ArrayBuffer.isView(a) ? i[s] = r2(a) : i[s] = t3(a);
                }
                return i;
              }
            };
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { buffer: 17 }], 73: [function(e, t, r) {
        var n = e("buffer"), i = n.Buffer;
        function o(e2, t2) {
          for (var r2 in e2)
            t2[r2] = e2[r2];
        }
        function s(e2, t2, r2) {
          return i(e2, t2, r2);
        }
        i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t.exports = n : (o(n, r), r.Buffer = s), s.prototype = Object.create(i.prototype), o(i, s), s.from = function(e2, t2, r2) {
          if ("number" == typeof e2)
            throw new TypeError("Argument must not be a number");
          return i(e2, t2, r2);
        }, s.alloc = function(e2, t2, r2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          var n2 = i(e2);
          return void 0 !== t2 ? "string" == typeof r2 ? n2.fill(t2, r2) : n2.fill(t2) : n2.fill(0), n2;
        }, s.allocUnsafe = function(e2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          return i(e2);
        }, s.allocUnsafeSlow = function(e2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          return n.SlowBuffer(e2);
        };
      }, { buffer: 17 }], 74: [function(e, t, r) {
        t.exports = function(e2) {
          var t2 = e2._readableState;
          return t2 ? t2.objectMode || "number" == typeof e2._duplexState ? e2.read() : e2.read((r2 = t2, r2.buffer.length ? r2.buffer.head ? r2.buffer.head.data.length : r2.buffer[0].length : r2.length)) : null;
          var r2;
        };
      }, {}], 75: [function(e, t, r) {
        "use strict";
        var n = e("safe-buffer").Buffer, i = n.isEncoding || function(e2) {
          switch ((e2 = "" + e2) && e2.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        function o(e2) {
          var t2;
          switch (this.encoding = function(e3) {
            var t3 = function(e4) {
              if (!e4)
                return "utf8";
              for (var t4; ; )
                switch (e4) {
                  case "utf8":
                  case "utf-8":
                    return "utf8";
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return "utf16le";
                  case "latin1":
                  case "binary":
                    return "latin1";
                  case "base64":
                  case "ascii":
                  case "hex":
                    return e4;
                  default:
                    if (t4)
                      return;
                    e4 = ("" + e4).toLowerCase(), t4 = true;
                }
            }(e3);
            if ("string" != typeof t3 && (n.isEncoding === i || !i(e3)))
              throw new Error("Unknown encoding: " + e3);
            return t3 || e3;
          }(e2), this.encoding) {
            case "utf16le":
              this.text = l, this.end = u, t2 = 4;
              break;
            case "utf8":
              this.fillLast = a, t2 = 4;
              break;
            case "base64":
              this.text = c, this.end = h, t2 = 3;
              break;
            default:
              return this.write = f, void (this.end = p);
          }
          this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(t2);
        }
        function s(e2) {
          return e2 <= 127 ? 0 : e2 >> 5 == 6 ? 2 : e2 >> 4 == 14 ? 3 : e2 >> 3 == 30 ? 4 : e2 >> 6 == 2 ? -1 : -2;
        }
        function a(e2) {
          var t2 = this.lastTotal - this.lastNeed, r2 = function(e3, t3, r3) {
            if (128 != (192 & t3[0]))
              return e3.lastNeed = 0, "";
            if (e3.lastNeed > 1 && t3.length > 1) {
              if (128 != (192 & t3[1]))
                return e3.lastNeed = 1, "";
              if (e3.lastNeed > 2 && t3.length > 2 && 128 != (192 & t3[2]))
                return e3.lastNeed = 2, "";
            }
          }(this, e2);
          return void 0 !== r2 ? r2 : this.lastNeed <= e2.length ? (e2.copy(this.lastChar, t2, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e2.copy(this.lastChar, t2, 0, e2.length), void (this.lastNeed -= e2.length));
        }
        function l(e2, t2) {
          if ((e2.length - t2) % 2 == 0) {
            var r2 = e2.toString("utf16le", t2);
            if (r2) {
              var n2 = r2.charCodeAt(r2.length - 1);
              if (n2 >= 55296 && n2 <= 56319)
                return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1], r2.slice(0, -1);
            }
            return r2;
          }
          return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e2[e2.length - 1], e2.toString("utf16le", t2, e2.length - 1);
        }
        function u(e2) {
          var t2 = e2 && e2.length ? this.write(e2) : "";
          if (this.lastNeed) {
            var r2 = this.lastTotal - this.lastNeed;
            return t2 + this.lastChar.toString("utf16le", 0, r2);
          }
          return t2;
        }
        function c(e2, t2) {
          var r2 = (e2.length - t2) % 3;
          return 0 === r2 ? e2.toString("base64", t2) : (this.lastNeed = 3 - r2, this.lastTotal = 3, 1 === r2 ? this.lastChar[0] = e2[e2.length - 1] : (this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1]), e2.toString("base64", t2, e2.length - r2));
        }
        function h(e2) {
          var t2 = e2 && e2.length ? this.write(e2) : "";
          return this.lastNeed ? t2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t2;
        }
        function f(e2) {
          return e2.toString(this.encoding);
        }
        function p(e2) {
          return e2 && e2.length ? this.write(e2) : "";
        }
        r.StringDecoder = o, o.prototype.write = function(e2) {
          if (0 === e2.length)
            return "";
          var t2, r2;
          if (this.lastNeed) {
            if (void 0 === (t2 = this.fillLast(e2)))
              return "";
            r2 = this.lastNeed, this.lastNeed = 0;
          } else
            r2 = 0;
          return r2 < e2.length ? t2 ? t2 + this.text(e2, r2) : this.text(e2, r2) : t2 || "";
        }, o.prototype.end = function(e2) {
          var t2 = e2 && e2.length ? this.write(e2) : "";
          return this.lastNeed ? t2 + "" : t2;
        }, o.prototype.text = function(e2, t2) {
          var r2 = function(e3, t3, r3) {
            var n3 = t3.length - 1;
            if (n3 < r3)
              return 0;
            var i2 = s(t3[n3]);
            if (i2 >= 0)
              return i2 > 0 && (e3.lastNeed = i2 - 1), i2;
            if (--n3 < r3 || -2 === i2)
              return 0;
            if ((i2 = s(t3[n3])) >= 0)
              return i2 > 0 && (e3.lastNeed = i2 - 2), i2;
            if (--n3 < r3 || -2 === i2)
              return 0;
            if ((i2 = s(t3[n3])) >= 0)
              return i2 > 0 && (2 === i2 ? i2 = 0 : e3.lastNeed = i2 - 3), i2;
            return 0;
          }(this, e2, t2);
          if (!this.lastNeed)
            return e2.toString("utf8", t2);
          this.lastTotal = r2;
          var n2 = e2.length - (r2 - this.lastNeed);
          return e2.copy(this.lastChar, 0, n2), e2.toString("utf8", t2, n2);
        }, o.prototype.fillLast = function(e2) {
          if (this.lastNeed <= e2.length)
            return e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e2.length), this.lastNeed -= e2.length;
        };
      }, { "safe-buffer": 73 }], 76: [function(e, t, r) {
        "use strict";
        var n = e("punycode"), i = e("./util");
        function o() {
          this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
        }
        r.parse = v, r.resolve = function(e2, t2) {
          return v(e2, false, true).resolve(t2);
        }, r.resolveObject = function(e2, t2) {
          return e2 ? v(e2, false, true).resolveObject(t2) : t2;
        }, r.format = function(e2) {
          i.isString(e2) && (e2 = v(e2));
          return e2 instanceof o ? e2.format() : o.prototype.format.call(e2);
        }, r.Url = o;
        var s = /^([a-z0-9.+-]+:)/i, a = /:[0-9]*$/, l = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, u = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]), c = ["'"].concat(u), h = ["%", "/", "?", ";", "#"].concat(c), f = ["/", "?", "#"], p = /^[+a-z0-9A-Z_-]{0,63}$/, d = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, g = { javascript: true, "javascript:": true }, y = { javascript: true, "javascript:": true }, b = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, m = e("querystring");
        function v(e2, t2, r2) {
          if (e2 && i.isObject(e2) && e2 instanceof o)
            return e2;
          var n2 = new o();
          return n2.parse(e2, t2, r2), n2;
        }
        o.prototype.parse = function(e2, t2, r2) {
          if (!i.isString(e2))
            throw new TypeError("Parameter 'url' must be a string, not " + typeof e2);
          var o2 = e2.indexOf("?"), a2 = -1 !== o2 && o2 < e2.indexOf("#") ? "?" : "#", u2 = e2.split(a2);
          u2[0] = u2[0].replace(/\\/g, "/");
          var v2 = e2 = u2.join(a2);
          if (v2 = v2.trim(), !r2 && 1 === e2.split("#").length) {
            var w = l.exec(v2);
            if (w)
              return this.path = v2, this.href = v2, this.pathname = w[1], w[2] ? (this.search = w[2], this.query = t2 ? m.parse(this.search.substr(1)) : this.search.substr(1)) : t2 && (this.search = "", this.query = {}), this;
          }
          var _ = s.exec(v2);
          if (_) {
            var k = (_ = _[0]).toLowerCase();
            this.protocol = k, v2 = v2.substr(_.length);
          }
          if (r2 || _ || v2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var S = "//" === v2.substr(0, 2);
            !S || _ && y[_] || (v2 = v2.substr(2), this.slashes = true);
          }
          if (!y[_] && (S || _ && !b[_])) {
            for (var E, C, T = -1, x = 0; x < f.length; x++) {
              -1 !== (A = v2.indexOf(f[x])) && (-1 === T || A < T) && (T = A);
            }
            -1 !== (C = -1 === T ? v2.lastIndexOf("@") : v2.lastIndexOf("@", T)) && (E = v2.slice(0, C), v2 = v2.slice(C + 1), this.auth = decodeURIComponent(E)), T = -1;
            for (x = 0; x < h.length; x++) {
              var A;
              -1 !== (A = v2.indexOf(h[x])) && (-1 === T || A < T) && (T = A);
            }
            -1 === T && (T = v2.length), this.host = v2.slice(0, T), v2 = v2.slice(T), this.parseHost(), this.hostname = this.hostname || "";
            var I = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
            if (!I)
              for (var P = this.hostname.split(/\./), O = (x = 0, P.length); x < O; x++) {
                var B = P[x];
                if (B && !B.match(p)) {
                  for (var R = "", M = 0, N = B.length; M < N; M++)
                    B.charCodeAt(M) > 127 ? R += "x" : R += B[M];
                  if (!R.match(p)) {
                    var L = P.slice(0, x), j = P.slice(x + 1), U = B.match(d);
                    U && (L.push(U[1]), j.unshift(U[2])), j.length && (v2 = "/" + j.join(".") + v2), this.hostname = L.join(".");
                    break;
                  }
                }
              }
            this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), I || (this.hostname = n.toASCII(this.hostname));
            var q = this.port ? ":" + this.port : "", D = this.hostname || "";
            this.host = D + q, this.href += this.host, I && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== v2[0] && (v2 = "/" + v2));
          }
          if (!g[k])
            for (x = 0, O = c.length; x < O; x++) {
              var z = c[x];
              if (-1 !== v2.indexOf(z)) {
                var F = encodeURIComponent(z);
                F === z && (F = escape(z)), v2 = v2.split(z).join(F);
              }
            }
          var V = v2.indexOf("#");
          -1 !== V && (this.hash = v2.substr(V), v2 = v2.slice(0, V));
          var H = v2.indexOf("?");
          if (-1 !== H ? (this.search = v2.substr(H), this.query = v2.substr(H + 1), t2 && (this.query = m.parse(this.query)), v2 = v2.slice(0, H)) : t2 && (this.search = "", this.query = {}), v2 && (this.pathname = v2), b[k] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
            q = this.pathname || "";
            var W = this.search || "";
            this.path = q + W;
          }
          return this.href = this.format(), this;
        }, o.prototype.format = function() {
          var e2 = this.auth || "";
          e2 && (e2 = (e2 = encodeURIComponent(e2)).replace(/%3A/i, ":"), e2 += "@");
          var t2 = this.protocol || "", r2 = this.pathname || "", n2 = this.hash || "", o2 = false, s2 = "";
          this.host ? o2 = e2 + this.host : this.hostname && (o2 = e2 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (o2 += ":" + this.port)), this.query && i.isObject(this.query) && Object.keys(this.query).length && (s2 = m.stringify(this.query));
          var a2 = this.search || s2 && "?" + s2 || "";
          return t2 && ":" !== t2.substr(-1) && (t2 += ":"), this.slashes || (!t2 || b[t2]) && false !== o2 ? (o2 = "//" + (o2 || ""), r2 && "/" !== r2.charAt(0) && (r2 = "/" + r2)) : o2 || (o2 = ""), n2 && "#" !== n2.charAt(0) && (n2 = "#" + n2), a2 && "?" !== a2.charAt(0) && (a2 = "?" + a2), t2 + o2 + (r2 = r2.replace(/[?#]/g, function(e3) {
            return encodeURIComponent(e3);
          })) + (a2 = a2.replace("#", "%23")) + n2;
        }, o.prototype.resolve = function(e2) {
          return this.resolveObject(v(e2, false, true)).format();
        }, o.prototype.resolveObject = function(e2) {
          if (i.isString(e2)) {
            var t2 = new o();
            t2.parse(e2, false, true), e2 = t2;
          }
          for (var r2 = new o(), n2 = Object.keys(this), s2 = 0; s2 < n2.length; s2++) {
            var a2 = n2[s2];
            r2[a2] = this[a2];
          }
          if (r2.hash = e2.hash, "" === e2.href)
            return r2.href = r2.format(), r2;
          if (e2.slashes && !e2.protocol) {
            for (var l2 = Object.keys(e2), u2 = 0; u2 < l2.length; u2++) {
              var c2 = l2[u2];
              "protocol" !== c2 && (r2[c2] = e2[c2]);
            }
            return b[r2.protocol] && r2.hostname && !r2.pathname && (r2.path = r2.pathname = "/"), r2.href = r2.format(), r2;
          }
          if (e2.protocol && e2.protocol !== r2.protocol) {
            if (!b[e2.protocol]) {
              for (var h2 = Object.keys(e2), f2 = 0; f2 < h2.length; f2++) {
                var p2 = h2[f2];
                r2[p2] = e2[p2];
              }
              return r2.href = r2.format(), r2;
            }
            if (r2.protocol = e2.protocol, e2.host || y[e2.protocol])
              r2.pathname = e2.pathname;
            else {
              for (var d2 = (e2.pathname || "").split("/"); d2.length && !(e2.host = d2.shift()); )
                ;
              e2.host || (e2.host = ""), e2.hostname || (e2.hostname = ""), "" !== d2[0] && d2.unshift(""), d2.length < 2 && d2.unshift(""), r2.pathname = d2.join("/");
            }
            if (r2.search = e2.search, r2.query = e2.query, r2.host = e2.host || "", r2.auth = e2.auth, r2.hostname = e2.hostname || e2.host, r2.port = e2.port, r2.pathname || r2.search) {
              var g2 = r2.pathname || "", m2 = r2.search || "";
              r2.path = g2 + m2;
            }
            return r2.slashes = r2.slashes || e2.slashes, r2.href = r2.format(), r2;
          }
          var v2 = r2.pathname && "/" === r2.pathname.charAt(0), w = e2.host || e2.pathname && "/" === e2.pathname.charAt(0), _ = w || v2 || r2.host && e2.pathname, k = _, S = r2.pathname && r2.pathname.split("/") || [], E = (d2 = e2.pathname && e2.pathname.split("/") || [], r2.protocol && !b[r2.protocol]);
          if (E && (r2.hostname = "", r2.port = null, r2.host && ("" === S[0] ? S[0] = r2.host : S.unshift(r2.host)), r2.host = "", e2.protocol && (e2.hostname = null, e2.port = null, e2.host && ("" === d2[0] ? d2[0] = e2.host : d2.unshift(e2.host)), e2.host = null), _ = _ && ("" === d2[0] || "" === S[0])), w)
            r2.host = e2.host || "" === e2.host ? e2.host : r2.host, r2.hostname = e2.hostname || "" === e2.hostname ? e2.hostname : r2.hostname, r2.search = e2.search, r2.query = e2.query, S = d2;
          else if (d2.length)
            S || (S = []), S.pop(), S = S.concat(d2), r2.search = e2.search, r2.query = e2.query;
          else if (!i.isNullOrUndefined(e2.search)) {
            if (E)
              r2.hostname = r2.host = S.shift(), (I = !!(r2.host && r2.host.indexOf("@") > 0) && r2.host.split("@")) && (r2.auth = I.shift(), r2.host = r2.hostname = I.shift());
            return r2.search = e2.search, r2.query = e2.query, i.isNull(r2.pathname) && i.isNull(r2.search) || (r2.path = (r2.pathname ? r2.pathname : "") + (r2.search ? r2.search : "")), r2.href = r2.format(), r2;
          }
          if (!S.length)
            return r2.pathname = null, r2.search ? r2.path = "/" + r2.search : r2.path = null, r2.href = r2.format(), r2;
          for (var C = S.slice(-1)[0], T = (r2.host || e2.host || S.length > 1) && ("." === C || ".." === C) || "" === C, x = 0, A = S.length; A >= 0; A--)
            "." === (C = S[A]) ? S.splice(A, 1) : ".." === C ? (S.splice(A, 1), x++) : x && (S.splice(A, 1), x--);
          if (!_ && !k)
            for (; x--; x)
              S.unshift("..");
          !_ || "" === S[0] || S[0] && "/" === S[0].charAt(0) || S.unshift(""), T && "/" !== S.join("/").substr(-1) && S.push("");
          var I, P = "" === S[0] || S[0] && "/" === S[0].charAt(0);
          E && (r2.hostname = r2.host = P ? "" : S.length ? S.shift() : "", (I = !!(r2.host && r2.host.indexOf("@") > 0) && r2.host.split("@")) && (r2.auth = I.shift(), r2.host = r2.hostname = I.shift()));
          return (_ = _ || r2.host && S.length) && !P && S.unshift(""), S.length ? r2.pathname = S.join("/") : (r2.pathname = null, r2.path = null), i.isNull(r2.pathname) && i.isNull(r2.search) || (r2.path = (r2.pathname ? r2.pathname : "") + (r2.search ? r2.search : "")), r2.auth = e2.auth || r2.auth, r2.slashes = r2.slashes || e2.slashes, r2.href = r2.format(), r2;
        }, o.prototype.parseHost = function() {
          var e2 = this.host, t2 = a.exec(e2);
          t2 && (":" !== (t2 = t2[0]) && (this.port = t2.substr(1)), e2 = e2.substr(0, e2.length - t2.length)), e2 && (this.hostname = e2);
        };
      }, { "./util": 77, punycode: 51, querystring: 54 }], 77: [function(e, t, r) {
        "use strict";
        t.exports = { isString: function(e2) {
          return "string" == typeof e2;
        }, isObject: function(e2) {
          return "object" == typeof e2 && null !== e2;
        }, isNull: function(e2) {
          return null === e2;
        }, isNullOrUndefined: function(e2) {
          return null == e2;
        } };
      }, {}], 78: [function(e, t, r) {
        (function(e2) {
          (function() {
            function r2(t2) {
              try {
                if (!e2.localStorage)
                  return false;
              } catch (e3) {
                return false;
              }
              var r3 = e2.localStorage[t2];
              return null != r3 && "true" === String(r3).toLowerCase();
            }
            t.exports = function(e3, t2) {
              if (r2("noDeprecation"))
                return e3;
              var n = false;
              return function() {
                if (!n) {
                  if (r2("throwDeprecation"))
                    throw new Error(t2);
                  r2("traceDeprecation") ? console.trace(t2) : console.warn(t2), n = true;
                }
                return e3.apply(this, arguments);
              };
            };
          }).call(this);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 79: [function(e, t, r) {
        t.exports = function e2(t2, r2) {
          if (t2 && r2)
            return e2(t2)(r2);
          if ("function" != typeof t2)
            throw new TypeError("need wrapper function");
          Object.keys(t2).forEach(function(e3) {
            n[e3] = t2[e3];
          });
          return n;
          function n() {
            for (var e3 = new Array(arguments.length), r3 = 0; r3 < e3.length; r3++)
              e3[r3] = arguments[r3];
            var n2 = t2.apply(this, e3), i = e3[e3.length - 1];
            return "function" == typeof n2 && n2 !== i && Object.keys(i).forEach(function(e4) {
              n2[e4] = i[e4];
            }), n2;
          }
        };
      }, {}], 80: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object");
        };
      }, {}], 81: [function(e, t, r) {
        t.exports = function() {
          for (var e2 = {}, t2 = 0; t2 < arguments.length; t2++) {
            var r2 = arguments[t2];
            for (var i in r2)
              n.call(r2, i) && (e2[i] = r2[i]);
          }
          return e2;
        };
        var n = Object.prototype.hasOwnProperty;
      }, {}], 82: [function(e, t, r) {
        "use strict";
        t.exports = function(e2) {
          e2.prototype[Symbol.iterator] = function* () {
            for (let e3 = this.head; e3; e3 = e3.next)
              yield e3.value;
          };
        };
      }, {}], 83: [function(e, t, r) {
        "use strict";
        function n(e2) {
          var t2 = this;
          if (t2 instanceof n || (t2 = new n()), t2.tail = null, t2.head = null, t2.length = 0, e2 && "function" == typeof e2.forEach)
            e2.forEach(function(e3) {
              t2.push(e3);
            });
          else if (arguments.length > 0)
            for (var r2 = 0, i2 = arguments.length; r2 < i2; r2++)
              t2.push(arguments[r2]);
          return t2;
        }
        function i(e2, t2, r2) {
          var n2 = t2 === e2.head ? new a(r2, null, t2, e2) : new a(r2, t2, t2.next, e2);
          return null === n2.next && (e2.tail = n2), null === n2.prev && (e2.head = n2), e2.length++, n2;
        }
        function o(e2, t2) {
          e2.tail = new a(t2, e2.tail, null, e2), e2.head || (e2.head = e2.tail), e2.length++;
        }
        function s(e2, t2) {
          e2.head = new a(t2, null, e2.head, e2), e2.tail || (e2.tail = e2.head), e2.length++;
        }
        function a(e2, t2, r2, n2) {
          if (!(this instanceof a))
            return new a(e2, t2, r2, n2);
          this.list = n2, this.value = e2, t2 ? (t2.next = this, this.prev = t2) : this.prev = null, r2 ? (r2.prev = this, this.next = r2) : this.next = null;
        }
        t.exports = n, n.Node = a, n.create = n, n.prototype.removeNode = function(e2) {
          if (e2.list !== this)
            throw new Error("removing node which does not belong to this list");
          var t2 = e2.next, r2 = e2.prev;
          return t2 && (t2.prev = r2), r2 && (r2.next = t2), e2 === this.head && (this.head = t2), e2 === this.tail && (this.tail = r2), e2.list.length--, e2.next = null, e2.prev = null, e2.list = null, t2;
        }, n.prototype.unshiftNode = function(e2) {
          if (e2 !== this.head) {
            e2.list && e2.list.removeNode(e2);
            var t2 = this.head;
            e2.list = this, e2.next = t2, t2 && (t2.prev = e2), this.head = e2, this.tail || (this.tail = e2), this.length++;
          }
        }, n.prototype.pushNode = function(e2) {
          if (e2 !== this.tail) {
            e2.list && e2.list.removeNode(e2);
            var t2 = this.tail;
            e2.list = this, e2.prev = t2, t2 && (t2.next = e2), this.tail = e2, this.head || (this.head = e2), this.length++;
          }
        }, n.prototype.push = function() {
          for (var e2 = 0, t2 = arguments.length; e2 < t2; e2++)
            o(this, arguments[e2]);
          return this.length;
        }, n.prototype.unshift = function() {
          for (var e2 = 0, t2 = arguments.length; e2 < t2; e2++)
            s(this, arguments[e2]);
          return this.length;
        }, n.prototype.pop = function() {
          if (this.tail) {
            var e2 = this.tail.value;
            return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e2;
          }
        }, n.prototype.shift = function() {
          if (this.head) {
            var e2 = this.head.value;
            return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e2;
          }
        }, n.prototype.forEach = function(e2, t2) {
          t2 = t2 || this;
          for (var r2 = this.head, n2 = 0; null !== r2; n2++)
            e2.call(t2, r2.value, n2, this), r2 = r2.next;
        }, n.prototype.forEachReverse = function(e2, t2) {
          t2 = t2 || this;
          for (var r2 = this.tail, n2 = this.length - 1; null !== r2; n2--)
            e2.call(t2, r2.value, n2, this), r2 = r2.prev;
        }, n.prototype.get = function(e2) {
          for (var t2 = 0, r2 = this.head; null !== r2 && t2 < e2; t2++)
            r2 = r2.next;
          if (t2 === e2 && null !== r2)
            return r2.value;
        }, n.prototype.getReverse = function(e2) {
          for (var t2 = 0, r2 = this.tail; null !== r2 && t2 < e2; t2++)
            r2 = r2.prev;
          if (t2 === e2 && null !== r2)
            return r2.value;
        }, n.prototype.map = function(e2, t2) {
          t2 = t2 || this;
          for (var r2 = new n(), i2 = this.head; null !== i2; )
            r2.push(e2.call(t2, i2.value, this)), i2 = i2.next;
          return r2;
        }, n.prototype.mapReverse = function(e2, t2) {
          t2 = t2 || this;
          for (var r2 = new n(), i2 = this.tail; null !== i2; )
            r2.push(e2.call(t2, i2.value, this)), i2 = i2.prev;
          return r2;
        }, n.prototype.reduce = function(e2, t2) {
          var r2, n2 = this.head;
          if (arguments.length > 1)
            r2 = t2;
          else {
            if (!this.head)
              throw new TypeError("Reduce of empty list with no initial value");
            n2 = this.head.next, r2 = this.head.value;
          }
          for (var i2 = 0; null !== n2; i2++)
            r2 = e2(r2, n2.value, i2), n2 = n2.next;
          return r2;
        }, n.prototype.reduceReverse = function(e2, t2) {
          var r2, n2 = this.tail;
          if (arguments.length > 1)
            r2 = t2;
          else {
            if (!this.tail)
              throw new TypeError("Reduce of empty list with no initial value");
            n2 = this.tail.prev, r2 = this.tail.value;
          }
          for (var i2 = this.length - 1; null !== n2; i2--)
            r2 = e2(r2, n2.value, i2), n2 = n2.prev;
          return r2;
        }, n.prototype.toArray = function() {
          for (var e2 = new Array(this.length), t2 = 0, r2 = this.head; null !== r2; t2++)
            e2[t2] = r2.value, r2 = r2.next;
          return e2;
        }, n.prototype.toArrayReverse = function() {
          for (var e2 = new Array(this.length), t2 = 0, r2 = this.tail; null !== r2; t2++)
            e2[t2] = r2.value, r2 = r2.prev;
          return e2;
        }, n.prototype.slice = function(e2, t2) {
          (t2 = t2 || this.length) < 0 && (t2 += this.length), (e2 = e2 || 0) < 0 && (e2 += this.length);
          var r2 = new n();
          if (t2 < e2 || t2 < 0)
            return r2;
          e2 < 0 && (e2 = 0), t2 > this.length && (t2 = this.length);
          for (var i2 = 0, o2 = this.head; null !== o2 && i2 < e2; i2++)
            o2 = o2.next;
          for (; null !== o2 && i2 < t2; i2++, o2 = o2.next)
            r2.push(o2.value);
          return r2;
        }, n.prototype.sliceReverse = function(e2, t2) {
          (t2 = t2 || this.length) < 0 && (t2 += this.length), (e2 = e2 || 0) < 0 && (e2 += this.length);
          var r2 = new n();
          if (t2 < e2 || t2 < 0)
            return r2;
          e2 < 0 && (e2 = 0), t2 > this.length && (t2 = this.length);
          for (var i2 = this.length, o2 = this.tail; null !== o2 && i2 > t2; i2--)
            o2 = o2.prev;
          for (; null !== o2 && i2 > e2; i2--, o2 = o2.prev)
            r2.push(o2.value);
          return r2;
        }, n.prototype.splice = function(e2, t2, ...r2) {
          e2 > this.length && (e2 = this.length - 1), e2 < 0 && (e2 = this.length + e2);
          for (var n2 = 0, o2 = this.head; null !== o2 && n2 < e2; n2++)
            o2 = o2.next;
          var s2 = [];
          for (n2 = 0; o2 && n2 < t2; n2++)
            s2.push(o2.value), o2 = this.removeNode(o2);
          null === o2 && (o2 = this.tail), o2 !== this.head && o2 !== this.tail && (o2 = o2.prev);
          for (n2 = 0; n2 < r2.length; n2++)
            o2 = i(this, o2, r2[n2]);
          return s2;
        }, n.prototype.reverse = function() {
          for (var e2 = this.head, t2 = this.tail, r2 = e2; null !== r2; r2 = r2.prev) {
            var n2 = r2.prev;
            r2.prev = r2.next, r2.next = n2;
          }
          return this.head = t2, this.tail = e2, this;
        };
        try {
          e("./iterator.js")(n);
        } catch (e2) {
        }
      }, { "./iterator.js": 82 }] }, {}, [12])(12);
    });
  }
});

// node_modules/@meta2d/core/src/pen/model.js
var PenType;
(function(PenType2) {
  PenType2[PenType2["Node"] = 0] = "Node";
  PenType2[PenType2["Line"] = 1] = "Line";
})(PenType || (PenType = {}));
var LockState;
(function(LockState2) {
  LockState2[LockState2["None"] = 0] = "None";
  LockState2[LockState2["DisableEdit"] = 1] = "DisableEdit";
  LockState2[LockState2["DisableMove"] = 2] = "DisableMove";
  LockState2[LockState2["DisableScale"] = 3] = "DisableScale";
  LockState2[LockState2["DisableMoveScale"] = 4] = "DisableMoveScale";
  LockState2[LockState2["Disable"] = 10] = "Disable";
})(LockState || (LockState = {}));
var AnchorMode;
(function(AnchorMode2) {
  AnchorMode2[AnchorMode2["Default"] = 0] = "Default";
  AnchorMode2[AnchorMode2["In"] = 1] = "In";
  AnchorMode2[AnchorMode2["Out"] = 2] = "Out";
})(AnchorMode || (AnchorMode = {}));
var Gradient;
(function(Gradient2) {
  Gradient2[Gradient2["None"] = 0] = "None";
  Gradient2[Gradient2["Linear"] = 1] = "Linear";
  Gradient2[Gradient2["Radial"] = 2] = "Radial";
})(Gradient || (Gradient = {}));
var CanvasLayer;
(function(CanvasLayer2) {
  CanvasLayer2[CanvasLayer2["CanvasTemplate"] = 1] = "CanvasTemplate";
  CanvasLayer2[CanvasLayer2["CanvasImageBottom"] = 2] = "CanvasImageBottom";
  CanvasLayer2[CanvasLayer2["CanvasMain"] = 3] = "CanvasMain";
  CanvasLayer2[CanvasLayer2["CanvasImage"] = 4] = "CanvasImage";
})(CanvasLayer || (CanvasLayer = {}));
var needCalcTextRectProps = [
  "text",
  "textWidth",
  "textHeight",
  "textLeft",
  "textTop",
  "fontFamily",
  "fontSize",
  "lineHeight",
  "fontStyle",
  "fontWeight",
  "textAlign",
  "textBaseline",
  "whiteSpace",
  "ellipsis",
  "keepDecimal"
];
var needSetPenProps = ["x", "y", "width", "height", "flipX", "flipY"];
var needPatchFlagsPenRectProps = [
  "paddingTop",
  "paddingRight",
  "paddingBottom",
  "paddingLeft",
  "flipX",
  "flipY",
  "visible",
  "showChild"
];
var needCalcIconRectProps = ["iconLeft", "iconTop", "iconRotate"];
var LineAnimateType;
(function(LineAnimateType2) {
  LineAnimateType2[LineAnimateType2["Normal"] = 0] = "Normal";
  LineAnimateType2[LineAnimateType2["Beads"] = 1] = "Beads";
  LineAnimateType2[LineAnimateType2["Dot"] = 2] = "Dot";
  LineAnimateType2[LineAnimateType2["Arrow"] = 3] = "Arrow";
  LineAnimateType2[LineAnimateType2["WaterDrop"] = 4] = "WaterDrop";
})(LineAnimateType || (LineAnimateType = {}));
var isDomShapes = [
  "gif",
  "iframe",
  "video",
  "echarts",
  "highcharts",
  "lightningCharts",
  "vue"
];
var isInteraction = [
  "radio",
  "checkbox",
  "button",
  "inputDom",
  "slider",
  "echarts"
];
var formatAttrs = /* @__PURE__ */ new Set([
  "borderRadius",
  // 'rotate',
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  "paddingBottom",
  "progress",
  "progressColor",
  "verticalProgress",
  "reverseProgress",
  // 'flip',
  "flipX",
  "flipY",
  "input",
  "lineDash",
  "lineCap",
  "lineJoin",
  "strokeType",
  "lineGradientFromColor",
  "lineGradientToColor",
  "lineGradientAngle",
  "color",
  "hoverColor",
  "activeColor",
  "lineWidth",
  "bkType",
  "gradientFromColor",
  "gradientToColor",
  "gradientAngle",
  "gradientRadius",
  "hoverBackground",
  "activeBackground",
  "globalAlpha",
  "anchorColor",
  "anchorRadius",
  "shadowColor",
  "shadowBlur",
  "shadowOffsetX",
  "shadowOffsetY",
  "textHasShadow",
  "fontFamily",
  "fontSize",
  "textColor",
  "hoverTextColor",
  "activeTextColor",
  "textBackground",
  "fontStyle",
  "fontWeight",
  "textAlign",
  "textBaseline",
  "lineHeight",
  "whiteSpace",
  "textWidth",
  "textHeight",
  "textLeft",
  "textTop",
  "ellipsis",
  "hiddenText",
  "keepDecimal",
  "borderWidth",
  "borderColor",
  "animateLineWidth",
  "lineAnimateType",
  "frames",
  "animateColor",
  "animateType",
  "animateReverse",
  "background",
  "gradientColors",
  "lineGradientColors",
  "animateLineWidth",
  "gradientSmooth",
  "lineSmooth",
  "animations"
]);
function clearLifeCycle(pen) {
  pen.onAdd = void 0;
  pen.onValue = void 0;
  pen.onBeforeValue = void 0;
  pen.onDestroy = void 0;
  pen.onMove = void 0;
  pen.onResize = void 0;
  pen.onRotate = void 0;
  pen.onClick = void 0;
  pen.onMouseEnter = void 0;
  pen.onMouseLeave = void 0;
  pen.onMouseDown = void 0;
  pen.onMouseMove = void 0;
  pen.onMouseUp = void 0;
  pen.onShowInput = void 0;
  pen.onInput = void 0;
  pen.onChangeId = void 0;
  pen.onBinds = void 0;
  pen.onStartVideo = void 0;
  pen.onPauseVideo = void 0;
  pen.onStopVideo = void 0;
  pen.onRenderPenRaw = void 0;
  pen.onKeyDown = void 0;
  pen.onContextmenu = void 0;
  pen.onScale = void 0;
  pen.onWheel = void 0;
  pen.onConnectLine = void 0;
}

// node_modules/@meta2d/core/src/data.js
var HoverType;
(function(HoverType2) {
  HoverType2[HoverType2["None"] = 0] = "None";
  HoverType2[HoverType2["LineAnchor"] = 1] = "LineAnchor";
  HoverType2[HoverType2["NodeAnchor"] = 2] = "NodeAnchor";
  HoverType2[HoverType2["Line"] = 3] = "Line";
  HoverType2[HoverType2["Node"] = 4] = "Node";
  HoverType2[HoverType2["Resize"] = 5] = "Resize";
  HoverType2[HoverType2["Rotate"] = 6] = "Rotate";
  HoverType2[HoverType2["LineAnchorPrev"] = 7] = "LineAnchorPrev";
  HoverType2[HoverType2["LineAnchorNext"] = 8] = "LineAnchorNext";
})(HoverType || (HoverType = {}));
var HotkeyType;
(function(HotkeyType2) {
  HotkeyType2[HotkeyType2["None"] = 0] = "None";
  HotkeyType2[HotkeyType2["Translate"] = 1] = "Translate";
  HotkeyType2[HotkeyType2["Select"] = 2] = "Select";
  HotkeyType2[HotkeyType2["Resize"] = 3] = "Resize";
  HotkeyType2[HotkeyType2["AddAnchor"] = 4] = "AddAnchor";
})(HotkeyType || (HotkeyType = {}));
var MouseRight;
(function(MouseRight2) {
  MouseRight2[MouseRight2["None"] = 0] = "None";
  MouseRight2[MouseRight2["Down"] = 1] = "Down";
  MouseRight2[MouseRight2["Translate"] = 2] = "Translate";
})(MouseRight || (MouseRight = {}));
var Direction;
(function(Direction2) {
  Direction2[Direction2["None"] = -1] = "None";
  Direction2[Direction2["Up"] = 0] = "Up";
  Direction2[Direction2["Right"] = 1] = "Right";
  Direction2[Direction2["Bottom"] = 2] = "Bottom";
  Direction2[Direction2["Left"] = 3] = "Left";
})(Direction || (Direction = {}));
var defaultCursors = [
  "nw-resize",
  "ne-resize",
  "se-resize",
  "sw-resize"
];
var rotatedCursors = [
  "n-resize",
  "e-resize",
  "s-resize",
  "w-resize"
];
var defaultDrawLineFns = ["curve", "polyline", "line"];
var inheritanceProps = [
  "dash",
  "lineWidth",
  "lineCap",
  "lineJoin",
  "strokeType",
  "color",
  "lineGradientFromColor",
  "lineGradientToColor",
  "lineGradientAngle",
  "globalAlpha",
  "bkType",
  "background",
  "gradientFromColor",
  "gradientToColor",
  "gradientAngle",
  "gradientRadius",
  "fontFamily",
  "fontSize",
  "textColor",
  "hoverTextColor",
  "activeTextColor",
  "textBackground",
  "fontStyle",
  "fontWeight",
  "textAlign",
  "textBaseline",
  "lineHeight",
  "whiteSpace",
  "textLeft",
  "textTop",
  "flipX",
  "flipY",
  "lineDash",
  "visible",
  "iconColor"
];

// node_modules/@meta2d/core/src/diagrams/rectangle.js
function rectangle(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  let wr = pen.calculative.borderRadius || 0, hr = wr;
  const { x, y, width, height, ex, ey } = pen.calculative.worldRect;
  if (wr < 1) {
    wr = width * wr;
    hr = height * hr;
  }
  let r = wr < hr ? wr : hr;
  if (width < 2 * r) {
    r = width / 2;
  }
  if (height < 2 * r) {
    r = height / 2;
  }
  path.moveTo(x + r, y);
  path.arcTo(ex, y, ex, ey, r);
  path.arcTo(ex, ey, x, ey, r);
  path.arcTo(x, ey, x, y, r);
  path.arcTo(x, y, ex, y, r);
  path.closePath();
  if (path instanceof Path2D) {
    return path;
  }
}
var square = rectangle;

// node_modules/@meta2d/core/src/diagrams/circle.js
function circle(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const { x, y, width, height } = pen.calculative.worldRect;
  path.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, Math.PI * 2);
  if (path instanceof Path2D) {
    return path;
  }
}

// node_modules/@meta2d/core/src/diagrams/svg/parse.js
var commandRegex = /^[\t\n\f\r ]*([MLHVZCSQTAmlhvzcsqta])[\t\n\f\r ]*/;
var flagRegex = /^[01]/;
var numberRegex = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/;
var commaWsp = /^(([\t\n\f\r ]+,?[\t\n\f\r ]*)|(,[\t\n\f\r ]*))/;
var grammar = {
  M: [numberRegex, numberRegex],
  L: [numberRegex, numberRegex],
  H: [numberRegex],
  V: [numberRegex],
  Z: [],
  C: [
    numberRegex,
    numberRegex,
    numberRegex,
    numberRegex,
    numberRegex,
    numberRegex
  ],
  S: [numberRegex, numberRegex, numberRegex, numberRegex],
  Q: [numberRegex, numberRegex, numberRegex, numberRegex],
  T: [numberRegex, numberRegex],
  A: [
    numberRegex,
    numberRegex,
    numberRegex,
    flagRegex,
    flagRegex,
    numberRegex,
    numberRegex
  ]
};
function parseSvgPath(path) {
  let cursor = 0;
  const commands = [];
  while (cursor < path.length) {
    const match = path.slice(cursor).match(commandRegex);
    if (match !== null) {
      const command = match[1];
      cursor += match[0].length;
      const parser = parseCommands(command, path, cursor);
      cursor = parser.cursor;
      commands.push(...parser.commands);
    } else {
      throw new Error("malformed path (first error at " + cursor + ")");
    }
  }
  return { commands };
}
function getRect(path) {
  let x = Infinity;
  let y = Infinity;
  let ex = -Infinity;
  let ey = -Infinity;
  calcWorldPositions(path);
  path.commands.forEach((item) => {
    item.worldPoints.forEach((num, index) => {
      if (index % 2 === 0) {
        if (num < x) {
          x = num;
        }
        if (num > ex) {
          ex = num;
        }
      } else {
        if (num < y) {
          y = num;
        }
        if (num > ey) {
          ey = num;
        }
      }
    });
  });
  --x;
  --y;
  return {
    x,
    y,
    ex,
    ey,
    width: ex - x + 1,
    height: ey - y + 1
  };
}
function translatePath(path, x, y) {
  if (y == null) {
    y = x;
  }
  path.commands.forEach((item, index) => {
    if (item.relative && index) {
      return;
    }
    switch (item.key) {
      case "A":
      case "a":
        item.values[5] += x;
        item.values[6] += y;
        break;
      case "V":
      case "v":
        item.values[0] += y;
        break;
      default:
        item.values.forEach((val, i) => {
          item.values[i] = val + (i % 2 === 0 ? x : y);
        });
        break;
    }
  });
}
function scalePath(path, x, y) {
  if (y == null) {
    y = x;
  }
  path.commands.forEach((item) => {
    switch (item.key) {
      case "A":
      case "a":
        const a = item.values[0];
        const b = item.values[1];
        const angle = Math.PI * item.values[2] / 180;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const A = b * b * y * y * cos * cos + a * a * y * y * sin * sin;
        const B = 2 * x * y * cos * sin * (b * b - a * a);
        const C = a * a * x * x * cos * cos + b * b * x * x * sin * sin;
        const F = -(a * a * b * b * x * x * y * y);
        const det = B * B - 4 * A * C;
        const val1 = Math.sqrt((A - C) * (A - C) + B * B);
        item.values[2] = B !== 0 ? Math.atan((C - A - val1) / B) * 180 / Math.PI : A < C ? 0 : 90;
        item.values[0] = -Math.sqrt(2 * det * F * (A + C + val1)) / det;
        item.values[1] = -Math.sqrt(2 * det * F * (A + C - val1)) / det;
        item.values[5] *= x;
        item.values[6] *= y;
        item.values[4] = x * y >= 0 ? item.values[4] : 1 - item.values[4];
        break;
      case "V":
      case "v":
        item.values[0] *= y;
        break;
      default:
        item.values.forEach((val, index) => {
          item.values[index] = val * (index % 2 === 0 ? x : y);
        });
        break;
    }
  });
}
function pathToString(path) {
  let text = "";
  path.commands.forEach((item) => {
    text += item.key + " ";
    item.values.forEach((num) => {
      text += num + " ";
    });
  });
  return text;
}
function parseCommands(type, path, cursor) {
  const expectedRegexList = grammar[type.toUpperCase()];
  const commands = [];
  while (cursor <= path.length) {
    const command = { key: type, values: [] };
    for (const regex of expectedRegexList) {
      const match = path.slice(cursor).match(regex);
      if (match !== null) {
        command.values.push(+match[0]);
        cursor += match[0].length;
        const ws = path.slice(cursor).match(commaWsp);
        if (ws !== null) {
          cursor += ws[0].length;
        }
      } else if (command.values.length === 0) {
        return { cursor, commands };
      } else {
        throw new Error("malformed path (first error at " + cursor + ")");
      }
    }
    command.relative = command.key.toUpperCase() !== command.key;
    commands.push(command);
    if (expectedRegexList.length === 0) {
      return { cursor, commands };
    }
    if (type === "m") {
      type = "l";
    }
    if (type === "M") {
      type = "L";
    }
  }
  throw new Error("malformed path (first error at " + cursor + ")");
}
function calcWorldPoints(command, previous) {
  const worldPoints = [];
  let current = command.relative && previous ? {
    x: previous.worldPoints[previous.worldPoints.length - 2],
    y: previous.worldPoints[previous.worldPoints.length - 1]
  } : { x: 0, y: 0 };
  for (let i = 0; i < command.values.length - 1; i += 2) {
    worldPoints.push(current.x + command.values[i]);
    worldPoints.push(current.y + command.values[i + 1]);
  }
  command.worldPoints = worldPoints;
}
function calcWorldPositions(path) {
  let previous;
  let x = 0;
  let y = 0;
  path.commands.forEach((item) => {
    switch (item.key) {
      case "Z":
      case "z":
        item.worldPoints = [x, y];
        break;
      case "H":
        item.worldPoints = [
          item.values[0],
          previous.worldPoints[previous.worldPoints.length - 1]
        ];
        break;
      case "h":
        item.worldPoints = [
          item.values[0] + previous.worldPoints[previous.worldPoints.length - 2],
          previous.worldPoints[previous.worldPoints.length - 1]
        ];
        break;
      case "V":
        item.worldPoints = [
          previous.worldPoints[previous.worldPoints.length - 2],
          item.values[0]
        ];
        break;
      case "v":
        item.worldPoints = [
          previous.worldPoints[previous.worldPoints.length - 2],
          item.values[0] + previous.worldPoints[previous.worldPoints.length - 1]
        ];
        break;
      case "A":
        item.worldPoints = [
          previous.worldPoints[previous.worldPoints.length - 2],
          item.values[0] + previous.worldPoints[previous.worldPoints.length - 1]
        ];
        break;
      default:
        calcWorldPoints(item, previous);
        break;
    }
    if (item.key === "M" || item.key === "m" || item.key === "Z" || item.key === "z") {
      x = item.worldPoints[item.worldPoints.length - 2];
      y = item.worldPoints[item.worldPoints.length - 1];
    }
    previous = item;
  });
}

// node_modules/@meta2d/core/src/diagrams/svgPath.js
function svgPath(pen, ctx) {
  var _a;
  const store = pen.calculative.canvas.store;
  const pathText = store.data.paths[pen.pathId];
  if (!pathText) {
    return new Path2D();
  }
  const path = parseSvgPath(pathText);
  pen.calculative.svgRect = getRect(path);
  calcCenter(pen.calculative.svgRect);
  if (pen.calculative.svgRect.width !== pen.calculative.worldRect.width || pen.calculative.svgRect.height !== pen.calculative.worldRect.height) {
    scalePath(path, pen.calculative.worldRect.width / pen.calculative.svgRect.width, pen.calculative.worldRect.height / pen.calculative.svgRect.height);
  }
  const rect = getRect(path);
  calcCenter(rect);
  translatePath(path, pen.calculative.worldRect.x - rect.x, pen.calculative.worldRect.y - rect.y);
  const pathStr = pathToString(path);
  if (ctx) {
    (_a = ctx.svgPath) == null ? void 0 : _a.call(ctx, pathStr);
    return;
  }
  const path2D = new Path2D(pathStr);
  return path2D;
}

// node_modules/@meta2d/core/src/diagrams/diamond.js
function diamond(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const { x, y, width, height } = pen.calculative.worldRect;
  path.moveTo(x + width / 2, y);
  path.lineTo(x + width, y + height / 2);
  path.lineTo(x + width / 2, y + height);
  path.lineTo(x, y + height / 2);
  path.lineTo(x + width / 2, y);
  path.closePath();
  if (path instanceof Path2D)
    return path;
}

// node_modules/@meta2d/core/src/diagrams/triangle.js
function triangle(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const { x, y, width, height } = pen.calculative.worldRect;
  path.moveTo(x + width / 2, y);
  path.lineTo(x + width, y + height);
  path.lineTo(x, y + height);
  path.lineTo(x + width / 2, y);
  path.closePath();
  if (path instanceof Path2D)
    return path;
}
function triangleAnchors(pen) {
  const points = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 0.75,
      y: 0.5
    },
    {
      x: 0.5,
      y: 1
    },
    {
      x: 0.25,
      y: 0.5
    }
  ];
  pen.anchors = points.map(({ x, y }, index) => {
    return {
      id: `${index}`,
      penId: pen.id,
      x,
      y
    };
  });
}

// node_modules/@meta2d/core/src/diagrams/pentagon.js
function pentagon(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const { x, y, width, height } = pen.calculative.worldRect;
  path.moveTo(x + width / 2, y);
  path.lineTo(x + width, y + height * 2 / 5);
  path.lineTo(x + width * 4 / 5, y + height);
  path.lineTo(x + width / 5, y + height);
  path.lineTo(x, y + height * 2 / 5);
  path.closePath();
  if (path instanceof Path2D)
    return path;
}
function pentagonAnchors(pen) {
  const points = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 1,
      y: 0.4
    },
    {
      x: 0.8,
      y: 1
    },
    {
      x: 0.2,
      y: 1
    },
    {
      x: 0,
      y: 0.4
    }
  ];
  pen.anchors = points.map(({ x, y }, index) => {
    return {
      id: `${index}`,
      penId: pen.id,
      x,
      y
    };
  });
}

// node_modules/@meta2d/core/src/diagrams/pentagram.js
function pentagram(pen, ctx) {
  if (!pen.onResize) {
    pen.onResize = resize;
  }
  const path = !ctx ? new Path2D() : ctx;
  const { width, height, center } = pen.calculative.worldRect;
  const r = width > height ? height : width;
  const centerx = center.x;
  const centery = center.y;
  const basey = centery - r / 2;
  const baseyi = centery - r / 4;
  const lx = -(baseyi - centery) * Math.sin(Math.PI / 180 * 324) + centerx;
  const ly = (baseyi - centery) * Math.cos(Math.PI / 180 * 324) + centery;
  path.moveTo(lx, ly);
  for (let i = 0; i < 5; ++i) {
    path.lineTo(-(basey - centery) * Math.sin(Math.PI / 180 * 72 * i) + centerx, (basey - centery) * Math.cos(Math.PI / 180 * 72 * i) + centery);
    path.lineTo((lx - centerx) * Math.cos(Math.PI / 180 * 72 * (i + 1)) - (ly - centery) * Math.sin(Math.PI / 180 * 72 * (i + 1)) + centerx, (lx - centerx) * Math.sin(Math.PI / 180 * 72 * (i + 1)) + (ly - centery) * Math.cos(Math.PI / 180 * 72 * (i + 1)) + centery);
  }
  path.closePath();
  if (path instanceof Path2D)
    return path;
}
function pentagramAnchors(pen) {
  const { width, height } = pen;
  const r = width > height ? height : width;
  const anchors = [];
  for (let i = 0; i < 5; ++i) {
    anchors.push({
      flag: 1,
      // 
      id: String(i),
      penId: pen.id,
      x: 0.5 + r / 2 * Math.sin(Math.PI / 180 * 72 * i) / width,
      y: -r / 2 * Math.cos(Math.PI / 180 * 72 * i) / height + 0.5
    });
  }
  pen.anchors = anchors;
}
function resize(pen) {
  const manualPoints = pen.anchors.filter((point) => point.flag !== 1);
  pentagramAnchors(pen);
  pen.anchors = pen.anchors.concat(...manualPoints);
}

// node_modules/@meta2d/core/src/diagrams/hexagon.js
function hexagon(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const { x, y, width, height } = pen.calculative.worldRect;
  path.moveTo(x + width / 4, y);
  path.lineTo(x + width * 3 / 4, y);
  path.lineTo(x + width, y + height / 2);
  path.lineTo(x + width * 3 / 4, y + height);
  path.lineTo(x + width * 1 / 4, y + height);
  path.lineTo(x, y + height / 2);
  path.lineTo(x + width / 4, y);
  path.closePath();
  if (path instanceof Path2D)
    return path;
}

// node_modules/@meta2d/core/src/diagrams/arrow.js
function leftArrow(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const { x, y, width, height } = pen.calculative.worldRect;
  path.moveTo(x, y + height / 2);
  path.lineTo(x + height / 2, y);
  path.lineTo(x + height / 2, y + height / 3);
  path.lineTo(x + width, y + height / 3);
  path.lineTo(x + width, y + height * 2 / 3);
  path.lineTo(x + height / 2, y + height * 2 / 3);
  path.lineTo(x + height / 2, y + height * 2 / 3);
  path.lineTo(x + height / 2, y + height);
  path.closePath();
  if (path instanceof Path2D)
    return path;
}
function rightArrow(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const { x, y, width, height } = pen.calculative.worldRect;
  path.moveTo(x, y + height / 3);
  path.lineTo(x + (width - height / 2), y + height / 3);
  path.lineTo(x + (width - height / 2), y);
  path.lineTo(x + width, y + height / 2);
  path.lineTo(x + (width - height / 2), y + height);
  path.lineTo(x + (width - height / 2), y + height * 2 / 3);
  path.lineTo(x, y + height * 2 / 3);
  path.closePath();
  if (path instanceof Path2D)
    return path;
}
function twowayArrow(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const { x, y, width, height } = pen.calculative.worldRect;
  path.moveTo(x, y + height / 2);
  path.lineTo(x + height / 2, y);
  path.lineTo(x + height / 2, y + height / 3);
  path.lineTo(x + (width - height / 2), y + height / 3);
  path.lineTo(x + (width - height / 2), y);
  path.lineTo(x + width, y + height / 2);
  path.lineTo(x + (width - height / 2), y + height);
  path.lineTo(x + (width - height / 2), y + height * 2 / 3);
  path.lineTo(x + height / 2, y + height * 2 / 3);
  path.lineTo(x + height / 2, y + height);
  path.closePath();
  if (path instanceof Path2D)
    return path;
}

// node_modules/@meta2d/core/src/diagrams/message.js
function message(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const { x, y, width, height, ey } = pen.calculative.worldRect;
  path.moveTo(x, y);
  path.lineTo(x + width, y);
  path.lineTo(x + width, y + height * 3 / 4);
  path.lineTo(x + width * 8 / 16, y + height * 3 / 4);
  path.lineTo(x + width / 4, ey);
  path.lineTo(x + width * 5 / 16, y + height * 3 / 4);
  path.lineTo(x, y + height * 3 / 4);
  path.closePath();
  if (path instanceof Path2D)
    return path;
}

// node_modules/@meta2d/core/src/diagrams/cloud.js
function cloud(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const { x, y, width, height } = pen.calculative.worldRect;
  path.moveTo(x + width / 5, y + height * 13 / 16);
  path.bezierCurveTo(x - width / 15, y + height * 13 / 16, x - width / 15, y + height * 7 / 16, x + width / 5, y + height * 7 / 16);
  path.bezierCurveTo(x + width / 5, y, x + width * 4 / 5, y, x + width * 4 / 5, y + height * 7 / 16);
  path.bezierCurveTo(x + width * 16 / 15, y + height * 7 / 16, x + width * 16 / 15, y + height * 13 / 16, x + width * 4 / 5, y + height * 13 / 16);
  path.closePath();
  if (path instanceof Path2D)
    return path;
}

// node_modules/@meta2d/core/src/diagrams/file.js
function file(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const { x, y, width, ex, ey } = pen.calculative.worldRect;
  const offsetX = width / 6;
  path.moveTo(x, y);
  path.lineTo(ex - offsetX, y);
  path.lineTo(ex, y + offsetX);
  path.lineTo(ex, ey);
  path.lineTo(x, ey);
  path.closePath();
  path.moveTo(ex - offsetX, y);
  path.lineTo(ex - offsetX, y + offsetX);
  path.lineTo(ex, y + offsetX);
  path.closePath();
  if (path instanceof Path2D)
    return path;
}

// node_modules/@meta2d/core/src/diagrams/cube.js
function cube(ctx, pen) {
  const { x, y, width, ex, ey } = pen.calculative.worldRect;
  let offset = width * 0.25;
  const z = pen.z;
  if (z > 1) {
    offset = z;
  } else if (z > 0) {
    offset = width * z;
  }
  const p1 = {
    x,
    y: y + offset
  };
  const p2 = {
    x: ex - offset,
    y: y + offset
  };
  const p3 = {
    x: ex - offset,
    y: ey
  };
  const p4 = {
    x,
    y: ey
  };
  face(ctx, [p1, p2, p3, p4], pen.backgroundFront || pen.background, pen.color);
  face(ctx, [
    p1,
    {
      x: x + offset,
      y
    },
    { x: ex, y },
    p2
  ], pen.backgroundUp || pen.background, pen.color);
  face(ctx, [
    p2,
    { x: ex, y },
    {
      x: ex,
      y: ey - offset
    },
    p3
  ], pen.backgroundRight || pen.background, pen.color);
}
function face(ctx, points, fillStyle = "", strokeStyle = "") {
  ctx.save();
  fillStyle && (ctx.fillStyle = fillStyle);
  strokeStyle && (ctx.strokeStyle = strokeStyle);
  ctx.beginPath();
  for (let i = 0; i < points.length; ++i) {
    if (i) {
      ctx.lineTo(points[i].x, points[i].y);
    } else {
      ctx.moveTo(points[i].x, points[i].y);
    }
  }
  ctx.closePath();
  fillStyle && ctx.fill();
  ctx.stroke();
  ctx.restore();
}

// node_modules/@meta2d/core/src/diagrams/people.js
function people(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const { x, y, width, ex, ey } = pen.calculative.worldRect;
  const r = width / 4;
  const middle = x + width / 2;
  path.arc(middle, y + r, r, 0, Math.PI * 2);
  path.moveTo(x, y + r * 3);
  path.lineTo(ex, y + r * 3);
  path.moveTo(middle, y + r * 2);
  path.lineTo(middle, y + r * 4);
  path.moveTo(middle, y + r * 4);
  path.lineTo(x, ey);
  path.moveTo(middle, y + r * 4);
  path.lineTo(ex, ey);
  path.closePath();
  if (path instanceof Path2D)
    return path;
}

// node_modules/@meta2d/core/src/utils/color.js
function pSBCr(d) {
  const i = parseInt, m = Math.round;
  let n = d.length, x = {};
  if (n > 9) {
    const [r, g, b, a] = d = d.split(",");
    n = d.length;
    if (n < 3 || n > 4)
      return null;
    x.r = i(r[3] == "a" ? r.slice(5) : r.slice(4)), x.g = i(g), x.b = i(b), x.a = a ? parseFloat(a) : -1;
  } else {
    if (n == 8 || n == 6 || n < 4)
      return null;
    if (n < 6)
      d = "#" + d[1] + d[1] + d[2] + d[2] + d[3] + d[3] + (n > 4 ? d[4] + d[4] : "");
    d = i(d.slice(1), 16);
    if (n == 9 || n == 5)
      x.r = d >> 24 & 255, x.g = d >> 16 & 255, x.b = d >> 8 & 255, x.a = m((d & 255) / 0.255) / 1e3;
    else
      x.r = d >> 16, x.g = d >> 8 & 255, x.b = d & 255, x.a = -1;
  }
  return x;
}
function pSBC(p, c0, c1, l) {
  let r, g, b, P, f, t, h, m = Math.round, a = typeof c1 == "string";
  if (typeof p != "number" || p < -1 || p > 1 || typeof c0 != "string" || c0[0] != "r" && c0[0] != "#" || c1 && !a)
    return null;
  h = c0.length > 9, h = a ? c1.length > 9 ? true : c1 == "c" ? !h : false : h, f = pSBCr(c0), P = p < 0, t = c1 && c1 != "c" ? pSBCr(c1) : P ? { r: 0, g: 0, b: 0, a: -1 } : { r: 255, g: 255, b: 255, a: -1 }, p = P ? p * -1 : p, P = 1 - p;
  if (!f || !t)
    return null;
  if (l)
    r = m(P * f.r + p * t.r), g = m(P * f.g + p * t.g), b = m(P * f.b + p * t.b);
  else
    r = m((P * f.r ** 2 + p * t.r ** 2) ** 0.5), g = m((P * f.g ** 2 + p * t.g ** 2) ** 0.5), b = m((P * f.b ** 2 + p * t.b ** 2) ** 0.5);
  a = f.a, t = t.a, f = a >= 0 || t >= 0, a = f ? a < 0 ? t : t < 0 ? a : a * P + t * p : 0;
  if (h)
    return "rgb" + (f ? "a(" : "(") + r + "," + g + "," + b + (f ? "," + m(a * 1e3) / 1e3 : "") + ")";
  else
    return "#" + (4294967296 + r * 16777216 + g * 65536 + b * 256 + (f ? m(a * 255) : 0)).toString(16).slice(1, f ? void 0 : -2);
}
globalThis.pSBC = pSBC;
function rgba(c, p) {
  const f = pSBCr(c) || { r: 0, g: 0, b: 0 };
  if (f.a < 0) {
    return `rgba(${f.r},${f.g},${f.b},${p})`;
  }
  return `rgba(${f.r},${f.g},${f.b},${p + f.a})`;
}

// node_modules/@meta2d/core/src/utils/math.js
function abs(num, percent) {
  if (+percent) {
    return +percent;
  }
  if (!percent || percent[percent.length - 1] !== "%") {
    return 0;
  }
  percent = percent.substr(0, percent.length - 1);
  return num * +percent / 100;
}
function valueInRange(realValue, collection) {
  if (isNaN(realValue)) {
    console.warn(`realValue not number`);
    return;
  }
  if (typeof collection !== "string") {
    console.warn("collection must be string");
    return;
  }
  const [start, end] = [collection[0], collection[collection.length - 1]];
  if (!["[", "("].includes(start)) {
    console.warn('collection must start with "[" or "("');
    return;
  }
  if (!["]", ")"].includes(end)) {
    console.warn('collection must end with "]" or ")"');
    return;
  }
  const nums = collection.substring(1, collection.length - 1).split(",");
  if (nums.length !== 2) {
    console.warn("collection must have 2 numbers");
    return;
  }
  const [startNum, endNum] = [+nums[0], +nums[1]];
  if (startNum >= endNum) {
    console.warn("startNum must less than endNum");
    return;
  }
  const left = realValue > startNum || start === "[" && realValue === startNum ? true : false;
  if (!left) {
    return false;
  }
  const right = realValue < endNum || end === "]" && realValue === endNum ? true : false;
  return right;
}
function valueInArray(realValue, collection) {
  if (typeof collection !== "string") {
    console.warn("collection must be string");
    return;
  }
  const [start, end] = [collection[0], collection[collection.length - 1]];
  if (start !== "[" || end !== "]") {
    console.warn('collection must start with "[" and end with "]"');
    return;
  }
  const numStrs = collection.substring(1, collection.length - 1).split(",");
  for (const numStr of numStrs) {
    if (numStr.includes("..")) {
      const [start2, end2] = numStr.split("..");
      const [startNum, endNum] = [+start2, +end2];
      if (startNum >= endNum) {
        console.warn("startNum must less than endNum");
        return;
      }
      if (realValue >= startNum && realValue <= endNum) {
        return true;
      }
    } else {
      if (realValue == numStr) {
        return true;
      }
    }
  }
  return false;
}

// node_modules/@meta2d/core/src/utils/uuid.js
function s4() {
  return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
}
function s8() {
  return ((1 + Math.random()) * 4294967296 | 0).toString(16).substring(1);
}
function s12() {
  return s4() + s8();
}
function s16() {
  return s8() + s8();
}

// node_modules/@meta2d/core/src/utils/padding.js
var formatPadding = (padding) => {
  let top = 0;
  let left = 0;
  let right = 0;
  let bottom = 0;
  if (typeof padding === "number") {
    top = left = right = bottom = padding;
  } else if (typeof padding === "string") {
    const intPadding = parseInt(padding, 10);
    top = left = right = bottom = intPadding;
  } else if (Array.isArray(padding)) {
    top = padding[0];
    right = !isNil(padding[1]) ? padding[1] : padding[0];
    bottom = !isNil(padding[2]) ? padding[2] : padding[0];
    left = !isNil(padding[3]) ? padding[3] : right;
  }
  return [top, right, bottom, left];
};
function isNil(value4) {
  return value4 == null;
}

// node_modules/@meta2d/core/src/utils/clone.js
function deepClone(o, keepCalc = false) {
  if (Array.isArray(o)) {
    const arr = [];
    o.forEach((item) => {
      arr.push(deepClone(item, keepCalc));
    });
    return arr;
  } else if (typeof o === "object") {
    if (o === null) {
      return null;
    } else if (o.constructor === RegExp) {
      return o;
    }
    const _o = {};
    for (const key in o) {
      if (["canvas", "lastFrame"].includes(key) || o[key] instanceof HTMLImageElement || o[key] instanceof HTMLMediaElement) {
        continue;
      } else if (key === "calculative" && !keepCalc) {
        continue;
      } else if (key === "singleton") {
        if (keepCalc) {
          _o[key] = {};
        } else {
          _o[key] = o[key];
        }
        continue;
      }
      _o[key] = deepClone(o[key], keepCalc);
    }
    return _o;
  }
  return o;
}
function deepSetValue(o, keyWords, value4) {
  if (Array.isArray(o)) {
    const arr = [];
    o.forEach((item) => {
      arr.push(deepSetValue(item, keyWords, value4));
    });
    return arr;
  } else if (typeof o === "object") {
    if (o === null) {
      return null;
    }
    for (const key in o) {
      if (keyWords.includes(key)) {
        if (Array.isArray(o[key])) {
          o[key].forEach((i, index) => {
            if (!Number.isNaN(Number(i))) {
              o[key][index] = Number(i * value4);
            }
          });
        } else {
          if (Number.isNaN(Number(o[key]))) {
            continue;
          }
          o[key] = Number(o[key]) * value4;
        }
      } else {
        o[key] = deepSetValue(o[key], keyWords, value4);
      }
    }
    return o;
  }
  return o;
}

// node_modules/@meta2d/core/src/utils/file.js
async function fileToBase64(file2) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      resolve(e.target.result);
    };
    reader.onerror = (e) => {
      reject(e);
    };
    reader.readAsDataURL(file2);
  });
}
async function uploadFile(file2, url, params, headers) {
  const formData = new FormData();
  formData.append("file", file2);
  if (params) {
    for (const key in params) {
      if (params.hasOwnProperty(key)) {
        formData.append(key, params[key]);
      }
    }
  }
  const res = await fetch(url, {
    method: "POST",
    headers,
    body: formData
  });
  return (await res.json()).url;
}
function loadCss(url, success, error) {
  var link = document.createElement("link");
  link.href = url;
  link.rel = "stylesheet";
  success && (link.onload = success);
  error && (link.onerror = error);
  document.head.appendChild(link);
}

// node_modules/@meta2d/core/src/utils/url.js
function queryURLParams(value4) {
  let url = value4 || window.location.search.split("?")[1];
  const urlSearchParams = new URLSearchParams(url);
  const params = Object.fromEntries(urlSearchParams.entries());
  return params;
}
var getRootDomain = () => {
  let domain = "";
  const domainItems = location.hostname.split(".");
  if (domainItems.length < 3 || domainItems.length === 4 && +domainItems[0] > 0 && +domainItems[1] > 0 && +domainItems[2] > 0 && +domainItems[3] > 0) {
    domain = location.hostname;
  } else if (location.hostname.endsWith(".com.cn") || location.hostname.endsWith(".org.cn")) {
    domain = domainItems.slice(-3).join(".");
  } else {
    domain = domainItems.slice(-2).join(".");
  }
  return domain;
};
function getCookie(name) {
  let arr;
  const reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)");
  if (arr = document.cookie.match(reg)) {
    return decodeURIComponent(arr[2]);
  } else {
    return "";
  }
}
var TokenType;
(function(TokenType2) {
  TokenType2[TokenType2["None"] = 0] = "None";
  TokenType2[TokenType2["LocalStorage"] = 1] = "LocalStorage";
  TokenType2[TokenType2["Cookie"] = 2] = "Cookie";
})(TokenType || (TokenType = {}));
var isLe5le = location.host.indexOf("le5le.com") !== -1;
function getToken() {
  const key = globalThis.le5leTokenName ?? "token";
  switch (globalThis.le5leTokenType) {
    case TokenType.LocalStorage:
      return localStorage.getItem(key);
    case TokenType.Cookie:
      return getCookie(key);
    default:
      const token = isLe5le ? getCookie(key) : localStorage.getItem(key);
      return token;
  }
}
async function getMeta2dData(store, id) {
  var _a, _b;
  if (globalThis.getMeta2dData) {
    return globalThis.getMeta2dData(id);
  }
  const netWork = store.options.navigatorNetWork;
  const collection = location.href.includes("2d.") || location.href.includes("/2d") ? "2d" : "v";
  let url = `/api/data/${collection}/get`;
  let hasId = ((_a = queryURLParams()) == null ? void 0 : _a.id) || url.includes("${id}");
  if (!hasId) {
    let d = (_b = queryURLParams()) == null ? void 0 : _b.data;
    if (d) {
      url = `./projects/${id}`;
    }
  }
  if (netWork == null ? void 0 : netWork.url) {
    if (netWork.url.includes("${id}")) {
      url = netWork.url.replace("${id}", id);
    } else {
      url = netWork.url + ((netWork == null ? void 0 : netWork.method) === "GET" ? `?id=${id}` : "");
    }
  }
  let method = (netWork == null ? void 0 : netWork.method) || "POST";
  if (!hasId) {
    method = "GET";
  }
  const res = await fetch(url, {
    headers: {
      Authorization: `Bearer ${getToken()}`
    },
    method,
    body: method === "GET" ? void 0 : JSON.stringify({ id })
  });
  if (res.ok) {
    let data = await res.text();
    if (data.constructor === Object || data.constructor === Array) {
      data = JSON.parse(JSON.stringify(data));
    } else if (typeof data === "string") {
      data = JSON.parse(data);
    }
    if (data.data) {
      data = data.data;
    }
    return data;
  } else {
    store.emitter.emit("error", { type: "http", error: res });
  }
}

// node_modules/@meta2d/core/src/utils/object.js
function getter(object, path) {
  if (path == void 0) {
    return object;
  }
  const arr = path.split(".");
  while (arr.length && (object = object[arr.shift()]))
    ;
  return object;
}
function setter(object, path, value4) {
  if (path == void 0) {
    return;
  }
  path.split(".").reduce((o, p, i) => o[p] = path.split(".").length === ++i ? value4 : o[p] || {}, object);
}

// node_modules/@meta2d/core/src/utils/time.js
function formatTime(format) {
  const weeks = ["", "", "", "", "", "", ""];
  const now = /* @__PURE__ */ new Date();
  const year = now.getFullYear();
  const month = now.getMonth() + 1;
  const day = now.getDate();
  const week = now.getDay();
  const hours = now.getHours();
  const minutes = now.getMinutes();
  const seconds = now.getSeconds();
  const fn = new Function("year", "month", "day", "week", "hours", "minutes", "seconds", format ? `return ${format}` : "return `${year}:${month}:${day} ${hours}:${minutes}:${seconds} ${week}`");
  const time = fn(year, month, day, weeks[week], hours, minutes, seconds);
  return time;
}

// node_modules/@meta2d/core/src/diagrams/line/curve.js
function curve(store, pen, mousedwon) {
  if (!pen.calculative.worldAnchors) {
    pen.calculative.worldAnchors = [];
  }
  if (mousedwon) {
    if (pen.calculative.activeAnchor) {
      pen.calculative.activeAnchor.next = {
        penId: pen.id,
        x: mousedwon.x,
        y: mousedwon.y
      };
      if (distance(pen.calculative.activeAnchor.next, pen.calculative.activeAnchor) < 5) {
        pen.calculative.activeAnchor.next = void 0;
      } else {
        pen.calculative.activeAnchor.prev = {
          ...pen.calculative.activeAnchor.next
        };
        rotatePoint(pen.calculative.activeAnchor.prev, 180, pen.calculative.activeAnchor);
      }
    }
  } else {
    const from = pen.calculative.worldAnchors[0];
    if (!from.next) {
      const fromFace = facePen(from, store.pens[from.connectTo]);
      calcCurveCP(from, fromFace, 50);
      from.prev = void 0;
    }
    const to = pen.calculative.worldAnchors[pen.calculative.worldAnchors.length - 1];
    if (to && to !== from && !to.prev) {
      const toFace = facePen(to, store.pens[to.connectTo]);
      calcCurveCP(to, toFace, -50);
      to.next = void 0;
    }
  }
}
function calcCurveCP(pt, d, dis) {
  switch (d) {
    case Direction.Up:
      pt.prev = {
        penId: pt.penId,
        x: pt.x,
        y: pt.y + dis
      };
      pt.next = {
        penId: pt.penId,
        x: pt.x,
        y: pt.y - dis
      };
      break;
    case Direction.Right:
      pt.prev = {
        penId: pt.penId,
        x: pt.x - dis,
        y: pt.y
      };
      pt.next = {
        penId: pt.penId,
        x: pt.x + dis,
        y: pt.y
      };
      break;
    case Direction.Bottom:
      pt.prev = {
        penId: pt.penId,
        x: pt.x,
        y: pt.y - dis
      };
      pt.next = {
        penId: pt.penId,
        x: pt.x,
        y: pt.y + dis
      };
      break;
    case Direction.Left:
      pt.prev = {
        penId: pt.penId,
        x: pt.x + dis,
        y: pt.y
      };
      pt.next = {
        penId: pt.penId,
        x: pt.x - dis,
        y: pt.y
      };
      break;
  }
}
function getQuadraticPoint(step, from, cp, to) {
  const pos = 1 - step;
  const x = pos * pos * from.x + 2 * pos * step * cp.x + step * step * to.x;
  const y = pos * pos * from.y + 2 * pos * step * cp.y + step * step * to.y;
  return { x, y, step };
}
function getBezierPoint(step, from, cp1, cp2, to) {
  const { x: x1, y: y1 } = from;
  const { x: x2, y: y2 } = to;
  const { x: cx1, y: cy1 } = cp1;
  const { x: cx2, y: cy2 } = cp2;
  const pos = 1 - step;
  const x = x1 * pos * pos * pos + 3 * cx1 * step * pos * pos + 3 * cx2 * step * step * pos + x2 * step * step * step;
  const y = y1 * pos * pos * pos + 3 * cy1 * step * pos * pos + 3 * cy2 * step * step * pos + y2 * step * step * step;
  return { x, y, step };
}
function lerp(pt1, pt2, t) {
  return {
    x: pt1.x + t * (pt2.x - pt1.x),
    y: pt1.y + t * (pt2.y - pt1.y)
  };
}
function getSplitAnchor(pen, pt, index) {
  let from = pen.calculative.worldAnchors[index];
  let to = pen.calculative.worldAnchors[index + 1];
  if (!to && pen.close) {
    to = pen.calculative.worldAnchors[0];
  }
  const t = pt.step;
  let anchor;
  if (from.next && to.prev) {
    const p0 = from;
    const p1 = from.next;
    const p2 = to.prev;
    const p3 = to;
    const p4 = lerp(p0, p1, t);
    const p5 = lerp(p1, p2, t);
    const p6 = lerp(p2, p3, t);
    const p7 = lerp(p4, p5, t);
    const p8 = lerp(p5, p6, t);
    anchor = lerp(p7, p8, t);
    p7.penId = pen.id;
    anchor.prev = p7;
    p8.penId = pen.id;
    anchor.next = p8;
    from.next.x = p4.x;
    from.next.y = p4.y;
    to.prev.x = p6.x;
    to.prev.y = p6.y;
  } else if (from.next || to.prev) {
    const p0 = from;
    const p1 = from.next || to.prev;
    const p2 = to;
    const p3 = lerp(p0, p1, t);
    const p4 = lerp(p1, p2, t);
    anchor = pt;
    p3.penId = pen.id;
    p4.penId = pen.id;
    anchor.prev = p3;
    anchor.next = p4;
    from.next = void 0;
    to.prev = void 0;
  } else {
    anchor = pt;
  }
  anchor.penId = pen.id;
  anchor.id = s8();
  anchor.prevNextType = PrevNextType.Bilateral;
  return anchor;
}
function mind(store, pen, mousedwon) {
  if (!pen.calculative.worldAnchors) {
    pen.calculative.worldAnchors = [];
  }
  if (pen.calculative.worldAnchors.length < 2) {
    return;
  }
  let from = pen.calculative.activeAnchor;
  let to = mousedwon || getToAnchor(pen);
  if (!from || !to) {
    return;
  }
  const dis = 20;
  const fromPen = store.pens[from.connectTo];
  let fromFace = facePen(from, fromPen);
  if (fromFace === Direction.None) {
    if (to.x > from.x) {
      fromFace = Direction.Right;
    } else {
      fromFace = Direction.Left;
    }
  }
  from.next = {
    id: s8(),
    penId: pen.id,
    x: from.x,
    y: from.y,
    prevNextType: 2
  };
  to.prev = { id: s8(), penId: pen.id, x: to.x, y: to.y, prevNextType: 2 };
  switch (fromFace) {
    case Direction.Up:
      from.next.y -= dis;
      to.prev.y = from.y;
      break;
    case Direction.Bottom:
      from.next.y += dis;
      to.prev.y = from.y;
      break;
    case Direction.Left:
      from.next.x -= dis;
      to.prev.x = from.x;
      break;
    default:
      from.next.x += dis;
      to.prev.x = from.x;
      break;
  }
}

// node_modules/@meta2d/core/src/diagrams/line/line.js
function line(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  if (pen.lineName === "line" || pen.lineName === "polyline") {
    if (pen.calculative.lineSmooth) {
      let _path = getGradientAnimatePath(pen);
      if (path instanceof Path2D)
        path.addPath(_path);
      if (path instanceof Path2D)
        return path;
    }
  }
  const worldAnchors = pen.calculative.worldAnchors;
  if (worldAnchors.length > 1) {
    let from;
    worldAnchors.forEach((pt) => {
      if (from) {
        draw(path, from, pt);
      } else {
        pt.start = true;
      }
      from = pt;
    });
    if (pen.close) {
      if (pen.lineName === "curve") {
        draw(path, from, worldAnchors[0]);
      } else {
        path.closePath();
      }
    }
  }
  if (path instanceof Path2D)
    return path;
}
function lineSegment(store, pen, mousedwon) {
  var _a;
  if (!pen.calculative.worldAnchors) {
    pen.calculative.worldAnchors = [];
  }
  if (pen.calculative.worldAnchors.length < 2 || ((_a = pen.anchors) == null ? void 0 : _a.length) > 1) {
    return;
  }
  const from = getFromAnchor(pen);
  const to = getToAnchor(pen);
  if (!from || !to || !to.id || from === to) {
    return;
  }
  from.next = void 0;
  deleteTempAnchor(pen);
  to.prev = void 0;
  pen.calculative.worldAnchors.push(to);
}
function draw(path, from, to) {
  if (!to || to.isTemp) {
    return;
  }
  from.start && path.moveTo(from.x, from.y);
  if (from.next) {
    if (to.prev) {
      path.bezierCurveTo(from.next.x, from.next.y, to.prev.x, to.prev.y, to.x, to.y);
    } else {
      path.quadraticCurveTo(from.next.x, from.next.y, to.x, to.y);
    }
  } else {
    if (to.prev) {
      path.quadraticCurveTo(to.prev.x, to.prev.y, to.x, to.y);
    } else {
      path.lineTo(to.x, to.y);
    }
  }
}
function getLineRect(pen) {
  getLineLength(pen);
  return getRectOfPoints(getLinePoints(pen));
}
function getLinePoints(pen) {
  const pts = [];
  let from;
  pen.calculative.worldAnchors.forEach((pt) => {
    pts.push(pt);
    from && pts.push(...getPoints(from, pt, pen));
    from = pt;
  });
  if (pen.close && pen.calculative.worldAnchors.length > 1) {
    pts.push(...getPoints(from, pen.calculative.worldAnchors[0], pen));
  }
  return pts;
}
function getLineR(pen) {
  return (pen == null ? void 0 : pen.lineWidth) ? pen.lineWidth / 2 + 4 : 4;
}
function getPoints(from, to, pen) {
  const pts = [];
  if (!to) {
    return pts;
  }
  let step = 0.02;
  if (from.lineLength) {
    const r = getLineR(pen);
    step = r / from.lineLength;
  }
  if (from.next) {
    if (to.prev) {
      for (let i = step; i < 1; i += step) {
        pts.push(getBezierPoint(i, from, from.next, to.prev, to));
      }
    } else {
      for (let i = step; i < 1; i += step) {
        pts.push(getQuadraticPoint(i, from, from.next, to));
      }
    }
  } else {
    if (to.prev) {
      for (let i = step; i < 1; i += step) {
        pts.push(getQuadraticPoint(i, from, to.prev, to));
      }
    } else {
      pts.push({ x: to.x, y: to.y });
    }
  }
  if (pts.length > 1) {
    from.curvePoints = pts;
  }
  return pts;
}
function pointInLine(pt, pen) {
  const r = getLineR(pen);
  let i = 0;
  let from;
  let point;
  for (const anchor of pen.calculative.worldAnchors) {
    if (from) {
      point = pointInLineSegment(pt, from, anchor, r);
      if (point) {
        return {
          i,
          point
        };
      }
      ++i;
    }
    from = anchor;
  }
  if (pen.close && pen.calculative.worldAnchors.length > 1 && (point = pointInLineSegment(pt, from, pen.calculative.worldAnchors[0], r))) {
    return {
      i,
      point
    };
  }
}
function pointInLineSegment(pt, pt1, pt2, r = 4) {
  if (!pt1.next && !pt2.prev) {
    const { x: x1, y: y1 } = pt1;
    const { x: x2, y: y2 } = pt2;
    const minX = Math.min(x1, x2);
    const maxX = Math.max(x1, x2);
    const minY = Math.min(y1, y2);
    const maxY = Math.max(y1, y2);
    if (!(pt.x >= minX - r && pt.x <= maxX + r && pt.y >= minY - r && pt.y <= maxY + r)) {
      return;
    }
    return pointToLine(pt, pt1, pt2, r);
  } else if (pt1.curvePoints) {
    for (const point of pt1.curvePoints) {
      if (hitPoint(pt, point, r)) {
        return point;
      }
    }
  }
}
function pointToLine(pt, pt1, pt2, r = 4) {
  if (pt1.x === pt2.x) {
    const len = Math.abs(pt.x - pt1.x);
    if (len <= r) {
      return {
        x: pt1.x,
        y: pt.y
      };
    }
  } else {
    const A = (pt1.y - pt2.y) / (pt1.x - pt2.x);
    const B = pt1.y - A * pt1.x;
    const len = Math.abs((A * pt.x + B - pt.y) / Math.sqrt(A * A + 1));
    if (len <= r) {
      const m = pt.x + A * pt.y;
      const x = (m - A * B) / (A * A + 1);
      return {
        x,
        y: A * x + B
      };
    }
  }
}
function lineLen(from, cp1, cp2, to) {
  if (!cp1 && !cp2) {
    return Math.sqrt(Math.pow(Math.abs(from.x - to.x), 2) + Math.pow(Math.abs(from.y - to.y), 2)) || 0;
  }
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  if (cp1 && cp2) {
    path.setAttribute("d", `M${from.x} ${from.y} C${cp1.x} ${cp1.y} ${cp2.x} ${cp2.y} ${to.x} ${to.y}`);
  } else if (cp1) {
    path.setAttribute("d", `M${from.x} ${from.y} Q${cp1.x} ${cp1.y} ${to.x} ${to.y}`);
  } else {
    path.setAttribute("d", `M${from.x} ${from.y} Q${cp2.x} ${cp2.y} ${to.x} ${to.y}`);
  }
  return path.getTotalLength() || 0;
}
function getLineLength(pen) {
  if (pen.calculative.worldAnchors.length < 2) {
    return 0;
  }
  let len = 0;
  let from;
  pen.calculative.worldAnchors.forEach((pt) => {
    if (from) {
      from.lineLength = lineLen(from, from.next, pt.prev, pt);
      len += from.lineLength;
    }
    from = pt;
  });
  if (pen.close) {
    const to = getFromAnchor(pen);
    from.lineLength = lineLen(from, from.next, to.prev, to);
    len += from.lineLength;
  }
  if (pen.calculative.animatePos) {
    pen.calculative.animatePos = len / pen.length * pen.calculative.animatePos;
  }
  pen.length = len;
  return len;
}
function lineInRect(line2, rect) {
  const worldAnchors = line2.calculative.worldAnchors;
  for (let index = 0; index < worldAnchors.length - 1; index++) {
    const current = worldAnchors[index];
    const next = worldAnchors[index + 1];
    if (!current.next && !next.prev) {
      if (isLineIntersectRectangle(current, next, rect)) {
        return true;
      }
    } else {
      if (isBezierIntersectRectangle(current, next, rect)) {
        return true;
      }
    }
  }
  return false;
}
function isLineIntersectRectangle(pt1, pt2, rect) {
  if (pointInSimpleRect(pt1, rect) || pointInSimpleRect(pt2, rect)) {
    return true;
  }
  const linePointX1 = pt1.x;
  const linePointY1 = pt1.y;
  const linePointX2 = pt2.x;
  const linePointY2 = pt2.y;
  let rectangleLeftTopX = rect.x;
  let rectangleLeftTopY = rect.y;
  let rectangleRightBottomX = rect.ex;
  let rectangleRightBottomY = rect.ey;
  const lineHeight = linePointY1 - linePointY2;
  const lineWidth = linePointX2 - linePointX1;
  const c = linePointX1 * linePointY2 - linePointX2 * linePointY1;
  if (lineHeight * rectangleLeftTopX + lineWidth * rectangleLeftTopY + c >= 0 && lineHeight * rectangleRightBottomX + lineWidth * rectangleRightBottomY + c <= 0 || lineHeight * rectangleLeftTopX + lineWidth * rectangleLeftTopY + c <= 0 && lineHeight * rectangleRightBottomX + lineWidth * rectangleRightBottomY + c >= 0 || lineHeight * rectangleLeftTopX + lineWidth * rectangleRightBottomY + c >= 0 && lineHeight * rectangleRightBottomX + lineWidth * rectangleLeftTopY + c <= 0 || lineHeight * rectangleLeftTopX + lineWidth * rectangleRightBottomY + c <= 0 && lineHeight * rectangleRightBottomX + lineWidth * rectangleLeftTopY + c >= 0) {
    if (rectangleLeftTopX > rectangleRightBottomX) {
      const temp = rectangleLeftTopX;
      rectangleLeftTopX = rectangleRightBottomX;
      rectangleRightBottomX = temp;
    }
    if (rectangleLeftTopY < rectangleRightBottomY) {
      const temp1 = rectangleLeftTopY;
      rectangleLeftTopY = rectangleRightBottomY;
      rectangleRightBottomY = temp1;
    }
    if (linePointX1 < rectangleLeftTopX && linePointX2 < rectangleLeftTopX || linePointX1 > rectangleRightBottomX && linePointX2 > rectangleRightBottomX || linePointY1 > rectangleLeftTopY && linePointY2 > rectangleLeftTopY || linePointY1 < rectangleRightBottomY && linePointY2 < rectangleRightBottomY) {
      return false;
    } else {
      return true;
    }
  } else {
    return false;
  }
}
function isBezierIntersectRectangle(from, to, rect) {
  const step = 0.02;
  if (!from.next && !to.prev) {
    return isLineIntersectRectangle(from, to, rect);
  } else if (from.next && to.prev) {
    for (let i = step; i < 1; i += step) {
      const point = getBezierPoint(i, from, from.next, to.prev, to);
      if (pointInSimpleRect(point, rect)) {
        return true;
      }
    }
  } else if (from.next || to.prev) {
    for (let i = step; i < 1; i += step) {
      const point = getQuadraticPoint(i, from, from.next || to.prev, to);
      if (pointInSimpleRect(point, rect)) {
        return true;
      }
    }
  }
  return false;
}

// node_modules/@meta2d/core/src/diagrams/line/polyline.js
var faceSpace = 10;
function polyline(store, pen, mousedwon) {
  var _a;
  if (!pen.calculative.worldAnchors) {
    pen.calculative.worldAnchors = [];
  }
  faceSpace = store.options.polylineSpace || 10;
  if (pen.calculative.worldAnchors.length < 2) {
    return;
  }
  let from = getFromAnchor(pen);
  let to = getToAnchor(pen);
  if (!from || !to) {
    return;
  }
  let dragFrom;
  if (((_a = pen.anchors) == null ? void 0 : _a.length) && from === pen.calculative.activeAnchor) {
    dragFrom = true;
    from = to;
    to = getFromAnchor(pen);
  } else if ((!pen.anchors || !pen.anchors.length) && from !== pen.calculative.activeAnchor) {
    from = pen.calculative.activeAnchor;
  }
  if (!from || !to) {
    return;
  }
  from.next = void 0;
  to.prev = void 0;
  const connected = to.connectTo;
  deleteTempAnchor(pen);
  const pts = [];
  const fromPen = store.pens[from.connectTo];
  const toPen = store.pens[to.connectTo];
  const fromFace = facePen(from, fromPen);
  const toFace = facePen(to, toPen);
  let a = getFacePoint(from, fromFace, faceSpace);
  if (a) {
    from = a;
    pts.push(a);
  }
  a = getFacePoint(to, toFace, faceSpace);
  const end = to;
  let corner = void 0;
  if (a) {
    to = a;
    if (end.connectTo) {
      if (a.y > end.y && from.y < end.y || a.y < end.y && from.y > end.y) {
        corner = a;
        let _faceSpace = faceSpace;
        if (from.x < a.x) {
          _faceSpace = -_faceSpace;
        }
        if (Math.abs(from.x - a.x) < _faceSpace) {
          _faceSpace = -_faceSpace;
        }
        const point = { x: a.x + _faceSpace, y: a.y, id: s8() };
        to = point;
      }
    }
  }
  switch (fromFace) {
    case Direction.Up:
      pts.push(...getNextPointsOfUp(from, to, toFace));
      break;
    case Direction.Right:
      pts.push(...getNextPointsOfRight(from, to, toFace));
      break;
    case Direction.Bottom:
      pts.push(...getNextPointsOfBottom(from, to, toFace));
      break;
    case Direction.Left:
      pts.push(...getNextPointsOfLeft(from, to, toFace));
      break;
    default:
      pts.push(...getNextPoints(pen, from, to));
      break;
  }
  pts.forEach((anchor) => {
    anchor.id = s8();
    anchor.penId = pen.id;
    pen.calculative.worldAnchors.push(anchor);
  });
  pen.calculative.worldAnchors.push(to);
  if (corner) {
    pen.calculative.worldAnchors.push(corner);
  }
  if (a) {
    pen.calculative.worldAnchors.push(end);
  }
  if (dragFrom) {
    pen.calculative.worldAnchors.reverse();
  }
  if (connected) {
    const i = pen.calculative.worldAnchors.length - 2;
    pen.calculative.worldAnchors[i].isTemp = false;
    pen.calculative.worldAnchors[1].isTemp = false;
  }
}
function getFacePoint(pt, d, dis) {
  const point = { x: pt.x, y: pt.y, id: s8() };
  switch (d) {
    case Direction.Up:
      point.y -= dis;
      break;
    case Direction.Right:
      point.x += dis;
      break;
    case Direction.Bottom:
      point.y += dis;
      break;
    case Direction.Left:
      point.x -= dis;
      break;
    default: {
      return;
    }
  }
  return point;
}
function getNextPointsOfUp(from, to, toFace) {
  if (from.x === to.x || from.y === to.y) {
    return [];
  }
  const pts = [];
  let x;
  let y;
  switch (toFace) {
    case Direction.Up:
      if (from.y < to.y) {
        x = to.x;
        y = from.y;
      } else {
        x = from.x;
        y = to.y;
      }
      pts.push({ x, y });
      break;
    case Direction.Bottom:
      x = to.x;
      y = from.y;
      if (to.y > from.y) {
        x = from.x + (to.x - from.x) / 2;
        pts.push({ x, y: from.y }, { x, y: to.y });
      } else {
        const centerY = (from.y + to.y) / 2;
        pts.push({ x: from.x, y: centerY }, { x: to.x, y: centerY });
      }
      break;
    case Direction.Right:
      x = to.x;
      y = from.y;
      if (to.x < from.x && to.y < from.y) {
        x = from.x;
        y = to.y;
      }
      pts.push({ x, y });
      break;
    case Direction.Left:
      x = to.x;
      y = from.y;
      if (to.x > from.x && to.y < from.y) {
        x = from.x;
        y = to.y;
      }
      pts.push({ x, y });
      break;
    default:
      if (to.y > from.y - faceSpace) {
        x = from.x + (to.x - from.x) / 2;
        pts.push({ x, y: from.y }, { x, y: to.y });
      } else {
        const centerY = (from.y + to.y + faceSpace) / 2;
        pts.push({ x: from.x, y: centerY }, { x: to.x, y: centerY });
      }
      break;
  }
  return pts;
}
function getNextPointsOfRight(from, to, toFace) {
  if (from.x === to.x || from.y === to.y) {
    return [];
  }
  const pts = [];
  let x;
  let y;
  switch (toFace) {
    case Direction.Up:
      x = from.x;
      y = to.y;
      if (to.x > from.x && to.y > from.y) {
        x = to.x;
        y = from.y;
      }
      pts.push({ x, y });
      break;
    case Direction.Bottom:
      x = from.x;
      y = to.y;
      if (to.x > from.x && to.y < from.y) {
        x = to.x;
        y = from.y;
      }
      pts.push({ x, y });
      break;
    case Direction.Left:
      x = to.x;
      y = from.y;
      if (to.x < from.x) {
        y = from.y + (to.y - from.y) / 2;
        pts.push({ x: from.x, y }, { x: to.x, y });
      } else {
        const centerX = (from.x + to.x) / 2;
        pts.push({ x: centerX, y }, { x: centerX, y: to.y });
      }
      break;
    case Direction.Right:
      if (to.x < from.x) {
        pts.push({ x: from.x, y: to.y });
      } else {
        pts.push({ x: to.x, y: from.y });
      }
      break;
    default:
      x = to.x;
      y = to.y;
      if (to.x < from.x + faceSpace) {
        pts.push({ x: from.x, y });
      } else {
        const centerX = (from.x + to.x - faceSpace) / 2;
        pts.push({ x: centerX, y: from.y }, { x: centerX, y });
      }
      break;
  }
  return pts;
}
function getNextPointsOfBottom(from, to, toFace) {
  if (from.x === to.x || from.y === to.y) {
    return [];
  }
  const pts = [];
  let x;
  let y;
  switch (toFace) {
    case Direction.Up:
      x = from.x;
      y = to.y;
      if (to.y < from.y) {
        x = from.x + (to.x - from.x) / 2;
        pts.push({ x, y: from.y }, { x, y: to.y });
      } else {
        const centerY = (from.y + to.y) / 2;
        pts.push({ x, y: centerY }, { x: to.x, y: centerY });
      }
      break;
    case Direction.Right:
      x = to.x;
      y = from.y;
      if (to.x < from.x && to.y > from.y) {
        x = from.x;
        y = to.y;
      }
      pts.push({ x, y });
      break;
    case Direction.Bottom:
      if (from.y > to.y) {
        x = to.x;
        y = from.y;
      } else {
        x = from.x;
        y = to.y;
      }
      pts.push({ x, y });
      break;
    case Direction.Left:
      x = to.x;
      y = from.y;
      if (to.x > from.x && to.y > from.y) {
        x = from.x;
        y = to.y;
      }
      pts.push({ x, y });
      break;
    default:
      x = from.x;
      if (to.y < from.y + faceSpace) {
        x = from.x + (to.x - from.x) / 2;
        pts.push({ x, y: from.y }, { x, y: to.y });
      } else {
        const centerY = (from.y + to.y - faceSpace) / 2;
        pts.push({ x, y: centerY }, { x: to.x, y: centerY });
      }
      break;
  }
  return pts;
}
function getNextPointsOfLeft(from, to, toFace) {
  if (from.x === to.x || from.y === to.y) {
    return [];
  }
  const pts = [];
  let x;
  let y;
  switch (toFace) {
    case Direction.Up:
      x = from.x;
      y = to.y;
      if (to.x < from.x && to.y > from.y) {
        x = to.x;
        y = from.y;
      }
      pts.push({ x, y });
      break;
    case Direction.Bottom:
      x = from.x;
      y = to.y;
      if (to.x < from.x && to.y < from.y) {
        x = to.x;
        y = from.y;
      }
      pts.push({ x, y });
      break;
    case Direction.Right:
      x = from.x;
      y = to.y;
      if (to.x > from.x) {
        x = to.x;
        y = from.y + (to.y - from.y) / 2;
        pts.push({ x: from.x, y }, { x: to.x, y });
      } else {
        const centerX = (from.x + to.x) / 2;
        pts.push({ x: centerX, y: from.y }, { x: centerX, y: to.y });
      }
      break;
    case Direction.Left:
      if (to.x > from.x) {
        pts.push({ x: from.x, y: to.y });
      } else {
        pts.push({ x: to.x, y: from.y });
      }
      break;
    default:
      x = from.x;
      y = to.y;
      if (to.x < from.x - faceSpace) {
        const centerX = (from.x + to.x + faceSpace) / 2;
        pts.push({ x: centerX, y: from.y }, { x: centerX, y });
      } else {
        pts.push({ x: from.x, y });
      }
      break;
  }
  return pts;
}
function getNextPoints(pen, from, to) {
  const pts = [];
  if (pen.calculative.drawlineH == void 0) {
    pen.calculative.drawlineH = Math.abs(to.x - from.x) > Math.abs(to.y - from.y);
  }
  let index = pen.calculative.worldAnchors.findIndex((anchor) => anchor.id == from.id);
  if (index > 1) {
    let prev = pen.calculative.worldAnchors[index - 1];
    if (prev.x === from.x && prev.y !== from.y) {
      pts.push({ x: to.x, y: from.y });
      return pts;
    } else if (prev.y === from.y && prev.x !== from.x) {
      pts.push({ x: from.x, y: to.y });
      return pts;
    }
  }
  if (pen.calculative.worldAnchors.length) {
    to.isTemp = void 0;
    if (pen.calculative.drawlineH) {
      pts.push({ x: to.x, y: from.y });
      if (Math.abs(to.y - from.y) < faceSpace) {
        to.isTemp = true;
      }
    } else {
      pts.push({ x: from.x, y: to.y });
      if (Math.abs(to.x - from.x) < faceSpace) {
        to.isTemp = true;
      }
    }
  }
  return pts;
}
function anchorInHorizontal(pen, anchor, from = true) {
  var _a, _b;
  let anchors = pen.calculative.worldAnchors;
  if (!from) {
    anchors = [];
    pen.calculative.worldAnchors.forEach((item) => {
      anchors.unshift(item);
    });
  }
  for (let i = 0; i < anchors.length; i++) {
    if (anchors[i].id === anchor.id) {
      break;
    }
    if (anchors[i].y !== anchor.y) {
      return false;
    }
    if (anchors[i].x === ((_a = anchors[i + 1]) == null ? void 0 : _a.x) && anchors[i].y !== ((_b = anchors[i + 1]) == null ? void 0 : _b.y)) {
      return false;
    }
  }
  return true;
}
function anchorInVertical(pen, anchor, from = true) {
  var _a, _b;
  let anchors = pen.calculative.worldAnchors;
  if (!from) {
    anchors = [];
    pen.calculative.worldAnchors.forEach((item) => {
      anchors.unshift(item);
    });
  }
  for (let i = 0; i < anchors.length; i++) {
    if (anchors[i].id === anchor.id) {
      break;
    }
    if (anchors[i].x !== anchor.x) {
      return false;
    }
    if (anchors[i].y === ((_a = anchors[i + 1]) == null ? void 0 : _a.y) && anchors[i].x !== ((_b = anchors[i + 1]) == null ? void 0 : _b.x)) {
      return false;
    }
  }
  return true;
}
function translatePolylineAnchor(pen, anchor, pt) {
  if (!pen.calculative.worldAnchors) {
    return;
  }
  const i = pen.calculative.worldAnchors.findIndex((item) => item.id === anchor.id);
  const from = getFromAnchor(pen);
  const to = getToAnchor(pen);
  let prev = pen.calculative.worldAnchors[i - 1];
  let next = pen.calculative.worldAnchors[i + 1];
  if (pen.calculative.h == void 0) {
    if (from.connectTo) {
      if (anchorInHorizontal(pen, anchor, true)) {
        pen.calculative.h = true;
      } else if (anchorInVertical(pen, anchor, true)) {
        pen.calculative.h = false;
      }
    }
    if (pen.calculative.h == void 0 && to.connectTo) {
      if (anchorInHorizontal(pen, anchor, false)) {
        pen.calculative.h = true;
      } else if (anchorInVertical(pen, anchor, false)) {
        pen.calculative.h = false;
      }
    }
    if (pen.calculative.h == void 0) {
      if (prev) {
        pen.calculative.h = prev.y === anchor.y;
      } else if (next) {
        pen.calculative.h = next.y === anchor.y;
      }
    }
  }
  if (pen.calculative.h) {
    anchor.x = pt.x;
    if (from.connectTo && anchorInHorizontal(pen, anchor, true)) {
      if (next && next.y !== anchor.y) {
        next.x = anchor.x;
      }
      return;
    }
    if (to.connectTo && anchorInHorizontal(pen, anchor, false)) {
      if (prev && prev.y !== anchor.y) {
        prev.x = anchor.x;
      }
      return;
    }
    const a = pen.anchors[i];
    let d;
    for (let pos = i - 1; pos > -1; pos--) {
      prev = pen.anchors[pos];
      if (d == void 0) {
        d = prev.y === a.y;
      }
      if (d === true) {
        if (prev.y === a.y) {
          pen.calculative.worldAnchors[pos].y = pt.y;
        } else {
          break;
        }
      } else {
        if (prev.x === a.x) {
          pen.calculative.worldAnchors[pos].x = pt.x;
        } else {
          break;
        }
      }
    }
    d = void 0;
    for (let pos = i + 1; pos < pen.calculative.worldAnchors.length; pos++) {
      next = pen.anchors[pos];
      if (next) {
        if (d == void 0) {
          d = next.y === a.y;
        }
        if (d === true) {
          if (next.y === a.y) {
            pen.calculative.worldAnchors[pos].y = pt.y;
          } else {
            break;
          }
        } else {
          if (next.x === a.x) {
            pen.calculative.worldAnchors[pos].x = pt.x;
          } else {
            break;
          }
        }
      } else {
        break;
      }
    }
    anchor.y = pt.y;
  } else {
    anchor.y = pt.y;
    if (from.connectTo && anchorInVertical(pen, anchor, true)) {
      if (next && next.x !== anchor.x) {
        next.y = anchor.y;
      }
      return;
    }
    if (to.connectTo && anchorInVertical(pen, anchor, false)) {
      if (prev && prev.x !== anchor.x) {
        prev.y = anchor.y;
      }
      return;
    }
    const a = pen.anchors[i];
    let d;
    for (let pos = i - 1; pos > -1; pos--) {
      prev = pen.anchors[pos];
      if (d == void 0) {
        d = prev.x === a.x;
      }
      if (d === true) {
        if (prev.x === a.x) {
          pen.calculative.worldAnchors[pos].x = pt.x;
        } else {
          break;
        }
      } else {
        if (prev.y === a.y) {
          pen.calculative.worldAnchors[pos].y = pt.y;
        } else {
          break;
        }
      }
    }
    d = void 0;
    for (let pos = i + 1; pos < pen.calculative.worldAnchors.length; pos++) {
      next = pen.anchors[pos];
      if (next) {
        if (d == void 0) {
          d = next.x === a.x;
        }
        if (d === true) {
          if (next.x === a.x) {
            pen.calculative.worldAnchors[pos].x = pt.x;
          } else {
            break;
          }
        } else {
          if (next.y === a.y) {
            pen.calculative.worldAnchors[pos].y = pt.y;
          } else {
            break;
          }
        }
      } else {
        break;
      }
    }
    anchor.x = pt.x;
  }
}

// node_modules/@meta2d/core/src/diagrams/line/smooth.js
function simplify(points, length, start, end) {
  const newPoints = [];
  let maxDist, index, xx, yy, dx, dy, ddx, ddy, p1, p2, p, t, dist, dist1;
  p1 = points[start];
  p2 = points[end];
  xx = p1.x;
  yy = p1.y;
  ddx = p2.x - xx;
  ddy = p2.y - yy;
  dist1 = ddx * ddx + ddy * ddy;
  maxDist = length;
  for (let i = start + 1; i < end; i++) {
    p = points[i];
    if (ddx !== 0 || ddy !== 0) {
      t = ((p.x - xx) * ddx + (p.y - yy) * ddy) / dist1;
      if (t > 1) {
        dx = p.x - p2.x;
        dy = p.y - p2.y;
      } else if (t > 0) {
        dx = p.x - (xx + ddx * t);
        dy = p.y - (yy + ddy * t);
      } else {
        dx = p.x - xx;
        dy = p.y - yy;
      }
    } else {
      dx = p.x - xx;
      dy = p.y - yy;
    }
    dist = dx * dx + dy * dy;
    if (dist > maxDist) {
      index = i;
      maxDist = dist;
    }
  }
  if (maxDist > length) {
    if (index - start > 1) {
      newPoints.push(...simplify(points, length, start, index));
    }
    newPoints.push({
      id: points[index].id,
      penId: points[index].penId,
      x: points[index].x,
      y: points[index].y
    });
    if (end - index > 1) {
      newPoints.push(...simplify(points, length, index, end));
    }
  }
  return newPoints;
}
function smoothLine(points, cornerThres = 0.8, match = false) {
  if (points.length < 3) {
    return points;
  }
  let p1, p2, p3, dist1, dist2, x, y, endP, len, angle, newPoints, aLen, nx1, nx2, ny1, ny2;
  const dot = (x2, y2, xx, yy) => {
    dist1 = Math.sqrt(x2 * x2 + y2 * y2);
    if (dist1 > 0) {
      nx1 = x2 / dist1;
      ny1 = y2 / dist1;
    } else {
      nx1 = 1;
      ny1 = 0;
    }
    dist2 = Math.sqrt(xx * xx + yy * yy);
    if (dist2 > 0) {
      nx2 = xx / dist2;
      ny2 = yy / dist2;
    } else {
      nx2 = 1;
      ny2 = 0;
    }
    return Math.acos(nx1 * nx2 + ny1 * ny2);
  };
  newPoints = [];
  aLen = points.length;
  p1 = points[0];
  endP = points[aLen - 1];
  newPoints.push({ ...points[0] });
  for (let i = 0; i < aLen - 1; i++) {
    p2 = points[i];
    p3 = points[i + 1];
    angle = Math.abs(dot(p2.x - p1.x, p2.y - p1.y, p3.x - p2.x, p3.y - p2.y));
    if (dist1) {
      if (angle < cornerThres * 3.14) {
        if (match) {
          dist1 = Math.min(dist1, dist2);
          dist2 = dist1;
        }
        x = (nx1 + nx2) / 2;
        y = (ny1 + ny2) / 2;
        len = Math.sqrt(x * x + y * y);
        if (len === 0) {
          newPoints.push({ ...p2 });
        } else {
          x /= len;
          y /= len;
          const pt = { ...p2 };
          pt.prevNextType = PrevNextType.Bilateral;
          pt.prev = {
            penId: pt.penId,
            x: p2.x - x * dist1 * 0.25,
            y: p2.y - y * dist1 * 0.25
          };
          pt.next = {
            penId: pt.penId,
            x: p2.x + x * dist2 * 0.25,
            y: p2.y + y * dist2 * 0.25
          };
          newPoints.push(pt);
        }
      } else {
        newPoints.push({ ...p2 });
      }
    }
    p1 = p2;
  }
  newPoints.push({ ...points[points.length - 1] });
  return newPoints;
}

// node_modules/@meta2d/core/src/diagrams/line/arrow.js
function drawArrow(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const worldAnchors = pen.calculative.worldAnchors;
  let scale = pen.calculative.canvas.store.data.scale;
  let size = (pen.calculative.animateLineWidth || 6) * scale;
  let arrowLength = (pen.animateLineWidth * 2 || 12) * scale;
  if (pen.lineAnimateType === LineAnimateType.WaterDrop) {
    arrowLength = (pen.animateLineWidth * 4 || 24) * scale;
  }
  let d = (pen.animateInterval || 100) * scale;
  let smoothLenth = pen.calculative.lineWidth * (pen.calculative.lineSmooth || 0);
  let lineWidth = (pen.calculative.animateLineWidth / 2 || 3) * scale;
  if (pen.animateReverse) {
    arrowLength = -arrowLength;
    size = -size;
  }
  if (worldAnchors.length > 1) {
    let from;
    let lastLength = 0;
    for (let i = 0; i < worldAnchors.length; i++) {
      let pt = worldAnchors[i];
      if (from) {
        let angle = getAngle(from, pt);
        let newP = {
          x: from.x + (pen.calculative.animatePos - lastLength) % d * Math.cos(angle * Math.PI / 180),
          y: from.y - (pen.calculative.animatePos - lastLength) % d * Math.sin(angle * Math.PI / 180)
        };
        if (pen.animateReverse) {
          newP = {
            x: from.x + (pen.length - (pen.calculative.animatePos + lastLength)) % d * Math.cos(angle * Math.PI / 180),
            y: from.y - (pen.length - (pen.calculative.animatePos + lastLength)) % d * Math.sin(angle * Math.PI / 180)
          };
        }
        let newPTFrom = Math.sqrt((newP.x - from.x) ** 2 + (newP.y - from.y) ** 2);
        let ptTFrom = Math.sqrt((pt.x - from.x) ** 2 + (pt.y - from.y) ** 2);
        while (newPTFrom < ptTFrom) {
          if ((pen.animateReverse && newPTFrom - arrowLength < ptTFrom || //
          !pen.animateReverse && newPTFrom > arrowLength) && newPTFrom > smoothLenth + arrowLength && ptTFrom - newPTFrom > smoothLenth) {
            if (pen.lineAnimateType === LineAnimateType.Arrow) {
              arrow(path, newP, size, angle, lineWidth, arrowLength);
            } else if (pen.lineAnimateType === LineAnimateType.WaterDrop) {
              waterDrop(path, newP, pen.animateReverse, angle, lineWidth, arrowLength);
            }
          }
          newP.x += d * Math.cos(angle * Math.PI / 180);
          newP.y -= d * Math.sin(angle * Math.PI / 180);
          newPTFrom = Math.sqrt((newP.x - from.x) ** 2 + (newP.y - from.y) ** 2);
        }
      }
      from = pt;
    }
  }
  if (path instanceof Path2D)
    return path;
}
function getAngle(p1, p2) {
  let dx = p2.x - p1.x;
  let dy = p2.y - p1.y;
  let angle = Math.atan(dy / dx) * 180 / Math.PI;
  if (p2.x >= p1.x) {
    angle = -angle;
  } else {
    angle = 180 - angle;
  }
  return angle;
}
function getRotatePoint(p, rp, _angle) {
  let angle = (180 - _angle) * Math.PI / 180;
  return {
    x: (p.x - rp.x) * Math.cos(angle) - (p.y - rp.y) * Math.sin(angle) + rp.x,
    y: (p.x - rp.x) * Math.sin(angle) + (p.y - rp.y) * Math.cos(angle) + rp.y
  };
}
function arrow(path, newP, size, angle, lineWidth, arrowLength) {
  let pr = getRotatePoint({ x: newP.x + size, y: newP.y + 0.57 * size }, { x: newP.x, y: newP.y }, angle);
  let pl = getRotatePoint({ x: newP.x + size, y: newP.y - 0.57 * size }, { x: newP.x, y: newP.y }, angle);
  let pr1 = getRotatePoint({ x: newP.x + size, y: newP.y + lineWidth / 2 }, { x: newP.x, y: newP.y }, angle);
  let pr2 = getRotatePoint({ x: newP.x + arrowLength, y: newP.y + lineWidth / 2 }, { x: newP.x, y: newP.y }, angle);
  let pl1 = getRotatePoint({ x: newP.x + size, y: newP.y - lineWidth / 2 }, { x: newP.x, y: newP.y }, angle);
  let pl2 = getRotatePoint({ x: newP.x + arrowLength, y: newP.y - lineWidth / 2 }, { x: newP.x, y: newP.y }, angle);
  path.moveTo(pr.x, pr.y);
  path.lineTo(newP.x, newP.y);
  path.lineTo(pl.x, pl.y);
  path.lineTo(pl1.x, pl1.y);
  path.lineTo(pl2.x, pl2.y);
  path.lineTo(pr2.x, pr2.y);
  path.lineTo(pr1.x, pr1.y);
  path.lineTo(pr.x, pr.y);
}
function waterDrop(path, newP, reverse, angle, lineWidth, arrowLength) {
  let dis = lineWidth / 2;
  if (reverse) {
    dis = -lineWidth / 2;
  }
  let pl1 = getRotatePoint({ x: newP.x, y: newP.y + dis }, { x: newP.x, y: newP.y }, angle);
  let pE = getRotatePoint({ x: newP.x + arrowLength, y: newP.y }, { x: newP.x, y: newP.y }, angle);
  let rAngle = Math.PI / 2;
  if (reverse) {
    rAngle = -Math.PI / 2;
  }
  path.moveTo(newP.x, newP.y);
  path.arc(newP.x, newP.y, lineWidth / 2, -rAngle - angle / 180 * Math.PI, rAngle - angle / 180 * Math.PI, false);
  path.lineTo(pE.x, pE.y);
  path.lineTo(pl1.x, pl1.y);
}

// node_modules/@meta2d/core/src/diagrams/iframe.js
function iframe(pen) {
  var _a;
  if (!pen.onDestroy) {
    pen.onDestroy = destory;
    pen.onMove = move;
    pen.onResize = move;
    pen.onRotate = move;
    pen.onValue = move;
    pen.onMouseMove = mouseMove;
    pen.onBeforeValue = beforeValue;
    pen.onRenderPenRaw = renderPenRaw;
  }
  if (!pen.calculative.singleton) {
    pen.calculative.singleton = {};
  }
  const worldRect = pen.calculative.worldRect;
  if (!pen.calculative.singleton.div) {
    const div = document.createElement("div");
    div.style.position = "absolute";
    div.style.outline = "none";
    div.style.left = "-9999px";
    div.style.top = "-9999px";
    div.style.width = worldRect.width + "px";
    div.style.height = worldRect.height + "px";
    document.body.appendChild(div);
    (_a = pen.calculative.canvas.externalElements) == null ? void 0 : _a.parentElement.appendChild(div);
    setElemPosition(pen, div);
    pen.calculative.singleton.div = div;
    const iframe2 = document.createElement("iframe");
    iframe2.style.width = "100%";
    iframe2.style.height = "100%";
    iframe2.scrolling = pen.scrolling || "no";
    iframe2.frameBorder = "0";
    iframe2.style.border = "none";
    iframe2.src = pen.iframe;
    pen.calculative.iframe = pen.iframe;
    div.appendChild(iframe2);
    generateAroundDiv(pen);
    iframe2.onload = () => {
      iframe2.setAttribute("document.domain", "");
    };
  }
  if (pen.calculative.patchFlags) {
    setElemPosition(pen, pen.calculative.singleton.div);
  }
  pen.onRenderPenRaw(pen);
  return new Path2D();
}
function destory(pen) {
  updatePointerEvents(pen);
  if (pen.calculative.singleton && pen.calculative.singleton.div) {
    pen.calculative.singleton.div.remove();
    delete pen.calculative.singleton.div;
  }
}
function move(pen) {
  pen.calculative.singleton.div && setElemPosition(pen, pen.calculative.singleton.div);
}
function beforeValue(pen, value4) {
  if (value4.iframe) {
    if (pen.calculative.singleton.div) {
      pen.calculative.singleton.div.children[0].src = value4.iframe;
      pen.calculative.iframe = value4.iframe;
    }
  }
  if (value4.operationalRect || value4["operationalRect.x"] !== void 0 || value4["operationalRect.y"] !== void 0 || value4["operationalRect.width"] !== void 0 || value4["operationalRect.height"] !== void 0) {
    if (!pen.operationalRect) {
      pen.operationalRect = {};
    }
    let _value = deepClone(value4);
    if (!_value.operationalRect) {
      _value.operationalRect = {};
    }
    if (_value["operationalRect.x"] !== void 0) {
      _value.operationalRect.x = _value["operationalRect.x"];
    }
    if (_value["operationalRect.y"] !== void 0) {
      _value.operationalRect.y = _value["operationalRect.y"];
    }
    if (_value["operationalRect.width"] !== void 0) {
      _value.operationalRect.width = _value["operationalRect.width"];
    }
    if (_value["operationalRect.height"] !== void 0) {
      _value.operationalRect.height = _value["operationalRect.height"];
    }
    Object.assign(pen.operationalRect, _value.operationalRect);
    if (pen.calculative.singleton.div) {
      let length = pen.calculative.singleton.div.children.length;
      if (length === 1) {
        generateAroundDiv(pen);
      } else {
        pen.calculative.singleton.div.children[1].style.height = pen.operationalRect.y * 100 + "%";
        pen.calculative.singleton.div.children[1].style.left = pen.operationalRect.x * 100 + "%";
        pen.calculative.singleton.div.children[1].style.width = pen.operationalRect.width * 100 + "%";
        pen.calculative.singleton.div.children[2].style.width = (1 - pen.operationalRect.x - pen.operationalRect.width) * 100 + "%";
        pen.calculative.singleton.div.children[3].style.height = (1 - pen.operationalRect.y - pen.operationalRect.height) * 100 + "%";
        pen.calculative.singleton.div.children[3].style.left = pen.operationalRect.x * 100 + "%";
        pen.calculative.singleton.div.children[3].style.width = pen.operationalRect.width * 100 + "%";
        pen.calculative.singleton.div.children[4].style.width = pen.operationalRect.x * 100 + "%";
      }
    }
  }
  if (value4.blur !== void 0) {
    for (let i = 1; i < 5; i++) {
      pen.calculative.singleton.div.children[i].style["backdrop-filter"] = `blur(${value4.blur || 2}px)`;
    }
  }
  if (value4.blurBackground !== void 0) {
    for (let i = 1; i < 5; i++) {
      pen.calculative.singleton.div.children[i].style.backgroundColor = value4.blurBackground;
    }
  }
  return value4;
}
function mouseMove(pen, e) {
  if (!pen.calculative.canvas.store.data.locked && !pen.locked) {
    return;
  }
  if (initOperationalRect(pen.operationalRect)) {
    if (pen.calculative.zIndex < 5 && e.x > pen.x + pen.width * pen.operationalRect.x && e.x < pen.x + pen.width * (pen.operationalRect.x + pen.operationalRect.width) && e.y > pen.y + pen.height * pen.operationalRect.y && e.y < pen.y + pen.height * (pen.operationalRect.y + pen.operationalRect.height)) {
      if (pen.calculative.singleton.div) {
        let children = pen.calculative.singleton.div.parentNode.children;
        for (let i = 0; i < 6; i++) {
          children[i].style.pointerEvents = "none";
        }
      }
    }
  }
}
function initOperationalRect(operationalRect) {
  if (operationalRect) {
    if (!operationalRect.width || !operationalRect.height) {
      return false;
    }
    if (operationalRect.x === void 0) {
      operationalRect.x = (1 - operationalRect.width) / 2;
    }
    if (operationalRect.y === void 0) {
      operationalRect.y = (1 - operationalRect.height) / 2;
    }
    return true;
  } else {
    return false;
  }
}
function generateAroundDiv(pen) {
  if (!initOperationalRect(pen.operationalRect)) {
    return;
  }
  const div = pen.calculative.singleton.div;
  if (!div) {
    return;
  }
  const top = document.createElement("div");
  top.style.position = "absolute";
  top.style.left = pen.operationalRect.x * 100 + "%";
  top.style.top = "0px";
  top.style.width = pen.operationalRect.width * 100 + "%";
  top.style.height = pen.operationalRect.y * 100 + "%";
  top.style["backdrop-filter"] = `blur(${pen.blur || 2}px)`;
  top.style.backgroundColor = pen.blurBackground;
  div.appendChild(top);
  const right = document.createElement("div");
  right.style.position = "absolute";
  right.style.right = "0px";
  right.style.top = "0px";
  right.style.width = (1 - pen.operationalRect.x - pen.operationalRect.width) * 100 + "%";
  right.style.height = "100%";
  right.style["backdrop-filter"] = `blur(${pen.blur || 2}px)`;
  right.style.backgroundColor = pen.blurBackground;
  div.appendChild(right);
  const bottom = document.createElement("div");
  bottom.style.position = "absolute";
  bottom.style.left = pen.operationalRect.x * 100 + "%";
  bottom.style.bottom = "0px";
  bottom.style.width = pen.operationalRect.width * 100 + "%";
  bottom.style.height = (1 - pen.operationalRect.y - pen.operationalRect.height) * 100 + "%";
  bottom.style["backdrop-filter"] = `blur(${pen.blur || 2}px)`;
  bottom.style.backgroundColor = pen.blurBackground;
  div.appendChild(bottom);
  const left = document.createElement("div");
  left.style.position = "absolute";
  left.style.left = "0px";
  left.style.top = "0px";
  left.style.width = pen.operationalRect.x * 100 + "%";
  left.style.height = "100%";
  left.style["backdrop-filter"] = `blur(${pen.blur || 2}px)`;
  left.style.backgroundColor = pen.blurBackground;
  div.appendChild(left);
  let mouseEnter2 = () => {
    updatePointerEvents(pen);
  };
  top.onmouseenter = mouseEnter2;
  bottom.onmouseenter = mouseEnter2;
  right.onmouseenter = mouseEnter2;
  left.onmouseenter = mouseEnter2;
  div.onmouseleave = mouseEnter2;
}
function updatePointerEvents(pen) {
  if (!pen.calculative.canvas.store.data.locked && !pen.locked) {
    return;
  }
  if (pen.calculative.zIndex < 5) {
    let children = pen.calculative.singleton.div.parentNode.children;
    for (let i = 1; i < 6; i++) {
      children[i].style.pointerEvents = "initial";
    }
  }
}
function renderPenRaw(pen) {
  if (pen.thumbImg) {
    if (!pen.calculative.img) {
      const img = new Image();
      img.crossOrigin = pen.crossOrigin === "undefined" ? void 0 : pen.crossOrigin || "anonymous";
      if (pen.calculative.canvas.store.options.cdn && !(pen.thumbImg.startsWith("http") || pen.thumbImg.startsWith("//") || pen.thumbImg.startsWith("data:image"))) {
        img.src = pen.calculative.canvas.store.options.cdn + pen.thumbImg;
      } else {
        img.src = pen.thumbImg;
      }
      img.onerror = (e) => {
        img.remove();
        pen.calculative.img = void 0;
      };
      pen.calculative.img = img;
    }
  } else {
  }
}

// node_modules/@meta2d/core/src/diagrams/video.js
var videos = {};
var mutedIcons = ['<svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M473.088 125.44L256 256H52.224C23.552 256 0 279.552 0 308.224V716.8c0 28.16 23.04 51.2 51.2 51.2h204.8l217.088 130.56c16.896 10.24 38.912-2.048 38.912-22.016V147.456c0-19.968-21.504-32.256-38.912-22.016zM699.904 320.512c-20.992-18.944-53.248-17.408-72.192 3.584-18.944 20.992-17.408 53.248 3.584 72.192 0.512 0.512 58.368 54.784 58.368 121.344 0 37.888-19.456 74.752-58.368 110.08-20.992 18.944-22.528 51.2-3.584 72.192 10.24 11.264 24.064 16.896 37.888 16.896 12.288 0 24.576-4.608 34.304-13.312 61.44-55.296 92.16-117.76 92.16-185.856 0-112.64-88.576-193.536-92.16-197.12z" fill="" p-id="2434"></path><path d="M853.504 166.4c-20.992-18.944-53.248-16.896-72.192 4.096-18.944 20.992-16.896 53.248 4.096 72.192 1.536 1.024 135.68 122.88 135.68 280.576 0 90.624-45.568 177.152-135.68 257.536-20.992 18.944-23.04 51.2-4.096 72.192 10.24 11.264 24.064 16.896 38.4 16.896 12.288 0 24.576-4.096 34.304-12.8 112.64-100.864 169.984-212.992 169.984-333.824-1.024-202.752-163.84-350.208-170.496-356.864z"></path></svg>', '<svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" ><path d="M256 768H51.2c-28.16 0-51.2-23.04-51.2-51.2V308.224C0 279.552 23.552 256 52.224 256H256v512zM512 147.456v728.576c0 19.968-21.504 32.256-38.912 22.016L256 768V256l217.088-130.56c17.408-10.24 38.912 2.048 38.912 22.016zM623.104 656.896c-19.968-19.968-19.968-52.224 0-72.192l217.088-217.088c19.968-19.968 52.224-19.968 72.192 0 19.968 19.968 19.968 52.224 0 72.192l-217.088 217.088c-19.456 19.968-52.224 19.968-72.192 0z" fill="" p-id="2582"></path><path d="M623.104 367.104c19.968-19.968 52.224-19.968 72.192 0l217.088 217.088c19.968 19.968 19.968 52.224 0 72.192-19.968 19.968-52.224 19.968-72.192 0l-217.088-217.088c-19.968-19.456-19.968-52.224 0-72.192z"></path></svg>'];
function video(pen) {
  var _a;
  if (!pen.onDestroy) {
    pen.onDestroy = destory2;
    pen.onMove = move2;
    pen.onResize = move2;
    pen.onRotate = move2;
    pen.onClick = click;
    pen.onValue = value;
    pen.onChangeId = changeId;
  }
  if (!videos[pen.id]) {
    const player = document.createElement("div");
    const progress = document.createElement("div");
    progress.style.position = "absolute";
    progress.style.outline = "none";
    progress.style.left = "0";
    progress.style.bottom = "0";
    progress.style.width = "0";
    progress.style.height = "2px";
    progress.style.background = "#52c41a";
    progress.style.zIndex = "1";
    if (pen.hideProgress) {
      progress.style.display = "none";
    }
    const muted = document.createElement("div");
    muted.innerHTML = mutedIcons[1];
    muted.style.position = "absolute";
    muted.style.right = "0";
    muted.style.bottom = "0";
    muted.style.width = "20px";
    muted.style.height = "20px";
    muted.style.fill = "hsla(0, 0%, 100%, .8)";
    muted.style.zIndex = "1";
    muted.style.display = "none";
    player.appendChild(progress);
    player.appendChild(muted);
    muted.onclick = (e) => {
      e.stopPropagation();
      if (pen.calculative.media.muted) {
        muted.innerHTML = mutedIcons[0];
        pen.calculative.media.muted = false;
      } else {
        muted.innerHTML = mutedIcons[1];
        pen.calculative.media.muted = true;
      }
    };
    if (!pen.calculative.singleton) {
      pen.calculative.singleton = {};
    }
    pen.calculative.singleton.muted = muted;
    player.onmouseenter = (e) => {
      muted.style.display = "block";
    };
    player.onmouseleave = (e) => {
      muted.style.display = "none";
    };
    player.onclick = (e) => {
      e.stopPropagation();
      click(pen);
    };
    let media;
    if (pen.video) {
      media = document.createElement("video");
      media.src = pen.video;
    } else if (pen.audio) {
      media = document.createElement("audio");
      media.controls = pen.controls;
      media.src = pen.audio;
    }
    media.loop = pen.playLoop;
    media.ontimeupdate = () => {
      resizeProcessWidth(progress, media, pen.calculative.worldRect.width);
    };
    media.onended = () => {
      pen.calculative.onended && pen.calculative.onended(pen);
    };
    pen.calculative.media = media;
    media.style.position = "absolute";
    media.style.outline = "none";
    media.style.left = "0";
    media.style.top = "0";
    media.style.width = "100%";
    media.style.height = "100%";
    player.appendChild(media);
    videos[pen.id] = player;
    (_a = pen.calculative.canvas.externalElements) == null ? void 0 : _a.parentElement.appendChild(player);
    setElemPosition(pen, player);
    if (pen.autoPlay) {
      media.autoplay = true;
      media.muted = true;
    }
  } else if (pen.video && pen.calculative.media && pen.video !== pen.calculative.video) {
    console.warn("video , ");
    pen.calculative.media.src = pen.video;
    if (pen.autoPlay) {
      pen.calculative.media.muted = true;
      pen.calculative.media.autoplay = true;
    }
    pen.calculative.media.loop = pen.playLoop;
    pen.calculative.video = pen.video;
  } else if (pen.audio && pen.calculative.media && pen.audio !== pen.calculative.audio) {
    pen.calculative.media.src = pen.audio;
    if (pen.autoPlay) {
      pen.calculative.media.muted = true;
      pen.calculative.media.autoplay = true;
    }
    pen.calculative.media.loop = pen.playLoop;
    pen.calculative.audio = pen.audio;
  }
  if (pen.calculative.patchFlags) {
    setElemPosition(pen, videos[pen.id]);
  }
  return new Path2D();
}
function destory2(pen) {
  videos[pen.id].onclick = null;
  videos[pen.id].remove();
  videos[pen.id] = void 0;
}
function move2(pen) {
  setElemPosition(pen, videos[pen.id]);
  const progress = videos[pen.id].children[0];
  const media = videos[pen.id].children[1];
  resizeProcessWidth(progress, media, pen.calculative.worldRect.width);
}
function click(pen) {
  if (pen.calculative.media) {
    pen.calculative.media.muted = false;
    pen.calculative.singleton.muted.innerHTML = mutedIcons[0];
    if (pen.calculative.media.paused) {
      pen.calculative.media.play();
    } else {
      pen.calculative.media.pause();
    }
  }
}
function resizeProcessWidth(progress, media, width) {
  progress.style.width = media.currentTime / media.duration * width + "px";
}
function changeId(pen, oldId, newId) {
  if (!videos[oldId]) {
    return;
  }
  videos[newId] = videos[oldId];
  delete videos[oldId];
}
function value(pen) {
  const video2 = videos[pen.id];
  if (!video2) {
    return;
  }
  setElemPosition(pen, video2);
  const currentSrc = pen.calculative.media.getAttribute("src");
  if (pen.video) {
    if (currentSrc !== pen.video) {
      pen.calculative.media.src = pen.video;
    }
  } else if (pen.audio) {
    if (currentSrc !== pen.audio) {
      pen.calculative.media.src = pen.audio;
    }
  }
  if (pen.autoPlay) {
    pen.calculative.media.muted = true;
    pen.calculative.media.autoplay = true;
  }
  pen.calculative.media.loop = pen.playLoop;
}

// node_modules/@meta2d/core/src/canvas/offscreen.js
function createOffscreen() {
  try {
    const offscreen = new OffscreenCanvas(0, 0);
    const context = offscreen.getContext("2d");
    if (context && context.arc) {
      return offscreen;
    }
    return document.createElement("canvas");
  } catch (e) {
    return document.createElement("canvas");
  }
}

// node_modules/@meta2d/core/src/options.js
var KeydownType;
(function(KeydownType2) {
  KeydownType2[KeydownType2["None"] = -1] = "None";
  KeydownType2[KeydownType2["Document"] = 0] = "Document";
  KeydownType2[KeydownType2["Canvas"] = 1] = "Canvas";
})(KeydownType || (KeydownType = {}));
var defaultOptions = {
  fontFamily: '"Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", Helvetica, Arial',
  fontSize: 12,
  lineHeight: 1.5,
  textAlign: "center",
  textBaseline: "middle",
  color: "#222222",
  activeColor: "#278df8",
  hoverColor: "rgba(39,141,248,0.50)",
  anchorColor: "#278DF8",
  hoverAnchorColor: "#FF4101",
  anchorRadius: 4,
  anchorBackground: "#fff",
  dockColor: "rgba(39,141,248,0.50)",
  dockPenColor: "#1890FF",
  dragColor: "#1890ff",
  rotateCursor: "rotate.cur",
  rightCursor: "right.cur",
  downCursor: "down.cur",
  hoverCursor: "pointer",
  minScale: 0.1,
  maxScale: 10,
  keydown: KeydownType.Document,
  gridSize: 20,
  gridColor: "#e2e2e2",
  ruleColor: "#888888",
  drawingLineName: "curve",
  interval: 30,
  animateInterval: 30,
  autoPolyline: true,
  autoAnchor: true,
  autoAlignGrid: false,
  animateColor: "#30EEDC",
  ruleLineColor: "#FF4101",
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowBlur: 64,
  shadowColor: "#00000014",
  globalAlpha: 1,
  defaultAnchors: [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 1,
      y: 0.5
    },
    {
      x: 0.5,
      y: 1
    },
    {
      x: 0,
      y: 0.5
    }
  ],
  measureTextWidth: true,
  moveConnectedLine: true,
  mouseRightActive: true,
  disableClipboard: false,
  drawingLineLength: 0,
  disableTouchPadScale: false,
  cdn: "",
  polylineSpace: 10,
  domShapes: [],
  containerShapes: ["tablePlus"],
  textFlip: true,
  textRotate: true,
  unavailableKeys: [],
  diagramOptions: {},
  svgPathStroke: true,
  reconnetTimes: 10
};

// node_modules/@meta2d/core/package.json
var package_default = {
  name: "@meta2d/core",
  version: "1.0.71",
  description: "@meta2d/core: Powerful, Beautiful, Simple, Open - Web-Based 2D At Its Best .",
  main: "index.js",
  types: "index.d.ts",
  scripts: {
    copy: "copyfiles  package.json ../../dist/core/",
    build: "tsc && npm run copy"
  },
  keywords: [
    "meta2d",
    "diagram",
    "2D",
    "canvas"
  ],
  author: "alsmile123@qq.com",
  license: "MIT",
  repository: {
    type: "git",
    url: "git+https://github.com/le5le-com/meta2d.js.git"
  },
  bugs: {
    url: "https://github.com/le5le-com/meta2d.js/issues"
  },
  homepage: "https://github.com/le5le-com/meta2d.js#readme",
  devDependencies: {
    "@types/marked": "^4.0.3",
    "@types/offscreencanvas": "latest"
  },
  dependencies: {
    mitt: "^2.1.0",
    mqtt: "^4.2.6"
  },
  publishConfig: {
    access: "public"
  },
  gitHead: "78f2a53ca1839c89b56e2e498d17ba4eb987ad14"
};

// node_modules/@meta2d/core/src/store/global.js
var globalStore = {
  version: package_default.version,
  path2dDraws: {},
  canvasDraws: {},
  anchors: {},
  htmlElements: {}
};
function register(path2dFns) {
  Object.assign(globalStore.path2dDraws, path2dFns);
}
function registerCanvasDraw(drawFns) {
  Object.assign(globalStore.canvasDraws, drawFns);
}
function registerAnchors(anchorsFns) {
  Object.assign(globalStore.anchors, anchorsFns);
}

// node_modules/@meta2d/core/node_modules/mitt/dist/mitt.es.js
function mitt_es_default(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i = n.get(t);
    i && i.push(e) || n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && i.splice(i.indexOf(e) >>> 0, 1);
  }, emit: function(t, e) {
    (n.get(t) || []).slice().map(function(n2) {
      n2(e);
    }), (n.get("*") || []).slice().map(function(n2) {
      n2(t, e);
    });
  } };
}

// node_modules/@meta2d/core/src/theme.js
var themeKeys = [
  "color",
  "hoverColor",
  "activeColor",
  "disabledColor",
  "background",
  "activeBackground",
  //
  "hoverBackground",
  "disabledBackground",
  "anchorColor",
  "hoverAnchorColor",
  "anchorBackground",
  "animateColor",
  "textColor",
  "ruleColor",
  "ruleLineColor",
  "gridColor",
  "lineColor",
  "penBackground",
  "dockPenColor"
  // "ruleOptions"
];
var defaultTheme = {
  dark: {
    color: "#bdc7db",
    background: "#1e2430",
    parentBackground: "#080b0f",
    ruleColor: "#222E47",
    ruleOptions: {
      background: "#121924",
      textColor: "#6E7B91"
    }
  },
  light: {
    color: "#222222",
    background: "#FFFFFF",
    parentBackground: "#F0F1F2",
    ruleColor: "#C8D0E1",
    ruleOptions: {
      background: "#F7F8FA",
      textColor: "#C8D0E1"
    }
  }
};
var le5leTheme = {
  "cssRuleSelector": ":root",
  "style_prefix": "le5le_",
  "vendor_css_prefix": "--le-",
  "dark": [
    "text-color-primary: #7f838c",
    "text-color-second: rgba(255,255,255,0.90)",
    "text-color-disabled: rgba(255,255,255,0.40)",
    "container-bg: rgba(21,24,28,0.95)",
    "form-bg: #2a2f36",
    "date-picker-cell-active-with-range-bg: #2c4475",
    "component-disabled-bg-color: #252b37",
    "data-picker-cell-active-bg: #4583ff",
    "active-bg: #25375b",
    "popcontent-bg: #252b37",
    "bdcolor-outside: #4583ff",
    "bdcolor-form: #424b61",
    "bdcolor-inside: rgba(255,255,255,0.40)",
    "shadow: 0px 1px 10px 0px rgba(0,0,0,0.05), 0px 4px 5px 0px rgba(0,0,0,0.08), 0px 2px 4px -1px rgba(0,0,0,0.12)",
    "radius: 4px"
  ],
  "light": [
    "text-color-primary: #7f838c",
    "text-color-second: #171B27",
    "text-color-disabled: rgba(0, 0, 0, 0.6)",
    "container-bg: #ffffff",
    "form-bg: #EFF1F4",
    "date-picker-cell-active-with-range-bg: #f2f3ff",
    "component-disabled-bg-color: #eee",
    "data-picker-cell-active-bg: #0052d9",
    "active-bg: #f2f3ff",
    "popcontent-bg: #ffffff",
    "bdcolor-outside: transparent",
    "bdcolor-form: #d4d6d9",
    "bdcolor-inside: #e7e7e7",
    "shadow: 0px 2px 4px 0px rgba(107,113,121,0.25)",
    "radius: 4px"
  ],
  /**
   * @description --le-text-color-primary: #7f838c
   * @author Joseph Ho
   * @date 26/12/2024
   * @param {*} theme
   * @returns {*}
   */
  _addVendorCssPrefix(themeList) {
    return themeList.map((item) => {
      const [key, value4] = item.split(":");
      return `${this.vendor_css_prefix}${key.trim()}:${value4.trim()}`;
    });
  },
  /**
   * @description css
   * @author Joseph Ho
   * @date 26/12/2024
   * @param {*} theme 
   * @param {*} id id
   */
  createThemeSheet(theme, id) {
    const style = document.createElement("style");
    style.type = "text/css";
    style.id = this.style_prefix + id;
    document.head.appendChild(style);
    const _theme = theme || "light";
    const cssDeclarations = this.getTheme(_theme);
    const newRuleText = `${this.cssRuleSelector} { ${cssDeclarations.join(";")} }`;
    style.innerHTML = newRuleText;
  },
  /**
   * @description id
   * @author Joseph Ho
   * @date 26/12/2024
   * @param {*} id
   */
  destroyThemeSheet(id) {
    const styleSheet = this.findStyleSheet(this.style_prefix + id);
    if (styleSheet) {
      document.head.removeChild(styleSheet.ownerNode);
    }
  },
  /**
   * @description 
   * @author Joseph Ho
   * @date 26/12/2024
   * @param {*} theme
   * @returns {*}
   */
  getTheme(theme) {
    return this._addVendorCssPrefix(this[theme] || this.light);
  },
  /**
   * @description id
   * @author Joseph Ho
   * @date 26/12/2024
   * @param {*} id
   * @returns {*}
   */
  findStyleSheet(id) {
    const styleSheets = document.styleSheets;
    for (let i = 0; i < styleSheets.length; i++) {
      const styleSheet = styleSheets[i];
      if (styleSheet.ownerNode && styleSheet.ownerNode.id === id) {
        return styleSheet;
      }
    }
    return null;
  },
  /**
   * @description 
   * @author Joseph Ho
   * @date 26/12/2024
   * @param {*} id
   * @param {*} theme
   */
  updateCssRule(id, themeName) {
    const theme = this.getTheme(themeName);
    const newCssDeclarations = theme;
    const styleSheet = this.findStyleSheet(this.style_prefix + id);
    if (!styleSheet)
      return;
    let ruleExists = false;
    for (let i = 0; i < styleSheet.cssRules.length; i++) {
      const rule = styleSheet.cssRules[i];
      if (rule.selectorText === this.cssRuleSelector) {
        ruleExists = true;
        break;
      }
    }
    if (ruleExists) {
      for (let i = 0; i < styleSheet.cssRules.length; i++) {
        const rule = styleSheet.cssRules[i];
        if (rule.selectorText === this.cssRuleSelector) {
          if (styleSheet.insertRule) {
            styleSheet.deleteRule(i);
            const newRuleText = `${this.cssRuleSelector} { ${newCssDeclarations.join(";")} }`;
            styleSheet.insertRule(newRuleText, i);
          } else if (styleSheet.addRule) {
            rule.style.cssText = newCssDeclarations.join(";");
          }
        }
      }
    } else {
      if (styleSheet.insertRule) {
        const newRuleText = `${this.cssRuleSelector} { ${newCssDeclarations.join(";")} }`;
        styleSheet.insertRule(newRuleText, styleSheet.cssRules.length);
      } else if (styleSheet.addRule) {
        const existingRootRule = styleSheet.cssRules.find((rule) => rule.selectorText === this.cssRuleSelector);
        if (existingRootRule) {
          const declarationsToAdd = newCssDeclarations.join(";");
          existingRootRule.style.cssText += `; ${declarationsToAdd}`;
        } else {
          styleSheet.addRule(this.cssRuleSelector, newCssDeclarations.join(";"));
        }
      }
    }
  }
};

// node_modules/@meta2d/core/src/store/store.js
var EditType;
(function(EditType2) {
  EditType2[EditType2["Add"] = 0] = "Add";
  EditType2[EditType2["Update"] = 1] = "Update";
  EditType2[EditType2["Delete"] = 2] = "Delete";
  EditType2[EditType2["Replace"] = 3] = "Replace";
})(EditType || (EditType = {}));
var createStore = () => {
  return {
    data: {
      x: 0,
      y: 0,
      scale: 1,
      pens: [],
      origin: { x: 0, y: 0 },
      center: { x: 0, y: 0 },
      paths: {}
      // theme:'light'
    },
    histories: [],
    pens: {},
    path2dMap: /* @__PURE__ */ new WeakMap(),
    animateMap: /* @__PURE__ */ new WeakMap(),
    active: [],
    animates: /* @__PURE__ */ new Set(),
    options: { ...defaultOptions },
    theme: { ...defaultTheme },
    emitter: mitt_es_default(),
    bindDatas: {},
    bind: {},
    pensNetwork: {},
    cacheDatas: [],
    messageEvents: {},
    templatePens: {},
    globalTriggers: {}
  };
};
var useStore = (id = "default") => {
  if (!globalStore[id]) {
    globalStore[id] = createStore();
    globalStore[id].id = id;
  }
  return globalStore[id];
};
var clearStore = (store, template) => {
  const isSame = store.data.template === template;
  if (isSame) {
    for (const pen of store.data.pens) {
      if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
        store.templatePens[pen.id] = pen;
      }
    }
  }
  store.lastScale = store.data.scale;
  store.data = {
    x: 0,
    y: 0,
    scale: 1,
    pens: [],
    origin: { x: 0, y: 0 },
    center: { x: 0, y: 0 },
    paths: {},
    template: isSame ? template : null
  };
  store.sameTemplate = isSame;
  store.pens = {};
  store.histories = [];
  store.historyIndex = null;
  store.path2dMap = /* @__PURE__ */ new WeakMap();
  store.animateMap = /* @__PURE__ */ new WeakMap();
  store.bindDatas = {};
  store.bind = {};
  store.pensNetwork = {};
  store.active = [];
  store.hover = void 0;
  store.lastHover = void 0;
  store.animates.clear();
};

// node_modules/@meta2d/core/src/tooltip/tooltip.js
var Tooltip = class _Tooltip {
  //  tooltip 
  constructor(parentElement, store) {
    __publicField(this, "parentElement");
    __publicField(this, "store");
    __publicField(this, "box");
    __publicField(this, "text");
    __publicField(this, "arrowUp");
    __publicField(this, "arrowDown");
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "currentPen");
    this.parentElement = parentElement;
    this.store = store;
    this.box = document.createElement("div");
    this.text = document.createElement("div");
    this.arrowUp = document.createElement("div");
    this.arrowDown = document.createElement("div");
    this.box.className = "meta2d-tooltip";
    this.text.className = "text";
    this.arrowUp.className = "arrow";
    this.arrowDown.className = "arrow down";
    this.box.appendChild(this.text);
    this.box.appendChild(this.arrowUp);
    this.box.appendChild(this.arrowDown);
    parentElement.appendChild(this.box);
    this.box.onmouseleave = () => {
      this.hide();
      this.store.lastHover = void 0;
    };
    let sheet;
    for (let i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].title === "le5le.com/tooltip") {
        sheet = document.styleSheets[i];
      }
    }
    if (!sheet) {
      let style = document.createElement("style");
      style.type = "text/css";
      style.title = "le5le.com/tooltip";
      document.head.appendChild(style);
      style = document.createElement("style");
      style.type = "text/css";
      document.head.appendChild(style);
      sheet = style.sheet;
      sheet.insertRule(".meta2d-tooltip{position:absolute;padding:8px 0;z-index:10;left: -9999px;top: -9999px;}");
      sheet.insertRule(".meta2d-tooltip .text{max-width:320px;min-height:30px;max-height:400px;outline:none;padding:8px 16px;border-radius:4px;background:#777777;color:#ffffff;line-height:1.8;overflow-y:auto;}");
      sheet.insertRule(".meta2d-tooltip .arrow{position:absolute;border:10px solid transparent;background:transparent;top:-5px;left:50%;transform:translateX(-50%)}");
      sheet.insertRule(".meta2d-tooltip .arrow.down{top:initial;bottom: -1px;}");
    }
  }
  /**
   *  pen  titleFn titleFnJs title  title
   * @returns  title
   */
  static getTitle(pen) {
    if (pen.titleFnJs && !pen.titleFn) {
      try {
        pen.titleFn = new Function("pen", pen.titleFnJs);
      } catch (error) {
        console.log("titleFnJs", error);
      }
    }
    return pen.titleFn ? pen.titleFn(pen) : String(pen.title);
  }
  /**
   *  tooltip dom 
   * @returns  rect
   */
  setText(pen) {
    const oldElemRect = this.box.getBoundingClientRect();
    let marked = globalThis.marked;
    const title = _Tooltip.getTitle(pen);
    if (marked) {
      this.text.innerHTML = marked(title);
      const a = this.text.getElementsByTagName("A");
      for (let i = 0; i < a.length; ++i) {
        a[i].setAttribute("target", "_blank");
      }
    } else {
      this.text.innerHTML = title;
    }
    return oldElemRect;
  }
  /**
   * 
   */
  updateText(pen) {
    var _a;
    if (((_a = this.currentPen) == null ? void 0 : _a.id) !== pen.id) {
      return;
    }
    if (_Tooltip.titleEmpty(pen)) {
      return;
    }
    const oldRect = this.setText(pen);
    const newRect = this.box.getBoundingClientRect();
    this.changePositionByText(oldRect, newRect);
  }
  /**
   *   box 
   * @param oldRect 
   * @param newRect 
   */
  changePositionByText(oldRect, newRect) {
    this.x -= (newRect.width - oldRect.width) / 2;
    this.y -= newRect.height - oldRect.height;
    this.box.style.left = this.x + "px";
    this.box.style.top = this.y + "px";
  }
  static titleEmpty(pen) {
    return !pen.title && !pen.titleFn && !pen.titleFnJs;
  }
  show(pen, pos) {
    this.currentPen = pen;
    if (_Tooltip.titleEmpty(pen)) {
      let parent = getParent(pen, true);
      if (parent) {
        this.show(parent, pos);
      }
      return;
    }
    this.setText(pen);
    const elemRect = this.box.getBoundingClientRect();
    const rect = pen.calculative.worldRect;
    let x = pen.calculative.canvas.store.data.x + pos.x - elemRect.width / 2;
    let y = pen.calculative.canvas.store.data.y + pos.y - elemRect.height;
    if (!pen.type) {
      x = pen.calculative.canvas.store.data.x + rect.x - (elemRect.width - rect.width) / 2;
      y = pen.calculative.canvas.store.data.y + rect.ey - elemRect.height - rect.height;
    }
    if (y > 0) {
      this.arrowUp.style.borderBottomColor = "transparent";
      this.arrowDown.style.borderTopColor = "#777777";
    } else {
      y += elemRect.height + rect.height + 5;
      this.arrowUp.style.borderBottomColor = "#777777";
      this.arrowDown.style.borderTopColor = "transparent";
    }
    this.x = x;
    this.y = y;
    this.box.style.left = this.x + "px";
    this.box.style.top = this.y + "px";
  }
  hide() {
    this.currentPen = null;
    this.x = -9999;
    this.box.style.left = "-9999px";
  }
  translate(x, y) {
    if (this.x < -1e3) {
      return;
    }
    this.x += x;
    this.y += y;
    this.box.style.left = this.x + "px";
    this.box.style.top = this.y + "px";
  }
  destroy() {
    this.box.onmouseleave = null;
  }
};

// node_modules/@meta2d/core/src/scroll/scroll.js
var Scroll = class {
  //
  constructor(parent) {
    __publicField(this, "parent");
    __publicField(this, "h");
    __publicField(this, "v");
    __publicField(this, "isDownH");
    __publicField(this, "isDownV");
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "hSize");
    __publicField(this, "vSize");
    __publicField(this, "scrollX");
    __publicField(this, "scrollY");
    __publicField(this, "lastScrollX");
    __publicField(this, "lastScrollY");
    __publicField(this, "rect");
    __publicField(this, "isShow");
    __publicField(this, "pageMode");
    __publicField(this, "onMouseDownH", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.isDownH = e.x;
      this.x = this.parent.store.data.x || 0;
      this.lastScrollX = this.scrollX;
    });
    __publicField(this, "onMouseDownV", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.isDownV = e.y;
      this.y = this.parent.store.data.y || 0;
      this.lastScrollY = this.scrollY;
    });
    __publicField(this, "onMouseMove", (e) => {
      if (this.isDownH) {
        const x = e.x - this.isDownH;
        this.scrollX = this.lastScrollX + x;
        this.h.style.left = `${this.scrollX}px`;
        this.parent.store.data.x = this.x - x * this.rect.width / this.parent.parentElement.clientWidth;
      }
      if (this.isDownV) {
        const y = e.y - this.isDownV;
        if (this.pageMode && this.canMouseMove(y)) {
          return;
        }
        this.scrollY = this.lastScrollY + y;
        this.v.style.top = `${this.scrollY}px`;
        this.parent.store.data.y = this.y - y * this.rect.height / this.parent.parentElement.clientHeight;
      }
      if (this.isDownH || this.isDownV) {
        this.parent.onMovePens();
        this.parent.canvasTemplate.init();
        this.parent.canvasImage.init();
        this.parent.canvasImageBottom.init();
        this.parent.render();
      }
    });
    __publicField(this, "onMouseUp", (e) => {
      if (!this.isDownH && !this.isDownV) {
        return;
      }
      this.isDownH = void 0;
      this.isDownV = void 0;
      if (this.scrollX < 20) {
        this.scrollX = 20;
        this.h.style.left = `${this.scrollX}px`;
      } else if (this.scrollX > this.parent.parentElement.clientWidth - this.hSize - 20) {
        this.scrollX = this.parent.parentElement.clientWidth - this.hSize - 20;
        this.h.style.left = `${this.scrollX}px`;
      }
      if (this.scrollY < 20) {
        this.scrollY = 20;
        this.v.style.top = `${this.scrollY}px`;
      } else if (this.scrollY > this.parent.parentElement.clientHeight - this.vSize - 20) {
        this.scrollY = this.parent.parentElement.clientHeight - this.vSize - 20;
        this.v.style.top = `${this.scrollY}px`;
      }
      this.resize();
    });
    this.parent = parent;
    this.h = document.createElement("div");
    this.v = document.createElement("div");
    this.parent.externalElements.appendChild(this.h);
    this.parent.externalElements.appendChild(this.v);
    this.h.className = "meta2d-scroll h";
    this.h.onmousedown = this.onMouseDownH;
    this.v.className = "meta2d-scroll v";
    this.v.onmousedown = this.onMouseDownV;
    document.addEventListener("mousemove", this.onMouseMove);
    document.addEventListener("mouseup", this.onMouseUp);
    let sheet;
    for (let i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].title === "le5le/scroll") {
        sheet = document.styleSheets[i];
      }
    }
    if (!sheet) {
      let style = document.createElement("style");
      style.type = "text/css";
      style.title = "le5le.com/scroll";
      document.head.appendChild(style);
      style = document.createElement("style");
      style.type = "text/css";
      document.head.appendChild(style);
      sheet = style.sheet;
      sheet.insertRule(".meta2d-scroll{position:absolute;width:8px;height:200px;background:#dddddd;border-radius:10px;z-index:20;cursor:default;}");
      sheet.insertRule(".meta2d-scroll:hover{background:#cccccc;cursor:pointer}");
      sheet.insertRule(".meta2d-scroll.v{right:0;top:calc(50% - 100px);}");
      sheet.insertRule(".meta2d-scroll.h{bottom:2px;left:calc(50% - 100px);width:200px;height:8px;}");
    }
    this.init();
  }
  init() {
    this.isShow = true;
    this.resize();
    this.initPos();
  }
  canMouseMove(y) {
    const rect = this.parent.parent.getRect();
    if (y < 0 && rect.y + this.parent.store.data.y >= 0) {
      return true;
    }
    if (y > 0 && rect.ey - this.parent.height + this.parent.store.data.y <= 0) {
      return true;
    }
    return false;
  }
  changeMode() {
    this.pageMode = true;
    this.h.style.display = `none`;
    const rect = this.parent.parent.getRect();
    if (rect.height < this.parent.height) {
      this.v.style.display = `none`;
    }
  }
  initPos() {
    this.scrollX = (this.parent.parentElement.clientWidth - this.hSize) / 2;
    this.scrollY = (this.parent.parentElement.clientHeight - this.vSize) / 2;
    this.h.style.left = `${this.scrollX}px`;
    this.v.style.top = `${this.scrollY}px`;
  }
  resize() {
    this.rect = getRect2(this.parent.store.data.pens);
    if (this.rect.width < 1400) {
      this.rect.width = 1400;
    }
    if (this.rect.height < 900) {
      this.rect.height = 900;
    }
    if (this.parent.store.data.x > 0) {
      this.rect.width += this.parent.store.data.x + (this.rect.x > 0 ? 0 : this.rect.x);
    } else {
      this.rect.width -= this.parent.store.data.x + (this.rect.x > 0 ? 0 : this.rect.x);
    }
    if (this.parent.store.data.y > 0) {
      this.rect.height += this.parent.store.data.y + (this.rect.y > 0 ? 0 : this.rect.y);
    } else {
      this.rect.height -= this.parent.store.data.y + (this.rect.y > 0 ? 0 : this.rect.y);
    }
    if (this.rect.width < 1400) {
      this.rect.width = 1400;
    }
    if (this.rect.height < 900) {
      this.rect.height = 900;
    }
    this.hSize = 1e3 * this.parent.parentElement.clientWidth / this.rect.width / 3;
    this.vSize = 1e3 * this.parent.parentElement.clientHeight / this.rect.height / 3;
    this.h.style.width = this.hSize + "px";
    this.v.style.height = this.vSize + "px";
  }
  show() {
    this.isShow = true;
    this.h.style.display = `block`;
    this.v.style.display = `block`;
    document.addEventListener("mousemove", this.onMouseMove);
    document.addEventListener("mouseup", this.onMouseUp);
  }
  hide() {
    this.isShow = false;
    this.h.style.display = `none`;
    this.v.style.display = `none`;
    this.destroy();
  }
  translate(x, y) {
    if (x) {
      this.scrollX -= x * this.parent.parentElement.clientWidth / this.rect.width;
      this.h.style.left = `${this.scrollX}px`;
    }
    if (y) {
      this.scrollY -= y * this.parent.parentElement.clientHeight / this.rect.height;
      this.v.style.top = `${this.scrollY}px`;
    }
  }
  wheel(up) {
    let y = 10;
    if (up) {
      y = -10;
    }
    if (this.pageMode && this.canMouseMove(y)) {
      return;
    }
    this.scrollY += y;
    this.v.style.top = `${this.scrollY}px`;
    this.parent.store.data.y -= y * this.rect.height / this.parent.parentElement.clientHeight;
    this.parent.onMovePens();
    this.parent.canvasTemplate.init();
    this.parent.canvasImage.init();
    this.parent.canvasImageBottom.init();
    this.parent.render();
  }
  destroy() {
    document.removeEventListener("mousemove", this.onMouseMove);
    document.removeEventListener("mouseup", this.onMouseUp);
  }
};

// node_modules/@meta2d/core/src/canvas/canvasImage.js
var CanvasImage = class {
  constructor(parentElement, store, isBottom) {
    __publicField(this, "parentElement");
    __publicField(this, "store");
    __publicField(this, "isBottom");
    __publicField(this, "canvas", document.createElement("canvas"));
    /**
     * 
     * isBottom true 
     * isBottom false  
     */
    __publicField(this, "otherOffsreen", createOffscreen());
    // 
    __publicField(this, "offscreen", createOffscreen());
    __publicField(this, "animateOffsScreen", createOffscreen());
    __publicField(this, "fitOffscreen", createOffscreen());
    __publicField(this, "fitFlag", false);
    //
    __publicField(this, "currentFit");
    __publicField(this, "activeFit");
    this.parentElement = parentElement;
    this.store = store;
    this.isBottom = isBottom;
    parentElement.appendChild(this.canvas);
    this.canvas.style.backgroundRepeat = "no-repeat";
    this.canvas.style.backgroundSize = "100% 100%";
    this.canvas.style.position = "absolute";
    this.canvas.style.top = "0";
    this.canvas.style.left = "0";
  }
  resize(w, h) {
    this.canvas.style.width = w + "px";
    this.canvas.style.height = h + "px";
    w = w * this.store.dpiRatio | 0;
    h = h * this.store.dpiRatio | 0;
    this.canvas.width = w;
    this.canvas.height = h;
    this.otherOffsreen.width = w;
    this.otherOffsreen.height = h;
    this.offscreen.width = w;
    this.offscreen.height = h;
    this.animateOffsScreen.width = w;
    this.animateOffsScreen.height = h;
    this.fitOffscreen.width = w;
    this.fitOffscreen.height = h;
    this.otherOffsreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio);
    this.otherOffsreen.getContext("2d").textBaseline = "middle";
    this.offscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio);
    this.offscreen.getContext("2d").textBaseline = "middle";
    this.animateOffsScreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio);
    this.animateOffsScreen.getContext("2d").textBaseline = "middle";
    this.fitOffscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio);
    this.fitOffscreen.getContext("2d").textBaseline = "middle";
    this.init();
  }
  init() {
    this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.animateOffsScreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.fitOffscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
    for (const pen of this.store.data.pens) {
      if (this.hasImage(pen)) {
        pen.calculative.imageDrawed = false;
      }
    }
    if (this.isBottom) {
      this.store.patchFlagsBackground = true;
    } else {
      this.store.patchFlagsTop = true;
    }
  }
  clear() {
    this.otherOffsreen.getContext("2d").clearRect(0, 0, this.otherOffsreen.width, this.otherOffsreen.height);
    this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.animateOffsScreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.fitOffscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.canvas.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  hasImage(pen) {
    pen.calculative.hasImage = pen.calculative && pen.calculative.inView && // !pen.isBottom == !this.isBottom && // undefined == false  false
    (this.isBottom && pen.canvasLayer === CanvasLayer.CanvasImageBottom || !this.isBottom && pen.canvasLayer === CanvasLayer.CanvasImage) && pen.image && pen.calculative.img && pen.name !== "gif";
    return pen.calculative.hasImage;
  }
  render() {
    var _a;
    let patchFlags = false;
    let patchFlagsAnimate = false;
    for (const pen of this.store.data.pens) {
      if (this.hasImage(pen)) {
        if (this.store.animates.has(pen)) {
          patchFlagsAnimate = true;
        } else if (!pen.calculative.imageDrawed) {
          patchFlags = true;
        }
        if (pen.parentId && this.store.animates.has(getParent(pen, true))) {
          patchFlagsAnimate = true;
        }
      }
    }
    const patchFlagsBackground = this.store.patchFlagsBackground;
    const patchFlagsTop = this.store.patchFlagsTop;
    if (patchFlagsTop && !this.isBottom) {
      const ctx = this.otherOffsreen.getContext("2d");
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.renderRule(ctx);
    }
    const patchFlagsLast = this.store.patchFlagsLast;
    if (patchFlagsLast) {
      const ctx = this.offscreen.getContext("2d");
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    if (patchFlags) {
      const ctx = this.offscreen.getContext("2d");
      ctx.save();
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctx.translate(this.store.data.x, this.store.data.y);
      for (const pen of this.store.data.pens) {
        if (!pen.calculative.hasImage || this.store.animates.has(pen) || this.store.animates.has(getParent(pen, true))) {
          continue;
        }
        if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
          continue;
        }
        if (pen.name === "combine" && !pen.draw) {
          continue;
        }
        pen.calculative.imageDrawed = true;
        ctx.save();
        ctxFlip(ctx, pen);
        if (pen.calculative.rotate) {
          ctxRotate(ctx, pen);
        }
        setGlobalAlpha(ctx, pen);
        drawImage(ctx, pen);
        ctx.restore();
      }
      ctx.restore();
    }
    if (patchFlagsAnimate) {
      const ctx = this.animateOffsScreen.getContext("2d");
      ctx.save();
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctx.translate(this.store.data.x, this.store.data.y);
      for (const pen of this.store.animates) {
        if (!pen.calculative.hasImage) {
          continue;
        }
        if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
          continue;
        }
        if (pen.visible === false || pen.calculative.visible === false) {
          continue;
        }
        pen.calculative.imageDrawed = true;
        ctx.save();
        ctxFlip(ctx, pen);
        if (pen.calculative.rotate) {
          ctxRotate(ctx, pen);
        }
        setGlobalAlpha(ctx, pen);
        drawImage(ctx, pen);
        ctx.restore();
      }
      for (const pen of this.store.data.pens) {
        if (!pen.calculative.hasImage || !pen.parentId) {
          continue;
        }
        if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
          continue;
        }
        if (pen.visible === false || pen.calculative.visible === false) {
          continue;
        }
        if (this.store.animates.has(getParent(pen, true))) {
          pen.calculative.imageDrawed = true;
          ctx.save();
          ctxFlip(ctx, pen);
          if (pen.calculative.rotate) {
            ctxRotate(ctx, pen);
          }
          setGlobalAlpha(ctx, pen);
          drawImage(ctx, pen);
          ctx.restore();
        }
      }
      ctx.restore();
    }
    if (!this.isBottom && !this.store.data.locked && this.fitFlag) {
      const width = (this.store.data.width || this.store.options.width) * this.store.data.scale;
      const height = (this.store.data.height || this.store.options.height) * this.store.data.scale;
      const x = this.store.data.origin.x + this.store.data.x || this.store.options.x || 0;
      const y = this.store.data.origin.y + this.store.data.y || this.store.options.y || 0;
      const ctx = this.fitOffscreen.getContext("2d");
      ctx.save();
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctx.fillStyle = "#ffffff66";
      ctx.strokeStyle = this.store.styles.activeColor;
      (_a = this.store.data.fits) == null ? void 0 : _a.forEach((item, index) => {
        ctx.fillRect(x + width * item.x, y + height * item.y, width * item.width, height * item.height);
        if (item.active) {
          ctx.strokeRect(x + width * item.x, y + height * item.y, width * item.width, height * item.height);
        }
      });
      ctx.restore();
    }
    if (patchFlags || patchFlagsAnimate || patchFlagsBackground && this.isBottom || // this.isBottom ||
    patchFlagsTop && !this.isBottom) {
      const ctxCanvas = this.canvas.getContext("2d");
      ctxCanvas.clearRect(0, 0, this.canvas.width, this.canvas.height);
      if (this.isBottom) {
        this.store.patchFlagsBackground = false;
      }
      ctxCanvas.drawImage(this.offscreen, 0, 0, this.canvas.width, this.canvas.height);
      ctxCanvas.drawImage(this.animateOffsScreen, 0, 0, this.canvas.width, this.canvas.height);
      if (!this.isBottom) {
        ctxCanvas.drawImage(this.otherOffsreen, 0, 0, this.canvas.width, this.canvas.height);
        this.store.patchFlagsTop = false;
        if (!this.store.data.locked && this.fitFlag) {
          ctxCanvas.drawImage(this.fitOffscreen, 0, 0, this.canvas.width, this.canvas.height);
        }
      }
    }
  }
  // renderGrid(
  //   ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D
  // ) {
  //   const { data, options } = this.store;
  //   const { grid, gridRotate, gridColor, gridSize, scale } = data;
  //   if (!(grid ?? options.grid)) {
  //     // grid false , undefined  options.grid
  //     return;
  //   }
  //   ctx.save();
  //   const { width, height } = this.canvas;
  //   if (gridRotate) {
  //     ctx.translate(width / 2, height / 2);
  //     ctx.rotate((gridRotate * Math.PI) / 180);
  //     ctx.translate(-width / 2, -height / 2);
  //   }
  //   ctx.lineWidth = 1;
  //   ctx.strokeStyle = gridColor || options.gridColor;
  //   ctx.beginPath();
  //   const size = (gridSize || options.gridSize) * scale;
  //   const longSide = Math.max(width, height);
  //   const count = Math.ceil(longSide / size);
  //   for (let i = -size * count; i < longSide * 2; i += size) {
  //     ctx.moveTo(i, -longSide);
  //     ctx.lineTo(i, longSide * 2);
  //   }
  //   for (let i = -size * count; i < longSide * 2; i += size) {
  //     ctx.moveTo(-longSide, i);
  //     ctx.lineTo(longSide * 2, i);
  //   }
  //   ctx.stroke();
  //   ctx.restore();
  // }
  renderRule(ctx) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { data, options } = this.store;
    const { rule, ruleColor, scale, origin } = data;
    if (!(rule ?? options.rule)) {
      return;
    }
    const span = scale * 10;
    ctx.save();
    const finalRuleColor = ruleColor || options.ruleColor;
    ctx.strokeStyle = rgba(finalRuleColor, 0.7);
    const x = origin.x + data.x;
    const y = origin.y + data.y;
    const { width, height } = this.canvas;
    let h = ((_a = options.ruleOptions) == null ? void 0 : _a.height) || 20;
    if ((_b = options.ruleOptions) == null ? void 0 : _b.background) {
      ctx.beginPath();
      ctx.fillStyle = (_c = options.ruleOptions) == null ? void 0 : _c.background;
      ctx.rect(0, 0, width, h);
      ctx.fill();
      ctx.rect(0, 0, h, height);
      ctx.fill();
    }
    if ((_d = options.ruleOptions) == null ? void 0 : _d.underline) {
      ctx.beginPath();
      ctx.fillStyle = rgba(finalRuleColor, 0.7);
      ctx.moveTo(0, h);
      ctx.lineTo(width, h);
      ctx.stroke();
      ctx.moveTo(h, 0);
      ctx.lineTo(h, height);
      ctx.stroke();
    }
    let b_y = h / 4;
    if (((_e = options.ruleOptions) == null ? void 0 : _e.baseline) === "bottom") {
      b_y = h * 3 / 4;
    }
    ctx.beginPath();
    ctx.lineWidth = h / 2;
    ctx.lineDashOffset = -x % span;
    ctx.setLineDash([1, span - 1]);
    ctx.moveTo(0, b_y);
    ctx.lineTo(width, b_y);
    ctx.stroke();
    ctx.beginPath();
    ctx.lineDashOffset = -y % span;
    ctx.moveTo(b_y, 0);
    ctx.lineTo(b_y, height);
    ctx.stroke();
    ctx.strokeStyle = finalRuleColor;
    ctx.beginPath();
    ctx.lineWidth = h;
    ctx.lineDashOffset = -x % (span * 10);
    ctx.setLineDash([1, span * 10 - 1]);
    ctx.moveTo(0, h / 2);
    ctx.lineTo(width, h / 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.lineDashOffset = -y % (span * 10);
    ctx.moveTo(h / 2, 0);
    ctx.lineTo(h / 2, height);
    ctx.stroke();
    ctx.beginPath();
    ctx.fillStyle = ((_f = options.ruleOptions) == null ? void 0 : _f.textColor) || ctx.strokeStyle;
    let text = 0 - Math.floor(x / span / 10) * 100;
    let textTop = ((_g = options.ruleOptions) == null ? void 0 : _g.textTop) || 16;
    let textLeft = ((_h = options.ruleOptions) == null ? void 0 : _h.textLeft) || 4;
    if (x < 0) {
      text -= 100;
    }
    for (let i = x % (span * 10); i < width; i += 10 * span, text += 100) {
      if (span < 3 && text % 500) {
        continue;
      }
      ctx.fillText(text.toString(), i + textLeft, textTop);
    }
    text = 0 - Math.floor(y / span / 10) * 100;
    if (y < 0) {
      text -= 100;
    }
    for (let i = y % (span * 10); i < height; i += 10 * span, text += 100) {
      if (span < 3 && text % 500) {
        continue;
      }
      ctx.save();
      ctx.beginPath();
      ctx.translate(textTop, i - textLeft);
      ctx.rotate(270 * Math.PI / 180);
      ctx.fillText(text.toString(), 0, 0);
      ctx.restore();
    }
    ctx.restore();
  }
};

// node_modules/@meta2d/core/src/canvas/magnifierCanvas.js
var MagnifierCanvas = class {
  constructor(parentCanvas, parentElement, store) {
    __publicField(this, "parentCanvas");
    __publicField(this, "parentElement");
    __publicField(this, "store");
    __publicField(this, "canvas", document.createElement("canvas"));
    __publicField(this, "magnifierScreen", createOffscreen());
    __publicField(this, "offscreen", createOffscreen());
    __publicField(this, "domOffscreen", createOffscreen());
    __publicField(this, "magnifierSize", 300);
    __publicField(this, "magnifier");
    this.parentCanvas = parentCanvas;
    this.parentElement = parentElement;
    this.store = store;
    parentElement.appendChild(this.canvas);
    this.canvas.style.backgroundRepeat = "no-repeat";
    this.canvas.style.backgroundSize = "100% 100%";
    this.canvas.style.position = "absolute";
    this.canvas.style.top = "0";
    this.canvas.style.left = "0";
    this.canvas.style.pointerEvents = "none";
  }
  resize(w, h) {
    this.canvas.style.width = w + "px";
    this.canvas.style.height = h + "px";
    w = w * this.store.dpiRatio | 0;
    h = h * this.store.dpiRatio | 0;
    this.canvas.width = w;
    this.canvas.height = h;
    this.offscreen.width = w;
    this.offscreen.height = h;
    this.offscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio);
    this.offscreen.getContext("2d").textBaseline = "middle";
    this.domOffscreen.width = w;
    this.domOffscreen.height = h;
    this.domOffscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio);
    this.domOffscreen.getContext("2d").textBaseline = "middle";
    this.magnifierScreen.width = this.magnifierSize + 5;
    this.magnifierScreen.height = this.magnifierSize + 5;
  }
  /**
   *   
   */
  renderMagnifier() {
    if (!this.magnifier) {
      return;
    }
    const r = this.magnifierSize / 2;
    const size = this.magnifierSize + 5;
    const ctx = this.magnifierScreen.getContext("2d");
    ctx.clearRect(0, 0, size, size);
    ctx.lineWidth = 5;
    ctx.save();
    ctx.translate(2.5, 2.5);
    ctx.save();
    ctx.arc(r, r, r, 0, Math.PI * 2, false);
    ctx.clip();
    ctx.translate(-r, -r);
    ctx.scale(2, 2);
    const pt = {
      x: (this.parentCanvas.mousePos.x + this.store.data.x) * this.store.dpiRatio,
      y: (this.parentCanvas.mousePos.y + this.store.data.y) * this.store.dpiRatio
    };
    const drawOffscreens = [
      this.parentCanvas.canvasTemplate.bgOffscreen,
      this.parentCanvas.canvasTemplate.offscreen,
      this.parentCanvas.canvasImageBottom.offscreen,
      this.parentCanvas.canvasImageBottom.animateOffsScreen,
      this.parentCanvas.offscreen,
      this.parentCanvas.canvasImage.offscreen,
      this.parentCanvas.canvasImage.animateOffsScreen,
      this.domOffscreen
      //dom
    ];
    drawOffscreens.forEach((offscreen) => {
      ctx.drawImage(offscreen, pt.x - r, pt.y - r, this.magnifierSize, this.magnifierSize, 0, 0, this.magnifierSize, this.magnifierSize);
    });
    ctx.restore();
    ctx.beginPath();
    const gradient = ctx.createRadialGradient(r, r, r - 5, r, r, r);
    gradient.addColorStop(0, "rgba(0,0,0,0.2)");
    gradient.addColorStop(0.8, "rgb(200,200,200)");
    gradient.addColorStop(0.9, "rgb(200,200,200)");
    gradient.addColorStop(1, "rgba(200,200,200,0.9)");
    ctx.strokeStyle = gradient;
    ctx.arc(r, r, r, 0, Math.PI * 2, false);
    ctx.stroke();
    ctx.restore();
    const offscreenCtx = this.offscreen.getContext("2d");
    offscreenCtx.drawImage(this.magnifierScreen, 0, 0, this.magnifierSize + 5, this.magnifierSize + 5, (pt.x - r - 2.5) / this.store.dpiRatio, (pt.y - r - 2.5) / this.store.dpiRatio, (this.magnifierSize + 5) / this.store.dpiRatio, (this.magnifierSize + 5) / this.store.dpiRatio);
  }
  updateDomOffscreen() {
    const domCtx = this.domOffscreen.getContext("2d");
    domCtx.clearRect(0, 0, this.domOffscreen.width, this.domOffscreen.height);
    for (const pen of this.store.data.pens) {
      if (pen.externElement || pen.name === "gif") {
        if (pen.calculative.img) {
          domCtx.save();
          domCtx.translate(this.store.data.x, this.store.data.y);
          const { x, y, width, height } = pen.calculative.worldRect;
          domCtx.drawImage(pen.calculative.img, x, y, width, height);
          domCtx.restore();
        }
      }
    }
  }
  render() {
    this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.renderMagnifier();
    const ctx = this.canvas.getContext("2d");
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    ctx.drawImage(this.offscreen, 0, 0, this.canvas.width, this.canvas.height);
  }
};

// node_modules/@meta2d/core/src/utils/error.js
function lockedError(store) {
  if (store.data.locked) {
    throw new Error("canvas is locked");
  }
}

// node_modules/@meta2d/core/src/event/event.js
var EventAction;
(function(EventAction2) {
  EventAction2[EventAction2["Link"] = 0] = "Link";
  EventAction2[EventAction2["SetProps"] = 1] = "SetProps";
  EventAction2[EventAction2["StartAnimate"] = 2] = "StartAnimate";
  EventAction2[EventAction2["PauseAnimate"] = 3] = "PauseAnimate";
  EventAction2[EventAction2["StopAnimate"] = 4] = "StopAnimate";
  EventAction2[EventAction2["JS"] = 5] = "JS";
  EventAction2[EventAction2["GlobalFn"] = 6] = "GlobalFn";
  EventAction2[EventAction2["Emit"] = 7] = "Emit";
  EventAction2[EventAction2["StartVideo"] = 8] = "StartVideo";
  EventAction2[EventAction2["PauseVideo"] = 9] = "PauseVideo";
  EventAction2[EventAction2["StopVideo"] = 10] = "StopVideo";
  EventAction2[EventAction2["SendPropData"] = 11] = "SendPropData";
  EventAction2[EventAction2["SendVarData"] = 12] = "SendVarData";
  EventAction2[EventAction2["Navigator"] = 13] = "Navigator";
  EventAction2[EventAction2["Dialog"] = 14] = "Dialog";
  EventAction2[EventAction2["SendData"] = 15] = "SendData";
  EventAction2[EventAction2["PostMessage"] = 16] = "PostMessage";
  EventAction2[EventAction2["PostMessageToParent"] = 17] = "PostMessageToParent";
  EventAction2[EventAction2["Message"] = 18] = "Message";
})(EventAction || (EventAction = {}));

// node_modules/@meta2d/core/src/map/map.js
var ViewMap = class {
  constructor(parent) {
    __publicField(this, "parent");
    __publicField(this, "box");
    __publicField(this, "boxWidth", 320);
    __publicField(this, "boxHeight", 180);
    __publicField(this, "ratio", this.boxWidth / this.boxHeight);
    __publicField(this, "padding", 5);
    __publicField(this, "img");
    __publicField(this, "isShow");
    __publicField(this, "isDown");
    __publicField(this, "view");
    // 
    __publicField(this, "timer");
    __publicField(this, "onMouseDown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.isDown = true;
    });
    __publicField(this, "onMouseMove", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (this.isDown) {
        try {
          this.parent.gotoView(e.offsetX / this.box.clientWidth, e.offsetY / this.box.clientHeight);
        } catch (e2) {
          console.warn(e2.message);
          this.isDown = false;
        }
      }
    });
    __publicField(this, "onMouseUp", (e) => {
      e.preventDefault();
      e.stopPropagation();
      try {
        this.parent.gotoView(e.offsetX / this.box.clientWidth, e.offsetY / this.box.clientHeight);
      } catch (e2) {
        console.warn(e2.message);
      } finally {
        this.isDown = false;
      }
    });
    __publicField(this, "onWheel", (e) => {
      let scaleOff = 0.015;
      if (this.parent.store.options.scaleOff) {
        scaleOff = this.parent.store.options.scaleOff;
        if (e.deltaY > 0) {
          scaleOff = -this.parent.store.options.scaleOff;
        }
      } else {
        let isMac = /mac os /i.test(navigator.userAgent);
        if (isMac) {
          if (!e.ctrlKey) {
            scaleOff *= e.wheelDeltaY / 240;
          } else if (e.deltaY > 0) {
            scaleOff *= -1;
          }
        } else {
          let offset = 0.2;
          if (e.deltaY.toString().indexOf(".") !== -1) {
            offset = 0.01;
          }
          if (e.deltaY > 0) {
            scaleOff = -offset;
          } else {
            scaleOff = offset;
          }
        }
      }
      let { offsetX: x, offsetY: y } = e;
      const width = this.parent.store.data.width || this.parent.store.options.width;
      const height = this.parent.store.data.height || this.parent.store.options.height;
      if (width && height) {
        x = x / this.boxWidth * width * this.parent.store.data.scale + this.parent.store.data.origin.x + this.parent.store.data.x;
        y = y / this.boxHeight * height * this.parent.store.data.scale + this.parent.store.data.origin.y + this.parent.store.data.y;
      } else {
        const rect = this.parent.parent.getRect();
        x = x / this.boxWidth * rect.width + rect.x + this.parent.store.data.x;
        y = y / this.boxHeight * rect.height + rect.y + this.parent.store.data.y;
      }
      this.parent.scale(this.parent.store.data.scale + scaleOff, { x, y });
    });
    var _a;
    this.parent = parent;
    this.box = document.createElement("div");
    this.img = new Image();
    this.view = document.createElement("div");
    this.box.appendChild(this.img);
    this.box.appendChild(this.view);
    (_a = this.parent.externalElements) == null ? void 0 : _a.parentElement.appendChild(this.box);
    this.box.className = "meta2d-map";
    this.box.onmousedown = this.onMouseDown;
    this.box.onmousemove = this.onMouseMove;
    this.box.onmouseup = this.onMouseUp;
    this.box.onwheel = this.onWheel;
    let sheet;
    for (let i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].title === "le5le/map") {
        sheet = document.styleSheets[i];
      }
    }
    if (!sheet) {
      let style = document.createElement("style");
      style.type = "text/css";
      style.title = "le5le.com/map";
      document.head.appendChild(style);
      style = document.createElement("style");
      style.type = "text/css";
      document.head.appendChild(style);
      sheet = style.sheet;
      sheet.insertRule(`.meta2d-map{display:flex;width:${this.boxWidth + 2 * this.padding}px;height:${this.boxHeight + 2 * this.padding}px;padding:${this.padding}px;background:#f4f4f4;border:1px solid #ffffff;box-shadow: 0px 0px 14px 0px rgba(0,10,38,0.30);border-radius:8px;position:absolute;z-index:9999;right:0;bottom:0;justify-content:center;align-items:center;cursor:default;user-select:none;overflow: hidden;}`);
      sheet.insertRule(".meta2d-map img{max-width:100%;max-height:100%;pointer-events: none;}");
      sheet.insertRule(".meta2d-map div{pointer-events: none;border:1px solid #1890ff;position:absolute}");
    }
  }
  show() {
    this.box.style.display = "flex";
    const data = this.parent.store.data;
    if (data.pens.length) {
      this.img.style.display = "block";
      this.img.src = this.parent.toPng(0, void 0, true);
      this.setView();
    } else {
      this.img.style.display = "none";
    }
    this.isShow = true;
  }
  hide() {
    this.box.style.display = "none";
    this.isShow = false;
  }
  setView() {
    const data = this.parent.store.data;
    if (data.pens.length) {
      let rect = getRect2(data.pens);
      const vW = this.parent.store.data.width || this.parent.store.options.width;
      const vH = this.parent.store.data.height || this.parent.store.options.height;
      if (vW && vH) {
        rect = {
          x: this.parent.store.data.origin.x,
          y: this.parent.store.data.origin.y,
          width: vW * this.parent.store.data.scale,
          height: vH * this.parent.store.data.scale
        };
      } else {
        clearTimeout(this.timer);
        this.timer = setTimeout(() => {
          if (this.parent.store.bkImg) {
            this.img.src = this.parent.toPng(0, void 0, true);
          }
        }, 300);
      }
      translateRect(rect, data.x, data.y);
      const rectRatio = rect.width / rect.height;
      if (rectRatio > this.ratio) {
        const height2 = rect.width / this.ratio;
        rect.y -= (height2 - rect.height) / 2;
        rect.height = height2;
        calcRightBottom(rect);
      } else {
        const width2 = rect.height * this.ratio;
        rect.x -= (width2 - rect.width) / 2;
        rect.width = width2;
        calcRightBottom(rect);
      }
      const canvasRect = this.parent.canvasRect;
      let left = 0, top = 0;
      if (rect.x < 0) {
        left = -rect.x / rect.width;
      } else if (rect.x + rect.width > canvasRect.width) {
        let space = 0;
        if (canvasRect.width > rect.width) {
          space = canvasRect.width - rect.width;
        }
        left = (-rect.x + space) / rect.width;
      }
      if (rect.y < 0) {
        top = -rect.y / rect.height;
      } else if (rect.y + rect.height > canvasRect.height) {
        let space = 0;
        if (canvasRect.height > rect.height) {
          space = canvasRect.height - rect.height;
        }
        top = (-rect.y + space) / rect.height;
      }
      const width = canvasRect.width > rect.width ? 1 : canvasRect.width / rect.width;
      const height = canvasRect.height > rect.height ? 1 : canvasRect.height / rect.height;
      this.view.style.left = this.padding + left * this.boxWidth + "px";
      this.view.style.width = width * this.boxWidth + "px";
      this.view.style.top = this.padding + top * this.boxHeight + "px";
      this.view.style.height = height * this.boxHeight + "px";
    }
  }
};

// node_modules/@meta2d/core/src/core.js
var mqtt = __toESM(require_mqtt_min());

// node_modules/@meta2d/core/src/message/message.js
var status = {
  success: {
    color: "#2ba471",
    icon: '<svg fill="none" viewBox="0 0 24 24"><path d="M12 23a11 11 0 100-22 11 11 0 000 22zM7.5 10.59l3 3 6-6L17.91 9l-7.41 7.41L6.09 12l1.41-1.41z"></path></svg>'
  },
  info: {
    color: "#0052d9",
    icon: '<svg fill="none" viewBox="0 0 24 24"><path d="M12 23a11 11 0 100-22 11 11 0 000 22zM11 8.5v-2h2v2h-2zm2 1.5v7.5h-2V10h2z"></path></svg>'
  },
  warning: {
    color: "#e37318",
    icon: '<svg fill="none" viewBox="0 0 24 24"><path d="M12 1a11 11 0 110 22 11 11 0 010-22zm-1 13h2V6.5h-2V14zm2 1.5h-2v2h2v-2z"></path></svg>'
  },
  error: {
    color: "#d54941",
    icon: '<svg fill="none" viewBox="0 0 24 24"><path d="M12 1a11 11 0 110 22 11 11 0 010-22zm-1 13h2V6.5h-2V14zm2 1.5h-2v2h2v-2z"></path></svg>'
  },
  question: {
    color: "#0052d9",
    icon: '<svg fill="none" viewBox="0 0 24 24"><path d="M12 23a11 11 0 100-22 11 11 0 000 22zm-.17-11.11c.43-.53.97-.97 1.4-1.32A2 2 0 0012 7a2 2 0 00-1.89 1.33l-.33.95L7.9 8.6l.34-.94a4 4 0 116.24 4.47 7 7 0 00-1.1 1.01c-.27.34-.37.61-.37.85v1.25h-2V14c0-.87.39-1.57.83-2.11zM11 18.25v-2h2v2h-2z"></path></svg>'
  }
};
var messageList = {};
var Message = class {
  constructor(parentElement, options) {
    __publicField(this, "parentElement");
    __publicField(this, "box");
    __publicField(this, "icon");
    __publicField(this, "text");
    __publicField(this, "closeBtn");
    __publicField(this, "duration");
    //
    __publicField(this, "content");
    __publicField(this, "theme");
    //
    __publicField(this, "placement");
    //
    __publicField(this, "id");
    this.parentElement = parentElement;
    this.box = document.createElement("div");
    this.icon = document.createElement("div");
    this.text = document.createElement("div");
    this.box.className = "meta2d-message";
    this.icon.className = "icon";
    this.text.className = "text";
    this.icon.innerHTML = status[options.theme || "info"].icon;
    this.text.innerHTML = options.content;
    this.box.appendChild(this.icon);
    this.box.appendChild(this.text);
    if (options.closeBtn) {
      this.closeBtn = document.createElement("div");
      this.closeBtn.className = "close";
      this.closeBtn.innerHTML = "x";
      this.closeBtn.onclick = () => {
        this.close();
      };
      this.box.appendChild(this.closeBtn);
    }
    parentElement.appendChild(this.box);
    let sheet;
    for (let i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].title === "le5le.com/message") {
        sheet = document.styleSheets[i];
      }
    }
    if (!sheet) {
      let style = document.createElement("style");
      style.type = "text/css";
      style.title = "le5le.com/message";
      document.head.appendChild(style);
      style = document.createElement("style");
      style.type = "text/css";
      document.head.appendChild(style);
      sheet = style.sheet;
      sheet.insertRule(`.meta2d-message{
           position:absolute;
           z-index:999;
           transform: translateX(-50%); 
           padding:12px 16px;
           max-width:400px;
           background:#fff;
           border-radius:6px;
           box-shadow:0 3px 14px 2px rgba(0, 0, 0, .05),0 8px 10px 1px rgba(0, 0, 0, 6%),0 5px 5px -3px rgba(0, 0, 0, 10%);
           display:flex;
           animation: fadein .5s;}`);
      sheet.insertRule(`
        @keyframes fadein {
          0% {
              transform: translate(-50%, -100%);
          }
          100% {
              transform: translate(-50%,0);
          }
      }`);
      sheet.insertRule(".meta2d-message .icon{width:20px;height:20px;}");
      sheet.insertRule(".meta2d-message .text{color:rgba(0, 0, 0, 0.9);font-size:12px;margin-left:8px;line-height:20px;}");
      sheet.insertRule(".meta2d-message .close{width:20px;height:20px;padding-left: 16px; cursor: pointer;}");
    }
    this.id = options.id || s8();
    this.duration = options.duration ?? 3e3;
    this.placement = options.placement || "top";
    this.theme = options.theme || "info";
  }
  init() {
    messageList[this.id] = this;
    if (this.duration) {
      setTimeout(() => {
        this.close();
      }, this.duration);
    }
    let idx = -1;
    Object.keys(messageList).forEach((key) => {
      var _a;
      if (((_a = messageList[key]) == null ? void 0 : _a.placement) === this.placement) {
        idx++;
      }
    });
    this.setPosition(this.placement, idx);
    this.icon.children[0].style.fill = status[this.theme].color;
  }
  setPosition(placement, index = 0) {
    switch (placement) {
      case "top":
        this.box.style.top = `${30 + index * 60}px`;
        this.box.style.left = "50%";
        break;
      case "bottom":
        this.box.style.bottom = `${30 + index * 60}px`;
        this.box.style.left = "50%";
        break;
      case "left":
        this.box.style.top = `${30 + index * 60}px`;
        this.box.style.left = "30px";
        break;
      case "right":
        this.box.style.top = `${30 + index * 60}px`;
        this.box.style.right = "30px";
        break;
    }
  }
  close() {
    Object.keys(messageList).forEach((key) => {
      var _a;
      if (((_a = messageList[key]) == null ? void 0 : _a.placement) === this.placement) {
        switch (this.placement) {
          case "top":
          case "left":
          case "right":
            messageList[key].box.style.top = parseInt(messageList[key].box.style.top) - 60 + "px";
            break;
          case "bottom":
            messageList[key].box.style.bottom = parseInt(messageList[key].box.style.bottom) - 60 + "px";
            break;
        }
      }
    });
    messageList[this.id] = null;
    delete messageList[this.id];
    this.box.remove();
  }
};

// node_modules/@meta2d/core/src/utils/jetLinks.js
function connectJetLinks(meta2d, net) {
  if (meta2d.jetLinksList.length) {
    meta2d.jetLinksClient = new WebSocket(`${net.url}/${localStorage.getItem("X-Access-Token") || getCookie("X-Access-Token") || new URLSearchParams(location.search).get("X-Access-Token") || ""}`);
    meta2d.jetLinksClient.onmessage = (e) => {
      var _a;
      const mess = JSON.parse(e.data);
      if (mess.payload && // mess.payload.success &&
      ((_a = mess.payload) == null ? void 0 : _a.properties)) {
        const data = [];
        for (let key in mess.payload.properties) {
          if (!key.startsWith("_")) {
            data.push({
              id: `${mess.payload.headers.productId}#${mess.payload.deviceId}#${key}`,
              value: mess.payload.properties[key]
            });
          }
        }
        meta2d.setDatas(data, { history: false });
      }
    };
    meta2d.jetLinksClient.onopen = () => {
      meta2d.jetLinksList.forEach((item) => {
        meta2d.jetLinksClient.send(JSON.stringify({
          type: "sub",
          topic: `/device${item.topic}/message/property/report`,
          parameter: {
            deviceId: item.deviceId,
            properties: item.properties,
            history: 1
          },
          id: item.topic + "-" + s8()
        }));
      });
    };
  }
}
function closeJetLinks(meta2d) {
  if (meta2d.jetLinksClient) {
    meta2d.jetLinksClient.close();
    meta2d.jetLinksClient = void 0;
  }
}
function getSendData(meta2d, pen, e) {
  const list = [];
  e.list.forEach((item, index) => {
    var _a, _b;
    const _pen = item.params ? meta2d.findOne(item.params) : pen;
    list[index] = {
      deviceId: _pen.deviceId,
      productId: _pen.productId,
      properties: {}
    };
    for (let key in item.value) {
      if (item.value[key] === void 0 || item.value[key] === "") {
        const realTime = (_a = _pen.realTimes) == null ? void 0 : _a.find((item2) => item2.propertyId === key);
        if (realTime) {
          list[index].properties[key] = _pen[realTime.key];
        }
      } else if (typeof item.value[key] === "string" && ((_b = item.value[key]) == null ? void 0 : _b.indexOf("${")) > -1) {
        let keys = item.value[key].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
        if (keys == null ? void 0 : keys.length) {
          list[index].properties[key] = _pen[keys[0]] ?? meta2d.getDynamicParam(keys[0]);
        }
      } else {
        list[index].properties[key] = item.value[key];
      }
    }
  });
  return list;
}
async function sendJetLinksData(meta2d, list) {
  list.forEach(async (item) => {
    const res = await fetch(`/api/device-instance/${item.deviceId}/property`, {
      headers: {
        "X-Access-Token": localStorage.getItem("X-Access-Token") || new URLSearchParams(location.search).get("X-Access-Token") || "",
        "Content-Type": "application/json"
      },
      method: "put",
      body: JSON.stringify(item.properties)
    });
    if (res.ok) {
      console.info("");
      meta2d.message({ theme: "success", content: "" });
    } else {
      meta2d.message({ theme: "error", content: "" });
    }
  });
}

// node_modules/@meta2d/core/src/core.js
var Meta2d = class {
  constructor(parent, opts = {}) {
    __publicField(this, "store");
    __publicField(this, "canvas");
    __publicField(this, "websocket");
    __publicField(this, "mqttClient");
    __publicField(this, "websockets");
    __publicField(this, "mqttClients");
    __publicField(this, "penPluginMap", /* @__PURE__ */ new Map());
    __publicField(this, "socketFn");
    __publicField(this, "events", {});
    __publicField(this, "map");
    __publicField(this, "mapTimer");
    __publicField(this, "facePen", facePen);
    __publicField(this, "getWords", getWords);
    __publicField(this, "calcTextLines", calcTextLines);
    __publicField(this, "calcTextRect", calcTextRect);
    __publicField(this, "calcTextDrawRect", calcTextDrawRect);
    __publicField(this, "jetLinksList", []);
    __publicField(this, "jetLinksClient");
    __publicField(this, "register", register);
    __publicField(this, "registerCanvasDraw", registerCanvasDraw);
    __publicField(this, "registerAnchors", registerAnchors);
    __publicField(this, "websocketTimes", 0);
    __publicField(this, "mqttTimes", 0);
    __publicField(this, "httpTimer");
    __publicField(this, "httpTimerList", []);
    __publicField(this, "updateTimer");
    __publicField(this, "updateTimerList", []);
    __publicField(this, "sqlTimerList", []);
    __publicField(this, "onEvent", (eventName, e) => {
      switch (eventName) {
        case "add":
          {
            e.forEach((pen) => {
              var _a;
              (_a = pen.onAdd) == null ? void 0 : _a.call(pen, pen);
            });
          }
          this.onSizeUpdate();
          break;
        case "enter":
          e && e.onMouseEnter && e.onMouseEnter(e, this.canvas.mousePos);
          this.store.data.locked && this.doEvent(e, eventName);
          break;
        case "leave":
          e && e.onMouseLeave && e.onMouseLeave(e, this.canvas.mousePos);
          this.store.data.locked && this.doEvent(e, eventName);
          break;
        case "active":
        case "inactive":
          {
            this.store.data.locked && e.forEach((pen) => {
              this.doEvent(pen, eventName);
            });
          }
          break;
        case "click":
          if (this.store.data.locked && e.pen && !e.pen.disabled) {
            if (e.pen.switch) {
              e.pen.checked = !e.pen.checked;
              e.pen.calculative.checked = e.pen.checked;
              e.pen.calculative.gradient = void 0;
              e.pen.calculative.radialGradient = void 0;
            }
          }
          if (e.pen && e.pen.formId) {
            const formPen = this.store.pens[e.pen.formId];
            if (e.pen.formType === "submit") {
              this.store.data.locked && formPen && !formPen.disabled && this.doEvent(formPen, "submit");
            } else if (e.pen.formType === "reset") {
              reset(e.pen);
              this.store.data.locked && formPen && !formPen.disabled && this.doEvent(formPen, "reset");
            }
          }
          e.pen && e.pen.onClick && !e.pen.disabled && e.pen.onClick(e.pen, this.canvas.mousePos);
          this.store.data.locked && e.pen && !e.pen.disabled && this.doEvent(e.pen, eventName);
          break;
        case "contextmenu":
          e.pen && e.pen.onContextmenu && !e.pen.disabled && e.pen.onContextmenu(e.pen, this.canvas.mousePos);
          this.store.data.locked && e.pen && !e.pen.disabled && this.doEvent(e.pen, eventName);
          break;
        case "mousedown":
          e.pen && e.pen.onMouseDown && !e.pen.disabled && e.pen.onMouseDown(e.pen, this.canvas.mousePos);
          this.store.data.locked && e.pen && !e.pen.disabled && this.doEvent(e.pen, eventName);
          break;
        case "mouseup":
          e.pen && e.pen.onMouseUp && !e.pen.disabled && e.pen.onMouseUp(e.pen, this.canvas.mousePos);
          this.store.data.locked && e.pen && !e.pen.disabled && this.doEvent(e.pen, eventName);
          break;
        case "dblclick":
          this.store.data.locked && e.pen && !e.pen.disabled && this.doEvent(e.pen, eventName);
          break;
        case "valueUpdate":
          e && updateFormData(e, e.formValue);
          this.store.data.locked && this.doEvent(e, eventName);
          this.canvas.tooltip.updateText(e);
          break;
        case "update":
        case "delete":
        case "translatePens":
        case "rotatePens":
        case "resizePens":
          this.onSizeUpdate();
          break;
        case "navigator":
          if (!this.store.data.id) {
            console.warn("");
          }
          this.navigatorTo(e.params);
          break;
        case "input":
          this.store.data.locked && e && !e.disabled && this.doEvent(e, eventName);
          break;
        case "change":
          e.pen && updateFormData(e.pen);
          this.store.data.locked && e && !e.disabled && this.doEvent(e, eventName);
          break;
      }
      this.doMessageEvent(eventName);
    });
    __publicField(this, "doEvent", (pen, eventName) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      if (!pen) {
        return;
      }
      let old = false;
      let indexArr = [];
      (_a = pen.events) == null ? void 0 : _a.forEach((event, index) => {
        var _a2;
        if (event.actions && event.actions.length) {
          if (event.name === eventName) {
            let flag = false;
            if (event.conditions && event.conditions.length) {
              if (event.conditionType === "and") {
                flag = event.conditions.every((condition) => {
                  return this.judgeCondition(pen, condition.key, condition);
                });
              } else if (event.conditionType === "or") {
                flag = event.conditions.some((condition) => {
                  return this.judgeCondition(pen, condition.key, condition);
                });
              }
            } else {
              flag = true;
            }
            if (flag) {
              indexArr.push(index);
            }
          }
        } else {
          old = true;
          if (this.events[event.action] && event.name === eventName) {
            let can = !((_a2 = event.where) == null ? void 0 : _a2.type);
            if (event.where) {
              const { fn, fnJs, comparison, key, value: value4 } = event.where;
              if (fn) {
                can = fn(pen, { meta2d: this });
              } else if (fnJs) {
                try {
                  event.where.fn = new Function("pen", "context", fnJs);
                } catch (err) {
                  console.error("Error: make function:", err);
                }
                if (event.where.fn) {
                  can = event.where.fn(pen, { meta2d: this });
                }
              } else {
                let pValue = pen[key];
                if (["x", "y", "width", "height"].includes(key)) {
                  pValue = this.getPenRect(pen)[key];
                }
                switch (comparison) {
                  case ">":
                    can = pValue > +value4;
                    break;
                  case ">=":
                    can = pValue >= +value4;
                    break;
                  case "<":
                    can = pValue < +value4;
                    break;
                  case "<=":
                    can = pValue <= +value4;
                    break;
                  case "=":
                  case "==":
                    can = pValue == value4;
                    break;
                  case "!=":
                    can = pValue != value4;
                    break;
                  case "[)":
                    can = valueInRange(+pValue, value4);
                    break;
                  case "![)":
                    can = !valueInRange(+pValue, value4);
                    break;
                  case "[]":
                    can = valueInArray(pValue, value4);
                    break;
                  case "![]":
                    can = !valueInArray(pValue, value4);
                    break;
                }
              }
            }
            if (can) {
              indexArr.push(index);
            }
          }
        }
      });
      if (old) {
        (_b = pen.events) == null ? void 0 : _b.forEach((event, index) => {
          if (indexArr.includes(index)) {
            this.events[event.action](pen, event);
          }
        });
      } else {
        (_c = pen.events) == null ? void 0 : _c.forEach(async (event, index) => {
          if (indexArr.includes(index)) {
            if (event.confirm) {
              if (!await this.canvas.popconfirm.showModal(pen, this.canvas.mousePos, event.confirmTitle)) {
                return;
              }
            }
            event.actions.forEach((action) => {
              if (action.timeout) {
                let timer = setTimeout(() => {
                  if (this.events[action.action]) {
                    this.events[action.action](pen, action);
                    clearTimeout(timer);
                    timer = null;
                  }
                }, action.timeout);
              } else {
                if (this.events[action.action]) {
                  this.events[action.action](pen, action);
                }
              }
            });
          }
        });
      }
      if (eventName === "valueUpdate") {
        (_d = pen.realTimes) == null ? void 0 : _d.forEach((realTime) => {
          var _a2, _b2;
          let indexArr3 = [];
          (_a2 = realTime.triggers) == null ? void 0 : _a2.forEach((trigger, index) => {
            var _a3;
            let flag = false;
            if ((_a3 = trigger.conditions) == null ? void 0 : _a3.length) {
              if (trigger.conditionType === "and") {
                flag = trigger.conditions.every((condition) => {
                  return this.judgeCondition(pen, realTime.key, condition);
                });
              } else if (trigger.conditionType === "or") {
                flag = trigger.conditions.some((condition) => {
                  return this.judgeCondition(pen, realTime.key, condition);
                });
              }
            } else {
              flag = true;
            }
            if (flag) {
              indexArr3.push(index);
            }
          });
          (_b2 = realTime.triggers) == null ? void 0 : _b2.forEach((trigger, index) => {
            var _a3;
            if (indexArr3.includes(index)) {
              (_a3 = trigger.actions) == null ? void 0 : _a3.forEach((event) => {
                if (event.timeout) {
                  let timer = setTimeout(() => {
                    if (this.events[event.action]) {
                      this.events[event.action](pen, event);
                      clearTimeout(timer);
                      timer = null;
                    }
                  }, event.timeout);
                } else {
                  this.events[event.action](pen, event);
                }
              });
            }
          });
        });
        let indexArr2 = [];
        (_e = this.store.globalTriggers[pen.id]) == null ? void 0 : _e.forEach((trigger, index) => {
          var _a2;
          let flag = false;
          if ((_a2 = trigger.conditions) == null ? void 0 : _a2.length) {
            if (trigger.conditionType === "and") {
              flag = trigger.conditions.every((condition) => {
                return this.judgeCondition(this.store.pens[condition.source], condition.key, condition);
              });
            } else if (trigger.conditionType === "or") {
              flag = trigger.conditions.some((condition) => {
                return this.judgeCondition(this.store.pens[condition.source], condition.key, condition);
              });
            }
          } else {
            flag = true;
          }
          if (flag) {
            indexArr2.push(index);
          }
        });
        (_f = this.store.globalTriggers[pen.id]) == null ? void 0 : _f.forEach((trigger, index) => {
          var _a2;
          if (indexArr2.includes(index)) {
            (_a2 = trigger.actions) == null ? void 0 : _a2.forEach((event) => {
              if (event.timeout) {
                let timer = setTimeout(() => {
                  if (this.events[event.action]) {
                    this.events[event.action](pen, event);
                    clearTimeout(timer);
                    timer = null;
                  }
                }, event.timeout);
              } else {
                this.events[event.action](pen, event);
              }
            });
          }
        });
        if ((_g = pen.triggers) == null ? void 0 : _g.length) {
          for (let trigger of pen.triggers) {
            if ((_h = trigger.status) == null ? void 0 : _h.length) {
              for (let state of trigger.status) {
                let flag = false;
                if ((_i = state.conditions) == null ? void 0 : _i.length) {
                  if (state.conditionType === "and") {
                    flag = state.conditions.every((condition) => {
                      return this.judgeCondition(pen, condition.key, condition);
                    });
                  } else if (state.conditionType === "or") {
                    flag = state.conditions.some((condition) => {
                      return this.judgeCondition(pen, condition.key, condition);
                    });
                  }
                } else {
                  flag = true;
                }
                if (flag) {
                  (_j = state.actions) == null ? void 0 : _j.forEach((event) => {
                    if (event.timeout) {
                      let timer = setTimeout(() => {
                        if (this.events[event.action]) {
                          this.events[event.action](pen, event);
                          clearTimeout(timer);
                          timer = null;
                        }
                      }, event.timeout);
                    } else {
                      this.events[event.action](pen, event);
                    }
                  });
                  break;
                }
              }
            }
          }
        }
      }
      this.doEvent(this.store.pens[pen.parentId], eventName);
    });
    __publicField(this, "doDataEvent", (datas) => {
      var _a, _b, _c;
      if (!((_a = this.store.data.dataEvents) == null ? void 0 : _a.length)) {
        return;
      }
      const data = datas.reduce((accumulator, { dataId, id, value: value4 }) => {
        accumulator[id || dataId] = value4;
        return accumulator;
      }, {});
      let indexArr = [];
      (_b = this.store.data.dataEvents) == null ? void 0 : _b.forEach((event, index) => {
        let flag = false;
        if (event.conditions && event.conditions.length) {
          if (event.conditionType === "and") {
            flag = event.conditions.every((condition) => {
              return this.dataJudegeCondition(data, condition.key, condition);
            });
          } else if (event.conditionType === "or") {
            flag = event.conditions.some((condition) => {
              return this.dataJudegeCondition(data, condition.key, condition);
            });
          }
        } else {
          flag = true;
        }
        if (flag) {
          indexArr.push(index);
        }
      });
      (_c = this.store.data.dataEvents) == null ? void 0 : _c.forEach((event, index) => {
        var _a2;
        if (indexArr.includes(index)) {
          (_a2 = event.actions) == null ? void 0 : _a2.forEach((action) => {
            this.events[action.action](data, action);
          });
        }
      });
    });
    __publicField(this, "renderPenRaw", renderPenRaw2);
    __publicField(this, "setElemPosition", setElemPosition);
    __publicField(this, "setLifeCycleFunc", setLifeCycleFunc);
    this.store = useStore(s8());
    this.setOptions(opts);
    this.setDatabyOptions(opts);
    this.init(parent);
    this.register(commonPens());
    this.registerCanvasDraw({ cube });
    this.registerAnchors(commonAnchors());
    globalThis.meta2d = this;
    this.initEventFns();
    this.store.emitter.on("*", this.onEvent);
  }
  /**
   * @deprecated  beforeAddPens
   */
  get beforeAddPen() {
    return this.canvas.beforeAddPen;
  }
  /**
   * @deprecated  beforeAddPens
   */
  set beforeAddPen(fn) {
    this.canvas.beforeAddPen = fn;
  }
  get beforeAddPens() {
    return this.canvas.beforeAddPens;
  }
  set beforeAddPens(fn) {
    this.canvas.beforeAddPens = fn;
  }
  get beforeAddAnchor() {
    return this.canvas.beforeAddAnchor;
  }
  set beforeAddAnchor(fn) {
    this.canvas.beforeAddAnchor = fn;
  }
  get beforeRemovePens() {
    return this.canvas.beforeRemovePens;
  }
  set beforeRemovePens(fn) {
    this.canvas.beforeRemovePens = fn;
  }
  get beforeRemoveAnchor() {
    return this.canvas.beforeRemoveAnchor;
  }
  set beforeRemoveAnchor(fn) {
    this.canvas.beforeRemoveAnchor = fn;
  }
  setOptions(opts = {}) {
    var _a;
    if (opts.grid !== void 0 || opts.gridColor !== void 0 || opts.gridSize !== void 0) {
      this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = true);
    }
    if (opts.rule !== void 0 || opts.ruleColor !== void 0 || opts.ruleOptions !== void 0) {
      this.store.patchFlagsTop = true;
      if (opts.ruleOptions) {
        if ((_a = this.store.options) == null ? void 0 : _a.ruleOptions) {
          Object.assign(this.store.options.ruleOptions, opts.ruleOptions);
          opts.ruleOptions = this.store.options.ruleOptions;
        }
      }
    }
    if (opts.background !== void 0) {
      this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = true);
    }
    if (opts.resizeMode !== void 0) {
      if (!opts.resizeMode) {
        this.canvas.hotkeyType = HotkeyType.None;
      }
    }
    if (opts.width !== void 0 || opts.height !== void 0) {
      this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = true);
      if (this.canvas && this.canvas.canvasTemplate.canvas.style.backgroundImage) {
        this.canvas.canvasTemplate.canvas.style.backgroundImage = "";
      }
    }
    this.store.options = Object.assign(this.store.options, opts);
    if (this.canvas && opts.scroll !== void 0) {
      if (opts.scroll) {
        !this.canvas.scroll && (this.canvas.scroll = new Scroll(this.canvas));
        this.canvas.scroll.show();
      } else {
        this.canvas.scroll && this.canvas.scroll.hide();
      }
    }
  }
  getOptions() {
    return this.store.options;
  }
  setTheme(theme) {
    this.store.data.theme = theme;
    this.setBackgroundColor(this.store.theme[theme].background);
    this.canvas.parentElement.style.background = this.store.theme[theme].parentBackground;
    this.store.data.color = this.store.theme[theme].color;
    this.setOptions({
      ruleColor: this.store.theme[theme].ruleColor,
      ruleOptions: this.store.theme[theme].ruleOptions
    });
    le5leTheme.updateCssRule(this.store.id, theme);
    this.canvas.initGlobalStyle();
    this.render();
  }
  setDatabyOptions(options = {}) {
    const { color, activeColor, activeBackground, grid, gridColor, gridSize, fromArrow, toArrow, rule, ruleColor, textColor, x = 0, y = 0 } = options;
    this.setRule({ rule, ruleColor });
    this.setGrid({
      grid,
      gridColor,
      gridSize
    });
    this.store.data = Object.assign(this.store.data, {
      textColor,
      color,
      activeColor,
      activeBackground,
      fromArrow,
      toArrow,
      x,
      y
    });
  }
  init(parent) {
    if (typeof parent === "string") {
      this.canvas = new Canvas(this, document.getElementById(parent), this.store);
    } else {
      this.canvas = new Canvas(this, parent, this.store);
    }
    this.canvas.initGlobalStyle();
    this.resize();
    this.canvas.listen();
    le5leTheme.createThemeSheet(this.store.data.theme, this.store.id);
  }
  initEventFns() {
    this.events[EventAction.Link] = (pen, e) => {
      if (window && e.value && typeof e.value === "string") {
        window.open(e.value, e.params ?? "_blank");
        return;
      }
      console.warn("[meta2d] Link param is not a string");
    };
    this.events[EventAction.SetProps] = (pen, e) => {
      const value4 = e.value;
      if (value4 && typeof value4 === "object") {
        const pens = e.params ? this.find(e.params) : this.find(pen.id);
        pens.forEach((pen2) => {
          if (value4.hasOwnProperty("visible")) {
            if (pen2.visible !== value4.visible) {
              this.setVisible(pen2, value4.visible);
            }
          }
          this.setValue({ id: pen2.id, ...value4 }, { render: false, doEvent: false });
        });
        this.render();
        return;
      }
      console.warn("[meta2d] SetProps value is not an object");
    };
    this.events[EventAction.StartAnimate] = (pen, e) => {
      let _pen = pen;
      if (e.value) {
        _pen = this.findOne(e.value);
      }
      if (this.store.animates.has(_pen) && !_pen.calculative.pause && _pen.animateName === e.params) {
        return;
      }
      if (e.targetType && e.params) {
        this.startAnimate(e.value || [pen], e.params);
        return;
      }
      if (!e.value || typeof e.value === "string") {
        this.startAnimate(e.value || [pen]);
        return;
      }
      console.warn("[meta2d] StartAnimate value is not a string");
    };
    this.events[EventAction.PauseAnimate] = (pen, e) => {
      if (!e.value || typeof e.value === "string") {
        this.pauseAnimate(e.value || [pen]);
        return;
      }
      console.warn("[meta2d] PauseAnimate value is not a string");
    };
    this.events[EventAction.StopAnimate] = (pen, e) => {
      if (!e.value || typeof e.value === "string") {
        if (e.value) {
          let _pen = this.findOne(e.value);
          if (!this.store.animates.has(_pen)) {
            return;
          }
        } else {
          if (!this.store.animates.has(pen)) {
            return;
          }
        }
        this.stopAnimate(e.value || [pen]);
        return;
      }
      console.warn("[meta2d] StopAnimate event value is not a string");
    };
    this.events[EventAction.StartVideo] = (pen, e) => {
      if (!e.value || typeof e.value === "string") {
        this.startVideo(e.value || [pen]);
        return;
      }
      console.warn("[meta2d] StartVideo value is not a string");
    };
    this.events[EventAction.PauseVideo] = (pen, e) => {
      if (!e.value || typeof e.value === "string") {
        this.pauseVideo(e.value || [pen]);
        return;
      }
      console.warn("[meta2d] PauseVideo value is not a string");
    };
    this.events[EventAction.StopVideo] = (pen, e) => {
      if (!e.value || typeof e.value === "string") {
        this.stopVideo(e.value || [pen]);
        return;
      }
      console.warn("[meta2d] StopVideo event value is not a string");
    };
    this.events[EventAction.JS] = (pen, e, params) => {
      var _a;
      if (e.value && !e.fn) {
        try {
          if (typeof e.value !== "string") {
            throw new Error("[meta2d] Function value must be string");
          }
          const fnJs = e.value;
          e.fn = new Function("pen", "params", "context", fnJs);
        } catch (err) {
          console.error("[meta2d]: Error on make a function:", err);
        }
      }
      (_a = e.fn) == null ? void 0 : _a.call(e, pen, params || e.params, { meta2d: this, eventName: e.name });
    };
    this.events[EventAction.GlobalFn] = (pen, e) => {
      if (typeof e.value !== "string") {
        console.warn("[meta2d] GlobalFn value must be a string");
        return;
      }
      if (globalThis[e.value]) {
        globalThis[e.value](pen, e.params);
      }
    };
    this.events[EventAction.Emit] = (pen, e) => {
      if (typeof e.value !== "string") {
        console.warn("[meta2d] Emit value must be a string");
        return;
      }
      this.store.emitter.emit(e.value, {
        pen,
        params: e.params,
        eventName: e.name
      });
    };
    this.events[EventAction.SendPropData] = (pen, e) => {
      const value4 = deepClone(e.value);
      if (value4 && typeof value4 === "object") {
        const _pen = e.params ? this.findOne(e.params) : pen;
        for (let key in value4) {
          if (value4[key] === void 0 || value4[key] === "") {
            value4[key] = _pen[key];
          }
        }
        value4.id = _pen.id;
        this.doSendDataEvent(value4, e.extend);
        return;
      }
      console.warn("[meta2d] SendPropData value is not an object");
    };
    this.events[EventAction.SendVarData] = (pen, e) => {
      const value4 = deepClone(e.value);
      if (value4 && typeof value4 === "object") {
        const _pen = e.params ? this.findOne(e.params) : pen;
        let array = [];
        for (let key in value4) {
          let obj = {
            dataId: key,
            value: value4[key]
          };
          if (!obj.value) {
            let oneForm = _pen.form.find((_item) => _item.dataIds && _item.dataIds.dataId === obj.dataId);
            if (oneForm) {
              obj.value = _pen[oneForm.key];
            }
          }
          array.push(obj);
        }
        this.doSendDataEvent(array, e.extend);
        return;
      }
      console.warn("[meta2d] SendVarData value is not an object");
    };
    this.events[EventAction.Navigator] = (pen, e) => {
      if (e.value && typeof e.value === "string") {
        this.navigatorTo(e.value);
      }
    };
    this.events[EventAction.Dialog] = (pen, e) => {
      var _a;
      if (e.params && typeof e.params === "string") {
        let url = e.params;
        if (e.params.includes("${")) {
          let keys = (_a = e.params.match(/\$\{([^}]+)\}/g)) == null ? void 0 : _a.map((m) => m.slice(2, -1));
          if (keys) {
            keys == null ? void 0 : keys.forEach((key) => {
              url = url.replace(`\${${key}}`, pen[key]);
            });
          }
        }
        Object.keys(e.extend).forEach((key) => {
          if (!["x", "y", "width", "height"].includes(key)) {
            if (url.indexOf("?") !== -1) {
              url += `&${key}=${e.extend[key]}`;
            } else {
              url += `?${key}=${e.extend[key]}`;
            }
          }
        });
        const data = this.getEventData(e.list, pen);
        this.canvas.dialog.show(e.value, url, e.extend, data);
      }
    };
    this.events[EventAction.SendData] = (pen, e) => {
      var _a, _b, _c;
      if ((_a = e.list) == null ? void 0 : _a.length) {
        if (e.network && e.network.protocol === "ADIIOT") {
          const list = getSendData(this, pen, e);
          if (list.length) {
            sendJetLinksData(this, list);
          }
          return;
        }
        const value5 = this.getEventData(e.list, pen);
        if (pen.deviceId) {
          value5.deviceId = pen.deviceId;
        }
        if (pen.formId && pen.formData) {
          Object.assign(value5, pen.formData);
        }
        this.sendDataToNetWork(value5, pen, e);
        return;
      }
      const value4 = deepClone(e.value);
      if (value4 && typeof value4 === "object") {
        if (e.targetType === "id") {
          const _pen = e.params ? this.findOne(e.params) : pen;
          for (let key in value4) {
            if (value4[key] === void 0 || value4[key] === "") {
              value4[key] = _pen[key];
            } else if (typeof value4[key] === "string" && ((_b = value4[key]) == null ? void 0 : _b.indexOf("${")) > -1) {
              let keys = (_c = value4[key].match(/\$\{([^}]+)\}/g)) == null ? void 0 : _c.map((m) => m.slice(2, -1));
              if (keys == null ? void 0 : keys.length) {
                value4[key] = _pen[keys[0]] ?? this.getDynamicParam(keys[0]);
              }
            }
          }
          if (_pen.deviceId) {
            value4.deviceId = _pen.deviceId;
          }
          this.sendDataToNetWork(value4, pen, e);
          return;
        }
      }
    };
    this.events[EventAction.PostMessage] = (pen, e) => {
      if (typeof e.value !== "string") {
        console.warn("[meta2d] Emit value must be a string");
        return;
      }
      const _pen = e.params ? this.findOne(e.params) : pen;
      if (_pen.name !== "iframe" || !_pen.iframe) {
        console.warn("");
        return;
      }
      let params = queryURLParams(_pen.iframe.split("?")[1]);
      const value4 = this.getEventData(e.list, _pen);
      _pen.calculative.singleton.div.children[0].contentWindow.postMessage(JSON.stringify({
        name: e.value,
        id: params.id,
        data: value4
      }), "*");
      return;
    };
    this.events[EventAction.PostMessageToParent] = (pen, e) => {
      if (typeof e.value !== "string") {
        console.warn("[meta2d] Emit value must be a string");
        return;
      }
      const value4 = this.getEventData(e.list, pen);
      window.parent.postMessage(JSON.stringify({ name: e.value, data: value4 }), "*");
      return;
    };
    this.events[EventAction.Message] = (pen, e) => {
      this.message({
        theme: e.params,
        content: e.value,
        ...e.extend
      });
    };
  }
  getEventData(list, pen) {
    const value4 = {};
    if (list == null ? void 0 : list.length) {
      list.forEach((item) => {
        var _a, _b;
        const _pen = item.params ? this.findOne(item.params) : pen;
        for (let key in item.value) {
          if (item.value[key] === void 0 || item.value[key] === "") {
            value4[key] = _pen[key];
          } else if (typeof item.value[key] === "string" && ((_a = item.value[key]) == null ? void 0 : _a.indexOf("${")) > -1) {
            let keys = (_b = item.value[key].match(/\$\{([^}]+)\}/g)) == null ? void 0 : _b.map((m) => m.slice(2, -1));
            if (keys == null ? void 0 : keys.length) {
              value4[key] = _pen[keys[0]] ?? this.getDynamicParam(keys[0]);
            }
          } else {
            value4[key] = item.value[key];
          }
        }
      });
    }
    if (Object.keys(value4).length) {
      return value4;
    } else
      return {};
  }
  message(options) {
    const message2 = new Message(this.canvas.parentElement, options);
    message2.init();
  }
  closeAll() {
    for (let key in messageList) {
      messageList[key].close();
    }
  }
  async navigatorTo(id) {
    var _a;
    if (!id) {
      return;
    }
    let hasId = (_a = queryURLParams()) == null ? void 0 : _a.id;
    if (hasId) {
      const url = new URL(window.location);
      url.searchParams.set("id", id);
      history.pushState({}, "", url);
    }
    const data = await getMeta2dData(this.store, id);
    if (data) {
      this.open(data);
    }
  }
  doSendDataEvent(value4, topics) {
    let data = JSON.stringify(value4);
    if (this.mqttClient && this.mqttClient.connected) {
      if (topics) {
        topics.split(",").forEach((topic) => {
          this.mqttClient.publish(topic, data);
        });
      } else {
        this.store.data.mqttTopics && this.store.data.mqttTopics.split(",").forEach((topic) => {
          this.mqttClient.publish(topic, data);
        });
      }
    }
    if (this.websocket && this.websocket.readyState === 1) {
      this.websocket.send(data);
    }
    if (this.store.data.https || this.store.data.http) {
      this.sendDatabyHttp(data);
    }
    this.store.emitter.emit("sendData", data);
  }
  async sendDataToNetWork(value4, pen, e) {
    var _a, _b, _c, _d, _e;
    const network = deepClone(e.network);
    if (network.data) {
      Object.assign(network, network.data);
      delete network.data;
    }
    if (!network.url) {
      return;
    }
    if (network.protocol === "http") {
      if (typeof network.headers === "object") {
        for (let i in network.headers) {
          if (typeof network.headers[i] === "string") {
            let keys = (_a = network.headers[i].match(/\$\{([^}]+)\}/g)) == null ? void 0 : _a.map((m) => m.slice(2, -1));
            if (keys) {
              network.headers[i] = network.headers[i].replace(`\${${keys[0]}}`, this.getDynamicParam(keys[0]));
            }
          }
        }
      }
      let params = void 0;
      let url = network.url;
      if (network.method === "GET") {
        params = "?" + Object.keys(value4).map((key) => key + "=" + value4[key]).join("&");
      }
      if (network.method === "POST") {
        if (url.indexOf("${") > -1) {
          let keys = (_b = url.match(/\$\{([^}]+)\}/g)) == null ? void 0 : _b.map((m) => m.slice(2, -1));
          if (keys) {
            keys.forEach((key) => {
              url = url.replace(`\${${key}}`, getter(pen, key) || this.getDynamicParam(key));
            });
          }
        }
      }
      const res = await fetch(url + (params ? params : ""), {
        headers: network.headers || {},
        method: network.method,
        body: network.method === "POST" ? JSON.stringify(value4) : void 0
      });
      if (res.ok) {
        if (e.callback) {
          const data = await res.text();
          if (!e.fn) {
            try {
              if (typeof e.callback !== "string") {
                throw new Error("[meta2d] Function callback must be string");
              }
              const fnJs = e.callback;
              e.fn = new Function("pen", "data", "context", fnJs);
            } catch (err) {
              console.error("[meta2d]: Error on make a function:", err);
            }
          }
          (_c = e.fn) == null ? void 0 : _c.call(e, pen, data, { meta2d: this, e });
        }
        console.info("http");
      }
    } else if (network.protocol === "mqtt") {
      const clients = (_d = this.mqttClients) == null ? void 0 : _d.filter((client) => client.options.href === network.url);
      if (clients && clients.length) {
        if (clients[0].connected) {
          network.topics.split(",").forEach((topic) => {
            clients[0].publish(topic, JSON.stringify(value4));
          });
        }
      } else {
        let mqttClient = mqtt.connect(network.url, network.options);
        mqttClient.on("connect", () => {
          console.info("mqtt");
          network.topics.split(",").forEach((topic) => {
            mqttClient.publish(topic, JSON.stringify(value4));
            setTimeout(() => {
              mqttClient == null ? void 0 : mqttClient.end();
            }, 1e3);
          });
        });
      }
    } else if (network.protocol === "websocket") {
      const websockets = (_e = this.websockets) == null ? void 0 : _e.filter((socket) => socket.url === network.url);
      if (websockets && websockets.length) {
        if (websockets[0].readyState === 1) {
          websockets[0].send(JSON.stringify(value4));
        }
      } else {
        let websocket = new WebSocket(network.url, network.protocols || void 0);
        websocket.onopen = function() {
          console.info("websocket");
          websocket.send(JSON.stringify(value4));
          setTimeout(() => {
            websocket.close();
          }, 100);
        };
      }
    }
  }
  resize(width, height) {
    this.canvas.resize(width, height);
    this.render();
    this.store.emitter.emit("resize", { width, height });
    if (this.canvas.scroll && this.canvas.scroll.isShow) {
      this.canvas.scroll.init();
    }
  }
  /**
   *
   * @param emit 
   */
  async addPen(pen, history2, emit = true, abs2 = false) {
    return await this.canvas.addPen(pen, history2, emit, abs2);
  }
  async addPens(pens, history2, abs2 = false) {
    return await this.canvas.addPens(pens, history2, abs2);
  }
  render(patchFlags) {
    var _a;
    (_a = this.canvas) == null ? void 0 : _a.render(patchFlags);
  }
  async setBackgroundImage(url, data) {
    var _a, _b, _c, _d;
    let that = this;
    async function loadImage(url2) {
      return new Promise((resolve) => {
        const img = new Image();
        img.src = url2;
        if (that.store.options.cdn && !(url2.startsWith("http") || url2.startsWith("//") || url2.startsWith("data:image"))) {
          img.src = that.store.options.cdn + url2;
        }
        img.crossOrigin = "anonymous";
        img.onload = () => {
          resolve(img);
        };
      });
    }
    this.store.data.bkImage = url;
    const width = (data == null ? void 0 : data.width) || ((_a = this.store.data) == null ? void 0 : _a.width) || ((_b = this.store.options) == null ? void 0 : _b.width);
    const height = (data == null ? void 0 : data.height) || ((_c = this.store.data) == null ? void 0 : _c.height) || ((_d = this.store.options) == null ? void 0 : _d.height);
    if (width && height) {
      this.canvas.canvasTemplate.canvas.style.backgroundImage = null;
      this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = true);
    } else {
      this.canvas.canvasTemplate.canvas.style.backgroundImage = url ? `url('${url}')` : "";
    }
    if (url) {
      const img = await loadImage(url);
      this.store.bkImg = img;
      if (width && height) {
        if (this.canvas) {
          this.canvas.canvasTemplate.init();
          this.render();
        }
      }
    } else {
      this.store.bkImg = null;
    }
  }
  setBackgroundColor(color = this.store.data.background) {
    this.store.data.background = color;
    this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = true);
  }
  setGrid({ grid = this.store.data.grid, gridColor = this.store.data.gridColor, gridSize = this.store.data.gridSize, gridRotate = this.store.data.gridRotate } = {}) {
    this.store.data.grid = grid;
    this.store.data.gridColor = gridColor;
    this.store.data.gridSize = gridSize < 0 ? 0 : gridSize;
    this.store.data.gridRotate = gridRotate;
    this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = true);
  }
  setRule({ rule = this.store.data.rule, ruleColor = this.store.data.ruleColor } = {}) {
    this.store.data.rule = rule;
    this.store.data.ruleColor = ruleColor;
    this.store.patchFlagsTop = true;
  }
  open(data, render = true) {
    this.clear(false, data == null ? void 0 : data.template);
    this.canvas.autoPolylineFlag = true;
    if (data) {
      if (data.theme) {
        this.setTheme(data.theme);
      }
      this.setBackgroundImage(data.bkImage, data);
      Object.assign(this.store.data, data);
      this.store.data.pens = [];
      for (const pen of data.pens) {
        if (!pen.id) {
          pen.id = s8();
        }
        !pen.calculative && (pen.calculative = { canvas: this.canvas });
        this.store.pens[pen.id] = pen;
      }
      for (const pen of data.pens) {
        this.canvas.makePen(pen);
      }
    }
    this.canvas.patchFlagsLines.forEach((pen) => {
      if (pen.type) {
        this.canvas.initLineRect(pen);
      }
    });
    if (!this.store.data.template) {
      this.store.data.template = s8();
    }
    if (!render) {
      this.canvas.opening = true;
    }
    this.doInitJS();
    this.doInitFn();
    this.initBindDatas();
    this.initBinds();
    this.initMessageEvents();
    this.initGlobalTriggers();
    this.startAnimate();
    this.startVideo();
    this.listenSocket();
    this.connectSocket();
    this.connectNetwork();
    this.startDataMock();
    this.canvas.initGlobalStyle();
    this.render();
    setTimeout(() => {
      const pen = this.store.data.pens.find((pen2) => pen2.autofocus);
      if (pen) {
        this.focus(pen.id);
      }
    }, 100);
    if (this.store.data.iconUrls) {
      for (const item of this.store.data.iconUrls) {
        loadCss(item, () => {
          this.render();
        });
      }
    }
    this.canvas.autoPolylineFlag = false;
    this.store.emitter.emit("opened");
    if (this.canvas.scroll && this.canvas.scroll.isShow) {
      this.canvas.scroll.init();
    }
  }
  cacheData(id) {
    if (id && this.store.options.cacheLength) {
      let index = this.store.cacheDatas.findIndex((item) => item.data && item.data._id === id);
      if (index === -1) {
        this.store.cacheDatas.push({
          data: deepClone(this.store.data, true)
          // offscreen: new Array(2),
          // flag: new Array(2)
        });
        if (this.store.cacheDatas.length > this.store.options.cacheLength) {
          this.store.cacheDatas.shift();
        }
      } else {
        let cacheDatas = this.store.cacheDatas.splice(index, 1)[0];
        this.store.cacheDatas.push(cacheDatas);
      }
    }
  }
  loadCacheData(id) {
    let index = this.store.cacheDatas.findIndex((item) => item.data && item.data._id === id);
    if (index === -1) {
      return;
    }
    this.store.data = this.store.cacheDatas[index].data;
    this.setBackgroundImage(this.store.data.bkImage);
    this.store.pens = {};
    this.store.data.pens.forEach((pen) => {
      pen.calculative.canvas = this.canvas;
      this.store.pens[pen.id] = pen;
      globalStore.path2dDraws[pen.name] && this.store.path2dMap.set(pen, globalStore.path2dDraws[pen.name](pen));
      pen.type && this.store.path2dMap.set(pen, globalStore.path2dDraws[pen.name](pen));
      if (pen.image) {
        pen.calculative.imageDrawed = false;
        this.canvas.loadImage(pen);
      }
    });
    this.render();
  }
  statistics() {
    const num = this.store.data.pens.length;
    const imgNum = this.store.data.pens.filter((pen) => pen.image).length;
    const imgDrawNum = this.store.data.pens.filter((pen) => pen.image && pen.calculative.inView).length;
    const domNum = this.store.data.pens.filter((pen) => pen.name.endsWith("Dom") || isDomShapes.includes(pen.name) || this.store.options.domShapes.includes(pen.name) || pen.externElement).length;
    const aningNum = this.store.animates.size;
    let dataPointsNum = 0;
    Object.keys(this.store.bind).forEach((key) => {
      dataPointsNum += this.store.bind[key].length;
    });
    Object.keys(this.store.bindDatas).forEach((key) => {
      dataPointsNum += this.store.bindDatas[key].length;
    });
    return {
      "": num,
      "": imgNum,
      "": imgDrawNum,
      "dom": domNum,
      "": aningNum,
      "": dataPointsNum
    };
  }
  initBindDatas() {
    this.store.bindDatas = {};
    this.store.data.pens.forEach((pen) => {
      var _a;
      (_a = pen.form) == null ? void 0 : _a.forEach((formItem) => {
        let dataIds;
        if (formItem.dataIds) {
          if (Array.isArray(formItem.dataIds)) {
            dataIds = formItem.dataIds;
          } else {
            dataIds = [formItem.dataIds];
          }
        }
        dataIds == null ? void 0 : dataIds.forEach((item) => {
          if (!this.store.bindDatas[item.dataId]) {
            this.store.bindDatas[item.dataId] = [];
          }
          this.store.bindDatas[item.dataId].push({
            id: pen.id,
            formItem
          });
        });
      });
    });
  }
  initBinds() {
    this.jetLinksList = [];
    this.store.bind = {};
    this.store.data.pens.forEach((pen) => {
      var _a;
      (_a = pen.realTimes) == null ? void 0 : _a.forEach((realTime) => {
        if (realTime.bind && realTime.bind.id) {
          let productId = realTime.productId || pen.productId;
          let deviceId = realTime.deviceId || pen.deviceId;
          let propertyId = realTime.propertyId;
          let flag = false;
          if (productId && productId.indexOf("${") > -1) {
            let keys = productId.match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
            if (keys == null ? void 0 : keys.length) {
              productId = this.getDynamicParam(keys[0]) || productId;
            }
            flag = true;
          }
          if (deviceId && deviceId.indexOf("${") > -1) {
            let keys = deviceId.match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
            if (keys == null ? void 0 : keys.length) {
              deviceId = this.getDynamicParam(keys[0]) || deviceId;
            }
            flag = true;
          }
          if (propertyId && propertyId.indexOf("${") > -1) {
            let keys = propertyId.match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
            if (keys == null ? void 0 : keys.length) {
              propertyId = this.getDynamicParam(keys[0]) || propertyId;
            }
            flag = true;
          }
          if (flag) {
            realTime.bind && (realTime.bind.id = productId + "#" + deviceId + "#" + propertyId);
          }
          if (!this.store.bind[realTime.bind.id]) {
            this.store.bind[realTime.bind.id] = [];
          }
          this.store.bind[realTime.bind.id].push({
            id: pen.id,
            key: realTime.key
          });
          if (productId && deviceId && propertyId) {
            const index = this.jetLinksList.findIndex((item) => item.topic.startsWith(`/${productId}/${deviceId}`));
            if (index > -1) {
              const properties = this.jetLinksList[index].properties;
              if (!properties.includes(realTime.propertyId)) {
                this.jetLinksList[index].properties.push(realTime.propertyId);
              }
            } else {
              this.jetLinksList.push({
                topic: `/${productId}/${deviceId}`,
                deviceId,
                properties: [realTime.propertyId]
              });
            }
          }
        }
      });
    });
  }
  connectSocket() {
    this.connectWebsocket();
    this.connectMqtt();
    this.connectHttp();
  }
  /**
   * open  Js  js
   */
  doInitJS() {
    const initJs = this.store.data.initJs;
    if (initJs && initJs.trim()) {
      try {
        const fn = new Function("context", initJs);
        fn({ meta2d: this });
      } catch (e) {
        console.warn("initJs error", e);
      }
    }
  }
  doInitFn() {
    let params = queryURLParams();
    let binds = [];
    for (let key in params) {
      if (params.hasOwnProperty(key)) {
        if (key.startsWith("bind-")) {
          binds.push({
            id: key.replace("bind-", ""),
            dataId: key.replace("bind-", ""),
            value: params[key]
          });
        }
      }
    }
    if (binds.length) {
      this.setDatas(binds, { history: false });
    }
  }
  drawLine(lineName) {
    lineName && lockedError(this.store);
    this.canvas.drawingLineName = lineName;
  }
  alignPenToGrid(pen) {
    this.canvas.alignPenToGrid(pen);
  }
  drawingPencil() {
    this.canvas.drawingPencil();
  }
  stopPencil() {
    this.canvas.stopPencil();
  }
  lock(lock) {
    this.store.data.locked = lock;
    this.finishDrawLine(true);
    this.canvas.drawingLineName = "";
    this.stopPencil();
    this.store.data.pens.forEach((pen) => {
      var _a;
      if (pen.externElement === true) {
        ((_a = pen.calculative.singleton) == null ? void 0 : _a.div) && setElemPosition(pen, pen.calculative.singleton.div);
      }
    });
    if (lock > 0) {
      this.initMessageEvents();
    }
  }
  // end  - 
  async finishDrawLine(end) {
    await this.canvas.finishDrawline(end);
  }
  async finishPencil() {
    await this.canvas.finishPencil();
  }
  updateLineType(pen, lineName) {
    if (!pen || pen.name != "line" || !lineName || !this.canvas[lineName]) {
      return;
    }
    pen.lineName = lineName;
    const from = getFromAnchor(pen);
    const to = getToAnchor(pen);
    from.prev = void 0;
    from.next = void 0;
    to.prev = void 0;
    to.next = void 0;
    pen.calculative.worldAnchors = [from, to];
    pen.calculative.activeAnchor = from;
    this.canvas[lineName](this.store, pen, to);
    if (pen.lineName === "curve") {
      from.prev = {
        penId: from.penId,
        x: from.x - 50,
        y: from.y
      };
      from.next = {
        penId: from.penId,
        x: from.x + 50,
        y: from.y
      };
      to.prev = {
        penId: to.penId,
        x: to.x - 50,
        y: to.y
      };
      to.next = {
        penId: to.penId,
        x: to.x + 50,
        y: to.y
      };
    }
    pen.calculative.activeAnchor = void 0;
    this.canvas.initLineRect(pen);
    this.render();
  }
  addDrawLineFn(fnName, fn) {
    this.canvas[fnName] = fn;
    this.canvas.drawLineFns.push(fnName);
  }
  removeDrawLineFn(fnName) {
    const index = this.canvas.drawLineFns.indexOf(fnName);
    if (index > -1) {
      this.canvas.drawLineFns.splice(index, 1);
    }
  }
  showMagnifier() {
    this.canvas.showMagnifier();
  }
  hideMagnifier() {
    this.canvas.hideMagnifier();
  }
  toggleMagnifier() {
    this.canvas.toggleMagnifier();
  }
  /**
   *  store  pens
   * @param render 
   */
  clear(render = true, template) {
    var _a;
    for (const pen of this.store.data.pens) {
      (_a = pen.onDestroy) == null ? void 0 : _a.call(pen, pen);
    }
    clearStore(this.store, template);
    this.hideInput();
    this.canvas.tooltip.hide();
    if (this.map && this.map.isShow) {
      this.map.show();
      this.map.setView();
    }
    this.canvas.clearCanvas();
    sessionStorage.removeItem("page");
    this.store.clipboard = void 0;
    if (!this.store.sameTemplate) {
      this.canvas.canvasTemplate.bgPatchFlags = true;
    }
    this.store.patchFlagsBackground = true;
    this.store.patchFlagsTop = true;
    this.setBackgroundImage(void 0);
    render && this.render();
  }
  emit(type, event) {
    this.store.emitter.emit(type, event);
  }
  on(type, handler) {
    this.store.emitter.on(type, handler);
    return this;
  }
  off(type, handler) {
    this.store.emitter.off(type, handler);
    return this;
  }
  // customeDock = (store, rect, pens, offset) => {xDock, yDock}
  // customDock return:
  // {
  //   xDock: {x, y, step, prev, penId},
  //   yDock: {x, y, step, prev, penId},
  // }
  // xDockyDock - 
  // prev - 
  // x,y - 
  // step - 
  // penId - 
  registerMoveDock(dock) {
    this.canvas.customMoveDock = dock;
  }
  /**
   *  registerMoveDock  offset  resize 
   */
  registerResizeDock(dock) {
    this.canvas.customResizeDock = dock;
  }
  find(idOrTag) {
    return this.canvas.find(idOrTag);
  }
  findOne(idOrTag) {
    return this.canvas.findOne(idOrTag);
  }
  getPenRect(pen) {
    return this.canvas.getPenRect(pen);
  }
  setPenRect(pen, rect, render = true) {
    this.canvas.setPenRect(pen, rect, render);
  }
  startAnimate(idOrTagOrPens, params) {
    this.stopAnimate(idOrTagOrPens);
    let pens;
    if (!idOrTagOrPens) {
      pens = this.store.data.pens.filter((pen) => {
        return (pen.type || pen.frames) && pen.autoPlay || pen.animations && pen.animations.length && pen.animations.findIndex((i) => i.autoPlay) !== -1;
      });
    } else if (typeof idOrTagOrPens === "string") {
      pens = this.find(idOrTagOrPens);
    } else {
      pens = idOrTagOrPens;
    }
    if (!pens.length) {
      return;
    }
    pens.forEach((pen) => {
      var _a, _b;
      if (pen.calculative.pause) {
        const d = Date.now() - pen.calculative.pause;
        pen.calculative.pause = void 0;
        pen.calculative.frameStart += d;
        pen.calculative.frameEnd += d;
      } else {
        let index = -1;
        if (params !== void 0 && pen.animations) {
          if (typeof params === "string") {
            index = pen.animations.findIndex((animation) => animation.name === params);
            if (index === -1) {
              return;
            }
          } else if (typeof params === "number") {
            if (pen.animations.length > params) {
              index = params;
            } else {
              return;
            }
          }
        } else if (params === void 0) {
          index = (_a = pen.animations) == null ? void 0 : _a.findIndex((i) => i.autoPlay);
          if (index === -1 && ((_b = pen.animations) == null ? void 0 : _b.length)) {
            index = 0;
          }
        }
        if (index !== -1 && index !== void 0) {
          const animate = deepClone(pen.animations[index]);
          animate.animateName = animate.name;
          delete animate.name;
          animate.currentAnimation = index;
          if (!pen.type && animate.frames) {
            animate.showDuration = this.calcAnimateDuration(animate);
          }
          this.setValue({
            id: pen.id,
            ...animate
          }, {
            doEvent: false,
            history: false
          });
        }
        this.store.animates.add(pen);
        if (!pen.type) {
          this.store.animateMap.set(pen, pen.calculative.canvas.getFrameProps(pen));
        }
      }
    });
    this.initImageCanvas(pens);
    this.canvas.animate();
  }
  pauseAnimate(idOrTagOrPens) {
    let pens = [];
    if (!idOrTagOrPens) {
      this.store.animates.forEach((pen) => {
        pens.push(pen);
      });
    } else if (typeof idOrTagOrPens === "string") {
      pens = this.find(idOrTagOrPens);
    } else {
      pens = idOrTagOrPens;
    }
    pens.forEach((pen) => {
      if (!pen.calculative.pause) {
        pen.calculative.pause = Date.now();
      }
    });
  }
  stopAnimate(idOrTagOrPens) {
    let pens = [];
    if (!idOrTagOrPens) {
      this.store.animates.forEach((pen) => {
        pens.push(pen);
      });
    } else if (typeof idOrTagOrPens === "string") {
      pens = this.find(idOrTagOrPens);
    } else {
      pens = idOrTagOrPens;
    }
    pens.forEach((pen) => {
      pen.currentAnimation = void 0;
      pen.calculative.pause = void 0;
      pen.calculative.start = void 0;
      pen.calculative.duration = void 0;
      pen.calculative.animatePos = 0;
      this.store.animates.delete(pen);
      this.canvas.restoreNodeAnimate(pen);
      this.canvas.updateLines(pen);
      this.store.animateMap.delete(pen);
    });
    this.initImageCanvas(pens);
    setTimeout(() => {
      var _a;
      (_a = this.canvas) == null ? void 0 : _a.calcActiveRect();
      this.render();
    }, 20);
  }
  startVideo(idOrTagOrPens) {
    let pens;
    if (!idOrTagOrPens) {
      pens = this.store.data.pens.filter((pen) => {
        return (pen.video || pen.audio) && pen.autoPlay;
      });
    } else if (typeof idOrTagOrPens === "string") {
      pens = this.find(idOrTagOrPens);
    } else {
      pens = idOrTagOrPens;
    }
    pens.forEach((pen) => {
      var _a, _b;
      (_a = pen.calculative.media) == null ? void 0 : _a.play();
      (_b = pen.onStartVideo) == null ? void 0 : _b.call(pen, pen);
    });
  }
  pauseVideo(idOrTagOrPens) {
    let pens = [];
    if (!idOrTagOrPens) {
      pens = this.store.data.pens.filter((pen) => {
        return (pen.video || pen.audio) && pen.autoPlay;
      });
    } else if (typeof idOrTagOrPens === "string") {
      pens = this.find(idOrTagOrPens);
    } else {
      pens = idOrTagOrPens;
    }
    pens.forEach((pen) => {
      var _a, _b;
      (_a = pen.calculative.media) == null ? void 0 : _a.pause();
      (_b = pen.onPauseVideo) == null ? void 0 : _b.call(pen, pen);
    });
  }
  stopVideo(idOrTagOrPens) {
    let pens = [];
    if (!idOrTagOrPens) {
      pens = this.store.data.pens.filter((pen) => {
        return (pen.video || pen.audio) && pen.autoPlay;
      });
    } else if (typeof idOrTagOrPens === "string") {
      pens = this.find(idOrTagOrPens);
    } else {
      pens = idOrTagOrPens;
    }
    pens.forEach((pen) => {
      var _a;
      if (pen.calculative.media) {
        pen.calculative.media.currentTime = 0;
        pen.calculative.media.pause();
      }
      (_a = pen.onStopVideo) == null ? void 0 : _a.call(pen, pen);
    });
  }
  calcAnimateDuration(pen) {
    return pen.frames.reduce((prev, frame) => prev + frame.duration, 0);
  }
  /**
   * 
   * @param pens 
   * @param showChild 
   * @param active 
   */
  combine(pens = this.store.active, showChild, active = true) {
    if (!pens || !pens.length) {
      return;
    }
    const initPens = deepClone(pens);
    if (pens.length === 1 && pens[0].type) {
      pens[0].type = PenType.Node;
      this.canvas.active(pens);
      this.pushHistory({
        type: EditType.Update,
        initPens,
        pens: deepClone(pens, true)
      });
      this.render();
      return;
    }
    const rect = getRect2(pens);
    let parent = {
      id: s8(),
      name: "combine",
      ...rect,
      children: [],
      showChild
    };
    this.canvas.makePen(parent);
    const initParent = deepClone(parent);
    let minIndex = Infinity;
    pens.forEach((pen) => {
      const index = this.store.data.pens.findIndex((_pen) => _pen.id === pen.id);
      if (index < minIndex) {
        minIndex = index;
      }
      if (pen === parent || pen.parentId === parent.id || pen.id === parent.id) {
        return;
      }
      parent.children.push(pen.id);
      pen.parentId = parent.id;
      const childRect = calcRelativeRect(pen.calculative.worldRect, rect);
      Object.assign(pen, childRect);
      pen.locked = pen.lockedOnCombine ?? LockState.None;
      pen.locked = pen.interaction || isInteraction.includes(pen.name) ? 0 : pen.locked;
    });
    this.store.data.pens.splice(minIndex, 0, parent);
    this.store.data.pens.pop();
    active && this.canvas.active([parent]);
    let step = 1;
    this.pushHistory({
      type: EditType.Add,
      pens: [initParent],
      step: 3
    });
    this.pushHistory({
      type: EditType.Update,
      initPens: [initParent],
      pens: [parent],
      step: 3
    });
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens,
      step: 3
    });
    if (showChild != void 0) {
      pens.forEach((pen) => {
        calcInView(pen, true);
      });
      this.initImageCanvas([parent]);
    }
    this.store.emitter.emit("combine", [parent]);
    this.render();
    return parent;
  }
  uncombine(pen) {
    if (!pen && this.store.active) {
      pen = this.store.active[0];
    }
    if (!pen || !pen.children) {
      return;
    }
    const children = pen.children.map((childId) => this.store.pens[childId]);
    let initPens = deepClone(children);
    children.forEach((child) => {
      child.parentId = void 0;
      child.x = child.calculative.worldRect.x;
      child.y = child.calculative.worldRect.y;
      child.width = child.calculative.worldRect.width;
      child.height = child.calculative.worldRect.height;
      child.locked = LockState.None;
      child.calculative.active = void 0;
      child.calculative.hover = false;
      this.setVisible(child, true);
    });
    const step = this.isCombine(pen) ? 3 : 2;
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens: children,
      step
    });
    initPens = [deepClone(pen)];
    pen.children = void 0;
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens: [pen],
      step
    });
    if (this.isCombine(pen)) {
      this.delete([pen]);
      this.store.histories[this.store.histories.length - 1].step = step;
    }
    this.inactive();
  }
  appendChild(pens = this.store.active) {
    if (!pens) {
      return;
    }
    if (pens.length < 2) {
      return;
    }
    const pIdx = pens.findIndex((pen) => pen.name === "combine" && pen.showChild !== void 0);
    if (pIdx !== -1) {
      let parent = pens[pIdx];
      const rect = getRect2(pens);
      Object.assign(parent, rect);
      Object.assign(parent.calculative.worldRect, rect);
      calcWorldAnchors(parent);
      parent.children.forEach((penId) => {
        const pen = this.store.pens[penId];
        const childRect = calcRelativeRect(pen.calculative.worldRect, rect);
        Object.assign(pen, childRect);
      });
      pens.forEach((pen) => {
        if (pen.id !== parent.id) {
          parent.children.push(pen.id);
          pen.parentId = parent.id;
          const childRect = calcRelativeRect(pen.calculative.worldRect, rect);
          Object.assign(pen, childRect);
          pen.locked = pen.lockedOnCombine ?? LockState.DisableMove;
          pen.locked = pen.interaction || isInteraction.includes(pen.name) ? 0 : pen.locked;
          calcInView(pen, true);
        }
      });
      this.initImageCanvas(pens);
      this.render();
    } else {
      console.warn("Invalid operation!");
    }
  }
  /***
   * 
   * @param rect  
   * @param child 
   * @param parent 
   */
  updateRectbyChild(rect, child, parent) {
    calcRightBottom(rect);
    calcCenter(rect);
    child.calculative.worldRect = rect;
    if (rectInRect(rect, parent.calculative.worldRect, true)) {
      const childRect = calcRelativeRect(rect, parent.calculative.worldRect);
      Object.assign(child, childRect);
    } else {
      let x = Math.min(rect.x, parent.calculative.worldRect.x);
      let y = Math.min(rect.y, parent.calculative.worldRect.y);
      let ex = Math.max(rect.ex, parent.calculative.worldRect.ex);
      let ey = Math.max(rect.ey, parent.calculative.worldRect.ey);
      parent.calculative.worldRect = {
        x,
        y,
        width: ex - x,
        height: ey - y,
        ex,
        ey
      };
      if (!parent.parentId) {
        Object.assign(parent, parent.calculative.worldRect);
      }
      calcCenter(parent.calculative.worldRect);
      parent.children.forEach((cid) => {
        const cPen = this.store.pens[cid];
        const childRect = calcRelativeRect(cPen.calculative.worldRect, parent.calculative.worldRect);
        Object.assign(cPen, childRect);
      });
      if (parent.parentId) {
        this.updateRectbyChild(parent.calculative.worldRect, parent, this.store.pens[parent.parentId]);
      }
    }
    this.canvas.updatePenRect(parent);
    this.render();
  }
  isCombine(pen) {
    if (pen.name === "combine") {
      return true;
    }
    if (pen.children && pen.children.length > 0) {
      return true;
    }
    return false;
  }
  active(pens, emit = true) {
    this.canvas.active(pens, emit);
  }
  inactive() {
    this.canvas.inactive();
  }
  activeAll() {
    this.canvas.active(this.store.data.pens.filter((pen) => !pen.parentId && pen.locked !== LockState.Disable));
    this.render();
  }
  focus(id) {
    const pen = this.findOne(id);
    if (pen) {
      this.store.hover = pen;
      this.store.hover.calculative.hover = true;
      this.showInput(pen);
    }
  }
  /**
   * 
   * @param pens 
   * @param canDelLocked 
   */
  delete(pens, canDelLocked = false, history2 = true) {
    this.canvas.delete(pens, canDelLocked, history2);
  }
  scale(scale, center = { x: 0, y: 0 }) {
    this.canvas.scale(scale, center);
  }
  translate(x, y) {
    this.canvas.translate(x, y);
  }
  translatePens(pens, x, y) {
    this.canvas.translatePens(pens, x, y);
  }
  getParent(pen, root) {
    return getParent(pen, root);
  }
  getAllChildren(pen) {
    return getAllChildren(pen, this.store);
  }
  getAllFollowers(pen) {
    return getAllFollowers(pen, this.store);
  }
  data() {
    const data = deepClone(this.store.data);
    const { pens, paths } = this.store.data;
    data.version = package_default.version;
    data.paths = {};
    for (const pathId in paths) {
      if (Object.prototype.hasOwnProperty.call(paths, pathId)) {
        if (pens.find((pen) => pen.pathId === pathId)) {
          data.paths[pathId] = paths[pathId];
        }
      }
    }
    data.dataPoints = [
      ...Object.keys(this.store.bind),
      ...Object.keys(this.store.bindDatas)
    ];
    return data;
  }
  copy(pens) {
    this.canvas.copy(pens);
  }
  cut(pens) {
    this.canvas.cut(pens);
  }
  paste() {
    this.canvas.paste();
  }
  undo() {
    this.canvas.undo();
  }
  redo() {
    this.canvas.redo();
  }
  listenSocket() {
    try {
      let socketFn;
      const socketCbJs = this.store.data.socketCbJs;
      if (socketCbJs) {
        socketFn = new Function("e", "context", socketCbJs);
      }
      if (!socketFn) {
        this.socketFn = null;
        return false;
      }
      this.socketFn = socketFn;
    } catch (e) {
      console.error("Create the function for socket:", e);
      return false;
    }
    return true;
  }
  connectWebsocket(websocket) {
    this.closeWebsocket();
    if (websocket) {
      this.store.data.websocket = websocket;
    }
    if (this.store.data.websocket) {
      this.websocket = new WebSocket(this.store.data.websocket, this.store.data.websocketProtocols || void 0);
      this.websocket.onmessage = (e) => {
        this.socketCallback(e.data, {
          type: "websocket",
          url: this.store.data.websocket
        });
      };
      this.websocket.onerror = (error) => {
        this.store.emitter.emit("error", { type: "websocket", error });
      };
      this.websocket.onclose = () => {
        if (this.store.options.reconnetTimes) {
          this.websocketTimes++;
          if (this.websocketTimes >= this.store.options.reconnetTimes) {
            this.websocketTimes = 0;
            this.closeWebsocket();
            return;
          }
        }
        console.info("Canvas websocket closed and reconneting...");
        this.connectWebsocket();
      };
    }
  }
  closeWebsocket() {
    if (this.websocket) {
      this.websocket.onclose = void 0;
      this.websocket.close();
      this.websocket = void 0;
    }
  }
  connectMqtt(params) {
    this.closeMqtt();
    if (params) {
      this.store.data.mqtt = params.mqtt;
      this.store.data.mqttTopics = params.mqttTopics;
      this.store.data.mqttOptions = params.mqttOptions;
    }
    if (this.store.data.mqtt) {
      if (this.store.data.mqttOptions.clientId && !this.store.data.mqttOptions.customClientId) {
        this.store.data.mqttOptions.clientId = s8();
      }
      const mqttOptions = { ...this.store.data.mqttOptions };
      if (!mqttOptions.username) {
        delete mqttOptions.username;
      }
      if (!mqttOptions.password) {
        delete mqttOptions.password;
      }
      const { username, password } = mqttOptions;
      if (username && password || !username && !password) {
        this.mqttClient = mqtt.connect(this.store.data.mqtt, mqttOptions);
        this.mqttClient.on("message", (topic, message2) => {
          this.socketCallback(message2.toString(), {
            topic,
            type: "mqtt",
            url: this.store.data.mqtt
          });
        });
        this.mqttClient.on("error", (error) => {
          this.store.emitter.emit("error", { type: "mqtt", error });
        });
        this.mqttClient.on("close", () => {
          if (this.store.options.reconnetTimes) {
            this.mqttTimes++;
            if (this.mqttTimes >= this.store.options.reconnetTimes) {
              this.mqttTimes = 0;
              this.closeMqtt();
            }
          }
        });
        if (this.store.data.mqttTopics) {
          this.mqttClient.subscribe(this.store.data.mqttTopics.split(","));
        }
      } else {
        console.warn("");
      }
    }
  }
  closeMqtt() {
    var _a;
    (_a = this.mqttClient) == null ? void 0 : _a.end();
  }
  connectHttp() {
    this.closeHttp();
    const { https } = this.store.data;
    if (https) {
      if (!this.store.data.cancelFirstConnect) {
        https.forEach(async (item) => {
          this.oldRequestHttp(item);
        });
      }
      https.forEach((item, index) => {
        if (item.http && item.httpTimeInterval !== 0) {
          item.times = 0;
          this.httpTimerList[index] = setInterval(async () => {
            this.oldRequestHttp(item);
            if (this.store.options.reconnetTimes) {
              if (item.times >= this.store.options.reconnetTimes) {
                item.times = 0;
                clearInterval(this.httpTimerList[index]);
                this.httpTimerList[index] = void 0;
              }
            }
          }, item.httpTimeInterval || 1e3);
        }
      });
    } else {
      const { http, httpTimeInterval, httpHeaders } = this.store.data;
      if (http) {
        this.httpTimer = setInterval(async () => {
          const res = await fetch(http, {
            headers: httpHeaders
          });
          if (res.ok) {
            const data = await res.text();
            this.socketCallback(data, { type: "http", url: http });
          }
        }, httpTimeInterval || 1e3);
      }
    }
  }
  async oldRequestHttp(_req) {
    let req = deepClone(_req);
    if (req.http) {
      const res = await fetch(req.http, {
        headers: req.httpHeaders,
        method: req.method || "GET",
        body: req.method === "POST" ? JSON.stringify(req.body) : void 0
      });
      if (res.ok) {
        const data = await res.text();
        this.socketCallback(data, { type: "http", url: req.http });
      } else {
        _req.times++;
        this.store.emitter.emit("error", { type: "http", error: res });
      }
    }
  }
  async sendDatabyHttp(data) {
    const { https } = this.store.data;
    if (https) {
      https.forEach(async (item) => {
        if (item.http) {
          const res = await fetch(item.http, {
            method: "post",
            body: data,
            headers: item.httpHeaders
          });
          if (res.ok) {
            console.info("http");
          }
        }
      });
    } else {
      const { http, httpHeaders } = this.store.data;
      if (http) {
        const res = await fetch(http, {
          method: "post",
          body: data,
          headers: httpHeaders
        });
        if (res.ok) {
          console.info("http");
        }
      }
    }
  }
  closeHttp() {
    clearInterval(this.httpTimer);
    this.httpTimer = void 0;
    this.httpTimerList && this.httpTimerList.forEach((_httpTimer) => {
      clearInterval(_httpTimer);
      _httpTimer = void 0;
    });
  }
  connectNetwork() {
    this.closeNetwork();
    const { networks } = this.store.data;
    const https = [];
    if (networks) {
      let mqttIndex = 0;
      this.mqttClients = [];
      let websocketIndex = 0;
      let sqlIndex = 0;
      this.websockets = [];
      networks.forEach(async (net) => {
        if (net.protocol === "mqtt") {
          net.index = mqttIndex;
          if (net.options.clientId && !net.options.customClientId) {
            net.options.clientId = s8();
          }
          net.times = 0;
          this.mqttClients[mqttIndex] = mqtt.connect(net.url, net.options);
          this.mqttClients[mqttIndex].on("message", (topic, message2) => {
            this.socketCallback(message2.toString(), {
              topic,
              type: "mqtt",
              url: net.url
            });
          });
          this.mqttClients[mqttIndex].on("error", (error) => {
            this.store.emitter.emit("error", { type: "mqtt", error });
          });
          this.mqttClients[mqttIndex].on("close", () => {
            var _a;
            if (this.store.options.reconnetTimes) {
              net.times++;
              if (net.times >= this.store.options.reconnetTimes) {
                net.times = 0;
                this.mqttClients && ((_a = this.mqttClients[net.index]) == null ? void 0 : _a.end());
              }
            }
          });
          if (net.topics) {
            this.mqttClients[mqttIndex].subscribe(net.topics.split(","));
          }
          mqttIndex += 1;
        } else if (net.protocol === "websocket") {
          net.index = websocketIndex;
          this.connectNetWebSocket(net);
          websocketIndex += 1;
        } else if (net.protocol === "http") {
          https.push({
            url: net.url,
            interval: net.interval,
            headers: net.headers || void 0,
            method: net.method,
            body: net.body
          });
        } else if (net.protocol === "iot") {
          const token = await this.getIotToken(net.devices);
          if (net.method === "mqtt") {
            net.index = mqttIndex;
            this.mqttClients[mqttIndex] = mqtt.connect(net.url);
            this.mqttClients[mqttIndex].on("message", (topic, message2) => {
              this.socketCallback(message2.toString(), {
                topic: `le5le-iot/properties/${token}`,
                type: "iot",
                url: net.url,
                method: "mqtt"
              });
            });
            this.mqttClients[mqttIndex].on("error", (error) => {
              this.store.emitter.emit("error", { type: "mqtt", error });
            });
            this.mqttClients[mqttIndex].subscribe(`le5le-iot/properties/${token}`);
            mqttIndex += 1;
          } else if (net.method === "websocket") {
            net.index = websocketIndex;
            this.websockets[websocketIndex] = new WebSocket(`${location.protocol === "https:" ? "wss" : "ws"}://${location.host}/api/ws/iot/properties`, token);
            this.websockets[websocketIndex].onmessage = (e) => {
              this.socketCallback(e.data, { type: "iot", method: "websocket" });
            };
            this.websockets[websocketIndex].onerror = (error) => {
              this.store.emitter.emit("error", { type: "websocket", error });
            };
            websocketIndex += 1;
          }
        } else if (net.protocol === "sql") {
          await this.doSqlCode("list", net.dbId, net.sql);
          if (net.interval) {
            net.index = sqlIndex;
            this.sqlTimerList[sqlIndex] = setInterval(async () => {
              await this.doSqlCode("list", net.dbId, net.sql);
            }, net.interval);
            sqlIndex += 1;
          }
        } else if (net.protocol === "ADIIOT") {
          connectJetLinks(this, net);
        }
      });
    }
    this.onNetworkConnect(https);
  }
  connectNetWebSocket(net) {
    var _a;
    if (this.websockets[net.index]) {
      this.websockets[net.index].onclose = void 0;
      (_a = this.websockets[net.index]) == null ? void 0 : _a.close();
      this.websockets[net.index] = void 0;
    }
    this.websockets[net.index] = new WebSocket(net.url, net.protocols || void 0);
    this.websockets[net.index].onmessage = (e) => {
      this.socketCallback(e.data, { type: "websocket", url: net.url });
    };
    this.websockets[net.index].onerror = (error) => {
      this.store.emitter.emit("error", { type: "websocket", error });
    };
    this.websockets[net.index].onclose = () => {
      var _a2;
      if (this.store.options.reconnetTimes) {
        net.times++;
        if (net.times >= this.store.options.reconnetTimes) {
          net.times = 0;
          this.websockets[net.index].onclose = void 0;
          (_a2 = this.websockets[net.index]) == null ? void 0 : _a2.close();
          this.websockets[net.index] = void 0;
          return;
        }
      }
      setTimeout(() => {
        console.info("Canvas websocket closed and reconneting...");
        this.connectNetWebSocket(net);
      }, 2e3);
    };
  }
  async getIotToken(devices) {
    const res = await fetch("/api/iot/subscribe/properties", {
      method: "POST",
      body: JSON.stringify({ devices })
    });
    if (res.ok) {
      const data = await res.text();
      return JSON.parse(data).token;
    }
  }
  async doSqlCode(type, dbid, sql) {
    const res = await fetch(`/api/iot/data/sql/${type}`, {
      method: "POST",
      body: JSON.stringify({ dbid, sql })
    });
    if (res.ok) {
      const data = await res.text();
      if (data) {
        this.socketCallback(data, {
          type: "sql",
          url: `/api/iot/data/sql/${type}`
        });
      }
    }
  }
  randomString(e) {
    e = e || 32;
    let t = "ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678", a = t.length, n = "";
    for (let i = 0; i < e; i++) {
      n += t.charAt(Math.floor(Math.random() * a));
    }
    return n;
  }
  mockValue(data) {
    let value4 = void 0;
    if (data.enableMock && data.mock !== void 0) {
      if (data.type === "float") {
        if (data.mock && data.mock.indexOf(",") !== -1) {
          let arr = data.mock.split(",");
          let rai = Math.floor(Math.random() * arr.length);
          value4 = parseFloat(arr[rai]);
        } else if (data.mock && data.mock.indexOf("-") !== -1) {
          let max;
          let min;
          let len;
          let arr = data.mock.split("-");
          if (data.mock.charAt(0) === "-") {
            if (arr.length === 4) {
              max = -parseFloat(arr[3]);
              min = -parseFloat(arr[1]);
              len = arr[3];
            } else {
              max = parseFloat(arr[2]);
              min = -parseFloat(arr[1]);
              len = arr[2];
            }
          } else {
            max = parseFloat(arr[1]);
            min = parseFloat(arr[0]);
            len = arr[1];
          }
          if ((len + "").indexOf(".") !== -1) {
            let length = (len + "").split(".")[1].length;
            value4 = (Math.random() * (max - min) + min).toFixed(length);
          } else {
            value4 = Math.random() * (max - min) + min;
          }
        } else {
          value4 = parseFloat(data.mock);
        }
      } else if (data.type === "integer") {
        if (data.mock && data.mock.indexOf(",") !== -1) {
          let arr = data.mock.split(",");
          let rai = Math.floor(Math.random() * arr.length);
          value4 = parseInt(arr[rai]);
        } else if (data.mock && data.mock.indexOf("-") !== -1) {
          let max;
          let min;
          let arr = data.mock.split("-");
          if (data.mock.charAt(0) === "-") {
            if (arr.length === 4) {
              max = -parseFloat(arr[3]);
              min = -parseFloat(arr[1]);
            } else {
              max = parseFloat(arr[2]);
              min = -parseFloat(arr[1]);
            }
          } else {
            max = parseInt(arr[1]);
            min = parseInt(arr[0]);
          }
          value4 = parseInt(Math.random() * (max - min) + min + "");
        } else {
          value4 = parseInt(data.mock);
        }
      } else if (data.type === "bool") {
        if (typeof data.mock === "boolean") {
          value4 = data.mock;
        } else if ("true" === data.mock) {
          value4 = true;
        } else if ("false" === data.mock) {
          value4 = false;
        } else {
          value4 = Math.random() < 0.5;
        }
      } else if (data.type === "object" || data.type === "array") {
        if (data.mock) {
        }
      } else {
        if (data.mock && data.mock.indexOf(",") !== -1) {
          let arr = data.mock.split(",");
          let rai = Math.floor(Math.random() * arr.length);
          value4 = arr[rai];
        } else if (data.mock && data.mock.startsWith("[") && data.mock.endsWith("]")) {
          let len = parseInt(data.mock.substring(1, data.mock.length - 1));
          value4 = this.randomString(len);
        } else {
          value4 = data.mock;
        }
      }
    }
    return value4;
  }
  //
  dataMock() {
    var _a, _b;
    let arr = [];
    (_b = (_a = this.store.data.dataset) == null ? void 0 : _a.devices) == null ? void 0 : _b.forEach((data) => {
      let value4 = this.mockValue(data);
      if (value4 !== void 0) {
        arr.push({
          id: data.id,
          value: value4
        });
      }
    });
    if (arr.length) {
      this.setDatas(arr, {
        render: true,
        doEvent: true,
        history: false
      });
    }
  }
  startDataMock() {
    let enable = this.store.data.enableMock;
    if (enable) {
      this.stopDataMock();
      this.initBinds();
      this.updateTimer = setInterval(() => {
        this.store.data.pens.forEach((pen) => {
          this.penMock(pen);
        });
        this.dataMock();
        this.render();
      }, this.store.data.networkInterval || 1e3);
    }
  }
  stopDataMock() {
    clearInterval(this.updateTimer);
    this.updateTimer = void 0;
  }
  penMock(pen) {
    var _a;
    if (pen.realTimes) {
      let _d = {};
      pen.realTimes.forEach((realTime) => {
        let value4 = this.mockValue(realTime);
        if (value4 !== void 0) {
          _d[realTime.key] = value4;
        }
      });
      if (Object.keys(_d).length) {
        let data = pen.onBeforeValue ? pen.onBeforeValue(pen, _d) : _d;
        this.canvas.updateValue(pen, data);
        (_a = pen.onValue) == null ? void 0 : _a.call(pen, pen);
        this.store.emitter.emit("valueUpdate", pen);
      }
    }
  }
  penNetwork(pen) {
    const penNetwork = {
      url: pen.apiUrl,
      method: pen.apiMethod,
      headers: pen.apiHeaders,
      body: pen.apiBody
    };
    this.requestHttp(penNetwork);
    if (pen.apiEnable) {
      if (!this.store.pensNetwork) {
        this.store.pensNetwork = {};
      }
      this.store.pensNetwork[pen.id] = penNetwork;
    } else {
      delete this.store.pensNetwork[pen.id];
    }
  }
  // getCookie(name: string) {
  //   let arr: RegExpMatchArray | null;
  //   const reg = new RegExp('(^| )' + name + '=([^;]*)(;|$)');
  //   if ((arr = document.cookie.match(reg))) {
  //     return decodeURIComponent(arr[2]);
  //   } else {
  //     return '';
  //   }
  // }
  //
  getDynamicParam(key) {
    let params = queryURLParams();
    let value4 = params[key] || localStorage[key] || getCookie(key) || "";
    return value4;
  }
  onNetworkConnect(https) {
    if (!(https && https.length)) {
      return;
    }
    if (this.store.pensNetwork) {
      for (let key in this.store.pensNetwork) {
        https.push(this.store.pensNetwork[key]);
      }
    }
    if (!this.store.data.cancelFirstConnect) {
      https.forEach(async (_item) => {
        this.requestHttp(_item);
      });
    }
    https.forEach((_item, index) => {
      _item.times = 0;
      if (_item.interval !== 0) {
        this.updateTimerList[index] = setInterval(async () => {
          this.requestHttp(_item);
          if (this.store.options.reconnetTimes) {
            if (_item.times >= this.store.options.reconnetTimes) {
              _item.times = 0;
              clearInterval(this.updateTimerList[index]);
              this.updateTimerList[index] = void 0;
            }
          }
        }, _item.interval || 1e3);
      }
    });
  }
  async requestHttp(_req) {
    var _a, _b, _c;
    let req = deepClone(_req);
    if (req.url) {
      if (req.url.indexOf("${") > -1) {
        let keys = (_a = req.url.match(/\$\{([^}]+)\}/g)) == null ? void 0 : _a.map((m) => m.slice(2, -1));
        if (keys) {
          keys.forEach((key) => {
            req.url = req.url.replace(`\${${key}}`, this.getDynamicParam(key));
          });
        }
      }
      if (typeof req.headers === "object") {
        for (let i in req.headers) {
          if (typeof req.headers[i] === "string") {
            let keys = (_b = req.headers[i].match(/\$\{([^}]+)\}/g)) == null ? void 0 : _b.map((m) => m.slice(2, -1));
            if (keys) {
              req.headers[i] = req.headers[i].replace(`\${${keys[0]}}`, this.getDynamicParam(keys[0]));
            }
          }
        }
      }
      if (typeof req.body === "object") {
        for (let i in req.body) {
          if (typeof req.body[i] === "string") {
            let keys = (_c = req.body[i].match(/\$\{([^}]+)\}/g)) == null ? void 0 : _c.map((m) => m.slice(2, -1));
            if (keys) {
              req.body[i] = req.body[i].replace(`\${${keys[0]}}`, this.getDynamicParam(keys[0]));
            }
          }
        }
      }
      const res = await fetch(req.url, {
        headers: req.headers,
        method: req.method,
        body: req.method === "GET" ? void 0 : JSON.stringify(req.body)
      });
      if (res.ok) {
        const data = await res.text();
        this.socketCallback(data, { type: "http", url: req.url });
      } else {
        _req.times++;
        this.store.emitter.emit("error", { type: "http", error: res });
      }
    }
  }
  closeNetwork() {
    this.mqttClients && this.mqttClients.forEach((mqttClient) => {
      mqttClient.end();
    });
    this.websockets && this.websockets.forEach((websocket) => {
      if (websocket) {
        websocket.onclose = void 0;
        websocket.close();
        websocket = void 0;
      }
    });
    this.mqttClients = void 0;
    this.websockets = void 0;
    this.updateTimerList && this.updateTimerList.forEach((_updateTimer) => {
      clearInterval(_updateTimer);
      _updateTimer = void 0;
    });
    this.sqlTimerList && this.sqlTimerList.forEach((_sqlTimer) => {
      clearInterval(_sqlTimer);
      _sqlTimer = void 0;
    });
    closeJetLinks(this);
  }
  socketCallback(message2, context) {
    this.store.emitter.emit("socket", { message: message2, context });
    let _message = message2;
    if (this.socketFn) {
      _message = this.socketFn(message2, {
        meta2d: this,
        type: context.type,
        topic: context.topic,
        url: context.url,
        method: context.method
      });
      if (!_message) {
        return;
      }
    }
    if (_message === true) {
      _message = message2;
    }
    let data;
    if (_message.constructor === Object || _message.constructor === Array) {
      data = _message;
    } else if (typeof _message === "string") {
      try {
        data = JSON.parse(_message);
      } catch (error) {
        console.warn("Invalid socket data:", data, error);
      }
    } else {
      return;
    }
    if (!data) {
      return;
    }
    if (!Array.isArray(data)) {
      data = [data];
    }
    if (!data.length) {
      return;
    }
    if (data[0].dataId) {
      this.setDatas(data);
    } else {
      data.forEach((_data) => {
        this.setValue(_data);
      });
    }
  }
  // 
  setDatas(datas, { render = true, doEvent = true, history: history2 } = {}) {
    const penValues = /* @__PURE__ */ new Map();
    datas.forEach((v) => {
      var _a, _b;
      (_a = this.store.bindDatas[v.dataId]) == null ? void 0 : _a.forEach((p) => {
        const pen = this.store.pens[p.id];
        if (!pen) {
          return;
        }
        let penValue = penValues.get(pen);
        if (!pen.noOnBinds && typeof pen.onBinds === "function") {
          if (penValue) {
            return;
          }
          penValues.set(pen, pen.onBinds(pen, datas, p.formItem));
          return;
        }
        if (penValue) {
          penValue[p.formItem.key] = v.value;
        } else {
          penValue = {
            id: p.id,
            [p.formItem.key]: v.value
          };
          penValues.set(pen, penValue);
        }
      });
      (_b = this.store.bind[v.id || v.dataId]) == null ? void 0 : _b.forEach((p) => {
        const pen = this.store.pens[p.id];
        if (!pen) {
          return;
        }
        let penValue = penValues.get(pen);
        if (penValue) {
          penValue[p.key] = v.value;
        } else {
          penValue = {
            id: p.id,
            [p.key]: v.value
          };
          penValues.set(pen, penValue);
        }
      });
    });
    this.store.data.locked && this.doDataEvent(datas);
    let initPens;
    let pens;
    if (history2) {
      initPens = [];
    }
    penValues.forEach((value4, pen) => {
      this.setValue(value4, { render: false, doEvent, history: false });
      if (history2) {
        initPens.push(deepClone(pen, true));
        pens.push(pen);
      }
    });
    render && this.render();
    if (history2) {
      this.pushHistory({
        type: EditType.Update,
        initPens,
        pens
      });
    }
  }
  setValue(data, { render = true, doEvent = true, history: history2 } = {}) {
    let pens = [];
    if (!data) {
      return;
    }
    if (data.id) {
      if (data.id === this.store.data.id) {
        this.setDatabyOptions(data);
        if (data.bkImage) {
          this.setBackgroundImage(data.bkImage);
        }
        if (data.background) {
          this.setBackgroundColor(data.background);
        }
        this.render();
        return;
      }
      const pen = this.store.pens[data.id];
      if (pen) {
        pens = [pen];
      } else {
        let bindArr = this.store.bind[data.id];
        if (bindArr && bindArr.length) {
          pens = [];
          this.setDatas([data], {
            render,
            doEvent,
            history: history2
          });
          return;
        }
      }
    } else if (data.dataId) {
      pens = [];
      this.setDatas([data], {
        render,
        doEvent,
        history: history2
      });
      return;
    } else if (data.tag) {
      pens = this.find(data.tag);
    } else {
      let binds = [];
      for (let key in data) {
        binds.push({
          dataId: key,
          id: key,
          value: data[key]
        });
      }
      if (binds.length) {
        this.setDatas(binds, {
          render,
          doEvent,
          history: history2
        });
      }
      return;
    }
    history2 = history2 && !this.store.data.locked;
    let initPens;
    if (history2) {
      initPens = deepClone(pens);
    }
    pens.forEach((pen) => {
      var _a;
      const afterData = pen.onBeforeValue ? pen.onBeforeValue(pen, data) : data;
      if (data.frames) {
        this.stopAnimate([pen]);
        if (!data.showDuration) {
          data.showDuration = data.frames.reduce((total, item) => {
            return total + item.duration;
          }, 0);
        }
      }
      setChildValue(pen, afterData);
      this.canvas.updateValue(pen, afterData);
      (_a = pen.onValue) == null ? void 0 : _a.call(pen, pen);
    });
    if (!this.store.data.locked && this.store.active.length && !this.canvas.movingPens) {
      this.canvas.calcActiveRect();
    }
    if (history2) {
      let _pens = deepClone(pens);
      this.pushHistory({
        type: EditType.Update,
        initPens,
        pens: _pens
      });
    }
    doEvent && pens.forEach((pen) => {
      this.store.emitter.emit("valueUpdate", pen);
    });
    render && this.render();
  }
  /**
   * @deprecated  setValue
   */
  _setValue(data, history2 = false) {
    this.setValue(data, { history: history2, render: false, doEvent: false });
  }
  pushHistory(action) {
    this.canvas.pushHistory(action);
  }
  showInput(pen, rect) {
    this.canvas.showInput(pen, rect);
  }
  hideInput() {
    this.canvas.hideInput();
  }
  clearDropdownList() {
    this.canvas.clearDropdownList();
  }
  clearRuleLines() {
    this.canvas.clearRuleLines();
  }
  doMessageEvent(eventName, data) {
    if (this.store.messageEvents[eventName]) {
      this.store.messageEvents[eventName].forEach((item) => {
        let flag = false;
        if (item.event.conditions && item.event.conditions.length) {
          if (item.event.conditionType === "and") {
            flag = item.event.conditions.every((condition) => {
              return this.judgeCondition(item.pen, condition.key, condition);
            });
          } else if (item.event.conditionType === "or") {
            flag = item.event.conditions.some((condition) => {
              return this.judgeCondition(item.pen, condition.key, condition);
            });
          }
        } else {
          flag = true;
        }
        if (flag) {
          item.event.actions.forEach((action) => {
            this.events[action.action](item.pen, action, data);
          });
        }
      });
    }
  }
  initGlobalTriggers() {
    var _a;
    this.store.globalTriggers = {};
    (_a = this.store.data.triggers) == null ? void 0 : _a.forEach((trigger) => {
      trigger.conditions.forEach((condition) => {
        if (condition.source) {
          if (!this.store.globalTriggers[condition.source]) {
            this.store.globalTriggers[condition.source] = [];
          }
          if (!this.store.globalTriggers[condition.source].includes(trigger)) {
            this.store.globalTriggers[condition.source].push(trigger);
          }
        }
      });
    });
  }
  initMessageEvents() {
    this.store.messageEvents = {};
    this.store.data.pens.forEach((pen) => {
      var _a;
      (_a = pen.events) == null ? void 0 : _a.forEach((event) => {
        if (event.name === "message" && event.message) {
          if (!this.store.messageEvents[event.message]) {
            this.store.messageEvents[event.message] = [];
          }
          this.store.messageEvents[event.message].push({
            pen,
            event
          });
        }
      });
    });
  }
  dataJudegeCondition(data, key, condition) {
    const { type, target, fnJs, fn, operator, valueType } = condition;
    let can = false;
    if (type === "fn") {
      if (fn) {
        can = fn(data, { meta2d: this });
      } else if (fnJs) {
        try {
          condition.fn = new Function("data", "context", fnJs);
        } catch (err) {
          console.error("Error: make function:", err);
        }
        if (condition.fn) {
          can = condition.fn(data, { meta2d: this });
        }
      }
    } else {
      let value4 = condition.value;
      if (valueType === "prop") {
        value4 = data[condition.value];
      }
      let compareValue = data[key];
      switch (operator) {
        case ">":
          can = compareValue > +value4;
          break;
        case ">=":
          can = compareValue >= +value4;
          break;
        case "<":
          can = compareValue < +value4;
          break;
        case "<=":
          can = compareValue <= +value4;
          break;
        case "=":
        case "==":
          can = compareValue == value4;
          break;
        case "!=":
          can = compareValue != value4;
          break;
        case "[)":
          can = valueInRange(+compareValue, value4);
          break;
        case "![)":
          can = !valueInRange(+compareValue, value4);
          break;
        case "[]":
          can = valueInArray(compareValue, value4);
          break;
        case "![]":
          can = !valueInArray(compareValue, value4);
          break;
      }
    }
    return can;
  }
  judgeCondition(pen, key, condition) {
    const { type, target, fnJs, fn, operator, valueType } = condition;
    let can = false;
    if (type === "fn") {
      if (fn) {
        can = fn(pen, { meta2d: this });
      } else if (fnJs) {
        try {
          condition.fn = new Function("pen", "context", fnJs);
        } catch (err) {
          console.error("Error: make function:", err);
        }
        if (condition.fn) {
          can = condition.fn(pen, { meta2d: this });
        }
      }
    } else {
      let value4 = condition.value;
      if (valueType === "prop") {
        value4 = this.store.pens[target][condition.value];
      }
      let compareValue = getter(pen, key);
      if (["x", "y", "width", "height"].includes(key)) {
        compareValue = this.getPenRect(pen)[key];
      }
      switch (operator) {
        case ">":
          can = compareValue > +value4;
          break;
        case ">=":
          can = compareValue >= +value4;
          break;
        case "<":
          can = compareValue < +value4;
          break;
        case "<=":
          can = compareValue <= +value4;
          break;
        case "=":
        case "==":
          can = compareValue == value4;
          break;
        case "!=":
          can = compareValue != value4;
          break;
        case "[)":
          can = valueInRange(+compareValue, value4);
          break;
        case "![)":
          can = !valueInRange(+compareValue, value4);
          break;
        case "[]":
          can = valueInArray(compareValue, value4);
          break;
        case "![]":
          can = !valueInArray(compareValue, value4);
          break;
      }
    }
    return can;
  }
  pushChildren(parent, children) {
    const initUpdatePens = [deepClone(parent, true)];
    const addPens = [];
    if (!parent.children) {
      parent.children = [];
    }
    const updatePens = [];
    children.forEach((pen) => {
      let oldPen = deepClone(pen, true);
      if (!pen.id || !this.store.pens[pen.id]) {
        this.canvas.makePen(pen);
        oldPen = null;
      }
      if (pen.parentId) {
        const oldParent = this.store.pens[pen.parentId];
        const i = oldParent.children.findIndex((id) => id === pen.id);
        initUpdatePens.push(deepClone(oldParent, true));
        oldParent.children.splice(i, 1);
        updatePens.push(deepClone(oldParent, true));
      }
      parent.children.push(pen.id);
      pen.parentId = parent.id;
      const childRect = calcRelativeRect(pen.calculative.worldRect, parent.calculative.worldRect);
      Object.assign(pen, childRect);
      pen.locked = pen.lockedOnCombine ?? LockState.DisableMove;
      pen.locked = pen.interaction || isInteraction.includes(pen.name) ? 0 : pen.locked;
      if (!oldPen) {
        addPens.push(deepClone(pen, true));
      } else {
        initUpdatePens.push(oldPen);
        updatePens.push(deepClone(pen, true));
      }
    });
    updatePens.push(deepClone(parent, true));
    let step = 1;
    if (addPens.length) {
      step = 2;
      this.pushHistory({
        type: EditType.Add,
        pens: addPens,
        step
      });
    }
    this.pushHistory({
      type: EditType.Update,
      initPens: initUpdatePens,
      pens: updatePens,
      step
    });
  }
  toPng(padding, callback, containBkImg = false, maxWidth) {
    return this.canvas.toPng(padding, callback, containBkImg, maxWidth);
  }
  activeToPng(padding, maxWidth) {
    return this.canvas.activeToPng(padding, maxWidth);
  }
  pensToPng(pens = this.store.active, padding, maxWidth) {
    return this.canvas.pensToPng(pens, padding, maxWidth);
  }
  /**
   *  png
   * @param name  'test.png'
   * @param padding 
   */
  downloadPng(name, padding, maxWidth) {
    var _a;
    for (const pen of this.store.data.pens) {
      if (pen.calculative.img || ["iframe"].includes(pen.name)) {
        (_a = pen.onRenderPenRaw) == null ? void 0 : _a.call(pen, pen);
      }
    }
    setTimeout(() => {
      const a = document.createElement("a");
      a.setAttribute("download", (name || this.store.data.name || "le5le.meta2d") + ".png");
      a.setAttribute("href", this.toPng(padding, void 0, true, maxWidth));
      const evt = document.createEvent("MouseEvents");
      evt.initEvent("click", true, true);
      a.dispatchEvent(evt);
    }, 1e3);
  }
  downloadSvg() {
    if (!window.C2S) {
      console.error("canvas2svg.js", "https://assets.le5lecdn.com/2d/canvas2svg.js");
      throw new Error("canvas2svg.js");
    }
    let isV = false;
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    if (width && height && !this.store.data.component) {
      isV = true;
    }
    const rect = this.getRect();
    if (isV) {
      rect.x = this.store.data.origin.x;
      rect.y = this.store.data.origin.y;
      rect.width = width * this.store.data.scale;
      rect.height = height * this.store.data.scale;
    }
    rect.x -= 10;
    rect.y -= 10;
    const ctx = new window.C2S(rect.width + 20, rect.height + 20);
    ctx.textBaseline = "middle";
    ctx.strokeStyle = this.store.styles.color;
    const background = this.store.data.background || this.store.styles.background;
    if (background && isV) {
      ctx.save();
      ctx.fillStyle = background;
      ctx.fillRect(0, 0, rect.width, rect.height);
      ctx.restore();
    }
    if (this.store.bkImg) {
      if (isV) {
        ctx.drawImage(this.store.bkImg, 0, 0, rect.width, rect.height);
      } else {
      }
    }
    if (background && !isV) {
      ctx.save();
      ctx.fillStyle = background;
      ctx.fillRect(0, 0, rect.width + 20, rect.height + 20);
      ctx.restore();
    }
    for (const pen of this.store.data.pens) {
      if (pen.visible == false || !isShowChild(pen, this.store)) {
        continue;
      }
      if (pen.name === "combine" && !pen.draw) {
        continue;
      }
      renderPenRaw2(ctx, pen, rect, true);
    }
    let mySerializedSVG = ctx.getSerializedSvg();
    if (this.store.data.background) {
      mySerializedSVG = mySerializedSVG.replace("{{bk}}", "");
      mySerializedSVG = mySerializedSVG.replace("{{bkRect}}", `<rect x="0" y="0" width="100%" height="100%" fill="${this.store.data.background}"></rect>`);
    } else {
      mySerializedSVG = mySerializedSVG.replace("{{bk}}", "");
      mySerializedSVG = mySerializedSVG.replace("{{bkRect}}", "");
    }
    mySerializedSVG = mySerializedSVG.replace(/--le5le--/g, "&#x");
    const urlObject = window.URL;
    const export_blob = new Blob([mySerializedSVG]);
    const url = urlObject.createObjectURL(export_blob);
    const a = document.createElement("a");
    a.setAttribute("download", `${this.store.data.name || "le5le.meta2d"}.svg`);
    a.setAttribute("href", url);
    const evt = document.createEvent("MouseEvents");
    evt.initEvent("click", true, true);
    a.dispatchEvent(evt);
  }
  getRect(pens = this.store.data.pens) {
    return getRect2(pens);
  }
  hiddenTemplate() {
    this.canvas.canvasTemplate.hidden();
  }
  showTemplate() {
    this.canvas.canvasTemplate.show();
  }
  lockTemplate(lock) {
    this.store.data.pens.forEach((pen) => {
      if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
        pen.locked = lock;
      }
    });
  }
  /**
   * 
   * @param fit truefalse
   */
  fitView(fit = true, viewPadding = 10) {
    var _a, _b;
    if (!this.hasView())
      return;
    const { canvas } = this.canvas;
    const { offsetWidth: width, offsetHeight: height } = canvas;
    this.resize(width, height);
    const padding = formatPadding(viewPadding);
    const rect = this.getRect();
    const w = (width - padding[1] - padding[3]) / rect.width;
    const h = (height - padding[0] - padding[2]) / rect.height;
    let ratio = w;
    if (fit) {
      ratio = w > h ? h : w;
    } else {
      ratio = w > h ? w : h;
    }
    if ((_a = this.store.data.fits) == null ? void 0 : _a.length) {
      this.canvas.opening = true;
    }
    this.scale(ratio * this.store.data.scale);
    this.centerView();
    if ((_b = this.store.data.fits) == null ? void 0 : _b.length) {
      this.fillView();
    }
  }
  fillView() {
    var _a, _b;
    const rect = this.getRect();
    const wGap = this.canvas.width - rect.width;
    const hGap = this.canvas.height - rect.height;
    if (Math.abs(wGap) > 10) {
      (_a = this.store.data.fits) == null ? void 0 : _a.forEach((fit) => {
        let pens = [];
        fit.children.forEach((id) => {
          this.store.pens[id].locked = LockState.None;
          pens.push(this.store.pens[id]);
        });
        let r = wGap / 2;
        if (fit.left && fit.right) {
          let left = fit.leftValue;
          let right = fit.rightValue;
          if (left) {
            left = Math.abs(left) < 1 ? left * this.canvas.width : left;
          } else {
            left = 0;
          }
          if (right) {
            right = Math.abs(right) < 1 ? right * this.canvas.width : right;
          } else {
            right = 0;
          }
          let ratio = (this.canvas.width - left - right) / (rect.width - left - right);
          pens.forEach((pen) => {
            var _a2;
            if (pen.image && pen.imageRatio) {
              if (pen.calculative.worldRect.width / this.canvas.width > 0.1) {
                pen.imageRatio = false;
              }
            }
            pen.calculative.worldRect.x = rect.x - wGap / 2 + left + (pen.calculative.worldRect.x - rect.x) * ratio;
            pen.calculative.worldRect.width *= ratio;
            pen.calculative.worldRect.ex = pen.calculative.worldRect.x + pen.calculative.worldRect.width;
            pen.calculative.width = pen.calculative.worldRect.width;
            pen.calculative.x = pen.calculative.worldRect.x;
            pen.width = pen.calculative.worldRect.width;
            pen.x = pen.calculative.worldRect.x;
            this.canvas.updatePenRect(pen, { worldRectIsReady: false });
            if (pen.externElement) {
              (_a2 = pen.onResize) == null ? void 0 : _a2.call(pen, pen);
            }
          });
        } else if (fit.left) {
          r = -r;
          if (fit.leftValue) {
            r += Math.abs(fit.leftValue) < 1 ? fit.leftValue * this.canvas.width : fit.leftValue;
          }
          this.translatePens(pens, r, 0);
        } else if (fit.right) {
          if (fit.rightValue) {
            r = r - (Math.abs(fit.rightValue) < 1 ? fit.rightValue * this.canvas.width : fit.rightValue);
          }
          this.translatePens(pens, r, 0);
        }
      });
      const iframePens = this.store.data.pens.filter((pen) => pen.name === "iframe");
      iframePens == null ? void 0 : iframePens.forEach((pen) => {
        var _a2, _b2;
        const worldRect = pen.calculative.worldRect;
        if (worldRect.width / this.store.data.scale > rect.width * 0.8) {
          let bfW = worldRect.width;
          pen.calculative.worldRect.x = worldRect.x - wGap / 2;
          pen.calculative.worldRect.width = worldRect.width + wGap;
          pen.calculative.worldRect.ex = worldRect.ex + wGap;
          pen.operationalRect.x = pen.operationalRect.x * bfW / pen.calculative.worldRect.width;
          pen.operationalRect.width = (pen.calculative.worldRect.width - (1 - pen.operationalRect.width) * bfW) / pen.calculative.worldRect.width;
          (_a2 = pen.onBeforeValue) == null ? void 0 : _a2.call(pen, pen, {
            operationalRect: pen.operationalRect
          });
          (_b2 = pen.onResize) == null ? void 0 : _b2.call(pen, pen);
        }
      });
    }
    if (Math.abs(hGap) > 10) {
      (_b = this.store.data.fits) == null ? void 0 : _b.forEach((fit) => {
        let pens = [];
        fit.children.forEach((id) => {
          this.store.pens[id].locked = LockState.None;
          pens.push(this.store.pens[id]);
        });
        let r = hGap / 2;
        if (fit.top && fit.bottom) {
          let top = fit.topValue;
          let bottom = fit.bottomValue;
          if (top) {
            top = Math.abs(top) < 1 ? top * this.canvas.height : top;
          } else {
            top = 0;
          }
          if (bottom) {
            bottom = Math.abs(bottom) < 1 ? bottom * this.canvas.height : bottom;
          } else {
            bottom = 0;
          }
          let ratio = (this.canvas.height - top - bottom) / (rect.height - top - bottom);
          pens.forEach((pen) => {
            var _a2;
            if (pen.image && pen.imageRatio) {
              if (pen.calculative.worldRect.height / this.canvas.height > 0.1) {
                pen.imageRatio = false;
              }
            }
            pen.calculative.worldRect.y = rect.y - hGap / 2 + top + (pen.calculative.worldRect.y - rect.y) * ratio;
            pen.calculative.worldRect.height *= ratio;
            pen.calculative.worldRect.ey = pen.calculative.worldRect.y + pen.calculative.worldRect.height;
            pen.calculative.height = pen.calculative.worldRect.height;
            pen.calculative.y = pen.calculative.worldRect.y;
            pen.height = pen.calculative.worldRect.height;
            pen.y = pen.calculative.worldRect.y;
            this.canvas.updatePenRect(pen, { worldRectIsReady: false });
            if (pen.externElement) {
              (_a2 = pen.onResize) == null ? void 0 : _a2.call(pen, pen);
            }
          });
        } else if (fit.top) {
          r = -r;
          if (fit.topValue) {
            r += Math.abs(fit.topValue) < 1 ? fit.topValue * this.canvas.height : fit.topValue;
          }
          this.translatePens(pens, 0, r);
        } else if (fit.bottom) {
          if (fit.bottomValue) {
            r = r - (Math.abs(fit.bottomValue) < 1 ? fit.bottomValue * this.canvas.height : fit.bottomValue);
          }
          this.translatePens(pens, 0, r);
        }
      });
      const iframePens = this.store.data.pens.filter((pen) => pen.name === "iframe");
      iframePens == null ? void 0 : iframePens.forEach((pen) => {
        var _a2, _b2;
        const worldRect = pen.calculative.worldRect;
        if (worldRect.height / this.store.data.scale > rect.height * 0.8) {
          let bfH = worldRect.height;
          pen.calculative.worldRect.y = worldRect.y - hGap / 2;
          pen.calculative.worldRect.height = worldRect.height + hGap;
          pen.calculative.worldRect.ey = worldRect.ey + hGap;
          pen.operationalRect.y = pen.operationalRect.y * bfH / pen.calculative.worldRect.width;
          pen.operationalRect.height = (pen.calculative.worldRect.height - (1 - pen.operationalRect.height) * bfH) / pen.calculative.worldRect.height;
          (_a2 = pen.onBeforeValue) == null ? void 0 : _a2.call(pen, pen, {
            operationalRect: pen.operationalRect
          });
          (_b2 = pen.onResize) == null ? void 0 : _b2.call(pen, pen);
        }
      });
    }
    this.canvas.canvasTemplate.fit = true;
    this.canvas.canvasTemplate.init();
    this.canvas.canvasImage.init();
    this.canvas.canvasImageBottom.init();
    this.render(true);
  }
  trimPens() {
    let pens = this.store.data.pens.filter((pen) => pen.name === "line" && pen.anchors.length < 2);
    this.delete(pens);
  }
  /**
   * 
   * @param fit truefalse
   */
  fitTemplateView(fit = true, viewPadding = 10) {
    if (!this.hasView())
      return;
    const { canvas } = this.canvas;
    const { offsetWidth: width, offsetHeight: height } = canvas;
    const padding = formatPadding(viewPadding);
    const rect = this.getRect();
    const w = (width - padding[1] - padding[3]) / rect.width;
    const h = (height - padding[0] - padding[2]) / rect.height;
    let ratio = w;
    if (fit) {
      ratio = w > h ? h : w;
    } else {
      ratio = w > h ? w : h;
    }
    this.canvas.templateScale(ratio * this.store.data.scale);
    let _rect = this.getRect();
    let pens = this.store.data.pens.filter((pen) => !pen.parentId);
    this.canvas.templateTranslatePens(pens, -_rect.x, -_rect.y);
    this.store.data.pens.forEach((pen) => {
      if (!pen.type) {
        this.canvas.updateLines(pen);
      } else {
        this.canvas.initLineRect(pen);
      }
    });
    this.centerView();
  }
  fitSizeView(fit = true, viewPadding = 10) {
    var _a, _b;
    const { canvas } = this.canvas;
    const { offsetWidth: width, offsetHeight: height } = canvas;
    this.resize(width, height);
    const padding = formatPadding(viewPadding);
    const _width = (this.store.data.width || this.store.options.width) * this.store.data.scale;
    const _height = (this.store.data.height || this.store.options.height) * this.store.data.scale;
    const w = (width - padding[1] - padding[3]) / _width;
    const h = (height - padding[0] - padding[2]) / _height;
    let ratio = w;
    if (fit === "width") {
      ratio = w;
    } else if (fit === "height") {
      ratio = h;
    } else {
      if (fit) {
        ratio = w > h ? h : w;
      } else {
        ratio = w > h ? w : h;
      }
    }
    if ((_a = this.store.data.fits) == null ? void 0 : _a.length) {
      this.canvas.opening = true;
    }
    this.scale(ratio * this.store.data.scale);
    this.centerSizeView();
    if ((_b = this.store.data.fits) == null ? void 0 : _b.length) {
      this.fillView();
    }
  }
  centerSizeView() {
    const viewCenter = this.getViewCenter();
    const _width = this.store.data.width || this.store.options.width;
    const _height = this.store.data.height || this.store.options.height;
    const pensRect = {
      x: 0,
      y: 0,
      width: _width,
      height: _height
    };
    calcCenter(pensRect);
    const { center } = pensRect;
    const { scale, origin, x: dataX, y: dataY } = this.store.data;
    this.translate((viewCenter.x - origin.x) / scale - center.x - dataX / scale, (viewCenter.y - origin.y) / scale - center.y - dataY / scale);
    const { canvas } = this.canvas;
    const x = (canvas.scrollWidth - canvas.offsetWidth) / 2;
    const y = (canvas.scrollHeight - canvas.offsetHeight) / 2;
    canvas.scrollTo(x, y);
  }
  /**
   * 
   *
   */
  scrollView(viewPadding = 10, pageMode = false) {
    if (!this.hasView())
      return;
    if (!this.canvas.scroll) {
      return;
    }
    const { canvas } = this.canvas;
    const { offsetWidth: width, offsetHeight: height } = canvas;
    this.resize(width, height);
    const padding = formatPadding(viewPadding);
    const rect = this.getRect();
    const ratio = (width - padding[1] - padding[3]) / rect.width;
    this.scale(ratio * this.store.data.scale);
    this.topView(padding[0]);
    if (pageMode) {
      this.canvas.scroll.changeMode();
    }
  }
  screenView(viewPadding = 10, WorH = true) {
    if (!this.hasView())
      return;
    const { canvas } = this.canvas;
    const { offsetWidth: width, offsetHeight: height } = canvas;
    this.resize(width, height);
    const padding = formatPadding(viewPadding);
    const rect = this.getRect();
    let ratio = (width - padding[1] - padding[3]) / rect.width;
    if (!WorH) {
      ratio = (height - padding[0] - padding[2]) / rect.height;
    }
    this.scale(ratio * this.store.data.scale);
    this.topView(padding[0]);
  }
  topView(paddingTop = 10) {
    if (!this.hasView())
      return;
    const rect = this.getRect();
    const viewCenter = this.getViewCenter();
    const pensRect = this.getPenRect(rect);
    calcCenter(pensRect);
    const { center } = pensRect;
    const { scale, origin, x: dataX, y: dataY } = this.store.data;
    this.translate((viewCenter.x - origin.x) / scale - center.x - dataX / scale, (paddingTop - origin.y) / scale - pensRect.y - dataY / scale);
    const { canvas } = this.canvas;
    const x = (canvas.scrollWidth - canvas.offsetWidth) / 2;
    const y = (canvas.scrollHeight - canvas.offsetHeight) / 2;
    canvas.scrollTo(x, y);
  }
  centerView() {
    if (!this.hasView())
      return;
    const rect = this.getRect();
    const viewCenter = this.getViewCenter();
    const pensRect = this.getPenRect(rect);
    calcCenter(pensRect);
    const { center } = pensRect;
    const { scale, origin, x: dataX, y: dataY } = this.store.data;
    this.translate((viewCenter.x - origin.x) / scale - center.x - dataX / scale, (viewCenter.y - origin.y) / scale - center.y - dataY / scale);
    const { canvas } = this.canvas;
    const x = (canvas.scrollWidth - canvas.offsetWidth) / 2;
    const y = (canvas.scrollHeight - canvas.offsetHeight) / 2;
    canvas.scrollTo(x, y);
  }
  /**
   *  
   * RuleLine 
   */
  hasView() {
    return !!this.store.data.pens.filter((pen) => !pen.isRuleLine).length;
  }
  getViewCenter() {
    const { width, height } = this.canvas;
    return {
      x: width / 2,
      y: height / 2
    };
  }
  /**
   * 
   * @param pens 
   */
  beSameByFirst(pens = this.store.data.pens, attribute) {
    const initPens = deepClone(pens);
    const firstPen = pens[0];
    const { width, height } = this.getPenRect(firstPen);
    for (let i = 1; i < pens.length; i++) {
      const pen = pens[i];
      if (attribute === "width") {
        this.setValue({ id: pen.id, width }, { render: false, doEvent: false });
      } else if (attribute === "height") {
        this.setValue({ id: pen.id, height }, { render: false, doEvent: false });
      } else {
        this.setValue({ id: pen.id, width, height }, { render: false, doEvent: false });
      }
    }
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  /**
   * 
   * @param pens 
   */
  beSameByLast(pens = this.store.data.pens, attribute) {
    const initPens = deepClone(pens);
    const lastPen = pens[pens.length - 1];
    const { width, height } = this.getPenRect(lastPen);
    for (let i = 0; i < pens.length - 1; i++) {
      const pen = pens[i];
      if (attribute === "width") {
        this.setValue({ id: pen.id, width }, { render: false, doEvent: false });
      } else if (attribute === "height") {
        this.setValue({ id: pen.id, height }, { render: false, doEvent: false });
      } else {
        this.setValue({ id: pen.id, width, height }, { render: false, doEvent: false });
      }
    }
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  /**
   * 
   * @param pens 
   */
  formatPainterByFirst(pens = this.store.data.pens) {
    const initPens = deepClone(pens);
    const firstPen = pens[0];
    const attrs = {};
    formatAttrs.forEach((attr) => {
      attrs[attr] = firstPen[attr];
    });
    for (let i = 1; i < pens.length; i++) {
      const pen = pens[i];
      this.setValue({ id: pen.id, ...attrs }, { render: false, doEvent: false });
    }
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  /**
   * 
   * @param pens 
   */
  formatPainterByLast(pens = this.store.data.pens) {
    const initPens = deepClone(pens);
    const firstPen = pens[pens.length - 1];
    const attrs = {};
    formatAttrs.forEach((attr) => {
      attrs[attr] = firstPen[attr];
    });
    for (let i = 0; i < pens.length - 1; i++) {
      const pen = pens[i];
      this.setValue({ id: pen.id, ...attrs }, { render: false, doEvent: false });
    }
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  setFormatPainter() {
    const pens = this.store.active;
    const attrs = {};
    if (pens.length > 0) {
      const firstPen = pens[0];
      formatAttrs.forEach((attr) => {
        attrs[attr] = firstPen[attr] !== void 0 ? firstPen[attr] : this.store.options.defaultFormat[attr] || this.store.data[attr] || this.store.options[attr];
      });
    } else {
      const attrs2 = {};
      formatAttrs.forEach((attr) => {
        attrs2[attr] = this.store.options.defaultFormat[attr] || this.store.data[attr] || this.store.options[attr] || void 0;
      });
    }
    localStorage.setItem("meta2d-formatPainter", JSON.stringify(attrs));
  }
  formatPainter() {
    const pens = this.store.active;
    const initPens = deepClone(pens);
    const attrs = JSON.parse(localStorage.getItem("meta2d-formatPainter"));
    for (let i = 0; i < pens.length; i++) {
      const pen = pens[i];
      this.setValue({ id: pen.id, ...attrs }, { render: false, doEvent: false });
    }
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  clearFormatPainter() {
    const pens = this.store.active;
    const initPens = deepClone(pens);
    formatAttrs.forEach((attr) => {
      for (let i = 0; i < pens.length; i++) {
        const pen = pens[i];
        const { fontSize, lineHeight } = this.store.options;
        if (attr === "lineWidth") {
          pen.lineWidth = 1;
          pen.calculative.lineWidth = 1;
        } else if (attr === "fontSize") {
          pen.fontSize = fontSize;
          pen.calculative.fontSize = fontSize;
        } else if (attr === "lineHeight") {
          pen.lineHeight = lineHeight;
          pen.calculative.lineHeight = lineHeight;
        } else {
          delete pen[attr];
          delete pen.calculative[attr];
        }
      }
    });
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  alignNodes(align, pens = this.store.data.pens, rect) {
    !rect && (rect = this.getPenRect(this.getRect(pens)));
    const initPens = deepClone(pens);
    for (const item of pens) {
      this.alignPen(align, item, rect);
    }
    this.initImageCanvas(pens);
    this.initTemplateCanvas(pens);
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  //
  alignNodesV(align, pens = this.store.data.pens, whole = false) {
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    let rect = {
      x: 0,
      y: 0,
      width,
      height
    };
    const initPens = deepClone(pens);
    if (whole) {
      const scale = this.store.data.scale;
      const rect2 = this.getRect(pens);
      const x = (rect2.x - this.store.data.origin.x) / scale;
      const y = (rect2.y - this.store.data.origin.y) / scale;
      const w = rect2.width / scale;
      const h = rect2.height / scale;
      let moveX = 0;
      let moveY = 0;
      switch (align) {
        case "left":
          moveX = -x;
          break;
        case "right":
          moveX = width - (x + w);
          break;
        case "top":
          moveY = -y;
          break;
        case "bottom":
          moveY = height - (y + h);
          break;
        case "center":
          moveX = width / 2 - (x + w / 2);
          break;
        case "middle":
          moveY = height / 2 - (y + h / 2);
          break;
      }
      this.translatePens(pens, moveX * scale, moveY * scale);
    } else {
      for (const item of pens) {
        this.alignPen(align, item, rect);
      }
    }
    this.initImageCanvas(pens);
    this.initTemplateCanvas(pens);
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  /**
   * 
   * @param align 
   * @param pens
   */
  alignNodesByFirst(align, pens = this.store.data.pens) {
    const initPens = deepClone(pens);
    const firstPen = pens[0];
    const rect = this.getPenRect(firstPen);
    for (let i = 1; i < pens.length; i++) {
      const pen = pens[i];
      this.alignPen(align, pen, rect);
    }
    this.initImageCanvas(pens);
    this.initTemplateCanvas(pens);
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  /**
   * 
   * @param align 
   * @param pens
   */
  alignNodesByLast(align, pens = this.store.data.pens) {
    const initPens = deepClone(pens);
    const lastPen = pens[pens.length - 1];
    const rect = this.getPenRect(lastPen);
    for (let i = 0; i < pens.length - 1; i++) {
      const pen = pens[i];
      this.alignPen(align, pen, rect);
    }
    this.initImageCanvas(pens);
    this.initTemplateCanvas(pens);
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  /**
   *  rect  align 
   * @param align 
   * @param pen 
   * @param rect 
   * @returns
   */
  alignPen(align, pen, rect) {
    const penRect = this.getPenRect(pen);
    switch (align) {
      case "left":
        penRect.x = rect.x;
        break;
      case "right":
        penRect.x = rect.x + rect.width - penRect.width;
        break;
      case "top":
        penRect.y = rect.y;
        break;
      case "bottom":
        penRect.y = rect.y + rect.height - penRect.height;
        break;
      case "center":
        penRect.x = rect.x + rect.width / 2 - penRect.width / 2;
        break;
      case "middle":
        penRect.y = rect.y + rect.height / 2 - penRect.height / 2;
        break;
    }
    this.setValue({ id: pen.id, ...penRect }, { render: false, doEvent: false });
  }
  /**
   * 
   * @param direction width 
   * @param pens 
   * @param distance  or 
   */
  spaceBetweenByDirection(direction, pens = this.store.data.pens, distance2) {
    if (!distance2) {
      let start = Infinity, end = -Infinity, key = direction === "width" ? "x" : "y";
      pens.forEach((item) => {
        start = Math.min(start, item.calculative.worldRect[key]);
        end = Math.max(end, item.calculative.worldRect["e" + key]);
      });
      distance2 = (end - start) / this.store.data.scale;
    }
    pens = pens.filter((item) => !item.parentId);
    if (pens.length <= 2) {
      return;
    }
    const initPens = deepClone(pens);
    const allDistance = pens.reduce((distance3, currentPen) => {
      const currentPenRect = this.getPenRect(currentPen);
      return distance3 + currentPenRect[direction];
    }, 0);
    const space = (distance2 - allDistance) / (pens.length - 1);
    pens = pens.sort((a, b) => {
      if (direction === "width") {
        return a.x - b.x;
      }
      return a.y - b.y;
    });
    const pen0Rect = this.getPenRect(pens[0]);
    let left = direction === "width" ? pen0Rect.x : pen0Rect.y;
    for (const pen of pens) {
      const penRect = this.getPenRect(pen);
      direction === "width" ? penRect.x = left : penRect.y = left;
      left += penRect[direction] + space;
      this.setValue({ id: pen.id, ...penRect }, { render: false, doEvent: false });
    }
    this.initImageCanvas(pens);
    this.initTemplateCanvas(pens);
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  spaceBetween(pens, width) {
    this.spaceBetweenByDirection("width", pens, width);
  }
  spaceBetweenColumn(pens, height) {
    this.spaceBetweenByDirection("height", pens, height);
  }
  layout(pens = this.store.data.pens, width, space = 30) {
    const rect = this.getPenRect(getRect2(pens));
    !width && (width = rect.width);
    pens = pens.filter((item) => !item.type && !item.parentId);
    const initPens = deepClone(pens);
    let maxHeight = 0;
    pens.forEach((pen) => {
      const penRect = this.getPenRect(pen);
      penRect.height > maxHeight && (maxHeight = penRect.height);
    });
    let currentX = rect.x;
    let currentY = rect.y;
    pens.forEach((pen, index) => {
      const penRect = this.getPenRect(pen);
      penRect.x = currentX;
      penRect.y = currentY + maxHeight / 2 - penRect.height / 2;
      this.setValue({ id: pen.id, ...penRect }, { render: false, doEvent: false });
      if (index === pens.length - 1) {
        return;
      }
      const currentWidth = currentX + penRect.width - rect.x;
      const nextPenRect = this.getPenRect(pens[index + 1]);
      if (Math.round(width - currentWidth) >= Math.round(nextPenRect.width + space))
        currentX += penRect.width + space;
      else {
        currentX = rect.x;
        currentY += maxHeight + space;
      }
    });
    this.initImageCanvas(pens);
    this.initTemplateCanvas(pens);
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  gotoView(pen) {
    const center = this.getViewCenter();
    const x = center.x - pen.calculative.worldRect.x - pen.calculative.worldRect.width / 2;
    const y = center.y - pen.calculative.worldRect.y - pen.calculative.worldRect.height / 2;
    if (this.canvas.scroll && this.canvas.scroll.isShow) {
      this.canvas.scroll.translate(x - this.store.data.x, y - this.store.data.y);
    }
    this.store.data.x = x;
    this.store.data.y = y;
    for (const pen2 of this.store.data.pens) {
      calcInView(pen2);
    }
    this.canvas.canvasImage.init();
    this.canvas.canvasImageBottom.init();
    this.render();
  }
  showMap() {
    if (!this.map) {
      this.map = new ViewMap(this.canvas);
    }
    this.map.show();
  }
  hideMap() {
    this.map.hide();
  }
  onSizeUpdate() {
    if (this.mapTimer) {
      clearTimeout(this.mapTimer);
      this.mapTimer = void 0;
    }
    this.mapTimer = setTimeout(() => {
      if (this.map && this.map.isShow) {
        this.map.show();
      }
      if (this.canvas && this.canvas.scroll && this.canvas.scroll.isShow) {
        this.canvas.scroll.resize();
      }
    }, 500);
  }
  toggleAnchorMode() {
    this.canvas.toggleAnchorMode();
  }
  addAnchorHand() {
    this.canvas.addAnchorHand();
  }
  removeAnchorHand() {
    this.canvas.removeAnchorHand();
  }
  toggleAnchorHand() {
    this.canvas.toggleAnchorHand();
  }
  /**
   * 
   * @param pens pen 
   */
  top(pens) {
    if (!pens)
      pens = this.store.active;
    if (!Array.isArray(pens))
      pens = [pens];
    for (const pen of pens) {
      const _pens = this.store.data.pens;
      const allIds = [...getAllChildren(pen, this.store), pen].map((p) => p.id);
      const allPens = _pens.filter((p) => allIds.includes(p.id));
      allPens.forEach((pen2) => {
        const index = _pens.findIndex((p) => p.id === pen2.id);
        if (index > -1) {
          _pens.push(_pens[index]);
          _pens.splice(index, 1);
          this.initTemplateCanvas([pen2]);
          this.initImageCanvas([pen2]);
        }
        this.specificLayerMove(pen2, "top");
      });
    }
    this.store.emitter.emit("layer", { type: "top", pens });
  }
  /**
   *  or  or 
   * 
   * @param pens  pens
   */
  initImageCanvas(pens) {
    this.canvas && this.canvas.initImageCanvas(pens);
  }
  /**
   * 
   * @param pens  pens
   */
  initTemplateCanvas(pens) {
    this.canvas && this.canvas.initTemplateCanvas(pens);
  }
  /**
   * 
   * @param pens  pen 
   */
  bottom(pens) {
    if (!pens)
      pens = this.store.active;
    if (!Array.isArray(pens))
      pens = [pens];
    for (const pen of pens) {
      const _pens = this.store.data.pens;
      const allIds = [...getAllChildren(pen, this.store), pen].map((p) => p.id);
      const allPens = _pens.filter((p) => allIds.includes(p.id));
      for (let i = allPens.length - 1; i >= 0; i--) {
        const pen2 = allPens[i];
        const index = _pens.findIndex((p) => p.id === pen2.id);
        if (index > -1) {
          _pens.unshift(_pens[index]);
          _pens.splice(index + 1, 1);
          this.initTemplateCanvas([pen2]);
          this.initImageCanvas([pen2]);
        }
        this.specificLayerMove(pen2, "bottom");
      }
    }
    this.store.emitter.emit("layer", { type: "bottom", pens });
  }
  /**
   * data.pens 
   * 
   * @param pen 
   */
  upByArea(pen) {
    const index = this.store.data.pens.findIndex((p) => p.id === pen.id);
    if (index === -1) {
      console.warn("upByArea: pen not in canvas");
      return;
    }
    const allPens = [pen, ...getAllChildren(pen, this.store)];
    let allIndexs = allPens.map((p) => this.store.data.pens.findIndex((p2) => p2.id === p.id));
    if (allIndexs.includes(-1)) {
      console.warn("upByArea: pen children not in canvas");
      allIndexs = allIndexs.filter((i) => i !== -1);
    }
    const minIndex = Math.min(...allIndexs);
    const penRect = pen.calculative.worldRect;
    const nextHitIndex = this.store.data.pens.findIndex((p, i) => {
      if (i <= minIndex) {
        return false;
      }
      if (p.id === pen.id || isAncestor(p, pen)) {
        return false;
      }
      const currentRect = p.calculative.worldRect;
      return rectInRect(penRect, currentRect);
    });
    if (nextHitIndex === -1) {
      this.up(pen);
      return;
    }
    this.store.data.pens.splice(nextHitIndex + 1, 0, ...allPens);
    for (const pen2 of allPens) {
      const index2 = this.store.data.pens.findIndex((p) => p.id === pen2.id);
      if (index2 > -1) {
        this.store.data.pens.splice(index2, 1);
      }
    }
    this.initImageCanvas([pen]);
  }
  //
  specificLayerMove(pen, type) {
    var _a;
    if (pen.image && pen.name !== "gif") {
      let layer = CanvasLayer.CanvasImageBottom;
      if (type === "top") {
        layer = CanvasLayer.CanvasImage;
      } else if (type === "up" || type === "down") {
        layer = CanvasLayer.CanvasMain;
      }
      this.setValue({ id: pen.id, canvasLayer: layer }, { render: false, doEvent: false, history: false });
    } else if (pen.externElement || pen.name === "gif") {
      let zIndex = 0;
      if (type === "top") {
        pen.calculative.canvas.maxZindex += 1;
        zIndex = pen.calculative.canvas.maxZindex;
      } else if (type === "up") {
        zIndex = pen.calculative.zIndex === void 0 ? 6 : pen.calculative.zIndex + 1;
      } else if (type === "down") {
        zIndex = pen.calculative.zIndex === void 0 ? 3 : pen.calculative.zIndex - 1;
        if (zIndex < 0) {
          zIndex = 0;
        }
      }
      this.setValue({ id: pen.id, zIndex }, { render: false, doEvent: false, history: false });
      ((_a = pen.calculative.singleton) == null ? void 0 : _a.div) && setElemPosition(pen, pen.calculative.singleton.div);
    }
  }
  /**
   * 
   * @param pens 
   */
  up(pens) {
    if (!pens)
      pens = this.store.active;
    if (!Array.isArray(pens))
      pens = [pens];
    for (const pen of pens) {
      const _pens = this.store.data.pens;
      if (pen.children && pen.children.length) {
        const preMovePens = [...getAllChildren(pen, this.store), pen];
        const orderPens = [];
        for (let index = 0; index < _pens.length; index++) {
          const _pen = _pens[index];
          if (preMovePens.findIndex((p) => p.id === _pen.id) !== -1) {
            _pen.temIndex = index;
            orderPens.push(_pen);
          }
        }
        let lastIndex = -1;
        let offset = 0;
        orderPens.forEach((_pen) => {
          _pen.temIndex -= offset;
          _pens.splice(_pen.temIndex, 1);
          offset += 1;
          lastIndex = _pen.temIndex;
          delete _pen.temIndex;
          this.specificLayerMove(_pen, "up");
        });
        _pens.splice(lastIndex + 1, 0, ...orderPens);
        this.initTemplateCanvas(orderPens);
        this.initImageCanvas(orderPens);
      } else {
        const index = _pens.findIndex((p) => p.id === pen.id);
        if (index > -1 && index !== _pens.length - 1) {
          _pens.splice(index + 2, 0, _pens[index]);
          _pens.splice(index, 1);
          this.initTemplateCanvas([pen]);
          this.initImageCanvas([pen]);
        }
        this.specificLayerMove(pen, "up");
      }
    }
    this.store.emitter.emit("layer", { type: "up", pens });
  }
  /**
   * 
   * @param pen 
   */
  down(pens) {
    if (!pens)
      pens = this.store.active;
    if (!Array.isArray(pens))
      pens = [pens];
    for (const pen of pens) {
      const _pens = this.store.data.pens;
      if (pen.children && pen.children.length) {
        const preMovePens = [...getAllChildren(pen, this.store), pen];
        const orderPens = [];
        for (let index = 0; index < _pens.length; index++) {
          const _pen = _pens[index];
          if (preMovePens.findIndex((p) => p.id === _pen.id) !== -1) {
            _pen.temIndex = index;
            orderPens.push(_pen);
          }
        }
        let firstIndex = -1;
        let offset = 0;
        orderPens.forEach((_pen, index) => {
          _pen.temIndex -= offset;
          _pens.splice(_pen.temIndex, 1);
          offset += 1;
          if (index === 0) {
            firstIndex = _pen.temIndex;
          }
          delete _pen.temIndex;
          this.specificLayerMove(_pen, "down");
        });
        _pens.splice(firstIndex - 1, 0, ...orderPens);
        this.initTemplateCanvas(orderPens);
        this.initImageCanvas(orderPens);
      } else {
        const index = _pens.findIndex((p) => p.id === pen.id);
        if (index > -1 && index !== 0) {
          _pens.splice(index - 1, 0, _pens[index]);
          _pens.splice(index + 1, 1);
          this.initTemplateCanvas([pen]);
          this.initImageCanvas([pen]);
        }
        this.specificLayerMove(pen, "down");
      }
    }
    this.store.emitter.emit("layer", { type: "down", pens });
  }
  setLayer(pen, toIndex, pens = this.store.data.pens) {
    const index = pens.findIndex((p) => p.id === pen.id);
    if (index > -1) {
      if (index > toIndex) {
        pens.splice(toIndex, 0, pens[index]);
        pens.splice(index + 1, 1);
      } else if (index < toIndex) {
        pens.splice(toIndex, 0, pens[index]);
        pens.splice(index, 1);
      }
    }
  }
  changePenId(oldId, newId) {
    this.canvas.changePenId(oldId, newId);
  }
  /**
   * 
   * @param node 
   * @param type //
   */
  getLines(node, type = "all") {
    var _a;
    if (node.type === PenType.Line) {
      return [];
    }
    const lines = [];
    (_a = node.connectedLines) == null ? void 0 : _a.forEach(({ lineId }) => {
      const line2 = this.store.pens[lineId];
      if (!line2) {
        console.warn(node, "node contain a error connectedLine");
        return;
      }
      if (lines.find((_line) => _line.id === line2.id)) {
        return;
      }
      switch (type) {
        case "all":
          lines.push(line2);
          break;
        case "in":
          getToAnchor(line2).connectTo === node.id && lines.push(line2);
          break;
        case "out":
          getFromAnchor(line2).connectTo === node.id && lines.push(line2);
          break;
      }
    });
    return lines;
  }
  /**
   * 
   * 
   * @param pen 
   */
  nextNode(pen) {
    if (pen.type === PenType.Line) {
      const nextNode = this.store.pens[getToAnchor(pen).connectTo];
      return nextNode ? [nextNode] : [];
    } else {
      const lines = this.getLines(pen, "out");
      const nextNodes = [];
      lines.forEach((line2) => {
        const lineNextNode = this.nextNode(line2);
        for (const node of lineNextNode) {
          const have = nextNodes.find((next) => next.id === node.id);
          !have && nextNodes.push(node);
        }
      });
      return nextNodes;
    }
  }
  /**
   * 
   * 
   * @param pen 
   */
  previousNode(pen) {
    if (pen.type === PenType.Line) {
      const preNode = this.store.pens[getFromAnchor(pen).connectTo];
      return preNode ? [preNode] : [];
    } else {
      const lines = this.getLines(pen, "in");
      const preNodes = [];
      lines.forEach((line2) => {
        const linePreNode = this.previousNode(line2);
        for (const node of linePreNode) {
          const have = preNodes.find((pre) => pre.id === node.id);
          !have && preNodes.push(node);
        }
      });
      return preNodes;
    }
  }
  /**
   * 
   * @param pen
   *
   */
  getNext(pen) {
    var _a;
    if (pen.type === PenType.Line) {
      console.warn("");
      return;
    }
    const next = [];
    (_a = pen.connectedLines) == null ? void 0 : _a.forEach(({ lineId, anchor }) => {
      var _a2, _b;
      const fromAnchor = (_a2 = pen.anchors) == null ? void 0 : _a2.filter((_anchor) => _anchor.id === anchor)[0];
      const line2 = this.findOne(lineId);
      if (line2.anchors[0].connectTo == pen.id) {
        const connectTo = line2.anchors[line2.anchors.length - 1].connectTo;
        if (connectTo) {
          const _next = this.findOne(connectTo);
          const connectedLine = (_b = _next.connectedLines) == null ? void 0 : _b.filter((item) => item.lineId === line2.id)[0];
          const penAnchor = _next.anchors.filter((_anchor) => _anchor.id === connectedLine.anchor)[0];
          next.push({
            from: pen,
            fromAnchor,
            line: line2,
            to: _next,
            toAnchor: penAnchor
          });
        }
      }
    });
    return next;
  }
  /**
   * 
   * @param pen 
   * @param anchor 
   * @param index  
   */
  addAnchor(pen, anchor, index) {
    if (!pen) {
      return;
    }
    if (!pen.anchors) {
      pen.anchors = [];
    }
    if (!pen.calculative.worldAnchors) {
      pen.calculative.worldAnchors = [];
    }
    if (pen.type === PenType.Line) {
      if (index < 0) {
        index = pen.anchors.length + 1 + index;
      }
      if (index > pen.anchors.length) {
        index = pen.anchors.length;
      }
      if (index < 0) {
        index = 0;
      }
      if (index == 0 && pen.anchors[0].connectTo || index == pen.anchors.length && pen.anchors[index - 1].connectTo) {
        console.warn("");
        return;
      }
    }
    let _anchor = null;
    let _worldAnchor = null;
    if (anchor.x <= 1 && anchor.x >= 0 && anchor.y <= 1 && anchor.y >= 0) {
      _worldAnchor = {
        id: anchor.id || s8(),
        penId: pen.id,
        x: pen.calculative.worldRect.x + pen.calculative.worldRect.width * anchor.x,
        y: pen.calculative.worldRect.y + pen.calculative.worldRect.height * anchor.y
      };
      if (pen.calculative.worldRect) {
        if (pen.rotate % 360) {
          rotatePoint(_worldAnchor, pen.rotate, pen.calculative.worldRect.center);
        }
      }
      _anchor = {
        id: _worldAnchor.id,
        penId: pen.id,
        x: anchor.x,
        y: anchor.y
      };
    } else {
      _worldAnchor = {
        id: anchor.id || s8(),
        penId: pen.id,
        x: anchor.x,
        y: anchor.y
      };
      if (pen.calculative.worldRect) {
        if (pen.rotate % 360) {
          rotatePoint(anchor, -pen.rotate, pen.calculative.worldRect.center);
        }
        _anchor = {
          id: _worldAnchor.id,
          penId: pen.id,
          x: (anchor.x - pen.calculative.worldRect.x) / pen.calculative.worldRect.width,
          y: (anchor.y - pen.calculative.worldRect.y) / pen.calculative.worldRect.height
        };
      }
    }
    if (pen.type === PenType.Line) {
      pen.calculative.worldAnchors.splice(index, 0, _worldAnchor);
      pen.anchors.splice(index, 0, _anchor);
      this.canvas.updateLines(pen);
      this.canvas.initLineRect(pen);
      this.render();
    } else {
      pen.calculative.worldAnchors.push(_worldAnchor);
      pen.anchors.push(_anchor);
    }
  }
  /**
   *
   * @param from 
   * @param fromAnchor 
   * @param to 
   * @param toAnchor 
   */
  connectLine(from, to, fromAnchor, toAnchor, render = true) {
    if (!fromAnchor) {
      const _worldRect = to.calculative.worldRect;
      fromAnchor = nearestAnchor(from, {
        x: _worldRect.x + _worldRect.width / 2,
        y: _worldRect.y + _worldRect.height / 2
      });
    }
    if (!toAnchor) {
      const _worldRect = from.calculative.worldRect;
      toAnchor = nearestAnchor(to, {
        x: _worldRect.x + _worldRect.width / 2,
        y: _worldRect.y + _worldRect.height / 2
      });
    }
    const absWidth = Math.abs(fromAnchor.x - toAnchor.x);
    const absHeight = Math.abs(fromAnchor.y - toAnchor.y);
    const line2 = {
      height: absHeight,
      lineName: "line",
      lineWidth: 1,
      name: "line",
      type: 1,
      width: absWidth,
      x: Math.min(fromAnchor.x, toAnchor.x),
      y: Math.min(fromAnchor.y, toAnchor.y),
      anchors: [
        {
          x: fromAnchor.x > toAnchor.x ? 1 : 0,
          y: fromAnchor.y > toAnchor.y ? 1 : 0,
          id: s8()
        },
        {
          x: fromAnchor.x > toAnchor.x ? 0 : 1,
          y: fromAnchor.x > toAnchor.x ? 0 : 1,
          id: s8()
        }
      ]
    };
    this.addPens([line2]);
    connectLine(from, fromAnchor, line2, line2.calculative.worldAnchors[0]);
    connectLine(to, toAnchor, line2, line2.calculative.worldAnchors[1]);
    line2.calculative.active = false;
    this.canvas.updateLines(line2);
    this.canvas.updateLines(from);
    this.canvas.updateLines(to);
    this.canvas.initLineRect(line2);
    if (render) {
      this.render();
    }
    return line2;
  }
  /**
   *   
   * @param pens 
   * @param showChild  combine showChild
   * @param anchor 
   * @returns 
   */
  toComponent(pens = this.store.data.pens, showChild, anchor) {
    if (pens.length === 1) {
      const pen = deepClone(pens[0]);
      pen.type = PenType.Node;
      pen.id = void 0;
      return [pen];
    }
    const components = deepClone(pens, true);
    const rect = getRect2(components);
    let parent = {
      id: s8(),
      name: "combine",
      ...rect,
      children: [],
      showChild
    };
    if (anchor) {
      parent.anchors = [
        {
          id: "0",
          penId: parent.id,
          x: 0.5,
          y: 0
        },
        {
          id: "1",
          penId: parent.id,
          x: 1,
          y: 0.5
        },
        {
          id: "2",
          penId: parent.id,
          x: 0.5,
          y: 1
        },
        {
          id: "3",
          penId: parent.id,
          x: 0,
          y: 0.5
        }
      ];
    }
    const parents = components.filter((pen) => !pen.parentId);
    const p = components.find((pen) => {
      return pen.width === rect.width && pen.height === rect.height;
    });
    const oneIsParent = p && showChild === void 0;
    if (parents.length === 1) {
      parent = parents[0];
    } else if (oneIsParent) {
      if (!p.children) {
        p.children = [];
      }
      parent = p;
    } else {
    }
    components.forEach((pen) => {
      if (pen === parent || pen.parentId === parent.id) {
        return;
      }
      if (pen.parentId) {
        return;
      }
      parent.children.push(pen.id);
      pen.parentId = parent.id;
      const childRect = calcRelativeRect(pen.calculative.worldRect, rect);
      Object.assign(pen, childRect);
      pen.locked = pen.lockedOnCombine ?? LockState.DisableMove;
    });
    return oneIsParent || parents.length === 1 ? deepClone(components) : deepClone([parent, ...components]);
  }
  // TODO pen install
  /**
   * @description 
   * @param plugins 
   * @param pen {string | Pen} tagnamePen*/
  installPenPlugins(pen, plugins) {
    if (!pen.tag && !pen.name && !pen.id)
      return;
    let type;
    pen.id ? type = "id" : pen.tag ? type = "tag" : pen.name ? type = "name" : "";
    plugins.forEach((pluginConfig) => {
      let plugin = pluginConfig.plugin;
      let option = pluginConfig.options;
      if (!plugin)
        return;
      if (validationPlugin(plugin) && type) {
        plugin.install(pen, option);
        if (!this.penPluginMap.has(plugin)) {
          this.penPluginMap.set(plugin, [{ [type]: pen[type], option }]);
        } else {
          let op = this.penPluginMap.get(plugin).find((i) => {
            return i[type] === pen[type];
          });
          if (op) {
            op.option = option;
          } else {
            this.penPluginMap.get(plugin).push({
              [type]: pen[type],
              option
            });
          }
        }
      }
    });
  }
  uninstallPenPlugins(pen, plugins) {
    let type;
    pen.id ? type = "id" : pen.tag ? type = "tag" : pen.name ? type = "name" : "";
    if (!type)
      return;
    plugins.forEach((pluginConfig) => {
      let plugin = pluginConfig.plugin;
      plugin.uninstall(pen, pluginConfig.options);
      let mapList = this.penPluginMap.get(plugin);
      let op = mapList.findIndex((i) => i[type] === pen[type]);
      if (op !== -1) {
        mapList.splice(op, 1);
        if (mapList.length === 0) {
          this.penPluginMap.delete(plugin);
        }
      }
    });
  }
  setVisible(pen, visible, render = true) {
    this.onSizeUpdate();
    this.setValue({ id: pen.id, visible }, { render: false, doEvent: false });
    if (pen.children) {
      for (const childId of pen.children) {
        const child = this.store.pens[childId];
        child && this.setVisible(child, visible, false);
      }
    }
    let allPens = getAllChildren(pen, this.store);
    allPens.push(pen);
    this.initImageCanvas(allPens);
    render && this.render();
  }
  clearHover() {
    this.canvas.clearHover();
  }
  closeSocket() {
    this.closeWebsocket();
    this.closeMqtt();
    this.closeHttp();
  }
  destroy(onlyData) {
    this.clear(false);
    this.stopDataMock();
    this.closeSocket();
    this.closeNetwork();
    this.closeAll();
    le5leTheme.destroyThemeSheet(this.store.id);
    this.store.emitter.all.clear();
    this.canvas.destroy();
    this.canvas = void 0;
    globalStore[this.store.id] = void 0;
    if (!onlyData) {
      for (const k in globalStore) {
        delete globalStore[k];
      }
      globalStore.path2dDraws = {};
      globalStore.canvasDraws = {};
      globalStore.anchors = {};
      globalStore.htmlElements = {};
    }
  }
};

// node_modules/@meta2d/core/src/dialog/dialog.js
var Dialog = class {
  constructor(parentElement, store) {
    __publicField(this, "parentElement");
    __publicField(this, "box");
    __publicField(this, "iframe");
    __publicField(this, "dialog");
    __publicField(this, "close");
    __publicField(this, "title");
    __publicField(this, "body");
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "url");
    __publicField(this, "meta2dDiv");
    __publicField(this, "dialogMeta2d");
    __publicField(this, "store");
    this.parentElement = parentElement;
    this.store = store;
    this.box = document.createElement("div");
    this.dialog = document.createElement("div");
    let header = document.createElement("div");
    this.title = document.createElement("div");
    this.close = document.createElement("span");
    this.close.innerHTML = `
      <svg fill="none" viewBox="0 0 16 16" width="1em" height="1em">
      <path
        fill="currentColor"
        d="M8 8.92L11.08 12l.92-.92L8.92 8 12 4.92 11.08 4 8 7.08 4.92 4 4 4.92 7.08 8 4 11.08l.92.92L8 8.92z"
        fill-opacity="0.9"
      ></path>
    </svg>`;
    this.body = document.createElement("div");
    this.iframe = document.createElement("iframe");
    this.iframe.setAttribute("frameborder", "0");
    this.meta2dDiv = document.createElement("div");
    this.box.className = "meta2d-dialog_mask";
    this.dialog.className = "meta2d-dialog";
    this.body.className = "meta2d-dialog_body";
    header.className = "meta2d-dialog_header";
    this.title.className = "meta2d-dialog-content";
    this.close.className = "meta2d-dialog-close";
    this.meta2dDiv.className = "meta2d-dialog-meta2d";
    header.appendChild(this.title);
    header.appendChild(this.close);
    this.body.appendChild(this.iframe);
    this.body.appendChild(this.meta2dDiv);
    this.dialog.appendChild(header);
    this.dialog.appendChild(this.body);
    this.box.appendChild(this.dialog);
    parentElement.appendChild(this.box);
    this.dialog.onclick = (e) => {
      e.stopPropagation();
    };
    this.box.onclick = () => {
      this.hide();
    };
    this.close.onclick = () => {
      this.hide();
    };
    let sheet;
    for (let i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].title === "le5le.com/dialog") {
        sheet = document.styleSheets[i];
      }
    }
    if (!sheet) {
      let style = document.createElement("style");
      style.type = "text/css";
      style.title = "le5le.com/dialog";
      document.head.appendChild(style);
      style = document.createElement("style");
      style.type = "text/css";
      document.head.appendChild(style);
      sheet = style.sheet;
      sheet.insertRule(`.meta2d-dialog_mask {
        display: none;
        position: absolute;
        top: 0%;
        left: 0%;
        width: 100%;
        height: 100%;
        background-color: #0000006f;
        z-index: 9999;`);
      sheet.insertRule(`.meta2d-dialog_mask .meta2d-dialog {
            position: absolute;
            top: 15vh;
            left: 10%;
            width: 80%;
            height:420px;
            padding: 16px 20px;
            border-radius: 9px;
            background-color: #1e2430;
            z-index: 19999;
            overflow: auto;
        }`);
      sheet.insertRule(`.meta2d-dialog_header {
            display: flex;
            position: relative;
            z-index: 999;
        }`);
      sheet.insertRule(`.meta2d-dialog-content {
            width: calc(100% - 20px);
            font-weight: 600;
            font-size: 14px;
            color: #bdc7db;
            padding-bottom:8px;
        }`);
      sheet.insertRule(`.meta2d-dialog-close {
            width: 20px;
            height: 20px;
            line-height: 20px;
            text-align: center;
            color: #617b91;
            position: absolute;
            right:20px;
            top:18px;
        }`);
      sheet.insertRule(`.meta2d-dialog-close :hover{
            cursor: pointer;
        }`);
      sheet.insertRule(`.meta2d-dialog_body{
          width: 100%;
          height: 100%;
        } `);
      sheet.insertRule(`.meta2d-dialog_body iframe{
            width: 100%;
            height: 100%;
        }`);
      sheet.insertRule(`.meta2d-dialog_body .meta2d-dialog-meta2d{
          width: 100%;
          height: 100%;
          display: none;
      }`);
    }
  }
  async show(title, url, rect, data) {
    if (!url) {
      return;
    }
    const isIframe = this.isUrl(url);
    if (isIframe) {
      this.meta2dDiv.style.display = "none";
      this.iframe.style.display = "block";
    } else {
      this.iframe.style.display = "none";
      this.meta2dDiv.style.display = "block";
    }
    if (isIframe && url !== this.url) {
      this.iframe.setAttribute("src", url);
      this.url = url;
    }
    title && (this.title.innerText = title);
    if (!title) {
      this.dialog.style.padding = "0px";
      this.title.style.display = "none";
      this.body.style.height = "100%";
      this.body.style.overflow = "hidden";
    } else {
      this.dialog.style.padding = "16px 20px";
      this.title.style.display = "block";
      this.body.style.height = "calc(100% - 26px)";
    }
    if (rect) {
      this.dialog.style.width = rect.width ? rect.width + "px" : "80%";
      this.dialog.style.height = rect.height ? rect.height + "px" : "420px";
      this.dialog.style.top = rect.y ? rect.y + "px" : rect.height ? `calc( 50% - ${rect.height / 2}px )` : "15vh";
      this.dialog.style.left = rect.x ? rect.x + "px" : `calc( 50% - ${rect.width ? rect.width / 2 + "px" : "40%"} )`;
    }
    if (isIframe && data) {
      let timeout = 0;
      const interval = setInterval(() => {
        if (this.iframe.contentWindow.meta2d) {
          clearInterval(interval);
          setTimeout(() => {
            this.iframe.contentWindow.postMessage(JSON.stringify({
              name: "dialog",
              data
            }), "*");
          }, 100);
        }
        timeout++;
        if (timeout > 50) {
          clearInterval(interval);
        }
      }, 300);
    }
    if (!this.dialogMeta2d || isIframe) {
      this.box.style.display = "block";
    }
    if (!isIframe) {
      this.meta2dDiv.style.display = "block";
      if (!this.dialogMeta2d) {
        globalThis.mainMeta2d = globalThis.meta2d;
        this.dialogMeta2d = new Meta2d(this.meta2dDiv);
        globalThis.meta2d = globalThis.mainMeta2d;
      }
      const meta2dData = await getMeta2dData(this.store, url);
      if (meta2dData) {
        this.box.style.display = "block";
        this.dialogMeta2d.clear(true);
        this.dialogMeta2d.open(meta2dData, false);
        this.dialogMeta2d.lock(1);
        this.dialogMeta2d.resize();
        this.dialogMeta2d.fitView(true, 0);
        this.dialogMeta2d.render(true);
      }
    }
  }
  hide() {
    this.box.style.display = "none";
  }
  isUrl(url) {
    if (url.startsWith("http") || url.includes("?") || url.includes("/")) {
      return true;
    } else {
      return false;
    }
  }
  destroy() {
    var _a;
    this.dialog.onclick = void 0;
    this.box.onclick = void 0;
    this.close.onclick = void 0;
    (_a = this.dialogMeta2d) == null ? void 0 : _a.destroy(true);
  }
};

// node_modules/@meta2d/core/src/title/title.js
var Title = class _Title {
  //  tooltip 
  constructor(parentElement) {
    __publicField(this, "parentElement");
    __publicField(this, "box");
    __publicField(this, "currentAnchor");
    this.parentElement = parentElement;
    this.box = document.createElement("div");
    this.box.className = "meta2d-title";
    parentElement.appendChild(this.box);
    let sheet;
    for (let i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].title === "le5le.com/title") {
        sheet = document.styleSheets[i];
      }
    }
    if (!sheet) {
      let style = document.createElement("style");
      style.type = "text/css";
      style.title = "le5le.com/title";
      document.head.appendChild(style);
      style = document.createElement("style");
      style.type = "text/css";
      document.head.appendChild(style);
      sheet = style.sheet;
      sheet.insertRule(".meta2d-title{position:absolute;padding:0;z-index:10;left: -9999px;top: -9999px;background:#fff;color:#000; cursor: crosshair;border: 1px solid black;}");
    }
  }
  /**
   * @returns  title
   */
  static getTitle(anchor) {
  }
  /**
   * @returns  rect
   */
  setText(anchor) {
    this.box.innerText = anchor.title;
  }
  /**
   * 
   */
  updateText(anchor) {
    var _a;
    if (((_a = this.currentAnchor) == null ? void 0 : _a.id) !== anchor.id) {
      return;
    }
    if (_Title.titleEmpty(anchor)) {
      return;
    }
    this.setText(anchor);
    this.changePositionByAnchor(anchor);
  }
  /**
   *   box 
   * @param oldRect 
   * @param newRect 
   */
  changePositionByAnchor(anchor) {
    this.box.style.left = anchor.x + 10 + "px";
    this.box.style.top = anchor.y + 10 + "px";
  }
  static titleEmpty(anchor) {
    return !anchor.title;
  }
  show(anchor, pen) {
    if (_Title.titleEmpty(anchor)) {
      return;
    }
    this.currentAnchor = anchor;
    this.setText(anchor);
    let pos = {
      x: pen.calculative.canvas.store.data.x + anchor.x,
      y: pen.calculative.canvas.store.data.y + anchor.y
    };
    this.changePositionByAnchor(pos);
  }
  hide() {
    this.box.style.left = "-9999px";
    this.box.innerText = "";
    this.currentAnchor = null;
  }
  destroy() {
    this.box.onmouseleave = null;
  }
};

// node_modules/@meta2d/core/src/canvas/canvasTemplate.js
var CanvasTemplate = class {
  // 
  constructor(parentElement, store) {
    __publicField(this, "parentElement");
    __publicField(this, "store");
    __publicField(this, "canvas", document.createElement("canvas"));
    __publicField(this, "offscreen", createOffscreen());
    __publicField(this, "bgOffscreen", createOffscreen());
    __publicField(this, "patchFlags");
    __publicField(this, "bgPatchFlags");
    __publicField(this, "fit");
    this.parentElement = parentElement;
    this.store = store;
    parentElement.appendChild(this.canvas);
    this.canvas.style.backgroundRepeat = "no-repeat";
    this.canvas.style.backgroundSize = "100% 100%";
    this.canvas.style.position = "absolute";
    this.canvas.style.top = "0";
    this.canvas.style.left = "0";
  }
  resize(w, h) {
    this.canvas.style.width = w + "px";
    this.canvas.style.height = h + "px";
    w = w * this.store.dpiRatio | 0;
    h = h * this.store.dpiRatio | 0;
    this.canvas.width = w;
    this.canvas.height = h;
    this.bgOffscreen.width = w;
    this.bgOffscreen.height = h;
    this.offscreen.width = w;
    this.offscreen.height = h;
    this.bgOffscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio);
    this.bgOffscreen.getContext("2d").textBaseline = "middle";
    this.offscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio);
    this.offscreen.getContext("2d").textBaseline = "middle";
    this.init();
  }
  init() {
    this.bgOffscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.patchFlags = true;
    this.bgPatchFlags = true;
  }
  hidden() {
    this.canvas.style.display = "none";
  }
  show() {
    this.canvas.style.display = "block";
  }
  clear() {
    this.bgOffscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.canvas.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.bgPatchFlags = true;
    this.patchFlags = true;
  }
  render() {
    if (this.bgPatchFlags) {
      const ctx = this.bgOffscreen.getContext("2d");
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      const width = this.store.data.width || this.store.options.width;
      const height = this.store.data.height || this.store.options.height;
      const x = this.store.data.x || this.store.options.x || 0;
      const y = this.store.data.y || this.store.options.y || 0;
      const background = this.store.data.background || this.store.styles.background;
      if (background) {
        ctx.save();
        ctx.fillStyle = background;
        ctx.globalAlpha = this.store.data.globalAlpha ?? this.store.options.globalAlpha;
        if (width && height && !this.fit) {
          ctx.shadowOffsetX = this.store.options.shadowOffsetX;
          ctx.shadowOffsetY = this.store.options.shadowOffsetY;
          ctx.shadowBlur = this.store.options.shadowBlur;
          ctx.shadowColor = this.store.options.shadowColor;
          ctx.fillRect(this.store.data.origin.x + x, this.store.data.origin.y + y, width * this.store.data.scale, height * this.store.data.scale);
        } else {
          ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
        ctx.restore();
      }
      if (width && height && this.store.bkImg) {
        ctx.save();
        if (this.fit) {
          ctx.drawImage(this.store.bkImg, 0, 0, this.canvas.offsetWidth, this.canvas.offsetHeight);
        } else {
          ctx.drawImage(this.store.bkImg, this.store.data.origin.x + x, this.store.data.origin.y + y, width * this.store.data.scale, height * this.store.data.scale);
        }
        ctx.restore();
      }
      this.renderGrid(ctx);
    }
    if (this.patchFlags) {
      const ctx = this.offscreen.getContext("2d");
      ctx.save();
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctx.translate(this.store.data.x, this.store.data.y);
      for (const pen of this.store.data.pens) {
        if (!isFinite(pen.x)) {
          continue;
        }
        if (
          // pen.template 
          pen.canvasLayer === CanvasLayer.CanvasTemplate && pen.calculative.inView
        ) {
          if (pen.name === "combine" && !pen.draw) {
            continue;
          }
          renderPen(ctx, pen);
          if (pen.image && pen.name !== "gif" && pen.calculative.img) {
            ctx.save();
            ctxFlip(ctx, pen);
            if (pen.calculative.rotate) {
              ctxRotate(ctx, pen);
            }
            setGlobalAlpha(ctx, pen);
            drawImage(ctx, pen);
            ctx.restore();
          }
        }
      }
      ctx.restore();
    }
    if (this.patchFlags || this.bgPatchFlags) {
      const ctxCanvas = this.canvas.getContext("2d");
      ctxCanvas.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctxCanvas.drawImage(this.bgOffscreen, 0, 0, this.canvas.width, this.canvas.height);
      ctxCanvas.drawImage(this.offscreen, 0, 0, this.canvas.width, this.canvas.height);
      this.patchFlags = false;
      this.bgPatchFlags = false;
    }
  }
  renderGrid(ctx) {
    const { data, options } = this.store;
    const { grid, gridRotate, gridColor, gridSize, scale, origin } = data;
    if (!(grid ?? options.grid)) {
      return;
    }
    ctx.save();
    const width = (data.width || options.width) * scale;
    const height = (data.height || options.height) * scale;
    const startX = (data.x || options.x || 0) + origin.x;
    const startY = (data.y || options.y || 0) + origin.y;
    if (gridRotate) {
      ctx.translate(width / 2, height / 2);
      ctx.rotate(gridRotate * Math.PI / 180);
      ctx.translate(-width / 2, -height / 2);
    }
    ctx.lineWidth = 1;
    ctx.strokeStyle = gridColor || options.gridColor;
    ctx.beginPath();
    let size = (gridSize || options.gridSize) * scale;
    size = size < 0 ? 0 : size;
    if (!width || !height) {
      const ratio = this.store.dpiRatio;
      const cW = this.canvas.width / ratio;
      const cH = this.canvas.height / ratio;
      const m = startX / size;
      const n = startY / size;
      const offset = size * 10;
      const newX = startX - Math.ceil(m) * size;
      const newY = startY - Math.ceil(n) * size;
      const endX = cW + newX + offset;
      const endY = cH + newY + offset;
      for (let i = newX; i <= endX; i += size) {
        ctx.moveTo(i, newY);
        ctx.lineTo(i, cH + newY + offset);
      }
      for (let i = newY; i <= endY; i += size) {
        ctx.moveTo(newX, i);
        ctx.lineTo(cW + newX + offset, i);
      }
    } else {
      const endX = width + startX;
      const endY = height + startY;
      for (let i = startX; i <= endX; i += size) {
        ctx.moveTo(i, startY);
        ctx.lineTo(i, height + startY);
      }
      for (let i = startY; i <= endY; i += size) {
        ctx.moveTo(startX, i);
        ctx.lineTo(width + startX, i);
      }
    }
    ctx.stroke();
    ctx.restore();
  }
};

// node_modules/@meta2d/core/src/popconfirm/popconfirm.js
var status2 = {
  "success": {},
  "info": {
    icon: '<svg fill="none" viewBox="0 0 24 24"><path fill="#0052d9" d="M12 23a11 11 0 100-22 11 11 0 000 22zM11 8.5v-2h2v2h-2zm2 1.5v7.5h-2V10h2z"></path></svg>'
  },
  "warning": {},
  "error": {}
};
var Popconfirm = class {
  constructor(parentElement, store) {
    __publicField(this, "parentElement");
    __publicField(this, "store");
    __publicField(this, "box");
    __publicField(this, "text");
    __publicField(this, "arrowUp");
    __publicField(this, "arrowDown");
    __publicField(this, "icon");
    __publicField(this, "confirm");
    __publicField(this, "cancel");
    __publicField(this, "x");
    __publicField(this, "y");
    this.parentElement = parentElement;
    this.store = store;
    this.box = document.createElement("div");
    this.text = document.createElement("div");
    this.arrowUp = document.createElement("div");
    this.arrowDown = document.createElement("div");
    this.icon = document.createElement("div");
    this.confirm = document.createElement("button");
    this.cancel = document.createElement("button");
    this.box.className = "meta2d-popconfirm";
    this.text.className = "text";
    this.arrowUp.className = "arrow";
    this.arrowDown.className = "arrow down";
    this.icon.className = "icon";
    this.confirm.className = "confirm";
    this.cancel.className = "cancel";
    this.confirm.innerHTML = "";
    this.cancel.innerHTML = "";
    this.icon.innerHTML = status2.info.icon;
    this.box.appendChild(this.text);
    this.box.appendChild(this.arrowUp);
    this.box.appendChild(this.arrowDown);
    this.box.appendChild(this.confirm);
    this.box.appendChild(this.cancel);
    this.box.appendChild(this.icon);
    parentElement.appendChild(this.box);
    let sheet;
    for (let i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].title === "le5le.com/popconfirm") {
        sheet = document.styleSheets[i];
      }
    }
    if (!sheet) {
      let style = document.createElement("style");
      style.type = "text/css";
      style.title = "le5le.com/popconfirm";
      document.head.appendChild(style);
      style = document.createElement("style");
      style.type = "text/css";
      document.head.appendChild(style);
      sheet = style.sheet;
      sheet.insertRule(".meta2d-popconfirm{position:absolute;z-index:999;left: -9999px;top: -9999px;padding:16px;max-width:400px;background:#fff;border-radius:6px;box-shadow:0 3px 14px 2px rgba(0, 0, 0, .05),0 8px 10px 1px rgba(0, 0, 0, 6%),0 5px 5px -3px rgba(0, 0, 0, 10%);}");
      sheet.insertRule(".meta2d-popconfirm .text{outline:none;padding:0px 0px 40px 28px;border-radius:4px;color:rgba(0, 0, 0, 0.9);overflow-y:auto;line-height:22px;font-size:13px;}");
      sheet.insertRule(".meta2d-popconfirm .arrow{position:absolute;border:10px solid transparent;background:transparent;top:-18px;left:50%;transform:translateX(-50%)}");
      sheet.insertRule(".meta2d-popconfirm .arrow.down{top:initial;bottom: -18px;}");
      sheet.insertRule(".meta2d-popconfirm .icon{position:absolute;width:22px;height:22px;left:16px;top:16px;}");
      sheet.insertRule(".meta2d-popconfirm .confirm{position:absolute;right:16px;bottom:16px;width:40px;height:24px;text-align:center;background:#4582e6;color:#fff;border-radius:3px;border-color:transparent}");
      sheet.insertRule(".meta2d-popconfirm .confirm:hover{background:#003cab;}");
      sheet.insertRule(".meta2d-popconfirm .cancel{position:absolute;right:64px;bottom:16px;width:40px;height:24px;text-align:center;background:#dcdcdc;color:rgba(0, 0, 0, 0.9);border-radius:3px;border-color:transparent}");
      sheet.insertRule(".meta2d-popconfirm .cancel:hover{background:#a6a6a6;}");
    }
  }
  show(pen, pos) {
    if (!pen) {
      return;
    }
    const elemRect = this.box.getBoundingClientRect();
    const rect = pen.calculative.worldRect;
    let x = pen.calculative.canvas.store.data.x + pos.x - elemRect.width / 2;
    let y = pen.calculative.canvas.store.data.y + pos.y - elemRect.height - 20;
    if (!pen.type) {
      x = pen.calculative.canvas.store.data.x + rect.x - (elemRect.width - rect.width) / 2;
      y = pen.calculative.canvas.store.data.y + rect.ey - elemRect.height - rect.height;
    }
    if (y > 0) {
      this.arrowUp.style.borderBottomColor = "transparent";
      this.arrowDown.style.borderTopColor = "#fff";
      y -= 10;
    } else {
      y += elemRect.height + rect.height + 5;
      y += 10;
      this.arrowUp.style.borderBottomColor = "#fff";
      this.arrowDown.style.borderTopColor = "transparent";
    }
    this.x = x;
    this.y = y;
    this.box.style.left = this.x + "px";
    this.box.style.top = this.y + "px";
  }
  hide() {
    this.x = -9999;
    this.box.style.left = "-9999px";
  }
  showModal(pen, pos, title) {
    return new Promise((resolve) => {
      this.text.innerHTML = title || "";
      this.show(pen, pos);
      this.confirm.onclick = () => {
        resolve(true);
        this.hide();
      };
      this.cancel.onclick = () => {
        resolve(false);
        this.hide();
      };
    });
  }
  destroy() {
    this.box = null;
  }
};

// node_modules/@meta2d/core/src/canvas/canvas.js
var movingSuffix = "-moving";
var Canvas = class {
  constructor(parent, parentElement, store) {
    __publicField(this, "parent");
    __publicField(this, "parentElement");
    __publicField(this, "store");
    __publicField(this, "canvas", document.createElement("canvas"));
    __publicField(this, "offscreen", createOffscreen());
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "externalElements", document.createElement("div"));
    __publicField(this, "clientRect");
    __publicField(this, "canvasRect");
    __publicField(this, "activeRect");
    __publicField(this, "initActiveRect");
    __publicField(this, "dragRect");
    __publicField(this, "lastRotate", 0);
    __publicField(this, "sizeCPs");
    __publicField(this, "activeInitPos");
    __publicField(this, "hoverType", HoverType.None);
    __publicField(this, "resizeIndex", 0);
    __publicField(this, "mouseDown");
    __publicField(this, "hotkeyType");
    __publicField(this, "mouseRight");
    __publicField(this, "addCaches");
    __publicField(this, "touchCenter");
    __publicField(this, "initTouchDis");
    __publicField(this, "initScale");
    __publicField(this, "touchScaling");
    __publicField(this, "touchMoving");
    __publicField(this, "startTouches");
    __publicField(this, "lastOffsetX", 0);
    __publicField(this, "lastOffsetY", 0);
    __publicField(this, "drawingLineName");
    __publicField(this, "drawLineFns", [...defaultDrawLineFns]);
    __publicField(this, "drawingLine");
    __publicField(this, "pencil");
    __publicField(this, "pencilLine");
    __publicField(this, "movingPens");
    __publicField(this, "patchFlagsLines", /* @__PURE__ */ new Set());
    __publicField(this, "dock");
    __publicField(this, "prevAnchor");
    __publicField(this, "nextAnchor");
    __publicField(this, "lastMouseTime", 0);
    __publicField(this, "hoverTimer", 0);
    __publicField(this, "fitTimer", 0);
    // Ctrl/
    __publicField(this, "willInactivePen");
    __publicField(this, "patchFlags", false);
    __publicField(this, "lastRender", 0);
    __publicField(this, "touchStart", 0);
    __publicField(this, "touchStartTimer");
    __publicField(this, "timer");
    __publicField(this, "lastAnimateRender", 0);
    __publicField(this, "animateRendering", false);
    __publicField(this, "renderTimer");
    __publicField(this, "initPens");
    __publicField(this, "pointSize", 8);
    __publicField(this, "pasteOffset", true);
    __publicField(this, "opening", false);
    __publicField(this, "maxZindex", 5);
    __publicField(this, "canMoveLine", false);
    //moveConnectedLine=false
    __publicField(this, "randomIdObj");
    //id
    __publicField(this, "keyOptions");
    /**
     * @deprecated  beforeAddPens
     */
    __publicField(this, "beforeAddPen");
    __publicField(this, "beforeAddPens");
    __publicField(this, "beforeAddAnchor");
    __publicField(this, "beforeRemovePens");
    __publicField(this, "beforeRemoveAnchor");
    __publicField(this, "customResizeDock");
    __publicField(this, "customMoveDock");
    __publicField(this, "inputParent", document.createElement("div"));
    // input = document.createElement('textarea');
    __publicField(this, "inputDiv", document.createElement("div"));
    // inputRight = document.createElement('div');
    __publicField(this, "dropdown", document.createElement("ul"));
    __publicField(this, "tooltip");
    __publicField(this, "popconfirm");
    __publicField(this, "title");
    __publicField(this, "mousePos", { x: 0, y: 0 });
    __publicField(this, "scroll");
    __publicField(this, "movingAnchor");
    // 
    __publicField(this, "canvasTemplate");
    __publicField(this, "canvasImage");
    __publicField(this, "canvasImageBottom");
    __publicField(this, "magnifierCanvas");
    __publicField(this, "dialog");
    __publicField(this, "autoPolylineFlag", false);
    //open
    __publicField(this, "stopPropagation", (e) => {
      e.stopPropagation();
    });
    __publicField(this, "curve", curve);
    __publicField(this, "polyline", polyline);
    __publicField(this, "mind", mind);
    __publicField(this, "line", lineSegment);
    __publicField(this, "onCopy", (event) => {
      if (this.store.options.disableClipboard) {
        return;
      }
      if (event.target !== this.externalElements && event.target !== document.body && event.target.offsetParent !== this.externalElements) {
        return;
      }
      this.copy();
    });
    __publicField(this, "onCut", (event) => {
      if (this.store.options.disableClipboard) {
        return;
      }
      if (event.target !== this.externalElements && event.target !== document.body && event.target.offsetParent !== this.externalElements) {
        return;
      }
      this.cut();
    });
    __publicField(this, "onPaste", async (event) => {
      if (this.store.data.locked || this.store.options.disableClipboard) {
        return;
      }
      if (event.target !== this.externalElements && event.target !== document.body && event.target.offsetParent !== this.externalElements) {
        return;
      }
      let hasImages;
      if (navigator.clipboard && event.clipboardData) {
        const items = event.clipboardData.items;
        if (items) {
          for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf("image") !== -1 && items[i].getAsFile()) {
              hasImages = true;
              break;
            }
          }
        }
      }
      if (hasImages) {
        const items = event.clipboardData.items;
        if (items) {
          for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf("image") !== -1 && items[i].getAsFile()) {
              const { x, y } = this.mousePos;
              const blob = items[i].getAsFile();
              let name = items[i].type.slice(6) === "gif" ? "gif" : "image";
              if (blob !== null) {
                const isGif = name === "gif";
                const pen = await this.fileToPen(blob, isGif);
                pen.height = pen.height / pen.width * 100, pen.width = 100;
                pen.x = x - 50 / 2, pen.y = y - pen.height / pen.width * 50, pen.externElement = isGif, this.addPens([pen]);
                this.active([pen]);
                this.copy([pen]);
              }
            }
          }
        }
      } else {
        this.paste();
      }
    });
    __publicField(this, "onMessage", (e) => {
      if (typeof e.data !== "string" || !e.data || e.data.startsWith("setImmediate")) {
        return;
      }
      let data = JSON.parse(e.data);
      if (typeof data === "object") {
        this.parent.doMessageEvent(data.name, JSON.stringify(data.data));
      } else {
        this.parent.doMessageEvent(data);
      }
    });
    __publicField(this, "onwheel", (e) => {
      if (this.inputDiv.contentEditable === "true") {
        return;
      }
      if (this.drawingLine) {
        return;
      }
      if (this.pencil) {
        return;
      }
      if (this.store.hover) {
        if (this.store.hover.onWheel) {
          this.store.hover.onWheel(this.store.hover, e);
          return;
        }
      }
      if (this.store.data.disableScale || this.store.options.disableScale) {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      if (this.mouseDown && (this.hoverType === HoverType.Node || this.hoverType === HoverType.Line))
        return;
      if (this.store.data.locked === LockState.Disable)
        return;
      if (this.store.data.locked === LockState.DisableScale)
        return;
      if (this.store.data.locked === LockState.DisableMoveScale)
        return;
      if (!e.ctrlKey && Math.abs(e.wheelDelta) < 100 && e.deltaY.toString().indexOf(".") === -1) {
        if (this.store.options.scroll && !e.metaKey && this.scroll) {
          this.scroll.wheel(e.deltaY < 0);
          return;
        }
        const scale = this.store.data.scale || 1;
        this.translate(-e.deltaX / scale, -e.deltaY / scale);
        return;
      }
      if (Math.abs(e.wheelDelta) > 100) {
        if (this.store.options.scroll && this.scroll && !this.store.options.scrollButScale && !(e.ctrlKey || e.metaKey)) {
          this.scroll.wheel(e.deltaY < 0);
          return;
        }
      }
      if (this.store.options.disableTouchPadScale) {
        return;
      }
      let scaleOff = 0.015;
      if (this.store.options.scaleOff) {
        scaleOff = this.store.options.scaleOff;
        if (e.deltaY > 0) {
          scaleOff = -this.store.options.scaleOff;
        }
      } else {
        let isMac = /mac os /i.test(navigator.userAgent);
        if (isMac) {
          if (!e.ctrlKey) {
            scaleOff *= e.wheelDeltaY / 240;
          } else if (e.deltaY > 0) {
            scaleOff *= -1;
          }
        } else {
          let offset = 0.2;
          if (e.deltaY.toString().indexOf(".") !== -1) {
            offset = 0.01;
          }
          if (e.deltaY > 0) {
            scaleOff = -offset;
          } else {
            scaleOff = offset;
          }
        }
      }
      let { offsetX: x, offsetY: y } = e;
      this.scale(this.store.data.scale + scaleOff, { x, y });
      this.externalElements.focus();
    });
    __publicField(this, "onkeydown", (e) => {
      var _a, _b, _c;
      if (this.store.data.locked >= LockState.DisableEdit && e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA" && !e.target.dataset.meta2dIgnore) {
        this.store.active.forEach((pen) => {
          var _a2;
          (_a2 = pen.onKeyDown) == null ? void 0 : _a2.call(pen, pen, e.key);
        });
      }
      if (this.store.data.locked >= LockState.DisableEdit || e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA" || e.target.dataset.meta2dIgnore) {
        return;
      }
      if (this.store.options.unavailableKeys.includes(e.key)) {
        return;
      }
      if (!this.keyOptions) {
        this.keyOptions = {};
      }
      this.keyOptions.altKey = e.altKey;
      this.keyOptions.shiftKey = e.shiftKey;
      this.keyOptions.ctrlKey = e.ctrlKey;
      this.keyOptions.metaKey = e.metaKey;
      this.keyOptions.F = false;
      if (e.key === "F" || e.key === "f") {
        this.keyOptions.F = true;
      }
      let x = 10;
      let y = 10;
      let vRect = null;
      if (this.store.options.strictScope) {
        const width = this.store.data.width || this.store.options.width;
        const height = this.store.data.height || this.store.options.height;
        if (width && height) {
          vRect = {
            x: this.store.data.origin.x,
            y: this.store.data.origin.y,
            width: width * this.store.data.scale,
            height: height * this.store.data.scale
          };
        }
      }
      switch (e.key) {
        case " ":
          this.hotkeyType = HotkeyType.Translate;
          break;
        case "Control":
          if (this.drawingLine) {
            this.drawingLine.calculative.drawlineH = !this.drawingLine.calculative.drawlineH;
          } else if (!this.hotkeyType) {
            this.patchFlags = true;
            this.hotkeyType = HotkeyType.Select;
          }
          break;
        case "Meta":
          break;
        case "Shift":
          if (this.store.active.length === 1 && this.store.active[0].type && this.store.activeAnchor) {
            this.toggleAnchorHand();
          } else if (!this.hotkeyType) {
            this.patchFlags = true;
            if (!this.store.options.resizeMode) {
              this.hotkeyType = HotkeyType.Resize;
            }
          }
          break;
        case "Alt":
          if (!e.ctrlKey && !e.shiftKey && this.drawingLine) {
            const to = getToAnchor(this.drawingLine);
            if (to !== this.drawingLine.calculative.activeAnchor) {
              deleteTempAnchor(this.drawingLine);
              this.drawingLine.calculative.worldAnchors.push(to);
            } else {
              this.drawingLine.calculative.worldAnchors.push({
                x: to.x,
                y: to.y
              });
            }
            const index = this.drawLineFns.indexOf(this.drawingLineName);
            this.drawingLineName = this.drawLineFns[(index + 1) % this.drawLineFns.length];
            this.drawingLine.lineName = this.drawingLineName;
            this.drawline();
            this.patchFlags = true;
          }
          e.preventDefault();
          break;
        case "a":
        case "A":
          if (e.ctrlKey || e.metaKey) {
            this.active(this.store.data.pens.filter((pen) => !pen.parentId && pen.locked !== LockState.Disable));
            e.preventDefault();
          } else {
            this.toggleAnchorMode();
          }
          break;
        case "Delete":
        case "Backspace":
          if (this.canvasImage.fitFlag && this.canvasImage.activeFit) {
            this.deleteFit();
            break;
          }
          !this.store.data.locked && this.delete();
          break;
        case "ArrowLeft":
          if (this.movingAnchor) {
            this.translateAnchor(-1, 0);
            break;
          }
          x = -1;
          if (e.shiftKey) {
            x = -5;
          }
          if (e.ctrlKey || e.metaKey) {
            x = -10;
          }
          x = x * this.store.data.scale;
          if (this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
            this.moveLineAnchor({ x: this.store.activeAnchor.x + x, y: this.store.activeAnchor.y }, {});
            break;
          }
          if (vRect && this.activeRect.x + x < vRect.x) {
            x = vRect.x - this.activeRect.x;
          }
          this.translatePens(this.store.active, x, 0);
          break;
        case "ArrowUp":
          if (this.movingAnchor) {
            this.translateAnchor(0, -1);
            break;
          }
          y = -1;
          if (e.shiftKey) {
            y = -5;
          }
          if (e.ctrlKey || e.metaKey) {
            y = -10;
          }
          y = y * this.store.data.scale;
          if (vRect && this.activeRect.y + y < vRect.y) {
            y = vRect.y - this.activeRect.y;
          }
          if (this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
            this.moveLineAnchor({ x: this.store.activeAnchor.x, y: this.store.activeAnchor.y + y }, {});
            break;
          }
          this.translatePens(this.store.active, 0, y);
          break;
        case "ArrowRight":
          if (this.movingAnchor) {
            this.translateAnchor(1, 0);
            break;
          }
          x = 1;
          if (e.shiftKey) {
            x = 5;
          }
          if (e.ctrlKey || e.metaKey) {
            x = 10;
          }
          x = x * this.store.data.scale;
          if (this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
            this.moveLineAnchor({ x: this.store.activeAnchor.x + x, y: this.store.activeAnchor.y }, {});
            break;
          }
          if (vRect && this.activeRect.x + this.activeRect.width + x > vRect.x + vRect.width) {
            x = vRect.x + vRect.width - (this.activeRect.x + this.activeRect.width);
          }
          this.translatePens(this.store.active, x, 0);
          break;
        case "ArrowDown":
          if (this.movingAnchor) {
            this.translateAnchor(0, 1);
            break;
          }
          y = 1;
          if (e.shiftKey) {
            y = 5;
          }
          if (e.ctrlKey || e.metaKey) {
            y = 10;
          }
          y = y * this.store.data.scale;
          if (vRect && this.activeRect.y + this.activeRect.height + y > vRect.y + vRect.height) {
            y = vRect.y + vRect.height - (this.activeRect.y + this.activeRect.height);
          }
          if (this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
            this.moveLineAnchor({ x: this.store.activeAnchor.x, y: this.store.activeAnchor.y + y }, {});
            break;
          }
          this.translatePens(this.store.active, 0, y);
          break;
        case "d":
        case "D":
          if (!((_a = this.store.active[0]) == null ? void 0 : _a.locked)) {
            this.removeAnchorHand();
          }
          break;
        case "h":
        case "H":
          if (!((_b = this.store.active[0]) == null ? void 0 : _b.locked)) {
            this.addAnchorHand();
          }
          break;
        case "m":
        case "M":
          this.toggleMagnifier();
          break;
        case "g":
        case "G":
          if (this.hoverType === HoverType.NodeAnchor) {
            this.movingAnchor = this.store.hoverAnchor;
            this.externalElements.style.cursor = "move";
          }
          break;
        case "s":
        case "S":
          if (!this.store.data.locked && this.hoverType === HoverType.LineAnchor && this.store.hover === this.store.active[0]) {
            this.splitLine(this.store.active[0], this.store.hoverAnchor);
          }
          (e.ctrlKey || e.metaKey) && this.store.emitter.emit("save", { event: e });
          break;
        case "c":
        case "C":
          if ((e.ctrlKey || e.metaKey) && this.store.options.disableClipboard) {
            this.copy();
          }
          break;
        case "x":
        case "X":
          if ((e.ctrlKey || e.metaKey) && this.store.options.disableClipboard) {
            this.cut();
          }
          break;
        case "":
        case "v":
        case "V":
          if (!e.ctrlKey && !e.metaKey) {
            if (this.pencil) {
              this.stopPencil();
            }
            if (this.drawingLineName) {
              this.finishDrawline();
              this.drawingLineName = "";
            } else {
              this.drawingLineName = this.store.options.drawingLineName;
            }
          }
          if (!this.store.data.locked && (e.ctrlKey || e.metaKey) && (this.store.options.disableClipboard || !this.store.options.disableClipboard && e.altKey)) {
            this.paste();
          }
          break;
        case "b":
        case "B":
          if (this.drawingLineName) {
            this.finishDrawline();
            this.drawingLineName = "";
          }
          if (this.pencil) {
            this.stopPencil();
          } else {
            this.drawingPencil();
          }
          break;
        case "y":
        case "Y":
          if (e.ctrlKey || e.metaKey) {
            this.redo();
          }
          break;
        case "z":
        case "Z":
          if (e.ctrlKey || e.metaKey) {
            this.undo();
          } else if (e.shiftKey) {
            this.redo();
          }
          break;
        case "Enter":
          if (this.drawingLineName) {
            this.finishDrawline(true);
            if (this.store.active[0].anchors[0].connectTo) {
              this.drawingLineName = "";
            } else {
              this.drawingLineName = this.store.options.drawingLineName;
            }
          }
          if (this.store.active) {
            this.store.active.forEach((pen) => {
              if (pen.type) {
                pen.close = !pen.close;
                if (pen.close) {
                  getLinePoints(pen);
                }
                this.store.path2dMap.set(pen, globalStore.path2dDraws.line(pen));
                getLineLength(pen);
              } else {
                pen.calculative.focus = true;
              }
            });
            this.render();
          }
          break;
        case "Escape":
          if (this.drawingLineName) {
            this.finishDrawline();
          }
          this.drawingLineName = void 0;
          this.stopPencil();
          if (this.store.active) {
            this.store.active.forEach((pen) => {
              if (pen.type) {
              } else {
                pen.calculative.focus = false;
              }
            });
          }
          if (this.movingPens) {
            this.getAllByPens(this.movingPens).forEach((pen) => {
              this.store.pens[pen.id] = void 0;
            });
            this.movingPens = void 0;
            this.mouseDown = void 0;
            this.clearDock();
            (_c = this.store.active) == null ? void 0 : _c.forEach((pen) => {
              this.updateLines(pen);
            });
            this.calcActiveRect();
            this.patchFlags = true;
          }
          this.hotkeyType = HotkeyType.None;
          this.movingAnchor = void 0;
          if (this.magnifierCanvas.magnifier) {
            this.magnifierCanvas.magnifier = false;
            this.patchFlags = true;
          }
          break;
        case "E":
        case "e":
          this.store.options.disableAnchor = !this.store.options.disableAnchor;
          this.store.emitter.emit("disableAnchor", this.store.options.disableAnchor);
          break;
        case "=":
          if (e.ctrlKey || e.metaKey) {
            this.scale(this.store.data.scale + 0.1);
            e.preventDefault();
            e.stopPropagation();
          }
          break;
        case "-":
          if (e.ctrlKey || e.metaKey) {
            this.scale(this.store.data.scale - 0.1);
            e.preventDefault();
            e.stopPropagation();
          }
          break;
        case "l":
        case "L":
          this.canMoveLine = true;
          break;
        case "[":
          this.parent.down();
          break;
        case "]":
          this.parent.up();
          break;
        case "{":
          this.parent.bottom();
          break;
        case "}":
          this.parent.top();
          break;
        case "F":
        case "f":
          if (!this.store.data.locked && (e.ctrlKey || e.metaKey) && !this.store.options.disableClipboard) {
            this.paste();
          }
          this.setFollowers();
          break;
      }
      this.render(false);
    });
    __publicField(this, "onkeyup", (e) => {
      switch (e.key) {
        case "l":
        case "L":
          this.canMoveLine = false;
          break;
      }
      if (this.hotkeyType) {
        this.render();
      }
      if (this.hotkeyType < HotkeyType.AddAnchor) {
        this.hotkeyType = HotkeyType.None;
      }
    });
    __publicField(this, "ondrop", async (event) => {
      if (this.store.data.locked) {
        console.warn("canvas is locked, can not drop");
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      const json = event.dataTransfer.getData("Meta2d") || event.dataTransfer.getData("Text");
      let obj = null;
      try {
        if (json) {
          obj = JSON.parse(json);
        }
      } catch (e) {
      }
      if (!obj) {
        const { files } = event.dataTransfer;
        if (files.length && files[0].type.match("image.*") && !(this.addCaches && this.addCaches.length)) {
          const isGif = files[0].type === "image/gif";
          obj = await this.fileToPen(files[0], isGif);
        } else if (this.addCaches && this.addCaches.length) {
          obj = this.addCaches;
          this.addCaches = [];
        } else {
          this.store.emitter.emit("drop", void 0);
          return;
        }
      }
      obj = Array.isArray(obj) ? obj : [obj];
      if (obj[0] && obj[0].draggable !== false) {
        const pt = { x: event.offsetX, y: event.offsetY };
        this.calibrateMouse(pt);
        this.dropPens(obj, pt);
        this.addCaches = [];
        this.getContainerHover(pt);
        this.mousePos.x = pt.x;
        this.mousePos.y = pt.y;
        this.store.emitter.emit("mouseup", {
          x: pt.x,
          y: pt.y,
          pen: this.store.hoverContainer
        });
      }
      this.store.emitter.emit("drop", obj || json);
    });
    __publicField(this, "ontouchstart", (e) => {
      if (this.store.data.locked === LockState.Disable) {
        return;
      }
      if (this.touchStartTimer) {
        clearTimeout(this.touchStartTimer);
      }
      this.touchStartTimer = setTimeout(() => {
        this.touchStart = performance.now();
        const x = e.touches[0].pageX - this.clientRect.x;
        const y = e.touches[0].pageY - this.clientRect.y;
        const pos = { x, y };
        this.calibrateMouse(pos);
        this.getHover(pos);
        this.onMouseDown({
          x,
          y,
          clientX: e.touches[0].clientX,
          clientY: e.touches[0].clientY,
          pageX: e.touches[0].pageX,
          pageY: e.touches[0].pageY,
          ctrlKey: e.ctrlKey || e.metaKey,
          shiftKey: e.shiftKey,
          altKey: e.altKey,
          buttons: 1
        });
        if (e.touches.length === 2) {
          this.initTouchDis = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
          this.initScale = this.store.data.scale;
          this.startTouches = e.touches;
          this.touchCenter = {
            x: e.touches[0].pageX + (e.touches[1].pageX - e.touches[0].pageX) / 2 - this.clientRect.x,
            y: e.touches[0].pageY + (e.touches[1].pageY - e.touches[0].pageY) / 2 - this.clientRect.y
          };
          return;
        } else if (e.touches.length === 3) {
          this.store.emitter.emit("contextmenu", {
            e: {
              x,
              y,
              clientX: e.touches[0].clientX,
              clientY: e.touches[0].clientY,
              pageX: e.touches[0].pageX,
              pageY: e.touches[0].pageY
            },
            clientRect: this.clientRect
          });
          e.preventDefault();
          e.stopPropagation();
        }
        this.touchStartTimer = void 0;
      }, 50);
    });
    __publicField(this, "ontouchmove", (event) => {
      var _a;
      if (this.store.data.locked === LockState.Disable) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      const now = performance.now();
      if (now - this.touchStart < 50) {
        return;
      }
      this.touchStart = now;
      const touches = event.touches;
      const len = touches.length;
      const x = event.touches[0].pageX - this.clientRect.x;
      const y = event.touches[0].pageY - this.clientRect.y;
      if (len === 1) {
        this.onMouseMove({
          x,
          y,
          clientX: event.changedTouches[0].clientX,
          clientY: event.changedTouches[0].clientY,
          pageX: event.changedTouches[0].pageX,
          pageY: event.changedTouches[0].pageY,
          ctrlKey: event.ctrlKey || event.metaKey,
          shiftKey: event.shiftKey,
          altKey: event.altKey,
          buttons: 1
        });
      } else if (len === 2 && ((_a = this.startTouches) == null ? void 0 : _a.length) === 2) {
        if (!this.touchMoving && !this.touchScaling) {
          const x1 = this.startTouches[0].pageX - touches[0].pageX;
          const x2 = this.startTouches[1].pageX - touches[1].pageX;
          const y1 = this.startTouches[0].pageY - touches[0].pageY;
          const y2 = this.startTouches[1].pageY - touches[1].pageY;
          if ((x1 >= 0 && x2 < 0 || x1 <= 0 && x2 > 0) && (y1 >= 0 && y2 < 0 || y1 <= 0 && y2 > 0)) {
            this.touchScaling = true;
          } else {
            this.touchMoving = true;
          }
        }
        if (this.touchScaling) {
          if (this.store.data.disableScale || this.store.options.disableScale) {
            return;
          }
          const scale = Math.hypot(touches[0].pageX - touches[1].pageX, touches[0].pageY - touches[1].pageY) / this.initTouchDis;
          this.scale(this.initScale * scale, deepClone(this.touchCenter));
        }
        if (this.touchMoving) {
          if (this.store.data.locked >= LockState.DisableMove && this.store.data.locked !== LockState.DisableScale || this.store.data.disableScale || this.store.options.disableScale) {
            return;
          }
          if (this.lastOffsetX) {
            const { scale } = this.store.data;
            this.translate((x - this.lastOffsetX) / scale, (y - this.lastOffsetY) / scale);
          }
          this.lastOffsetX = x;
          this.lastOffsetY = y;
        }
      }
    });
    __publicField(this, "ontouchend", (event) => {
      if (this.store.data.locked === LockState.Disable) {
        return;
      }
      this.touchCenter = void 0;
      this.touchScaling = void 0;
      this.touchMoving = void 0;
      this.startTouches = void 0;
      this.lastOffsetX = 0;
      this.lastOffsetY = 0;
      const x = event.changedTouches[0].pageX - this.clientRect.x;
      const y = event.changedTouches[0].pageY - this.clientRect.y;
      this.onMouseUp({
        x,
        y,
        clientX: event.changedTouches[0].clientX,
        clientY: event.changedTouches[0].clientY,
        pageX: event.changedTouches[0].pageX,
        pageY: event.changedTouches[0].pageY,
        ctrlKey: event.ctrlKey || event.metaKey,
        shiftKey: event.shiftKey,
        altKey: event.altKey,
        buttons: 1
      });
      setTimeout(() => {
        this.render();
      }, 20);
    });
    __publicField(this, "onGesturestart", (e) => {
      e.preventDefault();
    });
    __publicField(this, "onMouseDown", (e) => {
      var _a, _b, _c, _d, _e;
      if (e.buttons === 2 && !this.drawingLine) {
        this.mouseRight = MouseRight.Down;
      }
      this.hideInput();
      this.popconfirm.hide();
      if (this.store.data.locked === LockState.Disable || e.buttons !== 1 && e.buttons !== 2) {
        this.hoverType = HoverType.None;
        return;
      }
      if (this.magnifierCanvas.magnifier) {
        return;
      }
      this.calibrateMouse(e);
      this.mousePos.x = e.x;
      this.mousePos.y = e.y;
      this.mouseDown = e;
      this.lastMouseTime = performance.now();
      if (this.canvasImage.fitFlag) {
        if (!this.canvasImage.currentFit) {
          this.calcuActiveFit();
        }
        return;
      }
      if (this.hotkeyType === HotkeyType.AddAnchor) {
        this.setAnchor(this.store.pointAt);
        return;
      }
      if (!this.store.options.autoAnchor && !this.drawingLine) {
        if (e.shiftKey && e.ctrlKey && e.altKey) {
          this.setAnchor(this.store.pointAt);
          this.drawingLineName = this.store.options.drawingLineName;
          const anchor = this.store.activeAnchor;
          if (!anchor) {
            return;
          }
          const pt = {
            id: s8(),
            x: anchor.x,
            y: anchor.y
          };
          this.drawingLine = this.createDrawingLine(pt);
          let _pt = getFromAnchor(this.drawingLine);
          this.drawingLine.calculative.activeAnchor = _pt;
          connectLine(this.store.hover, anchor, this.drawingLine, pt);
          this.drawline();
          return;
        }
      }
      if (this.hotkeyType === HotkeyType.Translate || this.mouseRight === MouseRight.Down && !this.store.options.mouseRightActive) {
        return;
      }
      if (this.drawingLine) {
        if (this.store.hoverAnchor) {
          const to2 = getToAnchor(this.drawingLine);
          if (this.store.hoverAnchor.type === PointType.Line) {
            getDistance(to2, this.store.hoverAnchor, this.store);
          } else {
            to2.x = this.store.hoverAnchor.x;
            to2.y = this.store.hoverAnchor.y;
          }
          connectLine(this.store.hover, this.store.hoverAnchor, this.drawingLine, to2);
          this.drawline();
          this.finishDrawline(true);
          return;
        }
        if (!this.store.options.autoAnchor) {
          if (e.shiftKey && e.altKey && e.ctrlKey) {
            this.setAnchor(this.store.pointAt);
            const to2 = getToAnchor(this.drawingLine);
            const anchor = this.store.activeAnchor;
            if (!anchor) {
              return;
            }
            to2.x = anchor.x;
            to2.y = anchor.y;
            connectLine(this.store.hover, anchor, this.drawingLine, to2);
            this.drawline();
            this.finishDrawline(true);
            return;
          }
        }
        if (e.buttons === 2 || this.drawingLineName === "mind" && ((_a = this.drawingLine) == null ? void 0 : _a.calculative.worldAnchors.length) > 1 || this.store.options.drawingLineLength && ((_b = this.drawingLine) == null ? void 0 : _b.calculative.worldAnchors.length) > this.store.options.drawingLineLength) {
          this.finishDrawline(true);
          if (((_c = this.store.active[0]) == null ? void 0 : _c.anchors[0].connectTo) || this.store.active.length == 0) {
            this.drawingLineName = "";
          } else {
            this.drawingLineName = this.store.options.drawingLineName;
          }
          return;
        }
        if (this.store.options.autoAnchor && this.hoverType === HoverType.Node) {
          const to2 = getToAnchor(this.drawingLine);
          const anchor = nearestAnchor(this.store.hover, e);
          to2.x = anchor.x;
          to2.y = anchor.y;
          this.drawingLine.autoTo = true;
          connectLine(this.store.hover, anchor, this.drawingLine, to2);
          this.drawline();
          this.finishDrawline(true);
          return;
        }
        const to = getToAnchor(this.drawingLine);
        if (to.isTemp) {
          this.drawingLine.calculative.activeAnchor = this.drawingLine.calculative.worldAnchors[this.drawingLine.calculative.worldAnchors.length - 2];
          to.isTemp = void 0;
        } else {
          this.drawingLine.calculative.activeAnchor = to;
          this.drawingLine.calculative.worldAnchors.push({
            x: to.x,
            y: to.y,
            penId: to.penId
          });
        }
        this.drawingLine.calculative.drawlineH = void 0;
        this.drawingLineName !== "polyline" && this.drawline();
      }
      if (this.drawingLineName) {
        if (this.hoverType === HoverType.Node) {
          if (this.store.options.autoAnchor) {
            this.inactive(true);
            const anchor = nearestAnchor(this.store.hover, e);
            this.store.hoverAnchor = anchor;
            const pt = { id: s8(), x: anchor.x, y: anchor.y };
            this.drawingLine = this.createDrawingLine(pt);
            this.drawingLine.autoFrom = true;
            connectLine(this.store.hover, anchor, this.drawingLine, pt);
          } else {
            this.inactive();
            this.hoverType = HoverType.None;
          }
        } else if (this.hoverType === HoverType.NodeAnchor) {
          this.drawingLineName = this.store.options.drawingLineName;
          const pt = {
            id: s8(),
            x: this.store.hoverAnchor.x,
            y: this.store.hoverAnchor.y
          };
          this.drawingLine = this.createDrawingLine(pt);
          this.drawingLine.calculative.activeAnchor = pt;
          connectLine(this.store.hover, this.store.hoverAnchor, this.drawingLine, pt);
        } else if (!this.drawingLine && this.drawingLineName !== "curve") {
          this.inactive(true);
          const pt = { id: s8(), x: e.x, y: e.y };
          this.drawingLine = this.createDrawingLine(pt);
          this.drawingLine.calculative.activeAnchor = pt;
        }
      } else if (this.pencil) {
        this.inactive(true);
        const penId = s8();
        const pt = { x: e.x, y: e.y, id: s8(), penId };
        this.pencilLine = this.getInitPencilLine(pt);
      } else {
        switch (this.hoverType) {
          case HoverType.None:
            (this.store.data.rule || this.store.options.rule) && !this.store.options.disableRuleLine && this.addRuleLine(e);
            if (this.store.options.resizeMode) {
              this.hotkeyType = HotkeyType.None;
            }
            this.inactive();
            break;
          case HoverType.Node:
          case HoverType.Line:
            if (this.store.hover) {
              if (((_d = this.store.active) == null ? void 0 : _d.length) && this.store.active.length === 1) {
                if (this.store.hover.id === this.store.active[0].id) {
                  this.calcActiveRect();
                  break;
                }
              }
              const parentPen = getParent(this.store.hover, true);
              let pen = parentPen || this.store.hover;
              if (parentPen && (parentPen.container || ((_e = this.store.options.containerShapes) == null ? void 0 : _e.includes(parentPen.name)))) {
                pen = this.store.hover;
              }
              if (e.ctrlKey && !e.shiftKey) {
                if (pen.calculative.active) {
                  this.willInactivePen = pen;
                } else {
                  if (this.store.active.length > 0) {
                    pen.calculative.active = true;
                    setChildrenActive(pen);
                    this.store.active.push(pen);
                    this.store.emitter.emit("active", this.store.active);
                  }
                }
                this.patchFlags = true;
              } else if (e.ctrlKey && e.shiftKey && this.store.hover.parentId) {
                this.active([this.store.hover]);
              } else {
                if (!(this.activeRect && pointInRect({ x: e.x, y: e.y }, this.activeRect)) || this.store.active.length == 1) {
                  if (!pen.calculative.active) {
                    this.active([pen]);
                    if (this.store.options.resizeMode) {
                      this.hotkeyType = HotkeyType.Resize;
                    }
                  }
                }
              }
              this.calcActiveRect();
            }
            break;
          case HoverType.LineAnchor:
            this.store.activeAnchor = this.store.hoverAnchor;
            this.store.hover.calculative.activeAnchor = this.store.hoverAnchor;
            this.active([this.store.hover]);
            break;
          case HoverType.LineAnchorPrev:
          case HoverType.LineAnchorNext:
            if (this.store.activeAnchor) {
              this.prevAnchor = { ...this.store.activeAnchor.prev };
              this.nextAnchor = { ...this.store.activeAnchor.next };
            }
            break;
          case HoverType.Resize:
            this.activeInitPos = [];
            this.store.active.forEach((pen) => {
              this.activeInitPos.push({
                x: (pen.calculative.worldRect.x - this.activeRect.x) / this.activeRect.width,
                y: (pen.calculative.worldRect.y - this.activeRect.y) / this.activeRect.height
              });
            });
            break;
        }
        if (this.store.hover) {
          this.store.hover.calculative.mouseDown = true;
        }
        this.store.emitter.emit("mousedown", {
          x: e.x,
          y: e.y,
          pen: this.store.hover
        });
      }
      this.render();
    });
    __publicField(this, "onMouseMove", (e) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (this.store.data.locked === LockState.Disable) {
        this.hoverType = HoverType.None;
        return;
      }
      if (this.mouseDown && !this.mouseDown.restore && e.buttons !== 1 && e.buttons !== 2) {
        this.onMouseUp(e);
        return;
      }
      if (this.lastMouseTime) {
        const now2 = performance.now();
        if (now2 - this.lastMouseTime < 50) {
          this.lastMouseTime = 0;
          return;
        }
        this.lastMouseTime = 0;
      }
      this.calibrateMouse(e);
      this.mousePos.x = e.x;
      this.mousePos.y = e.y;
      if (this.magnifierCanvas.magnifier) {
        this.render();
        return;
      }
      if (this.canvasImage.fitFlag) {
        if (this.canvasImage.activeFit) {
          const now2 = performance.now();
          if (now2 - this.fitTimer > 100) {
            if (this.mouseDown) {
              this.updateFit(e);
            } else {
              this.inFitBorder(this.mousePos);
            }
            this.fitTimer = now2;
          }
          return;
        }
      }
      if (this.mouseDown && !this.store.options.disableTranslate && !this.store.data.disableTranslate) {
        if (this.mouseRight === MouseRight.Down) {
          this.mouseRight = MouseRight.Translate;
        }
        if (this.store.data.locked === LockState.DisableEdit || this.store.data.locked === LockState.DisableScale || this.hotkeyType === HotkeyType.Translate || this.mouseRight === MouseRight.Translate) {
          const { scale } = this.store.data;
          let x = (e.x - this.mouseDown.x) / scale;
          let y = (e.y - this.mouseDown.y) / scale;
          e.shiftKey && !e.ctrlKey && (y = 0);
          e.ctrlKey && (x = 0);
          this.translate(x, y);
          return;
        }
        if (this.store.data.locked) {
          return;
        }
        if (!this.drawingLine && !this.pencil) {
          if (!this.drawingLineName && !this.movingAnchor) {
            if (this.hoverType === HoverType.NodeAnchor) {
              if (!this.store.hoverAnchor) {
                return;
              }
              this.drawingLineName = this.store.options.drawingLineName;
              const pt = {
                id: s8(),
                x: this.store.hoverAnchor.x,
                y: this.store.hoverAnchor.y
              };
              this.drawingLine = this.createDrawingLine(pt);
              this.drawingLine.calculative.activeAnchor = pt;
              connectLine(this.store.hover, this.store.hoverAnchor, this.drawingLine, pt);
              this.drawline();
              return;
            }
          } else if (this.drawingLineName && this.hoverType === HoverType.None) {
            const pt = { id: s8(), x: e.x, y: e.y };
            this.drawingLine = this.createDrawingLine(pt);
            this.drawingLine.calculative.activeAnchor = pt;
            this.drawline();
            return;
          }
          if (e.buttons === 1 && (e.ctrlKey || !this.hoverType && !this.hotkeyType) && !(e.ctrlKey && (this.store.activeAnchor || ((_a = this.store.active) == null ? void 0 : _a.length)))) {
            this.dragRect = {
              x: Math.min(this.mouseDown.x, e.x),
              y: Math.min(this.mouseDown.y, e.y),
              ex: Math.max(this.mouseDown.x, e.x),
              ey: Math.max(this.mouseDown.y, e.y),
              width: Math.abs(e.x - this.mouseDown.x),
              height: Math.abs(e.y - this.mouseDown.y)
            };
            this.render();
            return;
          }
          if (this.movingAnchor) {
            const x = e.x - this.movingAnchor.x;
            const y = e.y - this.movingAnchor.y;
            this.translateAnchor(x, y);
            this.render();
            return;
          } else if (!((_b = this.store.active[0]) == null ? void 0 : _b.locked)) {
            const pt = { x: e.x, y: e.y };
            if (this.hoverType === HoverType.LineAnchor) {
              if ((this.dockInAnchor(e) || ((_c = this.store.active[0]) == null ? void 0 : _c.lineName) === "line") && !this.store.options.disableDock && !this.store.options.disableLineDock) {
                this.clearDock();
                this.dock = calcAnchorDock(this.store, pt, this.store.activeAnchor);
                ((_d = this.dock) == null ? void 0 : _d.xDock) && (pt.x += this.dock.xDock.step);
                ((_e = this.dock) == null ? void 0 : _e.yDock) && (pt.y += this.dock.yDock.step);
              }
              this.moveLineAnchor(pt, e);
              return;
            }
            if (this.hoverType === HoverType.LineAnchorPrev) {
              this.moveLineAnchorPrev(e);
              return;
            }
            if (this.hoverType === HoverType.LineAnchorNext) {
              this.moveLineAnchorNext(e);
              return;
            }
          }
          if (this.hoverType === HoverType.Rotate) {
            this.rotatePens({ x: e.x, y: e.y });
            return;
          }
          if (this.hoverType === HoverType.Resize) {
            this.resizePens(e);
            return;
          }
          if (this.hoverType === HoverType.Node || this.hoverType === HoverType.Line) {
            const x = e.x - this.mouseDown.x;
            const y = e.y - this.mouseDown.y;
            const shake = 20;
            if (e.ctrlKey && !e.shiftKey && (Math.abs(x) >= shake || Math.abs(y) >= shake)) {
              this.willInactivePen = void 0;
            }
            if (this.store.active.length === 1) {
              const activePen = this.store.active[0];
              if (activePen.locked === void 0 || activePen.locked < LockState.DisableMove) {
                (_f = activePen == null ? void 0 : activePen.onMouseMove) == null ? void 0 : _f.call(activePen, activePen, this.mousePos);
              }
              if (activePen.calculative.focus) {
                return;
              }
            }
            this.movePens(e);
            this.getContainerHover(e);
            return;
          }
        } else if (this.pencil) {
          const { x, y } = e;
          const pt = { x, y };
          pt.id = s8();
          pt.penId = this.pencilLine.id;
          this.pencilLine.calculative.worldAnchors.push(pt);
          this.store.path2dMap.set(this.pencilLine, globalStore.path2dDraws[this.pencilLine.name](this.pencilLine));
          this.patchFlags = true;
        }
      }
      if (this.drawingLine) {
        const { x, y } = e;
        const pt = { x, y };
        pt.id = s8();
        pt.penId = this.drawingLine.id;
        if (!this.store.options.disableDock && !this.store.options.disableLineDock) {
          this.clearDock();
          this.dock = calcAnchorDock(this.store, pt);
          ((_g = this.dock) == null ? void 0 : _g.xDock) && (pt.x += this.dock.xDock.step);
          ((_h = this.dock) == null ? void 0 : _h.yDock) && (pt.y += this.dock.yDock.step);
        }
        if (this.mouseDown && this.drawingLineName === "curve" && !this.drawingLine.calculative.worldAnchors[0].connectTo) {
          this.drawline(pt);
        } else {
          let to;
          if (this.drawingLine.calculative.worldAnchors.length > 1) {
            to = getToAnchor(this.drawingLine);
          }
          if (to) {
            to.prev = void 0;
            to.next = void 0;
            if (!to.id) {
              to.id = s8();
            }
            to.x = pt.x;
            to.y = pt.y;
            to.connectTo = void 0;
          } else {
            to = { ...pt };
            this.drawingLine.calculative.worldAnchors.push(to);
          }
          if (this.hoverType === HoverType.NodeAnchor || this.hoverType === HoverType.LineAnchor) {
            if (this.store.hoverAnchor.type !== PointType.Line) {
              to.x = this.store.hoverAnchor.x;
              to.y = this.store.hoverAnchor.y;
            }
            to.connectTo = this.store.hoverAnchor.penId;
            if (this.drawingLineName === "polyline") {
              to.isTemp = false;
            }
          }
          if (this.drawingLineName === "line") {
            if (e.ctrlKey && !e.shiftKey) {
              to.x = this.drawingLine.calculative.worldAnchors[this.drawingLine.calculative.worldAnchors.length - 2].x;
            } else if (e.shiftKey && !e.ctrlKey) {
              to.y = this.drawingLine.calculative.worldAnchors[this.drawingLine.calculative.worldAnchors.length - 2].y;
            } else if (e.shiftKey && e.ctrlKey) {
              let last = this.drawingLine.calculative.worldAnchors[this.drawingLine.calculative.worldAnchors.length - 2];
              this.getSpecialAngle(to, last);
            }
          }
          this.drawline();
        }
      }
      globalThis.debug && console.time("hover");
      const now = performance.now();
      if (now - this.hoverTimer > 50) {
        this.hoverTimer = now;
        this.getHover(e);
      }
      globalThis.debug && console.timeEnd("hover");
      if (this.hotkeyType === HotkeyType.AddAnchor) {
        this.patchFlags = true;
      }
      this.render(false);
    });
    __publicField(this, "onMouseUp", (e) => {
      if (this.store.data.locked === LockState.Disable) {
        this.hoverType = HoverType.None;
        return;
      }
      if (!this.mouseDown) {
        return;
      }
      if (this.mouseRight === MouseRight.Down) {
        if (this.store.hover && this.store.hover.onContextmenu) {
          this.store.hover.onContextmenu(this.store.hover, e);
        } else {
          this.store.emitter.emit("contextmenu", {
            e,
            clientRect: this.clientRect,
            pen: this.store.hover
          });
        }
      }
      this.mouseRight = MouseRight.None;
      this.calibrateMouse(e);
      this.mousePos.x = e.x;
      this.mousePos.y = e.y;
      this.pencil && this.finishPencil();
      if (this.drawingLine) {
        if (this.store.hoverAnchor) {
          const to = getToAnchor(this.drawingLine);
          if (this.store.hoverAnchor.type === PointType.Line) {
            getDistance(to, this.store.hoverAnchor, this.store);
          } else {
            to.x = this.store.hoverAnchor.x;
            to.y = this.store.hoverAnchor.y;
          }
          connectLine(this.store.hover, this.store.hoverAnchor, this.drawingLine, to);
          this.drawline();
          this.finishDrawline(true);
          return;
        }
        if (this.store.options.autoAnchor && this.hoverType === HoverType.Node) {
          const to = getToAnchor(this.drawingLine);
          const anchor = nearestAnchor(this.store.hover, e);
          to.x = anchor.x;
          to.y = anchor.y;
          this.drawingLine.autoTo = true;
          connectLine(this.store.hover, anchor, this.drawingLine, to);
          this.drawline();
          this.finishDrawline(true);
          return;
        }
      }
      if (this.hoverType === HoverType.LineAnchor && this.store.hover && this.store.active[0] && this.store.active[0].name === "line" && this.store.active[0] !== this.store.hover) {
        const line2 = this.store.active[0];
        const from = getFromAnchor(line2);
        const to = getToAnchor(line2);
        if (this.store.hoverAnchor) {
          const hover = this.store.hover;
          const isHoverFrom = getFromAnchor(hover) === this.store.hoverAnchor;
          const isHoverTo = getToAnchor(hover) === this.store.hoverAnchor;
          const isActiveFrom = from === this.store.activeAnchor;
          const isActiveTo = to === this.store.activeAnchor;
          if ((e.ctrlKey || e.altKey) && hover.type === PenType.Line && (isHoverFrom || isHoverTo) && (isActiveFrom || isActiveTo)) {
            const hoverAnchors = hover.calculative.worldAnchors.map((anchor) => {
              return {
                ...anchor,
                penId: line2.id
              };
            });
            if (isHoverFrom) {
              hoverAnchors.shift();
            } else if (isHoverTo) {
              hoverAnchors.pop();
            }
            if (isHoverFrom && isActiveFrom || isHoverTo && isActiveTo) {
              hoverAnchors.reverse();
            }
            if (isActiveFrom) {
              line2.calculative.worldAnchors[0].connectTo = void 0;
              line2.calculative.worldAnchors.unshift(...hoverAnchors);
            } else if (isActiveTo) {
              line2.calculative.worldAnchors[line2.calculative.worldAnchors.length - 1].connectTo = void 0;
              line2.calculative.worldAnchors.push(...hoverAnchors);
            }
            this.delete([hover]);
            this.render();
          } else {
            if (this.store.activeAnchor) {
              if (this.store.hoverAnchor.type === PointType.Line) {
                getDistance(this.store.activeAnchor, this.store.hoverAnchor, this.store);
              } else {
                this.store.activeAnchor.x = this.store.hoverAnchor.x;
                this.store.activeAnchor.y = this.store.hoverAnchor.y;
              }
              connectLine(this.store.hover, this.store.hoverAnchor, line2, this.store.activeAnchor);
            }
          }
          if (this[line2.lineName] && line2.lineName !== "polyline") {
            this[line2.lineName](this.store, line2);
          }
          this.store.path2dMap.set(line2, globalStore.path2dDraws.line(line2));
          this.initLineRect(line2);
        } else {
          if (from === this.store.activeAnchor && line2.autoFrom) {
            this.calcAutoAnchor(line2, from, this.store.hover);
          } else if (to === this.store.activeAnchor && line2.autoTo) {
            this.calcAutoAnchor(line2, to, this.store.hover);
          }
        }
      }
      if (this.addCaches && this.addCaches.length) {
        if (!this.store.data.locked) {
          if (this.dragRect) {
            if (this.addCaches.length === 1) {
              const target = this.addCaches[0];
              target.width = this.dragRect.width / this.store.data.scale;
              target.height = this.dragRect.height / this.store.data.scale;
              e.x = (this.dragRect.x + this.dragRect.ex) / 2;
              e.y = (this.dragRect.y + this.dragRect.ey) / 2;
            }
          }
          this.dropPens(this.addCaches, e);
        }
        this.addCaches = void 0;
      }
      if (this.hoverType === HoverType.Rotate) {
        this.getSizeCPs();
        this.store.active.forEach((pen) => {
          pen.rotate = pen.calculative.rotate;
        });
      }
      this.patchFlagsLines.forEach((pen) => {
        if (pen.type) {
          this.initLineRect(pen);
        }
      });
      this.patchFlagsLines.clear();
      if (this.dragRect) {
        if (this.canvasImage.fitFlag) {
          this.makeFit();
        } else {
          const pens = this.store.data.pens.filter((pen) => {
            if (pen.visible === false || pen.locked >= LockState.DisableMove || pen.parentId || pen.isRuleLine) {
              return false;
            }
            if (rectInRect(pen.calculative.worldRect, this.dragRect, e.ctrlKey || this.store.options.dragAllIn)) {
              if (pen.type === PenType.Line && !this.store.options.dragAllIn) {
                return lineInRect(pen, this.dragRect);
              }
              return true;
            }
          });
          this.active(pens);
        }
      }
      if (e.button !== 2) {
        if (distance(this.mouseDown, e) < 2) {
          if (this.store.hover && this.store.hover.input) {
            if (this.store.hover.onShowInput) {
              this.store.hover.onShowInput(this.store.hover, e);
            } else {
              this.showInput(this.store.hover);
            }
          }
          this.store.emitter.emit("click", {
            x: e.x,
            y: e.y,
            pen: this.store.hover
          });
        }
        if (this.store.hover) {
          this.store.hover.calculative.mouseDown = false;
        }
        if (this.store.hover != this.store.hoverContainer) {
          this.store.emitter.emit("mouseup", {
            x: e.x,
            y: e.y,
            pen: this.store.hover
          });
        }
        this.store.emitter.emit("mouseup", {
          x: e.x,
          y: e.y,
          pen: this.store.hoverContainer
        });
      }
      if (this.willInactivePen) {
        this.willInactivePen.calculative.active = void 0;
        setChildrenActive(this.willInactivePen, false);
        const index = this.store.active.findIndex((p) => p === this.willInactivePen);
        if (index >= 0) {
          this.store.active.splice(index, 1);
        }
        this.calcActiveRect();
        this.willInactivePen = void 0;
        this.store.emitter.emit("inactive", [this.willInactivePen]);
        this.render();
      }
      if (this.movingPens) {
        if (e.altKey && !e.shiftKey) {
          this.copyMovedPens();
        } else {
          this.movedActivePens(e.ctrlKey && e.shiftKey);
        }
        this.getAllByPens(this.movingPens).forEach((pen) => {
          this.store.pens[pen.id] = void 0;
        });
        this.movingPens = void 0;
      }
      if (this.store.active && this.store.active[0]) {
        this.store.active[0].calculative.h = void 0;
      }
      this.mouseDown = void 0;
      this.lastOffsetX = 0;
      this.lastOffsetY = 0;
      this.clearDock();
      this.dragRect = void 0;
      this.initActiveRect = void 0;
      this.render();
    });
    __publicField(this, "clearDock", () => {
      var _a, _b, _c, _d;
      const xPenId = (_b = (_a = this.dock) == null ? void 0 : _a.xDock) == null ? void 0 : _b.penId;
      const yPenId = (_d = (_c = this.dock) == null ? void 0 : _c.yDock) == null ? void 0 : _d.penId;
      const xPen = this.store.pens[xPenId];
      if (xPen) {
        xPen.calculative.isDock = false;
      }
      const yPen = this.store.pens[yPenId];
      if (yPen) {
        yPen.calculative.isDock = false;
      }
      this.dock = void 0;
    });
    __publicField(this, "onResize", () => {
      if (this.timer) {
        clearTimeout(this.timer);
      }
      this.timer = setTimeout(() => {
        this.resize();
        this.timer = void 0;
      }, 100);
    });
    __publicField(this, "onScroll", () => {
      if (this.timer) {
        clearTimeout(this.timer);
      }
      this.timer = setTimeout(() => {
        this.clientRect = this.canvas.getBoundingClientRect();
        this.timer = void 0;
      }, 100);
    });
    __publicField(this, "calibrateMouse", (pt) => {
      pt.x -= this.store.data.x;
      pt.y -= this.store.data.y;
      return pt;
    });
    __publicField(this, "getContainerHover", (pt) => {
      var _a;
      if (this.dragRect) {
        return;
      }
      this.store.hoverContainer = void 0;
      const containerPens = this.store.data.pens.filter((pen) => {
        var _a2;
        return pen.container || ((_a2 = this.store.options.containerShapes) == null ? void 0 : _a2.includes(pen.name));
      });
      if (containerPens.length) {
        for (let i = containerPens.length - 1; i >= 0; --i) {
          const pen = containerPens[i];
          if (pen.visible == false || pen.calculative.inView == false || pen.locked === LockState.Disable) {
            continue;
          }
          if (pointInRect(pt, pen.calculative.worldRect)) {
            this.store.hoverContainer = pen;
            (_a = pen == null ? void 0 : pen.onMouseMove) == null ? void 0 : _a.call(pen, pen, pt);
            if (this.store.lastHoverContainer !== this.store.hoverContainer) {
              this.patchFlags = true;
              if (this.store.lastHoverContainer) {
                this.store.lastHoverContainer.calculative.containerHover = false;
                this.store.emitter.emit("leave", this.store.lastHoverContainer);
              }
              if (this.store.hoverContainer) {
                this.store.hoverContainer.calculative.containerHover = true;
                this.store.emitter.emit("enter", this.store.hoverContainer);
              }
              this.store.lastHoverContainer = this.store.hoverContainer;
            }
          } else {
            if (pen === this.store.hoverContainer) {
              this.store.hoverContainer = void 0;
              if (this.store.lastHoverContainer !== this.store.hoverContainer) {
                this.patchFlags = true;
                const movingPen = this.store.lastHoverContainer.calculative.canvas.store.pens[this.store.lastHoverContainer.id + movingSuffix];
                if (this.store.lastHoverContainer && !movingPen) {
                  this.store.lastHoverContainer.calculative.containerHover = false;
                  this.store.emitter.emit("leave", this.store.lastHoverContainer);
                }
                this.store.lastHoverContainer = this.store.hoverContainer;
              }
            }
          }
        }
      }
    });
    __publicField(this, "getHover", (pt) => {
      var _a, _b;
      if (this.dragRect) {
        return;
      }
      if (this.canvasImage.fitFlag) {
        return;
      }
      let hoverType = HoverType.None;
      this.store.hover = void 0;
      this.store.hoverAnchor = void 0;
      this.title.hide();
      this.store.pointAt = void 0;
      this.store.pointAtIndex = void 0;
      const activeLine = this.store.active.length === 1 && this.store.active[0].type;
      if (!this.drawingLineName && this.hotkeyType !== HotkeyType.AddAnchor && this.activeRect && !activeLine && !this.store.data.locked) {
        const activePensLock = getPensLock(this.store.active);
        const activePensDisableRotate = getPensDisableRotate(this.store.active) || this.store.options.disableRotate;
        const activePensDisableResize = getPensDisableResize(this.store.active) || this.store.options.disableSize;
        if (!activePensLock && !activePensDisableRotate) {
          const rotatePt = {
            x: this.activeRect.center.x,
            y: this.activeRect.y - 30
          };
          if (this.activeRect.rotate) {
            rotatePoint(rotatePt, this.activeRect.rotate, this.activeRect.pivot || this.activeRect.center);
          }
          if (!this.hotkeyType && hitPoint(pt, rotatePt, this.pointSize)) {
            hoverType = HoverType.Rotate;
            this.externalElements.style.cursor = `url("${this.store.options.rotateCursor}"), auto`;
          }
        }
        if (!activePensLock && !activePensDisableResize) {
          for (let i = 0; i < 8; i++) {
            const firstFour = i < 4;
            const hotKeyIsResize = this.hotkeyType === HotkeyType.Resize || firstFour && !this.hotkeyType;
            if (hotKeyIsResize && hitPoint(pt, this.sizeCPs[i], this.pointSize)) {
              let cursors = firstFour ? defaultCursors : rotatedCursors;
              let offset = 0;
              if (Math.abs(this.activeRect.rotate % 90 - 45) < 25) {
                cursors = firstFour ? rotatedCursors : defaultCursors;
                offset = Math.round((this.activeRect.rotate - 45) / 90) + (firstFour ? 0 : 1);
              } else {
                offset = Math.round(this.activeRect.rotate / 90);
              }
              hoverType = HoverType.Resize;
              this.resizeIndex = i;
              this.externalElements.style.cursor = cursors[(i + offset) % 4];
              break;
            }
          }
        }
      }
      if (hoverType === HoverType.None) {
        hoverType = this.inPens(pt, this.store.data.pens);
      }
      if (!hoverType && !activeLine && pointInRect(pt, this.activeRect)) {
        hoverType = HoverType.Node;
        this.externalElements.style.cursor = "move";
      }
      this.hoverType = hoverType;
      if (hoverType === HoverType.None) {
        if (this.drawingLineName || this.pencil) {
          this.externalElements.style.cursor = "crosshair";
        } else if (!this.mouseDown) {
          this.externalElements.style.cursor = "default";
        }
        this.store.hover = void 0;
      }
      if (this.store.lastHover !== this.store.hover) {
        this.patchFlags = true;
        if (this.store.lastHover) {
          this.store.lastHover.calculative.hover = false;
          setHover(getParent(this.store.lastHover, true) || this.store.lastHover, false);
          this.store.emitter.emit("leave", this.store.lastHover);
          this.tooltip.hide();
        }
        if (this.store.hover) {
          this.store.hover.calculative.hover = true;
          setHover(getParent(this.store.hover, true) || this.store.hover);
          this.store.emitter.emit("enter", this.store.hover);
          this.tooltip.show(this.store.hover, pt);
        }
        this.store.lastHover = this.store.hover;
      }
      (_b = (_a = this.store.hover) == null ? void 0 : _a.onMouseMove) == null ? void 0 : _b.call(_a, this.store.hover, this.mousePos);
    });
    __publicField(this, "inPens", (pt, pens) => {
      var _a;
      let hoverType = HoverType.None;
      outer:
        for (let i = pens.length - 1; i >= 0; --i) {
          const pen = pens[i];
          if (pen.visible == false || pen.calculative.inView == false || pen.locked === LockState.Disable) {
            continue;
          }
          const r = getLineR(pen);
          if (!pen.calculative.active && !pointInSimpleRect(pt, pen.calculative.worldRect, r) && !pointInRect(pt, pen.calculative.worldRect)) {
            continue;
          }
          if (!this.store.data.locked && this.hotkeyType !== HotkeyType.Resize) {
            if (pen.calculative.worldAnchors) {
              for (const anchor of pen.calculative.worldAnchors) {
                hoverType = this.inAnchor(pt, pen, anchor);
                if (hoverType) {
                  let _anchor = deepClone(anchor);
                  Object.assign(_anchor, pt);
                  this.title.show(_anchor, pen);
                  break outer;
                }
              }
            }
          }
          if (pen.type) {
            if (pen.isRuleLine) {
              let ruleH = ((_a = this.store.options.ruleOptions) == null ? void 0 : _a.height) || 20;
              if (pt.x + this.store.data.x > ruleH && pt.y + this.store.data.y > ruleH) {
                break;
              }
            }
            const pos = pointInLine(pt, pen);
            if (pos) {
              if (!this.store.data.locked && !pen.locked) {
                if (this.hotkeyType === HotkeyType.AddAnchor) {
                  this.externalElements.style.cursor = "pointer";
                } else {
                  this.externalElements.style.cursor = "move";
                }
              } else {
                this.externalElements.style.cursor = this.store.options.hoverCursor;
              }
              if (pen.calculative.disabled) {
                this.externalElements.style.cursor = "not-allowed";
              }
              this.store.hover = pen;
              this.store.pointAt = pos.point;
              this.store.pointAtIndex = pos.i;
              this.initTemplateCanvas([this.store.hover]);
              hoverType = HoverType.Line;
              break;
            }
          } else {
            if (pen.children) {
              const pens2 = [];
              pen.children.forEach((id) => {
                this.store.pens[id] && pens2.push(this.store.pens[id]);
              });
              hoverType = this.inPens(pt, pens2);
              if (hoverType) {
                break;
              }
            }
            let isIn = false;
            if (pen.name === "line") {
              isIn = pointInSimpleRect(pt, pen.calculative.worldRect, pen.lineWidth);
            } else {
              isIn = pointInRect(pt, pen.calculative.worldRect);
            }
            if (isIn) {
              if (pen.type === PenType.Node && pen.name === "line") {
                let pIn = pointInPolygon(pt, pen.calculative.worldAnchors);
                if (!pIn) {
                  continue;
                }
              }
              if (!this.store.data.locked && !pen.locked) {
                if (this.hotkeyType === HotkeyType.AddAnchor) {
                  this.externalElements.style.cursor = "pointer";
                } else {
                  this.externalElements.style.cursor = "move";
                }
              } else {
                this.externalElements.style.cursor = this.store.options.hoverCursor;
              }
              if (pen.calculative.disabled) {
                this.externalElements.style.cursor = "not-allowed";
              }
              this.store.hover = pen;
              this.initTemplateCanvas([this.store.hover]);
              hoverType = HoverType.Node;
              this.store.pointAt = pt;
              if (!pt.ctrlKey) {
                let { x, y, ex, ey, rotate, center } = this.store.hover.calculative.worldRect;
                if (rotate) {
                  const pts = [
                    { x, y },
                    { x: ex, y },
                    { x: ex, y: ey },
                    { x, y: ey }
                  ];
                  pts.forEach((item) => {
                    rotatePoint(item, rotate, center);
                  });
                  let last = pts[pts.length - 1];
                  for (const item of pts) {
                    if (last.y > pt.y !== item.y > pt.y) {
                      const tempx = item.x + (pt.y - item.y) * (last.x - item.x) / (last.y - item.y);
                      if (Math.abs(tempx - this.store.pointAt.x) < 10) {
                        this.store.pointAt.x = tempx;
                      }
                    }
                    last = item;
                  }
                } else {
                  if (this.store.pointAt.x - 10 < x) {
                    this.store.pointAt.x = x;
                  } else if (this.store.pointAt.x + 10 > ex) {
                    this.store.pointAt.x = ex;
                  }
                  if (this.store.pointAt.y - 10 < y) {
                    this.store.pointAt.y = y;
                  } else if (this.store.pointAt.y + 10 > ey) {
                    this.store.pointAt.y = ey;
                  }
                }
              }
              break;
            }
          }
        }
      return hoverType;
    });
    __publicField(this, "dockInAnchor", (pt) => {
      var _a, _b;
      this.store.hover = void 0;
      for (let i = this.store.data.pens.length - 1; i >= 0; --i) {
        const pen = this.store.data.pens[i];
        if (pen.visible == false || pen.locked === LockState.Disable || pen === this.store.active[0]) {
          continue;
        }
        let r = getLineR(pen);
        r += 2 * this.store.options.anchorRadius;
        if (!pointInSimpleRect(pt, pen.calculative.worldRect, r)) {
          continue;
        }
        this.store.hover = pen;
        if (this.hotkeyType !== HotkeyType.Resize) {
          if (pen.calculative.worldAnchors) {
            for (const anchor of pen.calculative.worldAnchors) {
              if (anchor.twoWay === TwoWay.In) {
                const to = getToAnchor(this.store.active[0]);
                if (this.store.activeAnchor.id !== to.id) {
                  continue;
                }
              }
              if (anchor.twoWay === TwoWay.Out) {
                const from = getFromAnchor(this.store.active[0]);
                if (this.store.activeAnchor.id !== from.id) {
                  continue;
                }
              }
              if (anchor.twoWay === TwoWay.DisableConnected || anchor.twoWay === TwoWay.Disable || ((_a = this.store.activeAnchor) == null ? void 0 : _a.twoWay) === TwoWay.DisableConnectTo || ((_b = this.store.activeAnchor) == null ? void 0 : _b.twoWay) === TwoWay.Disable) {
                continue;
              }
              this.title.hide();
              if (this.inAnchor(pt, pen, anchor)) {
                let _anchor = deepClone(anchor);
                Object.assign(_anchor, pt);
                this.title.show(_anchor, pen);
                return true;
              }
            }
          }
        }
      }
    });
    __publicField(this, "imageTimer");
    __publicField(this, "templateImageTimer");
    __publicField(this, "render", (patchFlags) => {
      if (patchFlags) {
        this.opening = false;
      }
      if (this.opening) {
        return;
      }
      let now;
      if (patchFlags == null || patchFlags === true || patchFlags === Infinity) {
        now = performance.now();
        this.patchFlags = true;
      } else if (patchFlags > 1) {
        now = patchFlags;
      } else {
        now = performance.now();
      }
      if (!this.patchFlags) {
        return;
      }
      if (now - this.lastRender < this.store.options.interval) {
        if (this.renderTimer) {
          cancelAnimationFrame(this.renderTimer);
        }
        this.renderTimer = requestAnimationFrame(this.render);
        return;
      }
      this.renderTimer = void 0;
      this.lastRender = now;
      const offscreenCtx = this.offscreen.getContext("2d");
      offscreenCtx.clearRect(0, 0, this.offscreen.width, this.offscreen.height);
      offscreenCtx.save();
      offscreenCtx.translate(this.store.data.x, this.store.data.y);
      globalThis.debugRender && console.time("renderPens");
      this.renderPens();
      globalThis.debugRender && console.timeEnd("renderPens");
      this.renderBorder();
      this.renderHoverPoint();
      offscreenCtx.restore();
      this.magnifierCanvas.render();
      const ctx = this.canvas.getContext("2d");
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctx.drawImage(this.offscreen, 0, 0, this.width, this.height);
      this.canvasTemplate.render();
      this.canvasImageBottom.render();
      this.canvasImage.render();
      this.patchFlags = false;
    });
    __publicField(this, "renderPens", () => {
      const ctx = this.offscreen.getContext("2d");
      ctx.strokeStyle = this.store.styles.color;
      for (const pen of this.store.data.pens) {
        if (!isFinite(pen.x)) {
          continue;
        }
        if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
          continue;
        }
        if (pen.name === "combine" && !pen.draw) {
          continue;
        }
        if (pen.calculative.inView) {
          if (pen.canvasLayer === CanvasLayer.CanvasMain && pen.name !== "gif" && pen.image && pen.calculative.img) {
            ctx.save();
            ctxFlip(ctx, pen);
            if (pen.calculative.rotate) {
              ctxRotate(ctx, pen);
            }
            setGlobalAlpha(ctx, pen);
            drawImage(ctx, pen);
            ctx.restore();
          }
          renderPen(ctx, pen);
        }
      }
      if (this.drawingLine) {
        renderPen(ctx, this.drawingLine);
      }
      if (this.pencilLine) {
        renderPen(ctx, this.pencilLine);
      }
      if (this.movingPens) {
        this.movingPens.forEach((pen) => {
          this.renderPenContainChild(ctx, pen);
        });
      }
    });
    __publicField(this, "renderPenContainChild", (ctx, pen) => {
      var _a;
      if (pen.calculative.inView) {
        if (!(pen.name === "combine" && !pen.draw)) {
          renderPen(ctx, pen);
        }
      }
      (_a = pen.children) == null ? void 0 : _a.forEach((id) => {
        const child = this.store.pens[id];
        child && this.renderPenContainChild(ctx, child);
      });
    });
    __publicField(this, "renderBorder", () => {
      if (!this.store.data.locked) {
        if (this.activeRect && !(this.store.active.length === 1 && this.store.active[0].type) && !this.movingPens) {
          const ctx = this.offscreen.getContext("2d");
          ctx.save();
          ctx.translate(0.5, 0.5);
          const pivot = this.activeRect.pivot || this.activeRect.center;
          if (this.activeRect.rotate) {
            ctx.translate(pivot.x, pivot.y);
            ctx.rotate(this.activeRect.rotate * Math.PI / 180);
            ctx.translate(-pivot.x, -pivot.y);
          }
          ctx.strokeStyle = this.store.styles.activeColor;
          ctx.globalAlpha = this.store.options.activeGlobalAlpha === void 0 ? 0.3 : this.store.options.activeGlobalAlpha;
          ctx.beginPath();
          ctx.lineWidth = this.store.options.activeLineWidth || 1;
          ctx.setLineDash(this.store.options.activeLineDash || []);
          ctx.strokeRect(this.activeRect.x, this.activeRect.y, this.activeRect.width, this.activeRect.height);
          ctx.setLineDash([]);
          ctx.lineWidth = 1;
          ctx.globalAlpha = 1;
          if (getPensLock(this.store.active) || getPensDisableRotate(this.store.active) || this.store.options.disableRotate) {
            ctx.restore();
            return;
          }
          ctx.beginPath();
          ctx.moveTo(this.activeRect.center.x, this.activeRect.y);
          ctx.lineTo(this.activeRect.center.x, this.activeRect.y - 30);
          ctx.stroke();
          ctx.beginPath();
          ctx.strokeStyle = this.store.styles.activeColor;
          ctx.fillStyle = "#ffffff";
          ctx.arc(this.activeRect.center.x, this.activeRect.y - 30, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        }
      }
    });
    __publicField(this, "renderHoverPoint", () => {
      if (this.store.data.locked) {
        return;
      }
      const ctx = this.offscreen.getContext("2d");
      ctx.save();
      ctx.translate(0.5, 0.5);
      if (!this.store.options.disableAnchor && this.store.hover && !this.store.hover.disableAnchor && (this.hotkeyType !== HotkeyType.Resize || this.store.active.length !== 1 || this.store.active[0] !== this.store.hover)) {
        const anchors = [...this.store.hover.calculative.worldAnchors];
        if (this.store.pointAt && this.hotkeyType === HotkeyType.AddAnchor) {
          anchors.push(this.store.pointAt);
        }
        if (anchors) {
          ctx.strokeStyle = this.store.hover.anchorColor || this.store.styles.anchorColor;
          ctx.fillStyle = this.store.hover.anchorBackground || this.store.options.anchorBackground;
          anchors.forEach((anchor) => {
            if (anchor.hidden && anchor.locked > LockState.DisableEdit) {
              return;
            }
            if (anchor === this.store.hoverAnchor) {
              ctx.save();
              const hoverAnchorColor = this.store.hover.hoverAnchorColor || this.store.options.hoverAnchorColor;
              ctx.strokeStyle = hoverAnchorColor;
              ctx.fillStyle = hoverAnchorColor;
            }
            ctx.beginPath();
            let size = anchor.radius || this.store.hover.anchorRadius || this.store.options.anchorRadius;
            if (this.store.hover.type && !anchor.radius && !this.store.hover.anchorRadius) {
              size = 3;
              if (this.store.hover.calculative.lineWidth > 3) {
                size = this.store.hover.calculative.lineWidth;
              }
            }
            if (anchor.type === PointType.Line) {
              let _rotate = this.store.pens[anchor.penId].rotate || 0;
              if (this.store.pens[anchor.penId].calculative.flipX) {
                _rotate *= -1;
              }
              if (this.store.pens[anchor.penId].calculative.flipY) {
                _rotate *= -1;
              }
              let rotate = anchor.rotate + _rotate;
              if (this.store.pens[anchor.penId].calculative.flipX) {
                rotate *= -1;
              }
              if (this.store.pens[anchor.penId].calculative.flipY) {
                rotate *= -1;
              }
              ctx.save();
              ctx.translate(anchor.x, anchor.y);
              ctx.rotate(rotate * Math.PI / 180);
              ctx.translate(-anchor.x, -anchor.y);
              ctx.rect(anchor.x - anchor.length * this.store.data.scale / 2, anchor.y - size, anchor.length * this.store.data.scale, size * 2);
              ctx.restore();
            } else {
              ctx.arc(anchor.x, anchor.y, size, 0, Math.PI * 2);
            }
            if (this.store.hover.type && this.store.hoverAnchor === anchor) {
              ctx.save();
              ctx.strokeStyle = this.store.hover.activeColor || this.store.styles.activeColor;
              ctx.fillStyle = ctx.strokeStyle;
            } else if (anchor.color || anchor.background) {
              ctx.save();
              ctx.strokeStyle = anchor.color;
              ctx.fillStyle = anchor.background;
            }
            ctx.fill();
            ctx.stroke();
            if (anchor === this.store.hoverAnchor) {
              ctx.restore();
            }
            if (this.store.hover.type && this.store.hoverAnchor === anchor) {
              ctx.restore();
            } else if (anchor.color || anchor.background) {
              ctx.restore();
            }
            if (!this.store.hover.parentId && this.store.hover.children && this.store.hover.children.length > 0) {
              if (anchor === this.store.hoverAnchor) {
                ctx.save();
                ctx.beginPath();
                ctx.lineWidth = 3;
                const hoverAnchorColor = this.store.hover.hoverAnchorColor || this.store.options.hoverAnchorColor;
                if (globalThis.pSBC) {
                  ctx.strokeStyle = globalThis.pSBC(0.5, hoverAnchorColor);
                }
                ctx.arc(anchor.x, anchor.y, size + 1.5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
              }
            }
          });
        }
      }
      if (this.hotkeyType !== HotkeyType.AddAnchor && !this.movingPens && // 
      this.activeRect && !(this.store.active.length === 1 && this.store.active[0].type)) {
        if (!getPensLock(this.store.active) && !getPensDisableResize(this.store.active) && !this.store.options.disableSize) {
          ctx.strokeStyle = this.store.styles.activeColor;
          ctx.fillStyle = "#ffffff";
          this.sizeCPs.forEach((pt, i) => {
            if (this.activeRect.rotate) {
              ctx.save();
              ctx.translate(pt.x, pt.y);
              ctx.rotate(this.activeRect.rotate * Math.PI / 180);
              ctx.translate(-pt.x, -pt.y);
            }
            if (i < 4 || this.hotkeyType === HotkeyType.Resize) {
              ctx.beginPath();
              ctx.fillRect(pt.x - 4.5, pt.y - 4.5, 8, 8);
              ctx.strokeRect(pt.x - 5.5, pt.y - 5.5, 10, 10);
            }
            if (this.activeRect.rotate) {
              ctx.restore();
            }
          });
        }
      }
      if (!this.store.data.locked && this.dragRect) {
        ctx.save();
        ctx.fillStyle = rgba(this.store.options.dragColor, 0.2);
        ctx.strokeStyle = this.store.options.dragColor;
        ctx.beginPath();
        ctx.strokeRect(this.dragRect.x, this.dragRect.y, this.dragRect.width, this.dragRect.height);
        ctx.fillRect(this.dragRect.x, this.dragRect.y, this.dragRect.width, this.dragRect.height);
        ctx.restore();
      }
      if (this.dock) {
        ctx.strokeStyle = this.store.options.dockColor;
        if (this.dock.xDock) {
          ctx.beginPath();
          ctx.moveTo(this.dock.xDock.x, this.dock.xDock.y);
          ctx.lineTo(this.dock.xDock.x, this.dock.xDock.prev.y);
          ctx.stroke();
        }
        if (this.dock.yDock) {
          ctx.beginPath();
          ctx.moveTo(this.dock.yDock.x, this.dock.yDock.y);
          ctx.lineTo(this.dock.yDock.prev.x, this.dock.yDock.y);
          ctx.stroke();
        }
      }
      ctx.restore();
    });
    __publicField(this, "transTimeout");
    /**
     *
     * @param pen 
     * @param parentId  id
     * @param clipboard ,  origin  scale
     * @returns 
     */
    __publicField(this, "pastePen", (pen, parentId) => {
      const oldId = pen.id;
      randomId(pen);
      pen.parentId = parentId;
      if (pen.type === PenType.Line) {
        this.changeNodeConnectedLine(oldId, pen, this.store.clipboard.pens);
      } else {
        this.changeLineAnchors(oldId, pen, this.store.clipboard.pens);
      }
      if (!pen.parentId) {
        const rect = this.getPenRect(pen, this.store.clipboard.origin, this.store.clipboard.scale);
        const initRect = this.getPenRect(this.store.clipboard.initRect, this.store.clipboard.origin, this.store.clipboard.scale);
        const { origin, scale } = this.store.data;
        pen.x = origin.x + rect.x * scale;
        pen.y = origin.y + rect.y * scale;
        pen.width = rect.width * scale;
        pen.height = rect.height * scale;
        initRect.x = origin.x + initRect.x * scale;
        initRect.y = origin.y + initRect.y * scale;
        calcCenter(initRect);
        if (this.store.clipboard.pos) {
          pen.x -= initRect.center.x - this.store.clipboard.pos.x;
          pen.y -= initRect.center.y - this.store.clipboard.pos.y;
        }
        if (this.keyOptions && this.keyOptions.altKey && (this.keyOptions.ctrlKey || this.keyOptions.metaKey)) {
          pen.x = -this.store.data.x + this.width / 2 - pen.width / 2;
          pen.y = -this.store.data.y + this.height / 2 - pen.height / 2;
        } else if (this.keyOptions && this.keyOptions.shiftKey && (this.keyOptions.ctrlKey || this.keyOptions.metaKey || this.keyOptions.F)) {
        } else {
          pen.x += this.store.clipboard.offset * this.store.data.scale;
          pen.y += this.store.clipboard.offset * this.store.data.scale;
        }
      }
      this.makePen(pen);
      const newChildren = [];
      if (Array.isArray(pen.children)) {
        for (const childId of pen.children) {
          const childPen = this.store.clipboard.pens.find((pen2) => pen2.id === childId);
          childPen && newChildren.push(this.pastePen(childPen, pen.id).id);
        }
      }
      pen.children = newChildren;
      calcInView(pen, true);
      return pen;
    });
    __publicField(this, "ondblclick", (e) => {
      var _a;
      if (this.store.hover && (!this.store.data.locked || this.store.hover.dbInput) && !this.store.options.disableInput) {
        if (this.store.hover.onShowInput) {
          this.store.hover.onShowInput(this.store.hover, e);
        } else {
          if (this.store.hover && this.store.hover.parentId) {
            if (((_a = this.store.active) == null ? void 0 : _a.length) === 1 && this.store.active[0].id === this.store.hover.id) {
              this.showInput(this.store.hover);
            } else {
              this.store.pens[this.store.hover.parentId].children.forEach((id) => {
                this.store.pens[id].calculative.active = false;
                this.store.pens[id].calculative.hover = false;
              });
              this.active([this.store.hover]);
            }
          } else {
            this.showInput(this.store.hover);
          }
        }
      }
      this.store.emitter.emit("dblclick", {
        x: e.x,
        y: e.y,
        pen: this.store.hover
      });
    });
    __publicField(this, "showInput", (pen, rect, background = "transparent") => {
      if (!window || !this.store.hover || this.store.hover.locked || this.store.hover.externElement || this.store.hover.disableInput || this.store.hover.disabled) {
        return;
      }
      if (this.inputDiv.dataset.penId === pen.id) {
        this.inputDiv.dataset.isInput = "true";
        this.inputDiv.contentEditable = "true";
        this.inputDiv.focus();
        const range2 = window.getSelection();
        range2.selectAllChildren(this.inputDiv);
        range2.collapseToEnd();
        this.inputDiv.scrollTop = this.inputDiv.scrollHeight;
        this.inputDiv.scrollLeft = this.inputDiv.scrollWidth;
        return;
      }
      if (!rect && !pen.dbInput) {
        this.setInputStyle(pen);
      } else {
        this.inputDiv.style.width = "100%";
        this.inputDiv.style.height = "100%";
      }
      const textRect = rect || pen.calculative.worldTextRect;
      const preInputText = pen.calculative.tempText === void 0 ? pen.text + "" || "" : pen.calculative.tempText;
      const textArr = preInputText.replace(/\x20/g, "&nbsp;").split(/[\s\n]/);
      const finalText = `${textArr.join("</div><div>")}</div>`.replace("</div>", "").replace(/\<div\>\<\/div\>/g, "<div><br></div>");
      this.inputDiv.innerHTML = finalText;
      this.inputParent.style.left = textRect.x + this.store.data.x - (pen.calculative.textLeft || 0) + "px";
      this.inputParent.style.top = textRect.y + this.store.data.y - (pen.calculative.textTop || 0) + "px";
      let _width = textRect.width;
      this.inputParent.style.width = (_width < 0 ? 12 : _width) + "px";
      this.inputParent.style.height = textRect.height + (pen.textTop || 0) + "px";
      this.inputParent.style.zIndex = "9999";
      this.inputParent.style.background = background;
      if (pen.rotate % 360) {
        this.inputParent.style.transform = `rotate(${pen.rotate}deg)`;
      } else {
        this.inputParent.style.transform = null;
      }
      this.inputParent.style.display = "flex";
      this.inputDiv.dataset.penId = pen.id;
      this.inputDiv.contentEditable = pen.disableInput == void 0 ? "true" : pen.disableInput.toString();
      if (pen.dropdownList && this.dropdown.style.display !== "block") {
        this.dropdown.style.background = pen.dropdownBackground || "#fff";
        this.dropdown.style.color = pen.dropdownColor || "#bdc7db";
        this.dropdown.style.width = this.inputParent.style.width;
        this.dropdown.style.fontSize = (pen.fontSize || 12) + "px";
        this.setDropdownList();
        this.externalElements.style.zIndex = "9999";
      } else {
      }
      this.inputDiv.contentEditable = "true";
      this.inputDiv.focus();
      const range = window.getSelection();
      range.selectAllChildren(this.inputDiv);
      range.collapseToEnd();
      this.inputDiv.scrollTop = this.inputDiv.scrollHeight;
      this.inputDiv.scrollLeft = this.inputDiv.scrollWidth;
      pen.calculative.text = void 0;
      this.initTemplateCanvas([pen]);
      this.render();
    });
    __publicField(this, "setInputStyle", (pen) => {
      if (!pen.text) {
        pen.text = "";
      }
      let sheet;
      for (let i = 0; i < document.styleSheets.length; i++) {
        if (document.styleSheets[i].title === "le5le.com") {
          sheet = document.styleSheets[i];
        }
      }
      let style = "overflow: scroll;";
      let div_style = "";
      let font_scale = 1;
      const { scale } = this.store.data;
      if (pen.fontSize < 12) {
        font_scale = 12 / pen.fontSize;
      }
      if (pen.textAlign) {
        style += `text-align: ${pen.textAlign};`;
      } else {
        style += "text-align: center;";
      }
      if (pen.textAlign && pen.whiteSpace === "pre-line") {
        let textAlign = {
          left: "start",
          center: "center",
          right: "end"
        };
        style += `align-items: ${textAlign[pen.textAlign]};`;
      }
      if (pen.textBaseline) {
        let baseLine = {
          top: "start",
          middle: "center",
          bottom: "end"
        };
        style += `justify-content: ${baseLine[pen.textBaseline]};`;
      } else {
        style += "justify-content: center;";
      }
      if (pen.fontFamily) {
        style += `font-family: ${pen.fontFamily};`;
      }
      if (pen.fontSize) {
        if (pen.fontSize * scale < 12) {
          style += `font-size:${pen.fontSize}px;`;
          style += `zoom:${pen.fontSize / 12 * scale};`;
        } else {
          style += `font-size:${pen.fontSize * scale}px;`;
        }
      }
      style += `color:${getTextColor(pen, this.store)};`;
      if (pen.fontStyle) {
        style += `font-style: ${pen.fontStyle};`;
      }
      if (pen.fontWeight) {
        style += `font-weight: ${pen.fontWeight};`;
      }
      if (pen.textLeft) {
        style += `margin-left:${scale > 1 ? pen.textLeft * font_scale : pen.textLeft * font_scale / scale}px;`;
      }
      if (pen.textTop) {
        style += `margin-top:${scale > 1 ? pen.textTop * font_scale : pen.textTop * font_scale / scale}px;`;
      }
      if (pen.lineHeight) {
        style += `line-height:${scale > 1 ? pen.fontSize * pen.lineHeight * scale : pen.fontSize * pen.lineHeight * font_scale}px;`;
      }
      if (pen.textHeight) {
        style += `height:${scale > 1 ? pen.textHeight * font_scale * scale : pen.textHeight * font_scale}px;`;
      } else {
        let tem = pen.calculative.worldRect.height / scale;
        if (tem < 0) {
          tem = 0;
        }
        let height = pen.fontSize * scale < 12 ? tem * font_scale : tem * scale * font_scale;
        if (height < pen.fontSize * pen.lineHeight * scale) {
          height = pen.fontSize * pen.lineHeight * scale;
          style += `top:-${height / 2}px;`;
        }
        style += `height:${height}px;`;
      }
      let _textWidth = null;
      if (pen.textWidth) {
        _textWidth = pen.textWidth < 1 && pen.textWidth > -1 ? pen.textWidth * pen.calculative.worldRect.width : pen.textWidth;
        if (pen.whiteSpace !== "pre-line") {
          if (_textWidth < pen.fontSize) {
            style += `width:${pen.fontSize * 1.2 * font_scale}px;`;
          } else {
            style += `width:${scale > 1 ? _textWidth * font_scale * scale : _textWidth * font_scale}px;`;
          }
        }
      } else {
        if (pen.whiteSpace === void 0 || pen.whiteSpace === "break-all") {
          let tem = (pen.calculative.worldTextRect.width || 12) / scale;
          if (tem < 0) {
            tem = 0;
          }
          style += `width:${pen.fontSize * scale < 12 ? tem * font_scale : tem * scale}px;`;
        }
      }
      if (pen.whiteSpace) {
        if (pen.whiteSpace === "pre-line") {
          style += `white-space:pre;`;
        } else {
          style += `white-space:${pen.whiteSpace};`;
          if (pen.whiteSpace === "nowrap") {
            div_style += "display:contents;";
          }
        }
      }
      if (pen.whiteSpace !== "nowrap") {
        let textWidth = pen.fontSize * 1.2 * pen.text.length;
        let contentWidth = (_textWidth || pen.calculative.worldRect.width / scale) * Math.floor(pen.calculative.worldRect.height / scale / (pen.lineHeight * pen.fontSize));
        if (textWidth > contentWidth) {
          style += "justify-content: start;";
        }
      }
      sheet.deleteRule(0);
      sheet.deleteRule(0);
      sheet.insertRule(`.meta2d-input
      .input-div{
        resize:none;border:none;outline:none;background:transparent;position:absolute;flex-grow:1;height:100%;width: 100%;position:absolute;left:0;top:0;display:flex;flex-direction: column;cursor: text;${style}}`);
      sheet.insertRule(`.input-div div{${div_style}}`);
    });
    __publicField(this, "hideInput", () => {
      this.externalElements.style.zIndex = "5";
      if (this.inputParent.style.display === "flex") {
        this.inputParent.style.display = "none";
        const pen = this.store.pens[this.inputDiv.dataset.penId];
        if (!pen) {
          return;
        }
        pen.calculative.text = pen.text;
        this.inputDiv.dataset.value = this.inputDiv.innerHTML.replace(/\<div\>/g, "\n").replace(/\<\/div\>/g, "").replace(/\<br\>/g, "").replace(/&nbsp;/g, " ").replace(/(<([^>]+)>)/gi, "");
        this.inputDiv.dataset.value = this.convertSpecialCharacter(this.inputDiv.dataset.value);
        if (pen.onInput) {
          pen.onInput(pen, this.inputDiv.dataset.value);
        } else if (pen.text !== this.inputDiv.dataset.value) {
          const initPens = [deepClone(pen, true)];
          pen.text = this.inputDiv.dataset.value;
          pen.calculative.text = pen.text;
          this.inputDiv.dataset.penId = void 0;
          if (pen.text && pen.textAutoAdjust && !pen.parentId) {
            calcTextAutoWidth(pen);
          }
          calcTextRect(pen);
          this.patchFlags = true;
          this.pushHistory({
            type: EditType.Update,
            pens: [deepClone(pen, true)],
            initPens
          });
          this.store.emitter.emit("change", pen);
          this.store.emitter.emit("valueUpdate", pen);
        } else if (pen.text === this.inputDiv.dataset.value && pen.calculative.textLines.length == 0) {
          calcTextRect(pen);
        }
        this.initTemplateCanvas([pen]);
      }
      this.inputDiv.dataset.penId = void 0;
      this.dropdown.style.display = "none";
      this.inputDiv.dataset.isInput = "false";
      this.inputDiv.contentEditable = "false";
      this.render();
    });
    __publicField(this, "setDropdownList", (search) => {
      this.clearDropdownList();
      const pen = this.store.pens[this.inputDiv.dataset.penId];
      if (!this.store.data.locked && !["tablePlus"].includes(pen.name)) {
        return;
      }
      this.dropdown.style.display = "block";
      if (!pen || !pen.dropdownList) {
        this.dropdown.style.display = "none";
        return;
      }
      if (!pen.dropdownList.length) {
        const none = document.createElement("div");
        none.innerText = "None";
        none.style.padding = "5px 12px";
        none.style.color = "#ddd";
        this.dropdown.appendChild(none);
        return;
      }
      const text = this.inputDiv.innerHTML.replace(/\<div\>/g, "\n").replace(/\<\/div\>/g, "").replace(/\<br\>/g, "");
      let i = 0;
      for (const item of pen.dropdownList) {
        const t = typeof item === "string" ? item : item.text;
        if (search && text) {
          if (t.includes(text)) {
            this.dropdownAppendOption(t, i);
          }
        } else {
          this.dropdownAppendOption(t, i);
        }
        ++i;
      }
      if (!this.dropdown.hasChildNodes()) {
        const none = document.createElement("div");
        none.innerText = "None";
        none.style.padding = "5px 12px";
        none.style.color = "#ddd";
        this.dropdown.appendChild(none);
      }
    });
    __publicField(this, "selectDropdown", (e) => {
      const li = e.target;
      const pen = this.store.pens[this.inputDiv.dataset.penId];
      if (!li || !pen || !pen.dropdownList) {
        return;
      }
      const index = +li.dataset.i;
      const dropdown = pen.dropdownList[index];
      if (!dropdown) {
        return;
      }
      const initPens = [deepClone(pen, true)];
      if (typeof dropdown === "object") {
        this.updateValue(pen, { ...dropdown });
        pen.calculative.text = void 0;
        this.calcActiveRect();
      } else {
        pen.text = dropdown + "";
      }
      this.inputDiv.innerText = pen.text;
      this.hideInput();
      this.pushHistory({
        type: EditType.Update,
        pens: [deepClone(pen, true)],
        initPens
      });
      this.render();
      this.store.emitter.emit("change", pen);
      this.store.emitter.emit("valueUpdate", pen);
    });
    __publicField(this, "inFitBorder", (pt) => {
      let current = void 0;
      const width = this.store.data.width || this.store.options.width;
      const height = this.store.data.height || this.store.options.height;
      let point = {
        x: (pt.x - this.store.data.origin.x) / this.store.data.scale,
        y: (pt.y - this.store.data.origin.y) / this.store.data.scale
      };
      const fit = this.canvasImage.activeFit;
      this.externalElements.style.cursor = "default";
      if (point.y > height * fit.y - 10 && point.y < height * fit.y + 10) {
        current = "top";
        this.externalElements.style.cursor = "row-resize";
      }
      if (point.y > height * (fit.y + fit.height) - 10 && point.y < height * (fit.y + fit.height) + 10) {
        current = "bottom";
        this.externalElements.style.cursor = "row-resize";
      }
      if (point.x > width * fit.x - 10 && point.x < width * fit.x) {
        current = "left";
        this.externalElements.style.cursor = "col-resize";
      }
      if (point.x > width * (fit.x + fit.width) - 10 && point.x < width * (fit.x + fit.width) + 10) {
        current = "right";
        this.externalElements.style.cursor = "col-resize";
      }
      this.canvasImage.currentFit = current;
    });
    this.parent = parent;
    this.parentElement = parentElement;
    this.store = store;
    this.canvasTemplate = new CanvasTemplate(parentElement, store);
    this.canvasTemplate.canvas.style.zIndex = "1";
    this.canvasImageBottom = new CanvasImage(parentElement, store, true);
    this.canvasImageBottom.canvas.style.zIndex = "2";
    parentElement.appendChild(this.canvas);
    this.canvas.style.position = "absolute";
    this.canvas.style.backgroundRepeat = "no-repeat";
    this.canvas.style.backgroundSize = "100% 100%";
    this.canvas.style.zIndex = "3";
    this.canvasImage = new CanvasImage(parentElement, store);
    this.canvasImage.canvas.style.zIndex = "4";
    this.magnifierCanvas = new MagnifierCanvas(this, parentElement, store);
    this.magnifierCanvas.canvas.style.zIndex = "5";
    this.externalElements.style.position = "absolute";
    this.externalElements.style.left = "0";
    this.externalElements.style.top = "0";
    this.externalElements.style.outline = "none";
    this.externalElements.style.background = "transparent";
    this.externalElements.style.zIndex = "5";
    parentElement.style.position = "relative";
    parentElement.appendChild(this.externalElements);
    this.createInput();
    this.tooltip = new Tooltip(parentElement, store);
    this.tooltip.box.onmouseleave = (e) => {
      this.patchFlags = true;
      this.store.lastHover && (this.store.lastHover.calculative.hover = false);
      let hover = this.store.data.pens.find((item) => item.calculative.hover === true);
      setHover(hover, false);
    };
    this.popconfirm = new Popconfirm(parentElement, store);
    this.dialog = new Dialog(parentElement, store);
    this.title = new Title(parentElement);
    if (this.store.options.scroll) {
      this.scroll = new Scroll(this);
    }
    this.store.dpiRatio = globalThis.devicePixelRatio || 1;
    if (this.store.dpiRatio < 1) {
      this.store.dpiRatio = 1;
    } else if (this.store.dpiRatio > 1 && this.store.dpiRatio < 1.5) {
      this.store.dpiRatio = 1.5;
    }
    this.clientRect = this.externalElements.getBoundingClientRect();
    this.listen();
    window == null ? void 0 : window.addEventListener("resize", this.onResize);
    window == null ? void 0 : window.addEventListener("scroll", this.onScroll);
    window == null ? void 0 : window.addEventListener("message", this.onMessage);
  }
  listen() {
    this.externalElements.addEventListener("gesturestart", this.onGesturestart);
    this.externalElements.ondragover = (e) => e.preventDefault();
    this.externalElements.ondrop = this.ondrop;
    this.externalElements.oncontextmenu = (e) => e.preventDefault();
    this.store.options.interval = 50;
    this.externalElements.ontouchstart = this.ontouchstart;
    this.externalElements.ontouchmove = this.ontouchmove;
    this.externalElements.ontouchend = this.ontouchend;
    this.externalElements.onmousedown = (e) => {
      this.onMouseDown({
        x: e.offsetX,
        y: e.offsetY,
        clientX: e.clientX,
        clientY: e.clientY,
        pageX: e.pageX,
        pageY: e.pageY,
        ctrlKey: e.ctrlKey || e.metaKey,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        buttons: e.buttons
      });
    };
    this.externalElements.onmousemove = (e) => {
      if (e.target !== this.externalElements) {
        return;
      }
      this.onMouseMove({
        x: e.offsetX,
        y: e.offsetY,
        clientX: e.clientX,
        clientY: e.clientY,
        pageX: e.pageX,
        pageY: e.pageY,
        ctrlKey: e.ctrlKey || e.metaKey,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        buttons: e.buttons
      });
    };
    this.externalElements.onmouseup = (e) => {
      this.onMouseUp({
        x: e.offsetX,
        y: e.offsetY,
        clientX: e.clientX,
        clientY: e.clientY,
        pageX: e.pageX,
        pageY: e.pageY,
        ctrlKey: e.ctrlKey || e.metaKey,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        buttons: e.buttons,
        button: e.button
      });
    };
    this.externalElements.onmouseleave = (e) => {
      this.store.data.pens.forEach((pen) => {
        if (pen.calculative.hover) {
          pen.calculative.hover = false;
        }
      });
      if (this.store.hover) {
        this.store.hover.calculative.hover = false;
        this.store.hover = void 0;
      }
      this.render();
      if (e.toElement !== this.tooltip.box && e.toElement !== this.tooltip.arrowUp && e.toElement !== this.tooltip.arrowDown) {
        this.tooltip.hide();
        this.store.lastHover = void 0;
      }
    };
    this.externalElements.ondblclick = this.ondblclick;
    this.externalElements.tabIndex = 0;
    this.externalElements.onblur = () => {
      this.mouseDown = void 0;
    };
    this.externalElements.onwheel = this.onwheel;
    document.addEventListener("copy", this.onCopy);
    document.addEventListener("cut", this.onCut);
    document.addEventListener("paste", this.onPaste);
    switch (this.store.options.keydown) {
      case KeydownType.Document:
        document.addEventListener("keydown", this.onkeydown);
        document.addEventListener("keyup", this.onkeyup);
        break;
      case KeydownType.Canvas:
        this.externalElements.addEventListener("keydown", this.onkeydown);
        this.externalElements.addEventListener("keyup", this.onkeyup);
        break;
    }
  }
  /**
   * 
   * @param line 
   * @param anchor 
   */
  splitLine(line2, anchor) {
    const worldAnchors = line2.calculative.worldAnchors;
    const index = worldAnchors.findIndex((a) => a === anchor);
    if ([-1, 0, worldAnchors.length - 1].includes(index)) {
      return;
    }
    const initLine = deepClone(line2, true);
    const newLine = deepClone(line2, true);
    const id = s8();
    newLine.id = id;
    newLine.calculative.canvas = this;
    newLine.calculative.active = false;
    newLine.calculative.hover = false;
    const preAnchors = deepClone(worldAnchors.slice(0, index + 1));
    const laterAnchors = deepClone(worldAnchors.slice(index)).map((a) => {
      a.penId = id;
      return a;
    });
    line2.calculative.worldAnchors = preAnchors;
    newLine.calculative.worldAnchors = laterAnchors;
    this.initLineRect(line2);
    this.initLineRect(newLine);
    this.store.data.pens.push(newLine);
    this.store.pens[id] = newLine;
    this.pushHistory({
      type: EditType.Add,
      pens: [deepClone(newLine, true)],
      step: 2
    });
    this.pushHistory({
      type: EditType.Update,
      initPens: [initLine],
      pens: [deepClone(line2, true)],
      step: 2
    });
  }
  translateAnchor(x, y) {
    this.movingAnchor.x += x;
    this.movingAnchor.y += y;
    const penId = this.movingAnchor.penId;
    if (penId) {
      const pen = this.store.pens[penId];
      const rect = pen.calculative.worldRect;
      if (this.movingAnchor.x < rect.x) {
        this.movingAnchor.x = rect.x;
      } else if (this.movingAnchor.x > rect.ex) {
        this.movingAnchor.x = rect.ex;
      }
      if (this.movingAnchor.y < rect.y) {
        this.movingAnchor.y = rect.y;
      } else if (this.movingAnchor.y > rect.ey) {
        this.movingAnchor.y = rect.ey;
      }
      const anchor = calcRelativePoint(this.movingAnchor, rect);
      const index = pen.anchors.findIndex((anchor2) => anchor2.id === this.movingAnchor.id);
      pen.anchors[index] = anchor;
      this.patchFlags = true;
    }
  }
  async fileToPen(file2, isGif) {
    let url = "";
    if (this.store.options.uploadFn) {
      url = await this.store.options.uploadFn(file2);
    } else if (this.store.options.uploadUrl) {
      url = await uploadFile(file2, this.store.options.uploadUrl, this.store.options.uploadParams, this.store.options.uploadHeaders);
    } else {
      url = await fileToBase64(file2);
    }
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        globalStore.htmlElements[url] = img;
        resolve({
          width: img.width,
          height: img.height,
          name: isGif ? "gif" : "image",
          image: url
        });
      };
      img.onerror = (e) => {
        reject(e);
      };
      img.crossOrigin = "anonymous";
      img.src = url;
    });
  }
  async dropPens(pens, e) {
    var _a;
    this.randomIdObj = {};
    for (const pen of pens) {
      !pen.parentId && this.randomCombineId(pen, pens);
    }
    if (Object.keys(this.randomIdObj).length !== 0) {
      for (const pen of pens) {
        if (pen.type) {
          pen.anchors[0].connectTo = this.randomIdObj[pen.anchors[0].connectTo];
          pen.anchors[pen.anchors.length - 1].connectTo = this.randomIdObj[pen.anchors[pen.anchors.length - 1].connectTo];
        } else {
          (_a = pen.connectedLines) == null ? void 0 : _a.forEach((item) => {
            item.lineAnchor = this.randomIdObj[item.lineAnchor];
            item.lineId = this.randomIdObj[item.lineId];
          });
        }
      }
    }
    for (const pen of pens) {
      if (!pen.id) {
        pen.id = s8();
      }
      !pen.calculative && (pen.calculative = { canvas: this });
      this.store.pens[pen.id] = pen;
    }
    let num = 0;
    let lastH = 0;
    let lastW = 0;
    for (const pen of pens) {
      if (!pen.parentId) {
        pen.width *= this.store.data.scale;
        pen.height *= this.store.data.scale;
        pen.x = e.x - pen.width / 2 + lastW;
        pen.y = e.y - pen.height / 2 + lastH;
        if (pen.tags && pen.tags.includes("meta3d")) {
          pen.x = this.store.data.origin.x;
          pen.y = this.store.data.origin.y;
        }
        if (pen.dataset) {
          if (num % 2 === 0) {
            lastW = pen.width - 40 * this.store.data.scale;
          } else {
            lastW = 0;
          }
          num++;
          if (num % 2 === 0) {
            lastH += pen.height + 10 * this.store.data.scale;
          }
        }
      }
    }
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    if (width && height) {
      let rect = {
        x: this.store.data.origin.x,
        y: this.store.data.origin.y,
        width: width * this.store.data.scale,
        height: height * this.store.data.scale
      };
      let flag = true;
      for (const pen of pens) {
        if (!pen.parentId) {
          let points = [
            { x: pen.x, y: pen.y },
            { x: pen.x + pen.width, y: pen.y },
            { x: pen.x, y: pen.y + pen.height },
            { x: pen.x + pen.width, y: pen.y + pen.height },
            { x: pen.x + pen.width / 2, y: pen.y + pen.height / 2 }
          ];
          if (pen.x === rect.x && pen.y === rect.y && pen.width === rect.width && pen.height === rect.height || points.some((point) => pointInRect(point, rect))) {
            flag = false;
            if (this.store.options.strictScope) {
              if (pen.x < rect.x) {
                pen.x = rect.x;
              }
              if (pen.y < rect.y) {
                pen.y = rect.y;
              }
              if (pen.x + pen.width > rect.x + rect.width) {
                pen.x = rect.x + rect.width - pen.width;
              }
              if (pen.y + pen.height > rect.y + rect.height) {
                pen.y = rect.y + rect.height - pen.height;
              }
            }
            break;
          }
        }
      }
      if (flag) {
        console.info("");
        return;
      }
    }
    await this.addPens(pens, true);
    this.active(pens.filter((pen) => !pen.parentId));
    this.render();
    this.externalElements.focus();
  }
  randomCombineId(pen, pens, parentId) {
    let beforeIds = null;
    if (pen.type) {
      if (pen.anchors[0].connectTo || pen.anchors[pen.anchors.length - 1].connectTo) {
        beforeIds = [
          pen.id,
          pen.anchors[0].id,
          pen.anchors[pen.anchors.length - 1].id
        ];
      }
    } else {
      if (pen.connectedLines && pen.connectedLines.length) {
        beforeIds = [pen.id];
      }
    }
    randomId(pen);
    if (beforeIds) {
      if (beforeIds.length === 1) {
        this.randomIdObj[beforeIds[0]] = pen.id;
      } else {
        this.randomIdObj[beforeIds[0]] = pen.id;
        this.randomIdObj[beforeIds[1]] = pen.anchors[0].id;
        this.randomIdObj[beforeIds[2]] = pen.anchors[pen.anchors.length - 1].id;
      }
    }
    pen.parentId = parentId;
    const newChildren = [];
    if (Array.isArray(pen.children)) {
      for (const childId of pen.children) {
        const childPen = pens.find((pen2) => pen2.id === childId);
        childPen && newChildren.push(this.randomCombineId(childPen, pens, pen.id).id);
      }
    }
    pen.children = newChildren;
    return pen;
  }
  async addPens(pens, history2, abs2) {
    if (this.beforeAddPens && await this.beforeAddPens(pens) != true) {
      return [];
    }
    const list = [];
    for (const pen of pens) {
      if (this.beforeAddPen && this.beforeAddPen(pen) != true) {
        continue;
      }
      if (abs2) {
        pen.x = pen.x * this.store.data.scale + this.store.data.origin.x;
        pen.y = pen.y * this.store.data.scale + this.store.data.origin.y;
        pen.width = pen.width * this.store.data.scale;
        pen.height = pen.height * this.store.data.scale;
      }
      this.makePen(pen);
      list.push(pen);
    }
    this.render();
    this.store.emitter.emit("add", list);
    if (history2) {
      this.pushHistory({ type: EditType.Add, pens: deepClone(list, true) });
    }
    return list;
  }
  /**
   *  pencilLine
   * @param pt  penId
   */
  getInitPencilLine(pt) {
    const { data, options } = this.store;
    const scale = data.scale;
    const lineWidth = data.lineWidth || 1;
    return {
      id: pt.penId,
      name: "line",
      x: pt.x,
      y: pt.y,
      type: PenType.Line,
      calculative: {
        canvas: this,
        pencil: true,
        active: true,
        worldAnchors: [pt],
        lineWidth: lineWidth * scale
      },
      fromArrow: data.fromArrow || options.fromArrow,
      toArrow: data.toArrow || options.toArrow,
      lineWidth
    };
  }
  /**
   *  drawingLine
   * @param pt  penId
   */
  createDrawingLine(pt) {
    this.inactive();
    const { data, options } = this.store;
    const scale = data.scale;
    const lineWidth = data.lineWidth || 1;
    pt.penId = s8();
    return {
      id: pt.penId,
      name: "line",
      lineName: this.drawingLineName,
      x: pt.x,
      y: pt.y,
      type: PenType.Line,
      calculative: {
        canvas: this,
        active: true,
        worldAnchors: [pt],
        lineWidth: lineWidth * scale
      },
      fromArrow: data.fromArrow || options.fromArrow,
      toArrow: data.toArrow || options.toArrow,
      lineWidth
    };
  }
  addRuleLine(e) {
    const { x: offsetX, y: offsetY, scale, origin } = this.store.data;
    const x = e.x + offsetX;
    const y = e.y + offsetY;
    let lineX = e.x;
    let lineY = e.y;
    let width = 0;
    let height = 0;
    let otherPX = 0;
    let otherPY = 0;
    if (x <= y && x < 20) {
      lineX = -offsetX;
      width = this.width;
      otherPX = 1;
      if (!e.ctrlKey) {
        lineY = Math.round((lineY - origin.y) / (scale * 10)) * (scale * 10) + origin.y;
      }
    } else if (y < x && y < 20) {
      lineY = -offsetY;
      height = this.height;
      otherPY = 1;
      if (!e.ctrlKey) {
        lineX = Math.round((lineX - origin.x) / (scale * 10)) * (scale * 10) + origin.x;
      }
    } else {
      return;
    }
    this.addPen({
      isRuleLine: true,
      // locked: LockState.DisableMove,
      type: PenType.Line,
      name: "line",
      lineName: "line",
      x: lineX,
      y: lineY,
      width,
      height,
      color: this.store.options.ruleLineColor,
      anchors: [
        {
          x: 0,
          y: 0
        },
        {
          x: otherPX,
          y: otherPY
        }
      ]
    });
  }
  clearRuleLines() {
    this.delete(this.ruleLines);
  }
  get ruleLines() {
    return this.store.data.pens.filter((p) => p.isRuleLine);
  }
  /**
   * @description penpen
   * @author Joseph Ho
   * @date 14/11/2023
   * @memberof Canvas
   */
  alignPenToGrid(pen) {
    var _a;
    const autoAlignGrid = this.store.options.autoAlignGrid && this.store.data.grid;
    if (autoAlignGrid && !pen.type) {
      const gridSize = this.store.data.gridSize || this.store.options.gridSize;
      const { origin, scale } = this.store.data;
      const { x, y } = pen;
      const obj = { x, y };
      const rect = this.getPenRect(pen);
      const m = parseInt((rect.x / gridSize).toFixed());
      const n = parseInt((rect.y / gridSize).toFixed());
      const x1 = m * gridSize;
      const y1 = n * gridSize;
      obj.x = origin.x + x1 * scale;
      obj.y = origin.y + y1 * scale;
      Object.assign(pen, obj);
      (_a = pen.onMove) == null ? void 0 : _a.call(pen, pen);
      this.updatePenRect(pen);
      this.calcActiveRect();
      this.getSizeCPs();
    }
  }
  /**
   *  active.pens
   */
  movedActivePens(readyConnect) {
    let movedPens = this.getAllFollowersByPens(this.store.active, false);
    const initPens = deepClone(movedPens, true);
    const gridSize = this.store.data.gridSize || this.store.options.gridSize;
    const { origin, scale } = this.store.data;
    const autoAlignGrid = this.store.options.autoAlignGrid && this.store.data.grid;
    movedPens.forEach((pen) => {
      var _a;
      const i = this.movingPens.findIndex((item) => item.id === pen.id + movingSuffix);
      if (i < 0) {
        return;
      }
      const { x, y } = this.movingPens[i];
      const obj = { x, y };
      if (autoAlignGrid && !this.movingPens[i].type) {
        const rect = this.getPenRect(this.movingPens[i]);
        const m = parseInt((rect.x / gridSize).toFixed());
        const n = parseInt((rect.y / gridSize).toFixed());
        const x1 = m * gridSize;
        const y1 = n * gridSize;
        obj.x = origin.x + x1 * scale;
        obj.y = origin.y + y1 * scale;
      }
      Object.assign(pen, obj);
      (_a = pen.onMove) == null ? void 0 : _a.call(pen, pen);
      this.updatePenRect(pen);
      this.updateLines(pen);
      this.store.emitter.emit("updateLines", pen);
      this.patchFlagsLines.forEach((pen2) => {
        if (pen2.type) {
          this.initLineRect(pen2);
        }
      });
      this.patchFlagsLines.clear();
      pen.calculative.x = pen.x;
      pen.calculative.y = pen.y;
      if (pen.calculative.initRect) {
        pen.calculative.initRect.x = pen.calculative.x;
        pen.calculative.initRect.y = pen.calculative.y;
        pen.calculative.initRect.ex = pen.calculative.x + pen.calculative.width;
        pen.calculative.initRect.ey = pen.calculative.y + pen.calculative.height;
      }
      calcChildrenInitRect(pen);
      if (pen.parentId) {
        this.parent.updateRectbyChild(pen.calculative.worldRect, pen, this.store.pens[pen.parentId]);
      }
    });
    this.initImageCanvas(this.store.active);
    this.initTemplateCanvas(this.store.active);
    if (!this.dock)
      return;
    const { xDock, yDock } = this.dock;
    let dockPen;
    if (xDock) {
      dockPen = this.store.pens[xDock.penId];
    }
    if (!dockPen && yDock) {
      dockPen = this.store.pens[yDock.penId];
    }
    const pens = deepClone(this.store.active, true);
    if (readyConnect && this.store.active.length === 1 && (dockPen == null ? void 0 : dockPen.type) === 1 && ((xDock == null ? void 0 : xDock.anchorId) || (yDock == null ? void 0 : yDock.anchorId))) {
      const from = getFromAnchor(dockPen);
      const to = getToAnchor(dockPen);
      if (xDock == null ? void 0 : xDock.anchorId) {
        const anchor = this.store.pens[this.store.active[0].id + movingSuffix].calculative.worldAnchors.find((item) => item.id === xDock.anchorId);
        if (anchor.x === from.x && anchor.y === from.y) {
          initPens.push(deepClone(dockPen, true));
          connectLine(this.store.active[0], anchor, dockPen, from);
          pens.push(deepClone(dockPen, true));
        } else if (anchor.x === to.x && anchor.y === to.y) {
          initPens.push(deepClone(dockPen, true));
          connectLine(this.store.active[0], anchor, dockPen, to);
          pens.push(deepClone(dockPen, true));
        }
      } else if (yDock == null ? void 0 : yDock.anchorId) {
        const anchor = this.store.pens[this.store.active[0].id + movingSuffix].calculative.worldAnchors.find((item) => item.id === yDock.anchorId);
        if (anchor.x === from.x && anchor.y === from.y) {
          initPens.push(deepClone(dockPen, true));
          connectLine(this.store.active[0], anchor, dockPen, from);
          pens.push(deepClone(dockPen, true));
        } else if (anchor.x === to.x && anchor.y === to.y) {
          initPens.push(deepClone(dockPen, true));
          connectLine(this.store.active[0], anchor, dockPen, to);
          pens.push(deepClone(dockPen, true));
        }
      }
    }
    if (autoAlignGrid) {
      this.calcActiveRect();
      this.getSizeCPs();
    }
    this.pushHistory({
      type: EditType.Update,
      pens,
      initPens
    });
    this.store.emitter.emit("translatePens", pens);
  }
  /**
   * 
   */
  copyMovedPens() {
    this.copy(this.store.active.map((pen, i) => {
      const { x, y } = this.movingPens[i];
      this.updateLines(pen);
      return {
        ...pen,
        x,
        y
      };
    }));
    this.pasteOffset = false;
    this.paste();
  }
  /**
   *  or  or 
   * 
   * @param pens  pens
   */
  initImageCanvas(pens) {
    pens.some((pen) => this.hasImage(pen, false)) && this.canvasImage.init();
    pens.some((pen) => this.hasImage(pen, true)) && this.canvasImageBottom.init();
  }
  initTemplateCanvas(pens) {
    pens.some((pen) => pen.canvasLayer === CanvasLayer.CanvasTemplate) && this.canvasTemplate.init();
  }
  hasImage(pen, isBottom) {
    var _a;
    if (pen.image && pen.name !== "gif") {
      if (isBottom) {
        if (pen.canvasLayer === CanvasLayer.CanvasImageBottom) {
          return true;
        } else {
          return false;
        }
      } else {
        if (pen.canvasLayer === CanvasLayer.CanvasImage) {
          return true;
        } else {
          return false;
        }
      }
    }
    return (_a = pen.children) == null ? void 0 : _a.some((childId) => {
      const child = this.store.pens[childId];
      return child && this.hasImage(child, isBottom);
    });
  }
  inactive(drawing) {
    if (!this.store.active.length) {
      return;
    }
    this.initTemplateCanvas(this.store.active);
    this.store.active.forEach((pen) => {
      pen.calculative.active = void 0;
      pen.calculative.activeAnchor = void 0;
      pen.calculative.hover = false;
      setChildrenActive(pen, false);
    });
    !drawing && this.store.emitter.emit("inactive", this.store.active);
    this.store.active = [];
    this.activeRect = void 0;
    this.sizeCPs = void 0;
    this.store.activeAnchor = void 0;
    this.patchFlags = true;
  }
  active(pens, emit = true) {
    if (this.store.active) {
      emit && this.store.emitter.emit("inactive", this.store.active);
      for (const pen of this.store.active) {
        pen.calculative.active = void 0;
        pen.calculative.hover = false;
        setChildrenActive(pen, false);
      }
    }
    this.store.active = [];
    pens.forEach((pen) => {
      pen.calculative.active = true;
      setChildrenActive(pen);
    });
    this.store.active.push(...pens);
    this.activeRect = void 0;
    this.calcActiveRect();
    this.initTemplateCanvas(pens);
    this.patchFlags = true;
    emit && this.store.emitter.emit("active", this.store.active);
  }
  getSizeCPs() {
    this.sizeCPs = rectToPoints(this.activeRect);
    const pts = [
      { x: 0.5, y: 0 },
      { x: 1, y: 0.5 },
      { x: 0.5, y: 1 },
      { x: 0, y: 0.5 }
    ];
    const { x, y, width, height, rotate, center } = this.activeRect;
    pts.forEach((pt) => {
      const p = {
        x: pt.x * width + x,
        y: pt.y * height + y
      };
      rotatePoint(p, rotate, center);
      this.sizeCPs.push(p);
    });
  }
  getSpecialAngle(to, last) {
    let angle = 0;
    let angleArr = [0, 30, 45, 60, 90, 120, 150, 135, 180];
    if (to.x - last.x !== 0) {
      angle = Math.atan((last.y - to.y) / (to.x - last.x)) * 180 / Math.PI;
      if (to.x < last.x) {
        if (angle > 0) {
          angle -= 180;
        } else {
          angle += 180;
        }
      }
    } else {
      if (last.y > to.y) {
        angle = 90;
      } else if (last.y < to.y) {
        angle = -90;
      }
    }
    angle = Math.round(angle / 15) * 15;
    let length = Math.sqrt((last.x - to.x) * (last.x - to.x) + (last.y - to.y) * (last.y - to.y));
    to.x = last.x + Math.cos(angle / 180 * Math.PI) * length;
    to.y = last.y - Math.sin(angle / 180 * Math.PI) * length;
  }
  clearHover() {
    this.hoverType = HoverType.None;
    this.store.hover = null;
    this.store.hoverAnchor = null;
  }
  inAnchor(pt, pen, anchor) {
    var _a;
    this.store.hoverAnchor = void 0;
    this.movingAnchor = void 0;
    if (!anchor || anchor.locked > LockState.DisableEdit) {
      return HoverType.None;
    }
    if (!(pen.type && pen.calculative.active) && this.store.options.disableAnchor || pen.disableAnchor) {
      return HoverType.None;
    }
    if ((this.mouseDown || this.drawingLine) && pen.name === "line" && anchor.connectTo) {
      const connectPen = this.findOne(anchor.connectTo);
      if ((connectPen == null ? void 0 : connectPen.calculative) && !(connectPen == null ? void 0 : connectPen.calculative.active)) {
        pen = connectPen;
        const connectAnchor = connectPen.calculative.worldAnchors.find((item) => item.id === anchor.anchorId);
        connectAnchor && (anchor = connectAnchor);
      }
    }
    if (anchor.twoWay === TwoWay.Disable && pen.name !== "line") {
      return HoverType.None;
    }
    if (pen.name === "line" && anchor.connectTo) {
      let _anchor = (_a = this.findOne(anchor.connectTo)) == null ? void 0 : _a.anchors.find((item) => item.id === anchor.anchorId);
      if (_anchor && _anchor.twoWay) {
        return HoverType.None;
      }
    }
    if (this.drawingLine) {
      if (anchor.twoWay === TwoWay.Out) {
        return HoverType.None;
      }
    } else {
      if (this.mouseDown && this.hoverType === HoverType.LineAnchor) {
      } else if (anchor.twoWay === TwoWay.In) {
        return HoverType.None;
      }
    }
    if (hitPoint(pt, anchor, this.pointSize, anchor.penId ? this.store.pens[anchor.penId] : void 0)) {
      if (anchor !== this.store.hoverAnchor) {
        this.patchFlags = true;
      }
      this.store.hoverAnchor = anchor;
      this.store.hover = pen;
      if (pen.type) {
        if (anchor.connectTo && !pen.calculative.active) {
          this.store.hover = this.store.pens[anchor.connectTo];
          if (this.store.hover) {
            this.store.hoverAnchor = this.store.hover.calculative.worldAnchors.find((a) => a.id === anchor.anchorId);
            if (!this.store.hoverAnchor) {
              return HoverType.None;
            }
            this.externalElements.style.cursor = "crosshair";
            return HoverType.NodeAnchor;
          }
        }
        if (this.hotkeyType === HotkeyType.AddAnchor) {
          this.externalElements.style.cursor = "vertical-text";
        } else {
          this.externalElements.style.cursor = "pointer";
        }
        return HoverType.LineAnchor;
      }
      if (this.hotkeyType === HotkeyType.AddAnchor) {
        this.externalElements.style.cursor = "vertical-text";
      } else {
        this.externalElements.style.cursor = "crosshair";
      }
      return HoverType.NodeAnchor;
    }
    if (!this.mouseDown && pen.type) {
      if (pen.calculative.active && anchor.prev && hitPoint(pt, anchor.prev, this.pointSize)) {
        this.store.hoverAnchor = anchor;
        this.store.hover = pen;
        this.externalElements.style.cursor = "pointer";
        return HoverType.LineAnchorPrev;
      }
      if (pen.calculative.active && anchor.next && hitPoint(pt, anchor.next, this.pointSize)) {
        this.store.hoverAnchor = anchor;
        this.store.hover = pen;
        this.externalElements.style.cursor = "pointer";
        return HoverType.LineAnchorNext;
      }
    }
    return HoverType.None;
  }
  resize(w, h) {
    w = w || this.parentElement.clientWidth;
    h = h || this.parentElement.clientHeight;
    this.width = w;
    this.height = h;
    this.canvasRect = {
      x: 0,
      y: 0,
      width: w,
      height: h
    };
    calcRightBottom(this.canvasRect);
    this.canvas.style.width = w + "px";
    this.canvas.style.height = h + "px";
    this.externalElements.style.width = w + "px";
    this.externalElements.style.height = h + "px";
    this.canvasTemplate.resize(w, h);
    this.canvasImage.resize(w, h);
    this.canvasImageBottom.resize(w, h);
    this.magnifierCanvas.resize(w, h);
    w = w * this.store.dpiRatio | 0;
    h = h * this.store.dpiRatio | 0;
    this.canvas.width = w;
    this.canvas.height = h;
    this.offscreen.width = w;
    this.offscreen.height = h;
    this.clientRect = this.externalElements.getBoundingClientRect();
    this.canvas.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio);
    this.offscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio);
    this.offscreen.getContext("2d").textBaseline = "middle";
    for (const pen of this.store.data.pens) {
      if (pen.isRuleLine) {
        if (!pen.width) {
          pen.height = this.height;
        } else if (!pen.height) {
          pen.width = this.width;
        }
      }
      calcInView(pen);
    }
    this.render();
  }
  clearCanvas() {
    this.activeRect = void 0;
    this.sizeCPs = void 0;
    this.canvas.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.offscreen.getContext("2d").clearRect(0, 0, this.offscreen.width, this.offscreen.height);
    if (!this.store.data.template) {
      this.canvasTemplate.clear();
    }
    this.canvasImage.clear();
    this.canvasImageBottom.clear();
  }
  async addPen(pen, history2, emit, abs2) {
    if (this.beforeAddPens && await this.beforeAddPens([pen]) != true) {
      return;
    }
    if (this.beforeAddPen && this.beforeAddPen(pen) != true) {
      return;
    }
    if (abs2) {
      pen.x = pen.x * this.store.data.scale + this.store.data.origin.x;
      pen.y = pen.y * this.store.data.scale + this.store.data.origin.y;
      pen.width = pen.width * this.store.data.scale;
      pen.height = pen.height * this.store.data.scale;
    }
    this.makePen(pen);
    this.active([pen]);
    this.render();
    emit && this.store.emitter.emit("add", [pen]);
    if (history2) {
      this.pushHistory({ type: EditType.Add, pens: [pen] });
    }
    return pen;
  }
  pushHistory(action) {
    var _a;
    if (this.store.data.locked) {
      return;
    }
    const { origin, scale } = this.store.data;
    action.origin = deepClone(origin);
    action.scale = scale;
    if (action.type !== EditType.Update && action.pens) {
      action.pens.forEach((pen) => {
        pen.calculative && (pen.calculative.layer = this.store.data.pens.findIndex((p) => p.id === pen.id));
      });
    }
    if (this.store.historyIndex < this.store.histories.length - 1) {
      this.store.histories.splice(this.store.historyIndex + 1, this.store.histories.length - this.store.historyIndex - 1);
    }
    (_a = action.pens) == null ? void 0 : _a.forEach((pen) => {
      let found;
      if (action.initPens) {
        for (const p of action.initPens) {
          if (p.id === pen.id) {
            found = p;
          }
        }
      }
      if (found) {
        for (const k in pen) {
          if (found[k] == void 0) {
            found[k] = void 0;
          }
        }
      }
    });
    this.store.histories.push(action);
    this.store.historyIndex = this.store.histories.length - 1;
    this.store.emitter.emit("update", {
      previous: action.initPens,
      current: action.pens
    });
  }
  undo() {
    if (this.store.data.locked || this.store.historyIndex == null || this.store.historyIndex < 0) {
      return;
    }
    const action = this.store.histories[this.store.historyIndex--];
    this.doEditAction(action, true);
    let step = action.step;
    while (step > 1) {
      const action2 = this.store.histories[this.store.historyIndex--];
      this.doEditAction(action2, true);
      step--;
    }
    if (action.type == EditType.Add || action.type == EditType.Delete || action.type == EditType.Update) {
      this.activeHistory();
    }
  }
  redo() {
    if (this.store.data.locked || this.store.historyIndex == null || this.store.historyIndex > this.store.histories.length - 2) {
      return;
    }
    const action = this.store.histories[++this.store.historyIndex];
    this.doEditAction(action, false);
    let step = action.step;
    while (step > 1) {
      const action2 = this.store.histories[++this.store.historyIndex];
      this.doEditAction(action2, false);
      step--;
    }
    if (action.type == EditType.Add || action.type == EditType.Delete || action.type == EditType.Update) {
      this.activeHistory();
    }
  }
  activeHistory() {
    let now = this.store.histories[this.store.historyIndex + 1];
    const pens = [];
    if (now && now.type === EditType.Update) {
      now.pens.forEach((pen) => {
        pens.push(this.store.pens[pen.id]);
      });
      this.active(pens);
      return;
    }
    let before = this.store.histories[this.store.historyIndex];
    if (before && (before.type === EditType.Add || before.type === EditType.Delete)) {
      before.pens.forEach((pen) => {
        pens.push(this.store.pens[pen.id]);
      });
      this.active(pens);
    }
  }
  doEditAction(action, undo) {
    this.inactive();
    this.store.hoverAnchor = void 0;
    this.store.hover = void 0;
    switch (action.type) {
      case EditType.Add:
        action.pens.forEach((aPen) => {
          var _a;
          const pen = deepClone(aPen, true);
          const i = this.store.data.pens.findIndex((item) => item.id === pen.id);
          if (i > -1) {
            (_a = pen.onDestroy) == null ? void 0 : _a.call(pen, this.store.pens[pen.id]);
            this.store.data.pens.splice(i, 1);
            this.store.pens[pen.id] = void 0;
            if (!pen.calculative) {
              pen.calculative = {};
            }
            pen.calculative.canvas = this;
            this.store.animates.delete(pen);
            this.store.animateMap.delete(pen);
          }
        });
        action.type = EditType.Delete;
        break;
      case EditType.Update:
        const pens = undo ? action.initPens : action.pens;
        const unPens = undo ? action.pens : action.initPens;
        pens.forEach((p) => {
          const pen = deepClone(p, true);
          const i = this.store.data.pens.findIndex((item) => item.id === pen.id);
          if (i > -1) {
            pen.calculative = this.store.data.pens[i].calculative;
            if (this.store.data.pens[i].type && this.store.data.pens[i].lastConnected) {
              for (let key in this.store.data.pens[i].lastConnected) {
                if (this.store.pens[key]) {
                  let connected = deepClone(this.store.data.pens[i].lastConnected[key]);
                  this.store.pens[key].connectedLines = connected;
                  pen.anchors.forEach((anchor) => {
                    connected.forEach((item) => {
                      if (anchor.id === item.lineAnchor) {
                        anchor.connectTo = key;
                      }
                    });
                  });
                }
              }
            }
            this.store.data.pens[i] = pen;
            this.store.pens[pen.id] = pen;
            for (const k in pen) {
              if (typeof pen[k] !== "object" || k === "lineDash") {
                pen.calculative[k] = pen[k];
              }
            }
            pen.calculative.image = void 0;
            const rect = this.getPenRect(pen, action.origin, action.scale);
            this.setPenRect(pen, rect, false);
            this.updateLines(pen, true);
            if (pen.calculative.canvas.parent.isCombine(pen)) {
              let unPen = unPens.find((item) => item.id === pen.id);
              inheritanceProps.forEach((key) => {
                if (pen[key] !== unPen[key]) {
                  this.parent.setValue({ id: pen.id, [key]: pen[key] }, { render: true, doEvent: false });
                }
              });
            }
          }
        });
        break;
      case EditType.Delete:
        action.pens.reverse().forEach((aPen) => {
          var _a, _b;
          const pen = deepClone(aPen, true);
          if (!pen.calculative) {
            pen.calculative = {};
          }
          this.store.data.pens.splice(((_a = pen.calculative) == null ? void 0 : _a.layer) !== -1 ? (_b = pen.calculative) == null ? void 0 : _b.layer : this.store.data.pens.length, 0, pen);
          this.store.pens[pen.id] = pen;
          if (pen.type && pen.lastConnected) {
            for (let key in pen.lastConnected) {
              this.store.pens[key] && (this.store.pens[key].connectedLines = pen.lastConnected[key]);
            }
          }
          pen.calculative.canvas = this;
        });
        action.pens.reverse().forEach((aPen) => {
          const pen = this.store.pens[aPen.id];
          const rect = this.getPenRect(pen, action.origin, action.scale);
          this.setPenRect(pen, rect, false);
          pen.calculative.image = void 0;
          pen.calculative.backgroundImage = void 0;
          pen.calculative.strokeImage = void 0;
          this.loadImage(pen);
        });
        action.type = EditType.Add;
        break;
      case EditType.Replace: {
        const pens2 = undo ? action.initPens : action.pens;
        const unPens2 = undo ? action.pens : action.initPens;
        unPens2.forEach((aPen) => {
          var _a;
          const pen = deepClone(aPen, true);
          const i = this.store.data.pens.findIndex((item) => item.id === pen.id);
          if (i > -1) {
            (_a = pen.onDestroy) == null ? void 0 : _a.call(pen, this.store.data.pens.find((i3) => i3.id === pen.id));
            const i2 = this.store.data.pens.findIndex((item) => item.id === pen.id);
            this.store.data.pens.splice(i2, 1);
            this.store.pens[pen.id] = void 0;
            if (!pen.calculative) {
              pen.calculative = {};
            }
            pen.calculative.canvas = this;
            this.store.animates.delete(pen);
            this.store.animateMap.delete(pen);
          }
        });
        pens2.reverse().forEach((aPen) => {
          var _a, _b;
          const pen = deepClone(aPen, true);
          if (!pen.calculative) {
            pen.calculative = {};
          }
          this.store.data.pens.splice(((_a = pen.calculative) == null ? void 0 : _a.layer) !== -1 ? (_b = pen.calculative) == null ? void 0 : _b.layer : this.store.data.pens.length, 0, pen);
          this.store.pens[pen.id] = pen;
          if (pen.type && pen.lastConnected) {
            for (let key in pen.lastConnected) {
              this.store.pens[key] && (this.store.pens[key].connectedLines = pen.lastConnected[key]);
            }
          }
          pen.calculative.canvas = this;
        });
        pens2.reverse().forEach((aPen) => {
          const pen = this.store.data.pens.find((i) => i.id === aPen.id);
          const rect = this.getPenRect(pen, action.origin, action.scale);
          this.setPenRect(pen, rect, false);
          pen.calculative.image = void 0;
          pen.calculative.backgroundImage = void 0;
          pen.calculative.strokeImage = void 0;
          this.loadImage(pen);
        });
        action.type = EditType.Replace;
        break;
      }
    }
    if (action.type === EditType.Update) {
      let pens = [...action.pens, ...action.initPens];
      this.initImageCanvas(pens);
      this.initTemplateCanvas(pens);
    } else {
      this.initImageCanvas(action.pens);
      this.initTemplateCanvas(action.pens);
    }
    this.parent.onSizeUpdate();
    this.render();
    this.store.emitter.emit(undo ? "undo" : "redo", action);
  }
  makePen(pen) {
    var _a;
    if (!pen.id) {
      pen.id = s8();
    }
    if (Math.abs(this.store.lastScale - this.store.data.scale) < 1e-4 && this.store.sameTemplate && this.store.templatePens[pen.id] && // pen.template
    pen.canvasLayer === CanvasLayer.CanvasTemplate) {
      pen = this.store.templatePens[pen.id];
      this.store.data.pens.push(pen);
      this.updatePenRect(pen);
      return;
    }
    if (pen.copyIndex) {
      this.store.data.pens.splice(pen.copyIndex + 1, 0, pen);
      delete pen.copyIndex;
    } else {
      this.store.data.pens.push(pen);
    }
    this.store.pens[pen.id] = pen;
    if (pen.path) {
      !pen.pathId && (pen.pathId = s8());
      const paths = this.store.data.paths;
      !paths[pen.pathId] && (paths[pen.pathId] = pen.path);
      pen.path = void 0;
    }
    if (pen.lineWidth == void 0) {
      pen.lineWidth = 1;
    }
    const { fontSize, lineHeight } = this.store.options;
    if (!pen.fontSize) {
      pen.fontSize = fontSize >= 0 ? fontSize : 12;
    } else if (pen.fontSize < 0) {
      pen.fontSize = 0;
    }
    if (!pen.lineHeight) {
      pen.lineHeight = lineHeight;
    }
    if (pen.image && pen.name !== "gif" && pen.canvasLayer === void 0) {
      if (pen.isBottom) {
        pen.canvasLayer = CanvasLayer.CanvasImageBottom;
      } else {
        pen.canvasLayer = CanvasLayer.CanvasImage;
      }
      delete pen.isBottom;
    }
    if (pen.template) {
      pen.canvasLayer = CanvasLayer.CanvasTemplate;
    }
    pen.calculative = { canvas: this, singleton: (_a = pen.calculative) == null ? void 0 : _a.singleton };
    if (pen.video || pen.audio) {
      pen.calculative.onended = (pen2) => {
        this.nextAnimate(pen2);
      };
    }
    for (const k in pen) {
      if (typeof pen[k] !== "object" || k === "lineDash") {
        pen.calculative[k] = pen[k];
      }
    }
    pen.calculative.image = void 0;
    pen.calculative.backgroundImage = void 0;
    pen.calculative.strokeImage = void 0;
    if (!pen.anchors && globalStore.anchors[pen.name]) {
      if (!pen.anchors) {
        pen.anchors = [];
      }
      globalStore.anchors[pen.name](pen);
    }
    if (!pen.anchors) {
      const anchors = deepClone(this.store.options.defaultAnchors);
      anchors.forEach((item, index) => {
        item.id = `${index}`;
        item.penId = pen.id;
      });
      pen.anchors = anchors;
    }
    this.updatePenRect(pen);
    if (!pen.anchors && pen.calculative.worldAnchors) {
      pen.anchors = pen.calculative.worldAnchors.map((pt) => {
        return calcRelativePoint(pt, pen.calculative.worldRect);
      });
    }
    !pen.rotate && (pen.rotate = 0);
    this.loadImage(pen);
    this.parent.penNetwork(pen);
  }
  drawline(mouse) {
    var _a;
    if (!this.drawingLine) {
      return;
    }
    (_a = this[this.drawingLineName]) == null ? void 0 : _a.call(this, this.store, this.drawingLine, mouse);
    this.store.path2dMap.set(this.drawingLine, globalStore.path2dDraws.line(this.drawingLine));
    this.patchFlags = true;
  }
  initLineRect(pen) {
    var _a;
    if (!pen) {
      return;
    }
    if (!((_a = pen.calculative.worldAnchors) == null ? void 0 : _a.length)) {
      this._del([pen]);
      return;
    }
    if (!isFinite(pen.x) || !isFinite(pen.x)) {
      return;
    }
    if (pen.x == null || pen.y == null) {
      return;
    }
    const rect = getLineRect(pen);
    if (!pen.parentId) {
      Object.assign(pen, rect);
    }
    const { fontSize, lineHeight } = this.store.options;
    if (!pen.fontSize) {
      pen.fontSize = fontSize >= 0 ? fontSize : 12;
      pen.calculative.fontSize = pen.fontSize * this.store.data.scale;
    }
    if (!pen.lineHeight) {
      pen.lineHeight = lineHeight;
      pen.calculative.lineHeight = pen.lineHeight;
    }
    calcCenter(rect);
    pen.calculative.worldRect = rect;
    calcPadding(pen, rect);
    calcTextRect(pen);
    calcInView(pen);
    pen.calculative && (pen.calculative.gradientAnimatePath = void 0);
    this.store.path2dMap.set(pen, globalStore.path2dDraws[pen.name](pen));
    if (pen.calculative.worldAnchors) {
      pen.anchors = pen.calculative.worldAnchors.map((pt) => {
        return calcRelativePoint(pt, pen.calculative.worldRect);
      });
    }
  }
  drawingPencil() {
    lockedError(this.store);
    this.pencil = true;
    this.externalElements.style.cursor = "crosshair";
  }
  stopPencil() {
    this.pencil = false;
    this.pencilLine = void 0;
    this.externalElements.style.cursor = "default";
  }
  async finishDrawline(end) {
    if (!this.drawingLine) {
      return;
    }
    const from = getFromAnchor(this.drawingLine);
    let to = getToAnchor(this.drawingLine);
    if (to.isTemp) {
      this.drawingLine.calculative.worldAnchors.pop();
      to = getToAnchor(this.drawingLine);
    }
    if (!end) {
      !to.connectTo && this.drawingLine.calculative.worldAnchors.pop();
      if (getFromAnchor(this.drawingLine) === this.drawingLine.calculative.activeAnchor) {
        this.drawingLine = void 0;
        this.render();
        return;
      }
    }
    if (!from.connectTo || !to.connectTo) {
      if (this.store.options.disableEmptyLine) {
        if (from.connectTo) {
          this.store.pens[from.connectTo].connectedLines = this.store.pens[from.connectTo].connectedLines.filter((item) => item.lineId !== this.drawingLine.id);
        }
        this.drawingLine = void 0;
        this.render();
        return;
      }
    } else {
      if (this.store.options.disableRepeatLine) {
        const line2 = this.store.data.pens.find((pen) => {
          if (pen.type) {
            const penFrom = getFromAnchor(pen);
            const penTo = getToAnchor(pen);
            return samePoint(penFrom, from) && samePoint(penTo, to);
          }
        });
        if (line2) {
          this.drawingLine = void 0;
          this.render();
          return;
        }
      }
    }
    const rect = getLineRect(this.drawingLine);
    Object.assign(this.drawingLine, rect);
    this.drawingLine.calculative.worldRect = rect;
    this.drawingLine.calculative.activeAnchor = getToAnchor(this.drawingLine);
    this.store.activeAnchor = this.drawingLine.calculative.activeAnchor;
    const allowAdd = (!this.beforeAddPens || await this.beforeAddPens([this.drawingLine])) && (!this.beforeAddPen || this.beforeAddPen(this.drawingLine));
    if (allowAdd) {
      this.initLineRect(this.drawingLine);
      this.store.data.pens.push(this.drawingLine);
      this.store.pens[this.drawingLine.id] = this.drawingLine;
      this.store.emitter.emit("add", [this.drawingLine]);
      this.active([this.drawingLine]);
      this.pushHistory({
        type: EditType.Add,
        pens: deepClone([this.drawingLine], true)
      });
    }
    this.store.path2dMap.set(this.drawingLine, globalStore.path2dDraws[this.drawingLine.name](this.drawingLine));
    this.drawingLine = void 0;
    this.drawingLineName = void 0;
    this.render();
  }
  async finishPencil() {
    if (this.pencilLine) {
      const anchors = simplify(this.pencilLine.calculative.worldAnchors, 10, 0, this.pencilLine.calculative.worldAnchors.length - 1);
      let p = getFromAnchor(this.pencilLine);
      anchors.unshift({ id: p.id, penId: p.penId, x: p.x, y: p.y });
      p = getToAnchor(this.pencilLine);
      anchors.push({ id: p.id, penId: p.penId, x: p.x, y: p.y });
      this.pencilLine.calculative.worldAnchors = smoothLine(anchors);
      if (this.pencilLine.calculative.worldAnchors.length > 1) {
        this.pencilLine.calculative.pencil = false;
        this.store.path2dMap.set(this.pencilLine, globalStore.path2dDraws[this.pencilLine.name](this.pencilLine));
        const allowAdd = (!this.beforeAddPens || await this.beforeAddPens([this.pencilLine])) && (!this.beforeAddPen || this.beforeAddPen(this.pencilLine));
        if (allowAdd) {
          this.initLineRect(this.pencilLine);
          this.store.data.pens.push(this.pencilLine);
          this.store.pens[this.pencilLine.id] = this.pencilLine;
          this.store.emitter.emit("add", [this.pencilLine]);
          this.active([this.pencilLine]);
          this.pushHistory({
            type: EditType.Add,
            pens: deepClone([this.pencilLine], true)
          });
        }
      }
      this.pencilLine = void 0;
      this.render();
    }
  }
  /**
   *  svg  width height 
   *  width  height  svg
   * @param pen
   */
  firefoxLoadSvg(pen) {
    const img = new Image();
    const request = new XMLHttpRequest();
    request.open("GET", pen.image, true);
    request.onload = () => {
      const parser = new DOMParser();
      const result = parser.parseFromString(request.responseText, "text/xml");
      const inlineSVG = result.getElementsByTagName("svg")[0];
      const { width, height } = pen.calculative.worldRect;
      inlineSVG.setAttribute("width", `${width}px`);
      inlineSVG.setAttribute("height", `${height}px`);
      const svg64 = btoa(unescape(encodeURIComponent(new XMLSerializer().serializeToString(inlineSVG))));
      const image64 = "data:image/svg+xml;base64," + svg64;
      img.src = image64;
      img.onload = () => {
        pen.calculative.img = img;
        pen.calculative.imgNaturalWidth = img.naturalWidth || pen.iconWidth;
        pen.calculative.imgNaturalHeight = img.naturalHeight || pen.iconHeight;
        globalStore.htmlElements[pen.image] = img;
        this.imageLoaded();
        if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
          this.templateImageLoaded();
        }
      };
    };
    request.send();
  }
  loadImage(pen) {
    if (pen.image !== pen.calculative.image || !pen.calculative.img) {
      pen.calculative.img = void 0;
      if (pen.image) {
        if (globalStore.htmlElements[pen.image]) {
          const img = globalStore.htmlElements[pen.image];
          pen.calculative.img = img;
          pen.calculative.imgNaturalWidth = img.naturalWidth || pen.iconWidth;
          pen.calculative.imgNaturalHeight = img.naturalHeight || pen.iconHeight;
          this.imageLoaded();
          if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
            this.templateImageLoaded();
          }
        } else {
          if (navigator.userAgent.includes("Firefox") && pen.image.endsWith(".svg")) {
            this.firefoxLoadSvg(pen);
          } else {
            const img = new Image();
            img.crossOrigin = pen.crossOrigin === "undefined" ? void 0 : pen.crossOrigin || "anonymous";
            img.src = pen.image;
            if (this.store.options.cdn && !(pen.image.startsWith("http") || pen.image.startsWith("//") || pen.image.startsWith("data:image"))) {
              img.src = this.store.options.cdn + pen.image;
            }
            img.onload = () => {
              pen.calculative.img = img;
              pen.calculative.imgNaturalWidth = img.naturalWidth || pen.iconWidth;
              pen.calculative.imgNaturalHeight = img.naturalHeight || pen.iconHeight;
              globalStore.htmlElements[pen.image] = img;
              this.imageLoaded();
              if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
                this.templateImageLoaded();
              }
            };
          }
        }
      }
      pen.calculative.image = pen.image;
    }
    if (pen.backgroundImage !== pen.calculative.backgroundImage) {
      pen.calculative.backgroundImg = void 0;
      if (pen.backgroundImage) {
        if (globalStore.htmlElements[pen.backgroundImage]) {
          const img = globalStore.htmlElements[pen.backgroundImage];
          pen.calculative.backgroundImg = img;
        } else {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.src = pen.backgroundImage;
          if (this.store.options.cdn && !(pen.backgroundImage.startsWith("http") || pen.backgroundImage.startsWith("//") || pen.backgroundImage.startsWith("data:image"))) {
            img.src = this.store.options.cdn + pen.backgroundImage;
          }
          img.onload = () => {
            pen.calculative.backgroundImg = img;
            globalStore.htmlElements[pen.backgroundImage] = img;
            this.imageLoaded();
            if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
              this.templateImageLoaded();
            }
          };
        }
      }
      pen.calculative.backgroundImage = pen.backgroundImage;
    }
    if (pen.strokeImage !== pen.calculative.strokeImage) {
      pen.calculative.strokeImg = void 0;
      if (pen.strokeImage) {
        if (globalStore.htmlElements[pen.strokeImage]) {
          const img = globalStore.htmlElements[pen.strokeImage];
          pen.calculative.strokeImg = img;
        } else {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.src = pen.strokeImage;
          if (this.store.options.cdn && !(pen.strokeImage.startsWith("http") || pen.strokeImage.startsWith("//") || pen.strokeImage.startsWith("data:image"))) {
            img.src = this.store.options.cdn + pen.strokeImage;
          }
          img.onload = () => {
            pen.calculative.strokeImg = img;
            globalStore.htmlElements[pen.strokeImage] = img;
            this.imageLoaded();
            if (
              // pen.template
              pen.canvasLayer === CanvasLayer.CanvasTemplate && pen.name !== "gif"
            ) {
              this.templateImageLoaded();
            }
          };
        }
      }
      pen.calculative.strokeImage = pen.strokeImage;
    }
  }
  //  render
  imageLoaded() {
    this.imageTimer && clearTimeout(this.imageTimer);
    this.imageTimer = setTimeout(() => {
      this.canvasImage.init();
      this.canvasImageBottom.init();
      this.render();
    }, 100);
  }
  //  render
  templateImageLoaded() {
    this.templateImageTimer && clearTimeout(this.templateImageTimer);
    this.templateImageTimer = setTimeout(() => {
      this.canvasTemplate.init();
      this.render();
    }, 100);
  }
  setCalculativeByScale(pen) {
    const scale = this.store.data.scale;
    pen.calculative.lineWidth = pen.lineWidth * scale;
    pen.calculative.fontSize = pen.fontSize * scale;
    if (pen.fontSize < 1 && pen.fontSize > 0) {
      pen.calculative.fontSize = pen.fontSize * pen.calculative.worldRect.height;
    }
    pen.calculative.iconSize = pen.iconSize * scale;
    pen.calculative.iconWidth = pen.iconWidth * scale;
    pen.calculative.iconHeight = pen.iconHeight * scale;
    pen.calculative.iconLeft = pen.iconLeft < 1 && pen.iconLeft > -1 ? pen.iconLeft : pen.iconLeft * scale;
    pen.calculative.iconTop = pen.iconTop < 1 && pen.iconTop > -1 ? pen.iconTop : pen.iconTop * scale;
    pen.calculative.textWidth = pen.textWidth < 1 && pen.textWidth > -1 ? pen.textWidth : pen.textWidth * scale;
    pen.calculative.textHeight = pen.textHeight < 1 && pen.textHeight > -1 ? pen.textHeight : pen.textHeight * scale;
    pen.calculative.textLeft = pen.textLeft < 1 && pen.textLeft > -1 ? pen.textLeft * pen.calculative.worldRect.width : pen.textLeft * scale;
    pen.calculative.textTop = pen.textTop < 1 && pen.textTop > -1 ? pen.textTop * pen.calculative.worldRect.height : pen.textTop * scale;
    if (pen.type === PenType.Line && pen.borderWidth) {
      pen.calculative.borderWidth = pen.borderWidth * scale;
    }
  }
  updatePenRect(pen, { worldRectIsReady, playingAnimate } = {}) {
    if (worldRectIsReady) {
      calcPenRect(pen);
    } else {
      calcWorldRects(pen);
    }
    if (!playingAnimate) {
      this.setCalculativeByScale(pen);
    }
    calcWorldAnchors(pen);
    calcIconRect(this.store.pens, pen);
    calcTextRect(pen);
    calcInView(pen);
    globalStore.path2dDraws[pen.name] && this.store.path2dMap.set(pen, globalStore.path2dDraws[pen.name](pen));
    pen.calculative.patchFlags = true;
    this.patchFlags = true;
    if (pen.children) {
      pen.children.forEach((id) => {
        const child = this.store.pens[id];
        child && this.updatePenRect(child, { worldRectIsReady: false });
      });
    }
    pen.type && this.initLineRect(pen);
    if (pen.calculative.gradientTimer) {
      clearTimeout(pen.calculative.gradientTimer);
    }
    pen.calculative.gradientTimer = setTimeout(() => {
      if (pen.calculative.lineGradient) {
        pen.calculative.lineGradient = null;
      }
      if (pen.calculative.gradient) {
        pen.calculative.gradient = null;
      }
      if (pen.calculative.radialGradient) {
        pen.calculative.radialGradient = null;
      }
      this.patchFlags = true;
      pen.calculative.gradientTimer = void 0;
    }, 50);
  }
  initGlobalStyle() {
    const options = {};
    const data = {};
    const theme = {};
    themeKeys.forEach((key) => {
      var _a;
      if (this.store.options[key] !== void 0) {
        options[key] = this.store.options[key];
      }
      if (this.store.data[key] !== void 0) {
        data[key] = this.store.data[key];
      }
      if (this.store.data.theme) {
        const value4 = (_a = this.store.theme[this.store.data.theme]) == null ? void 0 : _a[key];
        if (value4 !== void 0) {
          theme[key] = value4;
        }
      }
    });
    this.store.styles = {};
    Object.assign(this.store.styles, options, data, theme);
  }
  translate(x = 0, y = 0) {
    this.store.data.x += x * this.store.data.scale;
    this.store.data.y += y * this.store.data.scale;
    this.store.data.x = Math.round(this.store.data.x);
    this.store.data.y = Math.round(this.store.data.y);
    if (this.store.options.padding) {
      let p = formatPadding(this.store.options.padding);
      const width = this.store.data.width || this.store.options.width;
      const height = this.store.data.height || this.store.options.height;
      if (this.width < (width + p[1] + p[3]) * this.store.data.scale) {
        if (this.store.data.x + this.store.data.origin.x > p[3] * this.store.data.scale) {
          this.store.data.x = p[3] * this.store.data.scale - this.store.data.origin.x;
        }
        if (this.store.data.x + this.store.data.origin.x + width * this.store.data.scale < this.width - p[1] * this.store.data.scale) {
          this.store.data.x = this.width - p[1] * this.store.data.scale - (this.store.data.origin.x + width * this.store.data.scale);
        }
      }
      if (this.height < (height + p[0] + p[2]) * this.store.data.scale) {
        if (this.store.data.y + this.store.data.origin.y > p[0] * this.store.data.scale) {
          this.store.data.y = p[0] * this.store.data.scale - this.store.data.origin.y;
        }
        if (this.store.data.y + this.store.data.origin.y + height * this.store.data.scale < this.height - p[2] * this.store.data.scale) {
          this.store.data.y = this.height - p[2] * this.store.data.scale - (this.store.data.origin.y + height * this.store.data.scale);
        }
      }
    }
    if (this.store.data.asyncTranslate) {
      clearTimeout(this.transTimeout);
      this.transTimeout = setTimeout(() => {
        this.canvasTemplate.init();
        this.canvasImage.init();
        this.canvasImageBottom.init();
        this.render();
      }, 300);
    } else {
      this.canvasTemplate.init();
      this.canvasImage.init();
      this.canvasImageBottom.init();
      this.render();
    }
    this.store.emitter.emit("translate", {
      x: this.store.data.x,
      y: this.store.data.y
    });
    this.tooltip.translate(x, y);
    if (this.scroll && this.scroll.isShow) {
      this.scroll.translate(x, y);
    }
    this.onMovePens();
  }
  onMovePens() {
    var _a;
    const map = this.parent.map;
    if (map && map.isShow) {
      map.setView();
    }
    for (const pen of this.store.data.pens) {
      calcInView(pen);
      (_a = pen.onMove) == null ? void 0 : _a.call(pen, pen);
      if (pen.isRuleLine) {
        if (!pen.width) {
          pen.y = -this.store.data.y;
        } else if (!pen.height) {
          pen.x = -this.store.data.x;
        }
        this.updatePenRect(pen);
      }
    }
  }
  /**
   * 
   * @param scale  data.scale
   * @param center 
   */
  scale(scale, center = { x: 0, y: 0 }) {
    var _a;
    const minScale = this.store.data.minScale || this.store.options.minScale;
    const maxScale = this.store.data.maxScale || this.store.options.maxScale;
    if (!(scale >= minScale && scale <= maxScale)) {
      return;
    }
    this.calibrateMouse(center);
    const s = scale / this.store.data.scale;
    this.store.data.scale = scale;
    this.store.data.center = center;
    if ((_a = this.store.clipboard) == null ? void 0 : _a.pos) {
      scalePoint(this.store.clipboard.pos, s, center);
    }
    scalePoint(this.store.data.origin, s, center);
    this.store.data.pens.forEach((pen) => {
      if (pen.parentId) {
        return;
      }
      scalePen(pen, s, center);
      pen.onScale && pen.onScale(pen);
      if (pen.isRuleLine) {
        const lineScale = 1 / s;
        const lineCenter = pen.calculative.worldRect.center;
        if (!pen.width) {
          scalePen(pen, lineScale, lineCenter);
        } else if (!pen.height) {
          scalePen(pen, lineScale, lineCenter);
        }
      }
      this.updatePenRect(pen, { worldRectIsReady: true });
      this.execPenResize(pen);
    });
    this.onMovePens();
    this.calcActiveRect();
    this.canvasTemplate.init();
    this.canvasImage.init();
    this.canvasImageBottom.init();
    const map = this.parent.map;
    if (map && map.isShow) {
      map.setView();
    }
    this.render();
    this.store.emitter.emit("scale", this.store.data.scale);
  }
  templateScale(scale, center = { x: 0, y: 0 }) {
    const { minScale, maxScale } = this.store.options;
    if (!(scale >= minScale && scale <= maxScale)) {
      return;
    }
    const s = scale / this.store.data.scale;
    this.store.data.scale = scale;
    this.store.data.center = { x: 0, y: 0 };
    this.store.data.origin = { x: 0, y: 0 };
    this.store.data.pens.forEach((pen) => {
      if (pen.parentId) {
        return;
      }
      scalePen(pen, s, center);
      pen.onScale && pen.onScale(pen);
      if (pen.isRuleLine) {
        const lineScale = s > 1 ? 1 : 1 / s / s;
        const lineCenter = pen.calculative.worldRect.center;
        if (!pen.width) {
          scalePen(pen, lineScale, lineCenter);
        } else if (!pen.height) {
          scalePen(pen, lineScale, lineCenter);
        }
      }
      this.execPenResize(pen);
    });
    this.calcActiveRect();
  }
  rotatePens(e) {
    if (!this.initPens) {
      this.initPens = deepClone(this.getAllByPens(this.store.active));
    }
    this.activeRect.rotate = calcRotate(e, this.activeRect.center);
    if (this.activeRect.rotate % 90 < 10) {
      this.activeRect.rotate -= this.activeRect.rotate % 90;
    }
    if (this.activeRect.rotate % 90 > 80) {
      this.activeRect.rotate += 90 - this.activeRect.rotate % 90;
    }
    if (this.store.active.length === 1) {
      this.lastRotate = this.store.active[0].rotate || 0;
    }
    const angle = this.activeRect.rotate - this.lastRotate;
    for (const pen of this.store.active) {
      if (pen.parentId) {
        return;
      }
      this.rotatePen(pen, angle, this.activeRect);
      pen.onRotate && pen.onRotate(pen);
      this.updateLines(pen);
    }
    this.lastRotate = this.activeRect.rotate;
    this.getSizeCPs();
    this.initImageCanvas(this.store.active);
    this.initTemplateCanvas(this.store.active);
    this.render();
    this.store.emitter.emit("rotatePens", this.store.active);
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.timer = setTimeout(() => {
      this.timer = void 0;
      this.pushHistory({
        type: EditType.Update,
        pens: deepClone(this.getAllByPens(this.store.active)),
        initPens: this.initPens
      });
      this.initPens = void 0;
    }, 200);
  }
  resizePens(e) {
    if (!this.initPens) {
      this.initPens = deepClone(this.store.active, true);
    }
    if (!this.initActiveRect) {
      this.initActiveRect = deepClone(this.activeRect);
      return;
    }
    const p1 = { x: this.mouseDown.x, y: this.mouseDown.y };
    const p2 = { x: e.x, y: e.y };
    let x = p2.x - p1.x;
    let y = p2.y - p1.y;
    const rect = deepClone(this.initActiveRect);
    resizeRect(rect, x, y, this.resizeIndex);
    calcCenter(rect);
    if (!this.store.options.disableDock) {
      this.clearDock();
      const resizeDock = this.customResizeDock || calcResizeDock;
      this.dock = resizeDock(this.store, rect, this.store.active, this.resizeIndex);
      const { xDock, yDock } = this.dock;
      if (xDock) {
        x += xDock.step;
        const dockPen = this.store.pens[xDock.penId];
        dockPen.calculative.isDock = true;
      }
      if (yDock) {
        y += yDock.step;
        const dockPen = this.store.pens[yDock.penId];
        dockPen.calculative.isDock = true;
      }
    }
    const w = this.activeRect.width;
    const h = this.activeRect.height;
    let offsetX = x - this.lastOffsetX;
    let offsetY = y - this.lastOffsetY;
    this.lastOffsetX = x;
    this.lastOffsetY = y;
    if (e.ctrlKey || this.initPens.length === 1 && this.initPens[0].ratio) {
      const sign = [1, 3].includes(this.resizeIndex) ? -1 : 1;
      offsetY = sign * (offsetX * h) / w;
    }
    this.activeRect.ratio = this.initPens[0].ratio;
    resizeRect(this.activeRect, offsetX, offsetY, this.resizeIndex);
    if (this.store.options.strictScope) {
      const width = this.store.data.width || this.store.options.width;
      const height = this.store.data.height || this.store.options.height;
      if (width && height) {
        let vRect = {
          x: this.store.data.origin.x,
          y: this.store.data.origin.y,
          width: width * this.store.data.scale,
          height: height * this.store.data.scale
        };
        if (this.activeRect.x < vRect.x) {
          this.activeRect.width = this.activeRect.width - (vRect.x - this.activeRect.x);
          this.activeRect.x = vRect.x;
        }
        if (this.activeRect.y < vRect.y) {
          this.activeRect.height = this.activeRect.height - (vRect.y - this.activeRect.y);
          this.activeRect.y = vRect.y;
        }
        if (this.activeRect.x + this.activeRect.width > vRect.x + vRect.width) {
          this.activeRect.width = this.activeRect.width - (this.activeRect.x + this.activeRect.width - (vRect.x + vRect.width));
          this.activeRect.x = vRect.x + vRect.width - this.activeRect.width;
          this.activeRect.ex = this.activeRect.x + this.activeRect.width;
        }
        if (this.activeRect.y + this.activeRect.height > vRect.y + vRect.height) {
          this.activeRect.height = this.activeRect.height - (this.activeRect.y + this.activeRect.height - (vRect.y + vRect.height));
          this.activeRect.y = vRect.y + vRect.height - this.activeRect.height;
          this.activeRect.ey = this.activeRect.y + this.activeRect.height;
        }
      }
    }
    calcCenter(this.activeRect);
    const scaleX = this.activeRect.width / w;
    const scaleY = this.activeRect.height / h;
    this.store.active.forEach((pen, i) => {
      pen.calculative.worldRect.x = this.activeInitPos[i].x * this.activeRect.width + this.activeRect.x;
      pen.calculative.worldRect.y = this.activeInitPos[i].y * this.activeRect.height + this.activeRect.y;
      pen.calculative.worldRect.width *= scaleX;
      pen.calculative.iconWidth && (pen.calculative.iconWidth *= scaleX);
      pen.calculative.worldRect.height *= scaleY;
      pen.calculative.iconHeight && (pen.calculative.iconHeight *= scaleY);
      calcRightBottom(pen.calculative.worldRect);
      calcCenter(pen.calculative.worldRect);
      this.updatePenRect(pen, { worldRectIsReady: true });
      this.execPenResize(pen);
      this.updateLines(pen);
    });
    this.getSizeCPs();
    this.initImageCanvas(this.store.active);
    this.initTemplateCanvas(this.store.active);
    this.render();
    this.store.emitter.emit("resizePens", this.store.active);
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.timer = setTimeout(() => {
      this.timer = void 0;
      this.pushHistory({
        type: EditType.Update,
        pens: deepClone(this.store.active, true),
        initPens: this.initPens
      });
      this.initPens = void 0;
    }, 200);
  }
  movePens(e) {
    var _a, _b;
    if (!this.activeRect || this.store.data.locked) {
      return;
    }
    if (!this.initActiveRect) {
      this.initActiveRect = deepClone(this.activeRect);
      return;
    }
    if (!this.store.options.moveConnectedLine && !this.canMoveLine && this.store.active.length === 1 && (((_a = this.store.active[0].anchors[0]) == null ? void 0 : _a.connectTo) || ((_b = this.store.active[0].anchors[this.store.active[0].anchors.length - 1]) == null ? void 0 : _b.connectTo))) {
      return;
    }
    if (!this.movingPens) {
      this.initMovingPens();
      this.store.active.forEach((pen) => {
        setHover(pen, false);
      });
      this.store.hover = void 0;
    }
    if (!this.mouseDown) {
      return;
    }
    let x = e.x - this.mouseDown.x;
    let y = e.y - this.mouseDown.y;
    e.shiftKey && !e.ctrlKey && (y = 0);
    e.ctrlKey && (x = 0);
    const rect = deepClone(this.initActiveRect);
    translateRect(rect, x, y);
    let vFlag = false;
    if (this.store.options.strictScope) {
      const width = this.store.data.width || this.store.options.width;
      const height = this.store.data.height || this.store.options.height;
      if (width && height) {
        let vRect = {
          x: this.store.data.origin.x,
          y: this.store.data.origin.y,
          width: width * this.store.data.scale,
          height: height * this.store.data.scale
        };
        if (rect.x < vRect.x) {
          rect.x = vRect.x;
          vFlag = true;
        }
        if (rect.y < vRect.y) {
          rect.y = vRect.y;
          vFlag = true;
        }
        if (rect.x + rect.width > vRect.x + vRect.width) {
          rect.x = vRect.x + vRect.width - rect.width;
          vFlag = true;
        }
        if (rect.y + rect.height > vRect.y + vRect.height) {
          rect.y = vRect.y + vRect.height - rect.height;
          vFlag = true;
        }
      }
    }
    const offset = {
      x: rect.x - this.activeRect.x,
      y: rect.y - this.activeRect.y
    };
    if (!this.store.options.disableDock && !vFlag) {
      this.clearDock();
      const moveDock = this.customMoveDock || calcMoveDock;
      this.dock = moveDock(this.store, rect, this.movingPens, offset);
      const { xDock, yDock } = this.dock;
      let dockPen;
      if (xDock) {
        offset.x += xDock.step;
        dockPen = this.store.pens[xDock.penId];
        dockPen.calculative.isDock = true;
      }
      if (yDock) {
        offset.y += yDock.step;
        dockPen = this.store.pens[yDock.penId];
        dockPen.calculative.isDock = true;
      }
    }
    this.translatePens(this.movingPens, offset.x, offset.y, true);
  }
  /**
   *  id parentId 
   * @param pen 
   * @param pens 
   */
  changeIdsByMoving(pen, pens) {
    pen.id += movingSuffix;
    if (pen.parentId && pens.find((p) => p.id === pen.parentId)) {
      pen.parentId += movingSuffix;
    }
    if (pen.children) {
      pen.children = pen.children.map((child) => child + movingSuffix);
    }
    if (pen.connectedLines) {
      pen.connectedLines = pen.connectedLines.map((line2) => {
        if (pens.find((p) => p.id === line2.lineId)) {
          line2.lineId += movingSuffix;
        }
        return line2;
      });
    }
    if (pen.type && pen.calculative.worldAnchors) {
      pen.calculative.worldAnchors = pen.calculative.worldAnchors.map((anchor) => {
        if (anchor.connectTo && pens.find((p) => p.id === anchor.connectTo)) {
          anchor.connectTo += movingSuffix;
        }
        return anchor;
      });
    }
  }
  /**
   *  this.movingPens
   *  ids id parentId children 
   * 
   */
  initMovingPens() {
    var _a, _b;
    if (!this.store.options.moveConnectedLine && !this.canMoveLine) {
      for (let i = 0; i < this.store.active.length; i++) {
        const pen = this.store.active[i];
        if (((_a = pen.anchors[0]) == null ? void 0 : _a.connectTo) || ((_b = pen.anchors[pen.anchors.length - 1]) == null ? void 0 : _b.connectTo)) {
          this.store.active.splice(i, 1);
          pen.calculative.active = void 0;
          --i;
        }
      }
    }
    this.movingPens = deepClone(this.store.active, true);
    this.movingPens = this.getAllFollowersByPens(this.movingPens);
    const containChildPens = this.getAllByPens(this.movingPens);
    const copyContainChildPens = deepClone(containChildPens, true);
    containChildPens.forEach((pen) => {
      this.changeIdsByMoving(pen, copyContainChildPens);
      this.store.pens[pen.id] = pen;
      pen.calculative.canvas = this;
      const value4 = {
        globalAlpha: 0.5
      };
      pen.lineWidth === 0 && (value4.lineWidth = 1);
      if (pen.name.endsWith("Dom") || isDomShapes.includes(pen.name) || this.store.options.domShapes.includes(pen.name) || pen.image) {
        value4.name = "rectangle";
        value4.onDestroy = void 0;
      }
      this.updateValue(pen, value4);
      pen.calculative.image = void 0;
    });
  }
  moveLineAnchor(pt, keyOptions) {
    var _a, _b, _c, _d, _e;
    if (!this.activeRect || this.store.data.locked) {
      return;
    }
    if (!this.initPens) {
      this.initPens = deepClone(this.store.active, true);
    }
    if ((_a = this.store.activeAnchor) == null ? void 0 : _a.connectTo) {
      const pen = this.store.pens[this.store.activeAnchor.connectTo];
      disconnectLine(pen, getAnchor(pen, this.store.activeAnchor.anchorId), this.store.pens[this.store.activeAnchor.penId], this.store.activeAnchor);
    }
    let anchorId = (_b = this.store.activeAnchor) == null ? void 0 : _b.id;
    let connectedLine = (_d = (_c = this.store.pens[this.store.activeAnchor.penId]) == null ? void 0 : _c.connectedLines) == null ? void 0 : _d.filter((item) => item.anchor === anchorId);
    if (connectedLine && connectedLine.length > 0) {
      connectedLine.forEach((connected) => {
        const pen = this.store.pens[connected.lineId];
        disconnectLine(this.store.pens[this.store.activeAnchor.penId], this.store.activeAnchor, pen, getAnchor(pen, connected.lineAnchor));
      });
    }
    const line2 = this.store.active[0];
    const from = getFromAnchor(line2);
    const to = getToAnchor(line2);
    if (line2.lineName === "polyline" && !keyOptions.shiftKey) {
      translatePolylineAnchor(line2, this.store.activeAnchor, pt);
    } else {
      let offsetX = 0;
      let offsetY = 0;
      if (line2.lineName === "line") {
        let index = line2.calculative.worldAnchors.findIndex((anchor) => anchor.id === this.store.activeAnchor.id);
        if (index === 0) {
          index = 2;
        }
        let relativePt = line2.calculative.worldAnchors[index - 1];
        if (keyOptions.ctrlKey && keyOptions.shiftKey) {
          let _pt = deepClone(pt);
          this.getSpecialAngle(_pt, relativePt);
          offsetX = _pt.x - this.store.activeAnchor.x;
          offsetY = _pt.y - this.store.activeAnchor.y;
        } else if (!keyOptions.ctrlKey && keyOptions.shiftKey) {
          let _pt = {
            x: pt.x,
            y: relativePt.y
          };
          offsetX = _pt.x - this.store.activeAnchor.x;
          offsetY = _pt.y - this.store.activeAnchor.y;
        } else if (keyOptions.ctrlKey && !keyOptions.shiftKey) {
          let _pt = {
            x: relativePt.x,
            y: pt.y
          };
          offsetX = _pt.x - this.store.activeAnchor.x;
          offsetY = _pt.y - this.store.activeAnchor.y;
        } else {
          offsetX = pt.x - this.store.activeAnchor.x;
          offsetY = pt.y - this.store.activeAnchor.y;
        }
      } else {
        if (!keyOptions.ctrlKey && keyOptions.shiftKey) {
          offsetX = pt.x - this.store.activeAnchor.x;
          offsetY = 0;
        } else if (keyOptions.ctrlKey && !keyOptions.shiftKey) {
          offsetX = 0;
          offsetY = pt.y - this.store.activeAnchor.y;
        } else {
          offsetX = pt.x - this.store.activeAnchor.x;
          offsetY = pt.y - this.store.activeAnchor.y;
        }
      }
      translatePoint(this.store.activeAnchor, offsetX, offsetY);
      if (this.store.hover && this.store.hoverAnchor && this.store.hoverAnchor.penId !== this.store.activeAnchor.penId) {
        if (this.store.hoverAnchor.type === PointType.Line) {
          offsetX = pt.x - this.store.activeAnchor.x;
          offsetY = pt.y - this.store.activeAnchor.y;
          getDistance(this.store.activeAnchor, this.store.hoverAnchor, this.store);
        } else {
          offsetX = this.store.hoverAnchor.x - this.store.activeAnchor.x;
          offsetY = this.store.hoverAnchor.y - this.store.activeAnchor.y;
        }
        translatePoint(this.store.activeAnchor, offsetX, offsetY);
        to.prev = void 0;
        if (line2.lineName !== "polyline") {
          (_e = this[line2.lineName]) == null ? void 0 : _e.call(this, this.store, line2);
        }
      }
    }
    this.patchFlagsLines.add(line2);
    this.store.path2dMap.set(line2, globalStore.path2dDraws[line2.name](line2));
    this.render();
    this.store.active[0].calculative && (this.store.active[0].calculative.gradientAnimatePath = void 0);
    this.store.emitter.emit("moveLineAnchor", {
      pen: this.store.active[0],
      anchor: this.store.activeAnchor
    });
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.timer = setTimeout(() => {
      this.timer = void 0;
      this.pushHistory({
        type: EditType.Update,
        pens: deepClone(this.store.active, true),
        initPens: this.initPens
      });
      this.initPens = void 0;
    }, 500);
  }
  moveLineAnchorPrev(e) {
    if (!this.activeRect || this.store.data.locked || !this.store.activeAnchor) {
      return;
    }
    if (!this.initPens) {
      this.initPens = deepClone(this.store.active, true);
    }
    this.store.activeAnchor.prev.x = e.x;
    this.store.activeAnchor.prev.y = e.y;
    if (this.store.activeAnchor.next) {
      if (!this.store.activeAnchor.prevNextType) {
        this.store.activeAnchor.next.x = e.x;
        this.store.activeAnchor.next.y = e.y;
        rotatePoint(this.store.activeAnchor.next, 180, this.store.activeAnchor);
      } else if (this.store.activeAnchor.prevNextType === PrevNextType.Bilateral && this.prevAnchor) {
        const rotate = calcRotate(e, this.store.activeAnchor);
        const prevRotate = calcRotate(this.prevAnchor, this.store.activeAnchor);
        this.store.activeAnchor.next.x = this.nextAnchor.x;
        this.store.activeAnchor.next.y = this.nextAnchor.y;
        rotatePoint(this.store.activeAnchor.next, rotate - prevRotate, this.store.activeAnchor);
      }
    }
    const line2 = this.store.active[0];
    this.patchFlagsLines.add(line2);
    this.store.path2dMap.set(line2, globalStore.path2dDraws[line2.name](line2));
    this.render();
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.timer = setTimeout(() => {
      this.timer = void 0;
      this.pushHistory({
        type: EditType.Update,
        pens: deepClone(this.store.active, true),
        initPens: this.initPens
      });
      this.initPens = void 0;
    }, 200);
  }
  moveLineAnchorNext(e) {
    if (!this.activeRect || this.store.data.locked || !this.store.activeAnchor) {
      return;
    }
    if (!this.initPens) {
      this.initPens = deepClone(this.store.active, true);
    }
    this.store.activeAnchor.next.x = e.x;
    this.store.activeAnchor.next.y = e.y;
    if (this.store.activeAnchor.prev) {
      if (!this.store.activeAnchor.prevNextType) {
        this.store.activeAnchor.prev.x = e.x;
        this.store.activeAnchor.prev.y = e.y;
        rotatePoint(this.store.activeAnchor.prev, 180, this.store.activeAnchor);
      } else if (this.store.activeAnchor.prevNextType === PrevNextType.Bilateral && this.nextAnchor) {
        const rotate = calcRotate(e, this.store.activeAnchor);
        const nextRotate = calcRotate(this.nextAnchor, this.store.activeAnchor);
        this.store.activeAnchor.prev.x = this.prevAnchor.x;
        this.store.activeAnchor.prev.y = this.prevAnchor.y;
        rotatePoint(this.store.activeAnchor.prev, rotate - nextRotate, this.store.activeAnchor);
      }
    }
    const line2 = this.store.active[0];
    this.patchFlagsLines.add(line2);
    this.store.path2dMap.set(line2, globalStore.path2dDraws[line2.name](line2));
    this.render();
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.timer = setTimeout(() => {
      this.timer = void 0;
      this.pushHistory({
        type: EditType.Update,
        pens: deepClone(this.store.active, true),
        initPens: this.initPens
      });
      this.initPens = void 0;
    }, 200);
  }
  async setAnchor(e) {
    var _a;
    const initPens = [deepClone(this.store.hover, true)];
    const hoverPen = this.store.hover;
    if (this.store.hoverAnchor) {
      if (this.beforeRemoveAnchor && !await this.beforeRemoveAnchor(hoverPen, this.store.hoverAnchor)) {
        return;
      }
      if (hoverPen.type === PenType.Line && ((_a = hoverPen.calculative.worldAnchors) == null ? void 0 : _a.length) <= 2) {
        this.delete([hoverPen]);
      } else {
        removePenAnchor(hoverPen, this.store.hoverAnchor);
        if (hoverPen.type === PenType.Line) {
          this.initLineRect(hoverPen);
        }
      }
      this.store.hoverAnchor = void 0;
      this.store.activeAnchor = void 0;
      this.externalElements.style.cursor = "default";
    } else if (hoverPen) {
      if (this.beforeAddAnchor && !await this.beforeAddAnchor(hoverPen, this.store.pointAt)) {
        return;
      }
      if (hoverPen.type === PenType.Line) {
        this.store.activeAnchor = addLineAnchor(hoverPen, this.store.pointAt, this.store.pointAtIndex);
        this.initLineRect(hoverPen);
        const pt = { x: e.x, y: e.y };
        this.getHover(pt);
      } else {
        const pt = { id: s8(), x: e.x, y: e.y };
        this.store.activeAnchor = pushPenAnchor(hoverPen, pt);
      }
    }
    this.hotkeyType = HotkeyType.None;
    this.render();
    if (hoverPen) {
      this.pushHistory({
        type: EditType.Update,
        pens: [deepClone(hoverPen, true)],
        initPens
      });
    }
  }
  /**
   * 
   * @param line 
   * @param pens 
   */
  checkDisconnect(line2, pens) {
    if (line2.id.indexOf(movingSuffix) > 0) {
      const id = line2.id;
      line2 = this.store.pens[id.replace(movingSuffix, "")];
    }
    line2.anchors.forEach((anchor) => {
      if (anchor.connectTo && !pens.find((p) => p.id === anchor.connectTo || p.id === anchor.connectTo + movingSuffix)) {
        const pen = this.store.pens[anchor.connectTo];
        if (!pen || pen.type) {
          return;
        }
        disconnectLine(pen, getAnchor(pen, anchor.anchorId), line2, anchor);
      }
    });
  }
  /**
   *  
   * @param pens 
   * @param x  x
   * @param y  y
   * @param doing 
   */
  translatePens(pens = this.store.active, x, y, doing) {
    if (!pens || !pens.length) {
      return;
    }
    let hasLocked = pens.some((item) => {
      if (item.locked >= LockState.DisableMove)
        return true;
    });
    if (hasLocked) {
      return;
    }
    const initPens = !doing && deepClone(pens, true);
    this.activeRect && translateRect(this.activeRect, x, y);
    const containChildPens = this.getAllByPens(pens);
    pens.forEach((pen) => {
      var _a, _b;
      if (pen.locked >= LockState.DisableMove) {
        return;
      }
      if (pen.type === PenType.Line) {
        if (!this.store.options.moveConnectedLine && !this.canMoveLine) {
          return;
        }
        if (pen.isRuleLine) {
          return;
        }
        translateLine(pen, x, y);
        this.checkDisconnect(pen, containChildPens);
        this.store.path2dMap.set(pen, globalStore.path2dDraws[pen.name](pen));
        if (!doing) {
          this.initLineRect(pen);
          (_a = pen.connectedLines) == null ? void 0 : _a.forEach((item) => {
            const line2 = this.store.pens[item.lineId];
            this.initLineRect(line2);
          });
        }
      } else {
        translateRect(pen.calculative.worldRect, x, y);
        this.updatePenRect(pen, { worldRectIsReady: true });
        pen.calculative.x = pen.x;
        pen.calculative.y = pen.y;
        if (pen.calculative.initRect) {
          pen.calculative.initRect.x = pen.calculative.x;
          pen.calculative.initRect.y = pen.calculative.y;
          pen.calculative.initRect.ex = pen.calculative.x + pen.calculative.width;
          pen.calculative.initRect.ey = pen.calculative.y + pen.calculative.height;
        }
      }
      this.updateLines(pen);
      (_b = pen.onMove) == null ? void 0 : _b.call(pen, pen);
    });
    this.activeRect && this.getSizeCPs();
    this.render();
    this.tooltip.translate(x, y);
    if (!doing) {
      this.pushHistory({
        type: EditType.Update,
        pens: deepClone(pens, true),
        initPens
      });
      this.initImageCanvas(pens);
      this.initTemplateCanvas(pens);
      this.store.emitter.emit("translatePens", pens);
    }
    this.store.emitter.emit("translatingPens", pens);
  }
  /**
   *  
   * @param pens 
   * @param x  x
   * @param y  y
   * @param doing 
   */
  templateTranslatePens(pens = this.store.active, x, y) {
    if (!pens || !pens.length) {
      return;
    }
    const containChildPens = this.getAllByPens(pens);
    pens.forEach((pen) => {
      var _a;
      if (pen.type === PenType.Line) {
        if (!this.store.options.moveConnectedLine && !this.canMoveLine) {
          return;
        }
        translateLine(pen, x, y);
        this.checkDisconnect(pen, containChildPens);
        this.store.path2dMap.set(pen, globalStore.path2dDraws[pen.name](pen));
      } else {
        translateRect(pen.calculative.worldRect, x, y);
        this.updatePenRect(pen, { worldRectIsReady: true });
        pen.calculative.x = pen.x;
        pen.calculative.y = pen.y;
        if (pen.calculative.initRect) {
          pen.calculative.initRect.x = pen.calculative.x;
          pen.calculative.initRect.y = pen.calculative.y;
          pen.calculative.initRect.ex = pen.calculative.x + pen.calculative.width;
          pen.calculative.initRect.ey = pen.calculative.y + pen.calculative.height;
        }
      }
      (_a = pen.onMove) == null ? void 0 : _a.call(pen, pen);
    });
  }
  calcAutoAnchor(line2, lineAnchor, pen, penConnection) {
    const from = getFromAnchor(line2);
    const to = getToAnchor(line2);
    const newAnchor = nearestAnchor(pen, lineAnchor === from ? to : from);
    if (!newAnchor) {
      return;
    }
    lineAnchor.x = newAnchor.x;
    lineAnchor.y = newAnchor.y;
    lineAnchor.prev = void 0;
    lineAnchor.next = void 0;
    if (penConnection) {
      penConnection.anchor = newAnchor.id;
    } else {
      connectLine(pen, newAnchor, line2, lineAnchor);
    }
    if (this[line2.lineName]) {
      this[line2.lineName](this.store, line2);
    }
    this.store.path2dMap.set(line2, globalStore.path2dDraws.line(line2));
    this.initLineRect(line2);
  }
  restoreNodeAnimate(pen) {
    var _a, _b;
    if (pen.calculative.initRect) {
      if (pen.keepAnimateState) {
        for (const k in pen) {
          if (pen.calculative[k] === void 0) {
            continue;
          }
          if (k !== "x" && k !== "y" && k !== "width" && k !== "height" && k !== "initRect" && (typeof pen[k] !== "object" || k === "lineDash")) {
            if (k === "fontSize" || k === "lineWidth") {
              pen[k] = pen.calculative[k] / pen.calculative.canvas.store.data.scale;
            } else {
              pen[k] = pen.calculative[k];
            }
          }
        }
      } else {
        const rotate = pen.calculative.initRect.rotate - pen.calculative.rotate;
        for (const k in pen) {
          if (k !== "x" && k !== "y" && k !== "width" && k !== "height" && k !== "initRect" && k !== "rotate" && (typeof pen[k] !== "object" || k === "lineDash")) {
            pen.calculative[k] = pen[k];
          }
        }
        if ((_a = pen.children) == null ? void 0 : _a.length) {
          if (rotate) {
            rotatePen(pen, rotate, pen.calculative.worldRect);
          }
        } else {
          pen.calculative.rotate = pen.rotate;
        }
        const originStatus = deepClone(this.store.animateMap.get(pen));
        if (originStatus) {
          originStatus.id = pen.id;
          this.parent.setValue(originStatus, {
            doEvent: false,
            render: true,
            history: false
          });
        }
        pen.calculative.worldRect = pen.calculative.initRect;
      }
      this.updatePenRect(pen, { worldRectIsReady: true });
      this.updateLines(pen);
      if (pen.image && pen.name !== "gif") {
        this.canvasImage.init();
        this.canvasImageBottom.init();
      }
      if (pen.calculative.text !== pen.text) {
        pen.calculative.text = pen.text;
        calcTextLines(pen);
      }
      if ((_b = this.store.active) == null ? void 0 : _b.length) {
        this.calcActiveRect();
      }
      pen.calculative.initRect = void 0;
    }
  }
  updateLines(pen, change) {
    var _a;
    (_a = pen.children) == null ? void 0 : _a.forEach((child) => {
      const childPen = this.store.pens[child];
      if (childPen) {
        this.updateLines(childPen, change);
      }
    });
    if (!pen.connectedLines) {
      return;
    }
    pen.connectedLines.forEach((item, index) => {
      const line2 = this.store.pens[item.lineId];
      if (!line2 || line2.calculative.active) {
        return;
      }
      const lineAnchor = getAnchor(line2, item.lineAnchor);
      if (!lineAnchor) {
        return;
      }
      if (!lineAnchor.connectTo) {
        pen.connectedLines.splice(index, 1);
        return;
      }
      if (line2.autoFrom) {
        const from = getFromAnchor(line2);
        if (from.id === lineAnchor.id) {
          this.calcAutoAnchor(line2, from, pen, item);
        }
      }
      if (line2.autoTo) {
        const to = getToAnchor(line2);
        if (to.id === lineAnchor.id) {
          this.calcAutoAnchor(line2, to, pen, item);
        }
      }
      const penAnchor = getAnchor(pen, item.anchor);
      if (!penAnchor) {
        return;
      }
      let rotate = pen.rotate;
      if (pen.flipX) {
        rotate *= -1;
      }
      if (pen.flipY) {
        rotate *= -1;
      }
      let offsetX = lineAnchor.distance * this.store.data.scale * Math.cos((rotate + penAnchor.rotate) / 180 * Math.PI) || 0;
      let offsetY = lineAnchor.distance * this.store.data.scale * Math.sin((rotate + penAnchor.rotate) / 180 * Math.PI) || 0;
      if (pen.flipX) {
        offsetX = -offsetX;
      }
      if (pen.flipY) {
        offsetY = -offsetY;
      }
      translatePoint(lineAnchor, penAnchor.x - lineAnchor.x + offsetX, penAnchor.y - lineAnchor.y + offsetY);
      if (this.store.options.autoPolyline && !this.autoPolylineFlag && line2.autoPolyline !== false && line2.lineName === "polyline") {
        let from = getFromAnchor(line2);
        let to = getToAnchor(line2);
        let found = false;
        if (from.id === lineAnchor.id) {
          from = lineAnchor;
          found = true;
        } else if (to.id === lineAnchor.id) {
          to = lineAnchor;
          found = true;
        }
        if (found) {
          line2.calculative.worldAnchors = [from, to];
          line2.calculative.activeAnchor = from;
          this.polyline(this.store, line2, to);
          this.initLineRect(line2);
        }
      }
      this.store.path2dMap.set(line2, globalStore.path2dDraws[line2.name](line2));
      this.patchFlagsLines.add(line2);
      if (line2.calculative.gradientSmooth) {
        line2.calculative.gradientAnimatePath = getGradientAnimatePath(line2);
      }
      change && getLineLength(line2);
    });
  }
  calcActiveRect() {
    const canMovePens = this.store.active.filter((pen) => (!pen.locked || pen.locked < LockState.DisableMove) && pen.visible != false);
    if (!canMovePens.length) {
      return;
    } else if (canMovePens.length === 1) {
      this.activeRect = deepClone(canMovePens[0].calculative.worldRect);
      this.activeRect.rotate = canMovePens[0].calculative.rotate || 0;
      calcCenter(this.activeRect);
    } else {
      this.activeRect = getRect2(canMovePens);
      this.activeRect.rotate = 0;
    }
    this.lastRotate = 0;
    this.getSizeCPs();
  }
  /**
   * 
   * @param pen 
   * @param angle  pen.calculative.rotate 
   */
  rotatePen(pen, angle, rect) {
    if (pen.type) {
      pen.calculative.worldAnchors.forEach((anchor) => {
        rotatePoint(anchor, angle, rect.center);
      });
      this.initLineRect(pen);
      calcPenRect(pen);
    } else {
      if (pen.calculative.rotate) {
        pen.calculative.rotate += angle;
      } else {
        pen.calculative.rotate = angle;
      }
      rotatePoint(pen.calculative.worldRect.center, angle, rect.center);
      if (pen.parentId) {
        pen.calculative.worldRect.x = pen.calculative.worldRect.center.x - pen.calculative.worldRect.width / 2;
        pen.calculative.worldRect.y = pen.calculative.worldRect.center.y - pen.calculative.worldRect.height / 2;
        pen.x = (pen.calculative.worldRect.x - rect.x) / rect.width;
        pen.y = (pen.calculative.worldRect.y - rect.y) / rect.height;
      } else {
        pen.x = pen.calculative.worldRect.center.x - pen.width / 2;
        pen.y = pen.calculative.worldRect.center.y - pen.height / 2;
      }
      pen.rotate = pen.calculative.rotate;
      this.updatePenRect(pen);
      if (pen.children) {
        pen.children.forEach((id) => {
          const child = this.store.pens[id];
          this.rotatePen(child, angle, pen.calculative.worldRect);
        });
      }
    }
  }
  nextAnimate(pen) {
    if (!pen) {
      return;
    }
    this.store.emitter.emit("animateEnd", pen);
    let pens;
    if (pen.nextAnimate) {
      pens = this.store.data.pens.filter((p) => {
        return p.id === pen.nextAnimate || p.tags && p.tags.indexOf(pen.nextAnimate) > -1;
      });
    }
    if (!pens) {
      return;
    }
    pens.forEach((pen2) => {
      var _a, _b, _c, _d, _e;
      if (pen2.calculative.pause) {
        const d = Date.now() - pen2.calculative.pause;
        pen2.calculative.pause = void 0;
        pen2.calculative.frameStart += d;
        pen2.calculative.frameEnd += d;
      } else {
        if (pen2.name === "video") {
          pen2.calculative.media.currentTime = 0;
          (_a = pen2.calculative.media) == null ? void 0 : _a.play();
          (_b = pen2.onStartVideo) == null ? void 0 : _b.call(pen2, pen2);
        } else if (pen2.type || ((_c = pen2.frames) == null ? void 0 : _c.length) || pen2.animations && pen2.animations.length) {
          if (!pen2.type) {
            if (!pen2.frames && pen2.animations && pen2.animations.length) {
              let autoIndex = (_d = pen2.animations) == null ? void 0 : _d.findIndex((i) => i.autoPlay);
              let index = autoIndex === -1 ? 0 : autoIndex;
              const animate = deepClone(pen2.animations[index]);
              delete animate.name;
              animate.currentAnimation = index;
              if (!pen2.type && animate.frames) {
                animate.showDuration = this.parent.calcAnimateDuration(animate);
              }
              this.parent.setValue({
                id: pen2.id,
                ...animate
              }, {
                doEvent: false,
                history: false
              });
            }
            this.store.animateMap.set(pen2, this.getFrameProps(pen2));
          } else {
            if ((_e = pen2.animations) == null ? void 0 : _e.length) {
              const animate = deepClone(pen2.animations[0]);
              delete animate.name;
              animate.currentAnimation = 0;
              this.parent.setValue({
                id: pen2.id,
                ...animate
              }, {
                doEvent: false,
                history: false
              });
            }
          }
          this.store.animates.add(pen2);
        }
      }
    });
    this.animate();
  }
  getFrameProps(pen) {
    let initProps = {};
    pen.frames && pen.frames.forEach((frame) => {
      for (let key in frame) {
        if (!["duration", "x", "y", "width", "height", "rotate"].includes(key) && !initProps[key]) {
          initProps[key] = pen[key];
        }
      }
    });
    return initProps;
  }
  animate() {
    if (this.animateRendering) {
      return;
    }
    requestAnimationFrame(() => {
      const now = Date.now();
      if (now - this.lastAnimateRender < this.store.options.animateInterval) {
        if (this.store.animates.size > 0) {
          this.animate();
        }
        return;
      }
      this.lastAnimateRender = now;
      this.animateRendering = true;
      const dels = [];
      let active = false;
      for (const pen of this.store.animates) {
        if (pen.calculative.pause) {
          continue;
        }
        if (pen.calculative.active && !pen.type && !this.movingPens) {
          active = true;
        }
        if (!pen.type) {
          if (setNodeAnimate(pen, now)) {
            if (pen.calculative.patchFlags) {
              calcCenter(pen.calculative.worldRect);
              this.updatePenRect(pen, {
                worldRectIsReady: true,
                playingAnimate: true
              });
            }
          } else {
            requestAnimationFrame(() => {
              this.restoreNodeAnimate(pen);
            });
            dels.push(pen);
            this.nextAnimate(pen);
          }
          this.updateLines(pen, true);
        } else {
          if (!setLineAnimate(pen, now)) {
            if (pen.keepAnimateState) {
              for (const k in pen) {
                if (pen.calculative[k] === void 0) {
                  continue;
                }
                if (k === "length") {
                  continue;
                }
                if (typeof pen[k] !== "object" || k === "lineDash") {
                  if (k === "lineWidth") {
                    pen[k] = pen.calculative[k] / pen.calculative.canvas.store.data.scale;
                  } else {
                    pen[k] = pen.calculative[k];
                  }
                }
              }
              calcPenRect(pen);
            } else {
              for (const k in pen) {
                if (typeof pen[k] !== "object" || k === "lineDash") {
                  if (k === "lineWidth") {
                    pen.calculative[k] = pen[k] * pen.calculative.canvas.store.data.scale;
                  } else {
                    pen.calculative[k] = pen[k];
                  }
                }
              }
            }
            dels.push(pen);
            this.nextAnimate(pen);
          }
        }
        this.patchFlags = true;
      }
      if (active) {
        this.calcActiveRect();
      }
      dels.forEach((pen) => {
        this.store.animates.delete(pen);
      });
      this.render(false);
      this.animateRendering = false;
      this.animate();
    });
  }
  get clipboardName() {
    return "meta2d-clipboard";
  }
  async copy(pens, emit = true) {
    const page = s8();
    const { origin, scale } = this.store.data;
    this.store.clipboard = void 0;
    localStorage.removeItem(this.clipboardName);
    sessionStorage.setItem("page", page);
    let copyPens = this.getAllByPens(deepClone(pens || this.store.active, true));
    copyPens.forEach((activePen) => {
      activePen.copyIndex = this.store.data.pens.findIndex((pen) => pen.id === activePen.id);
      if (activePen.pathId) {
        activePen.path = this.store.data.paths[activePen.pathId];
      }
    });
    copyPens.sort((a, b) => {
      return a.copyIndex - b.copyIndex;
    });
    const clipboard = {
      meta2d: true,
      pens: copyPens,
      origin: deepClone(origin),
      scale,
      page,
      initRect: deepClone(this.activeRect),
      offset: 10,
      mousePos: deepClone(this.mousePos)
    };
    if (navigator.clipboard && !this.store.options.disableClipboard && !navigator.userAgent.includes("Firefox")) {
      try {
        await navigator.clipboard.writeText(JSON.stringify(clipboard));
      } catch {
        localStorage.setItem(this.clipboardName, JSON.stringify(clipboard));
      }
    } else {
      localStorage.setItem(this.clipboardName, JSON.stringify(clipboard));
    }
    emit && this.store.emitter.emit("copy", clipboard.pens);
  }
  cut(pens) {
    this.copy(pens, false);
    this.delete(pens);
    this.store.emitter.emit("cut", pens);
  }
  async paste() {
    var _a, _b;
    let clipboardText;
    let clipboard;
    if (navigator.clipboard && !this.store.options.disableClipboard && !navigator.userAgent.includes("Firefox")) {
      try {
        clipboardText = await ((_a = navigator.clipboard) == null ? void 0 : _a.readText());
      } catch {
        clipboardText = localStorage.getItem(this.clipboardName);
      }
    } else {
      clipboardText = localStorage.getItem(this.clipboardName);
    }
    if (clipboardText) {
      try {
        clipboard = JSON.parse(clipboardText);
      } catch (e) {
        console.warn("json", e.message);
        return;
      }
      if (!clipboard || !clipboard.meta2d) {
        return;
      }
    } else {
      return;
    }
    if (this.beforeAddPens && await this.beforeAddPens(clipboard.pens) != true) {
      return;
    }
    let offset;
    let pos;
    if (this.store.clipboard) {
      offset = this.store.clipboard.offset + 10;
      pos = this.store.clipboard.pos;
    }
    this.store.clipboard = deepClone(clipboard);
    const curPage = sessionStorage.getItem("page");
    const scale = this.store.data.scale;
    if (this.store.clipboard.mousePos && (Math.abs(this.store.clipboard.mousePos.x - this.mousePos.x) > 100 * scale || Math.abs(this.store.clipboard.mousePos.y - this.mousePos.y) > 100 * scale)) {
      const offsetX = (scale - this.store.clipboard.scale) * this.store.clipboard.initRect.width / 2;
      const offsetY = (scale - this.store.clipboard.scale) * this.store.clipboard.initRect.height / 2;
      this.store.clipboard.pos = { x: this.mousePos.x - offsetX, y: this.mousePos.y - offsetY };
      this.store.clipboard.offset = 0;
    } else if (curPage !== clipboard.page) {
      this.store.clipboard.pos = { x: this.mousePos.x, y: this.mousePos.y };
      this.store.clipboard.offset = 0;
    } else if (!this.pasteOffset) {
      this.store.clipboard.offset = 0;
      this.pasteOffset = true;
    } else {
      offset && (this.store.clipboard.offset = offset);
      pos && (this.store.clipboard.pos = pos);
    }
    if (!((_b = this.keyOptions) == null ? void 0 : _b.F)) {
      this.store.clipboard.pens.forEach((pen) => {
        delete pen.copyIndex;
      });
    }
    const rootPens = this.store.clipboard.pens.filter((pen) => !pen.parentId);
    for (const pen of rootPens) {
      this.pastePen(pen, void 0);
    }
    sessionStorage.setItem("page", clipboard.page);
    this.active(rootPens);
    this.pushHistory({ type: EditType.Add, pens: this.store.clipboard.pens });
    this.render();
    this.store.emitter.emit("add", this.store.clipboard.pens);
    this.store.emitter.emit("paste", this.store.clipboard.pens);
  }
  /**
   *  pens 
   * @param pens 
   */
  getAllByPens(pens) {
    const retPens = [];
    for (const pen of pens) {
      retPens.push(...deepClone(getAllChildren(pen, this.store), true));
    }
    return retPens.concat(pens);
  }
  getAllFollowersByPens(pens, deep = true) {
    const retPens = pens;
    for (const pen of pens) {
      let followers = getAllFollowers(pen, this.store);
      if (deep) {
        followers = deepClone(followers, true);
      }
      for (const follower of followers) {
        if (!retPens.find((p) => p.id === follower.id)) {
          retPens.push(follower);
        }
      }
    }
    return retPens;
  }
  setFollowers(pens = this.store.active) {
    if (!pens) {
      return;
    }
    if (pens.length < 2) {
      pens[0].followers = [];
    } else {
      let ids = pens.map((pen) => pen.id);
      ids.pop();
      const lastPen = pens[pens.length - 1];
      if (!lastPen.followers) {
        lastPen.followers = ids;
      } else {
        ids.forEach((id) => {
          if (!lastPen.followers.includes(id)) {
            lastPen.followers.push(id);
          }
        });
      }
    }
  }
  /**
   *  anchors
   * @param oldId  id
   * @param pen 
   * @param pastePens  pens 
   */
  changeLineAnchors(oldId, pen, pastePens) {
    if (!Array.isArray(pen.connectedLines)) {
      return;
    }
    for (let index = 0; index < pen.connectedLines.length; index++) {
      const { lineId } = pen.connectedLines[index];
      const line2 = pastePens.find((pen2) => pen2.id === lineId);
      if (line2) {
        const from = line2.anchors[0];
        const to = line2.anchors[line2.anchors.length - 1];
        from.connectTo === oldId && (from.connectTo = pen.id);
        to.connectTo === oldId && (to.connectTo = pen.id);
      } else {
        pen.connectedLines.splice(index, 1);
        index--;
      }
    }
  }
  /**
   *    node  connectedLines
   * @param oldId  id
   * @param line 
   * @param pastePens  pens ()
   */
  changeNodeConnectedLine(oldId, line2, pastePens) {
    var _a;
    const from = line2.anchors[0];
    const to = line2.anchors[line2.anchors.length - 1];
    const anchors = [from, to];
    for (const anchor of anchors) {
      const nodeId = anchor.connectTo;
      if (nodeId) {
        const node = pastePens.find((pen) => pen.id === nodeId);
        if (node) {
          (_a = node.connectedLines) == null ? void 0 : _a.forEach((cl) => {
            if (cl.lineId === oldId) {
              cl.lineId = line2.id;
              cl.lineAnchor = anchor.id;
            }
          });
        } else {
          anchor.connectTo = void 0;
          if (anchor.prev) {
            anchor.prev.connectTo = void 0;
          }
          if (anchor.next) {
            anchor.next.connectTo = void 0;
          }
        }
      }
    }
  }
  async delete(pens = this.store.active, canDelLocked = false, history2 = true) {
    if (!pens || !pens.length) {
      return;
    }
    if (this.beforeRemovePens && await this.beforeRemovePens(pens) != true) {
      return;
    }
    if (!canDelLocked) {
      pens = pens.filter((pen) => !pen.locked);
    }
    if (!pens || !pens.length) {
      return;
    }
    const deletePens = [];
    this._del(pens, deletePens, canDelLocked);
    this.initImageCanvas(deletePens);
    this.initTemplateCanvas(deletePens);
    this.inactive();
    this.clearHover();
    this.render();
    if (history2) {
      if (deletePens.length === 0)
        return;
      this.pushHistory({ type: EditType.Delete, pens: deletePens });
    }
    this.store.emitter.emit("delete", pens);
  }
  _del(pens, delPens, canDelLocked) {
    if (!pens) {
      return;
    }
    pens.forEach((pen) => {
      if (pen.type) {
        pen.lastConnected = {};
      }
      if (!pen.parentId) {
        if (!canDelLocked && pen.locked) {
          return;
        } else {
          if (delPens) {
            this.getDelPens(pen, delPens);
          }
          this.delForce(pen);
        }
      } else {
        const lockedParent = this.getLockedParent(pen);
        if (lockedParent) {
          console.warn("");
          return;
        } else {
          const parentPen = getParent(pen);
          const _index = parentPen.children.indexOf(pen.id);
          parentPen.children.splice(_index, 1);
          if (delPens) {
            this.getDelPens(pen, delPens);
          }
          this.delForce(pen);
        }
      }
    });
  }
  getDelPens(pen, delPens) {
    if (!pen) {
      return;
    }
    const i = this.store.data.pens.findIndex((item) => item.id === pen.id);
    if (i > -1) {
      const delPen = this.store.pens[pen.id];
      if (delPen && delPen.calculative) {
        delPen.calculative.active = void 0;
      }
      delPens.push(delPen);
    }
    if (pen.children) {
      pen.children.forEach((id) => {
        this.getDelPens(this.store.pens[id], delPens);
      });
    }
  }
  getLockedParent(pen) {
    if (!pen.parentId) {
      return false;
    }
    const parentPen = getParent(pen);
    if (parentPen.locked) {
      return parentPen;
    } else {
      this.getLockedParent(parentPen);
    }
  }
  delForce(pen) {
    var _a;
    if (!pen) {
      return;
    }
    const i = this.store.data.pens.findIndex((item) => item.id === pen.id);
    if (i > -1) {
      this.delConnectedLines(this.store.data.pens[i]);
      this.store.data.pens.splice(i, 1);
      this.store.pens[pen.id] = void 0;
      delete this.store.pens[pen.id];
      if (pen.pathId) {
        delete this.store.data.paths[pen.pathId];
      }
    }
    this.store.animates.delete(pen);
    this.store.animateMap.delete(pen);
    if (pen.children) {
      pen.children.forEach((id) => {
        this.delForce(this.store.pens[id]);
      });
    }
    (_a = pen.onDestroy) == null ? void 0 : _a.call(pen, pen);
  }
  delConnectedLines(pen) {
    var _a;
    if (pen.connectedLines) {
      for (let i = 0; i < pen.connectedLines.length; i++) {
        const { lineId, lineAnchor } = pen.connectedLines[i];
        const line2 = this.store.pens[lineId];
        if (line2) {
          let anchor = line2.anchors.find((anchor2) => anchor2.id === lineAnchor);
          if ((anchor == null ? void 0 : anchor.connectTo) === pen.id) {
            anchor.connectTo = void 0;
            anchor.anchorId = void 0;
            anchor.prev && (anchor.prev.connectTo = void 0);
            anchor.next && (anchor.next.connectTo = void 0);
          }
          anchor = getAnchor(line2, lineAnchor);
          if (anchor) {
            anchor.connectTo = void 0;
            anchor.anchorId = void 0;
            anchor.prev && (anchor.prev.connectTo = void 0);
            anchor.next && (anchor.next.connectTo = void 0);
          }
        }
      }
    }
    if (!pen.type) {
      return;
    }
    (_a = pen.calculative.worldAnchors) == null ? void 0 : _a.forEach((lineAnchor, index) => {
      var _a2;
      if (!lineAnchor.connectTo) {
        return;
      }
      const connectTo = this.store.pens[lineAnchor.connectTo];
      if (connectTo) {
        (_a2 = connectTo.calculative.worldAnchors) == null ? void 0 : _a2.forEach((anchor) => {
          disconnectLine(connectTo, anchor, pen, lineAnchor);
        });
      }
    });
  }
  convertSpecialCharacter(str) {
    var arrEntities = { lt: "<", gt: ">", nbsp: " ", amp: "&", quot: '"' };
    return str.replace(/&(lt|gt|nbsp|amp|quot);/gi, function(all, t) {
      return arrEntities[t];
    });
  }
  createInput() {
    this.inputParent.classList.add("meta2d-input");
    this.inputDiv.classList.add("input-div");
    this.inputParent.appendChild(this.inputDiv);
    this.dropdown.onmouseleave = () => {
      this.store.hover = null;
    };
    this.inputParent.appendChild(this.dropdown);
    this.externalElements.appendChild(this.inputParent);
    this.inputParent.onmousedown = this.stopPropagation;
    this.inputDiv.onmousedown = this.stopPropagation;
    this.inputDiv.contentEditable = "false";
    this.dropdown.onmousedown = this.stopPropagation;
    let sheet;
    for (let i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].title === "le5le.com") {
        sheet = document.styleSheets[i];
      }
    }
    if (!sheet) {
      const style = document.createElement("style");
      style.title = "le5le.com";
      document.head.appendChild(style);
      sheet = style.sheet;
      sheet.insertRule(".meta2d-input{display:none;position:absolute;outline:none;align-items: center;}");
      sheet.insertRule(".meta2d-input textarea{resize:none;border:none;outline:none;background:transparent;flex-grow:1;height:100%;left:0;top:0}");
      sheet.insertRule(".meta2d-input .right{width:10px;height:10px;flex-shrink:0;border-top: 1px solid;border-right: 1px solid;margin-right: 5px;transition: all .3s cubic-bezier(.645,.045,.355,1);position:absolute;right:1px;}");
      sheet.insertRule(".meta2d-input ul{position:absolute;top:100%;margin-top:4px; width:calc(100% + 10px);min-height:30px;border-radius: 2px;box-shadow: 0 2px 8px #00000026;list-style-type: none;background-color: #fff;padding: 4px 0;max-height: 105px;overflow-y: auto;}");
      sheet.insertRule(".meta2d-input ul li{padding: 5px 12px;line-height: 22px;white-space: nowrap;cursor: pointer;}");
      sheet.insertRule(".meta2d-input ul li:hover{background: #eeeeee;}");
      sheet.insertRule(`.input-div::-webkit-scrollbar {display:none}`);
      sheet.insertRule(`.input-div{scrollbar-width: none;}`);
      sheet.insertRule(".meta2d-input .input-div{resize:none;border:none;outline:none;background:transparent;flex-grow:1;height:100%;width: 100%;left:0;top:0;display:flex;text-align: center;justify-content: center;flex-direction: column;}");
      sheet.insertRule(`.input-div div{}`);
    }
    this.inputDiv.onfocus = (e) => {
      if (navigator.userAgent.includes("Firefox")) {
        if (!e.target.innerText) {
          let left = this.inputDiv.offsetWidth / 2;
          let inputDivStyle = window.getComputedStyle(this.inputDiv, null);
          if (inputDivStyle.textAlign !== "center") {
            left = 0;
          }
          this.inputDiv.innerHTML = `<br style="margin-left:${left}px;margin-top:4px;" />`;
        }
      } else {
        if (!e.target.innerText) {
          let inputDivStyle = window.getComputedStyle(this.inputDiv, null);
          if (inputDivStyle.justifyContent === "center") {
            this.inputDiv.style.paddingTop = ` ${this.inputDiv.offsetHeight / 2 - parseFloat(inputDivStyle.lineHeight) / 2}px`;
          }
        } else {
          this.inputDiv.style.paddingTop = "";
        }
      }
    };
    this.inputDiv.onblur = () => {
      setTimeout(() => {
        this.hideInput();
      }, 300);
    };
    this.inputDiv.oninput = (e) => {
      const pen = this.store.pens[this.inputDiv.dataset.penId];
      if (pen && pen.inputType === "number") {
        const value4 = e.target.innerText;
        const numericValue = value4.replace(/[^0-9]/g, "");
        if (value4 !== numericValue) {
          e.preventDefault();
          e.target.innerText = numericValue;
        }
      }
      if (navigator.userAgent.includes("Firefox")) {
        if (!e.target.innerText.trim()) {
          let left = this.inputDiv.offsetWidth / 2;
          let inputDivStyle = window.getComputedStyle(this.inputDiv, null);
          if (inputDivStyle.textAlign !== "center") {
            left = 0;
          }
          this.inputDiv.innerHTML = `<br style="margin-left:${left}px;margin-top:4px;" />`;
        }
      } else {
        if (!e.target.innerText) {
          let inputDivStyle = window.getComputedStyle(this.inputDiv, null);
          if (inputDivStyle.justifyContent === "center") {
            this.inputDiv.style.paddingTop = ` ${this.inputDiv.offsetHeight / 2 - parseFloat(inputDivStyle.lineHeight) / 2}px`;
          }
        } else {
          this.inputDiv.style.paddingTop = "";
        }
      }
      this.store.emitter.emit("input", pen);
    };
    this.inputDiv.onclick = (e) => {
      e.stopPropagation();
      const pen = this.store.pens[this.inputDiv.dataset.penId];
      if (this.dropdown.style.display === "block") {
        this.dropdown.style.display = "none";
      } else if ((pen == null ? void 0 : pen.dropdownList) && this.store.data.locked) {
        this.dropdown.style.display = "block";
      }
      this.store.emitter.emit("clickInput", pen);
    };
    this.inputDiv.onkeyup = (e) => {
      this.setDropdownList(true);
      const pen = this.store.pens[this.inputDiv.dataset.penId];
      this.store.emitter.emit("input", { pen, text: e.key });
      e.stopPropagation();
    };
    this.inputDiv.onkeydown = (e) => {
      e.stopPropagation();
    };
    this.inputDiv.onmousedown = this.stopPropagation;
    this.inputDiv.onwheel = (e) => {
      e.stopPropagation();
    };
    this.inputDiv.onpaste = (e) => {
      e.preventDefault();
      let text = "";
      if (e.clipboardData && e.clipboardData.getData) {
        text = e.clipboardData.getData("text/plain");
      }
      document.execCommand("insertHTML", false, text);
    };
  }
  clearDropdownList() {
    if (this.dropdown.hasChildNodes()) {
      for (let i = 0; i < this.dropdown.childNodes.length; i++) {
        this.dropdown.childNodes[i].remove();
        --i;
      }
    }
  }
  /**
   *  dropdown dom 
   * @param text 
   * @param index 
   */
  dropdownAppendOption(text, index) {
    const li = document.createElement("li");
    li.onwheel = this.stopPropagation;
    li.innerText = text;
    li.style.overflow = "hidden";
    li.style.textOverflow = "ellipsis";
    li.title = text;
    li.style.zoom = this.store.data.scale;
    li.onmousedown = this.stopPropagation;
    li.dataset.i = index + "";
    li.onclick = this.selectDropdown;
    const pen = this.store.pens[this.inputDiv.dataset.penId];
    li.onmouseenter = () => {
      li.style.background = pen.dropdownHoverBackground || "#eee";
      li.style.color = pen.dropdownHoverColor || "#bdc7db";
    };
    li.onmouseleave = () => {
      li.style.background = pen.dropdownBackground || "#fff";
      li.style.color = pen.dropdownColor || "#bdc7db";
    };
    this.dropdown.appendChild(li);
  }
  find(idOrTag) {
    return this.store.data.pens.filter((pen) => {
      return pen.id == idOrTag || pen.tags && pen.tags.indexOf(idOrTag) > -1;
    });
  }
  findOne(idOrTag) {
    return this.store.data.pens.find((pen) => {
      return pen.id == idOrTag || pen.tags && pen.tags.indexOf(idOrTag) > -1;
    });
  }
  changePenId(oldId, newId) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (oldId === newId) {
      return;
    }
    const pen = this.store.pens[oldId];
    if (!pen) {
      return;
    }
    if (this.store.pens[newId]) {
      return;
    }
    pen.id = newId;
    this.store.pens[newId] = this.store.pens[oldId];
    (_a = pen.onChangeId) == null ? void 0 : _a.call(pen, pen, oldId, newId);
    delete this.store.pens[oldId];
    if (pen.parentId) {
      const parent = this.store.pens[pen.parentId];
      const index = (_b = parent.children) == null ? void 0 : _b.findIndex((id) => id === oldId);
      index !== -1 && ((_c = parent.children) == null ? void 0 : _c.splice(index, 1, newId));
    }
    (_d = pen.children) == null ? void 0 : _d.forEach((childId) => {
      const child = this.store.pens[childId];
      child.parentId = newId;
    });
    if (pen.formId) {
      pen.followers.forEach((id) => {
        const followerPen = this.store.pens[id];
        followerPen.formId = newId;
      });
    }
    if (pen.type === PenType.Line) {
      this.changeNodeConnectedLine(oldId, pen, this.store.data.pens);
    } else {
      this.changeLineAnchors(oldId, pen, this.store.data.pens);
      (_e = pen.connectedLines) == null ? void 0 : _e.forEach(({ lineId }) => {
        const line2 = this.store.pens[lineId];
        calcWorldAnchors(line2);
      });
    }
    (_f = pen.anchors) == null ? void 0 : _f.forEach((anchor) => anchor.penId = newId);
    (_g = pen.calculative.worldAnchors) == null ? void 0 : _g.forEach((anchor) => anchor.penId = newId);
  }
  updateValue(pen, data) {
    var _a, _b;
    const penRect = this.getPenRect(pen);
    const oldName = pen.name;
    Object.assign(pen, data);
    const isChangedName = oldName !== pen.name;
    data.newId && this.changePenId(pen.id, data.newId);
    let willUpdatePath = false;
    let willCalcTextRect = false;
    let willPatchFlagsPenRect = false;
    let willCalcIconRect = false;
    let willSetPenRect = false;
    let containIsBottom = false;
    let oldRotate = void 0;
    let willRenderImage = false;
    for (const k in data) {
      if (k.indexOf(".") === -1) {
        if (k === "rotate") {
          if (pen.disableRotate) {
            pen.rotate = pen.calculative.rotate || 0;
          } else {
            oldRotate = pen.calculative.rotate || 0;
          }
        } else if (k === "canvasLayer" || k === "isBottom" || k === "showChild") {
          containIsBottom = true;
        } else if (k === "image") {
          willRenderImage = true;
        }
        if (typeof pen[k] !== "object" || k === "lineDash") {
          if (!pen.disableRotate || k !== "rotate") {
            pen.calculative[k] = data[k];
          }
        }
        if (needCalcTextRectProps.includes(k)) {
          willCalcTextRect = true;
        }
        if (["name", "borderRadius", "lineSmooth", "close"].includes(k)) {
          willUpdatePath = true;
        }
        if (needSetPenProps.includes(k)) {
          willSetPenRect = true;
        }
        if (needPatchFlagsPenRectProps.includes(k)) {
          willPatchFlagsPenRect = true;
        }
        if (needCalcIconRectProps.includes(k)) {
          willCalcIconRect = true;
        }
        if (pen.image && pen.name !== "gif" && ["globalAlpha", "flipY", "flipX", "x", "y", "width", "height", "iconWidth", "iconHeight", "imageRatio", "iconLeft", "iconTop", "iconAlign", "rotate"].includes(k)) {
          willRenderImage = true;
        }
      } else {
        delete pen[k];
        setter(pen, k, data[k]);
      }
      if (k.split(".")[0] === "anchors") {
        calcWorldAnchors(pen);
      }
    }
    this.setCalculativeByScale(pen);
    if (isChangedName) {
      (_a = pen.onDestroy) == null ? void 0 : _a.call(pen, pen);
      clearLifeCycle(pen);
    }
    if (willSetPenRect) {
      const rect = {
        x: data.x ?? penRect.x,
        y: data.y ?? penRect.y,
        width: data.width ?? penRect.width,
        height: data.height ?? penRect.height
      };
      this.setPenRect(pen, rect, false);
      this.updateLines(pen, true);
      if (this.store.active && this.store.active.length && pen.id === this.store.active[0].id) {
        this.calcActiveRect();
      }
    } else if (willPatchFlagsPenRect) {
      this.updatePenRect(pen);
    } else {
      willCalcTextRect && calcTextRect(pen);
      willCalcIconRect && calcIconRect(this.store.pens, pen);
      if (willUpdatePath) {
        globalStore.path2dDraws[pen.name] && this.store.path2dMap.set(pen, globalStore.path2dDraws[pen.name](pen));
      }
    }
    if (oldRotate !== void 0) {
      const currentRotate = pen.calculative.rotate;
      pen.calculative.rotate = oldRotate;
      this.rotatePen(pen, currentRotate - oldRotate, pen.calculative.worldRect);
    }
    if (data.image || data.backgroundImage || data.strokeImage) {
      pen.calculative.image = void 0;
      pen.calculative.backgroundImage = void 0;
      pen.calculative.strokeImage = void 0;
      this.loadImage(pen);
    }
    if (data.lineGradientColors) {
      pen.calculative.lineGradient = void 0;
      pen.calculative.gradientColorStop = void 0;
    }
    if (data.gradientColors) {
      pen.calculative.gradient = void 0;
      pen.calculative.radialGradient = void 0;
    }
    if (data.gradientRadius) {
      pen.calculative.gradient = void 0;
      pen.calculative.radialGradient = void 0;
    }
    if (data.animateLineWidth) {
      pen.calculative.gradientAnimatePath = void 0;
    }
    if (data.gradientSmooth) {
      pen.calculative.gradientAnimatePath = void 0;
    }
    if (containIsBottom) {
      this.canvasImage.init();
      this.canvasImageBottom.init();
    } else if (willRenderImage) {
      if (pen.canvasLayer === void 0) {
        pen.canvasLayer = CanvasLayer.CanvasImageBottom;
        pen.calculative.canvasLayer = CanvasLayer.CanvasImageBottom;
      }
      if (pen.canvasLayer === CanvasLayer.CanvasImageBottom) {
        this.canvasImageBottom.init();
      } else if (pen.canvasLayer === CanvasLayer.CanvasImage) {
        this.canvasImage.init();
      }
    }
    if (data.canvasLayer !== void 0 || pen.canvasLayer === CanvasLayer.CanvasTemplate) {
      this.initTemplateCanvas([pen]);
    }
    if (data.zIndex !== void 0) {
      ((_b = pen.calculative.singleton) == null ? void 0 : _b.div) && setElemPosition(pen, pen.calculative.singleton.div);
    }
  }
  /**
   *  pen  pen  onResize 
   */
  execPenResize(pen) {
    var _a, _b;
    (_a = pen.onResize) == null ? void 0 : _a.call(pen, pen);
    (_b = pen.children) == null ? void 0 : _b.forEach((chlidId) => {
      const child = this.store.pens[chlidId];
      child && this.execPenResize(child);
    });
  }
  setPenRect(pen, rect, render = true) {
    if (pen.parentId) {
      Object.assign(pen, rect);
    } else {
      const { origin, scale } = this.store.data;
      pen.x = origin.x + rect.x * scale;
      pen.y = origin.y + rect.y * scale;
      pen.width = rect.width * scale;
      pen.height = rect.height * scale;
    }
    this.updatePenRect(pen);
    this.execPenResize(pen);
    render && this.render();
  }
  getPenRect(pen, origin = this.store.data.origin, scale = this.store.data.scale) {
    if (!pen) {
      return;
    }
    if (pen.parentId) {
      return {
        x: pen.x,
        y: pen.y,
        width: pen.width,
        height: pen.height
      };
    }
    return {
      x: (pen.x - origin.x) / scale,
      y: (pen.y - origin.y) / scale,
      width: pen.width / scale,
      height: pen.height / scale
    };
  }
  toPng(padding = 2, callback, containBkImg = false, maxWidth) {
    const rect = getRect2(this.store.data.pens);
    const _scale = this.store.data.scale;
    if (!isFinite(rect.width)) {
      throw new Error("can not to png, because width is not finite");
    }
    const oldRect = deepClone(rect);
    const storeData = this.store.data;
    const isDrawBkImg = containBkImg && this.store.bkImg;
    let isRight = false, isBottom = false;
    if (isDrawBkImg) {
      rect.x += storeData.x;
      rect.y += storeData.y;
      calcRightBottom(rect);
      if (rectInRect(rect, this.canvasRect, true)) {
        Object.assign(rect, this.canvasRect);
      } else {
        const mergeArea = getRectOfPoints([
          ...rectToPoints(rect),
          ...rectToPoints(this.canvasRect)
        ]);
        Object.assign(rect, mergeArea);
      }
      isRight = rect.x === 0;
      isBottom = rect.y === 0;
    }
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    let isV = false;
    if (width && height && !this.store.data.component) {
      isV = true;
    }
    if (isV) {
      rect.x = this.store.data.origin.x;
      rect.y = this.store.data.origin.y;
      rect.width = width * this.store.data.scale;
      rect.height = height * this.store.data.scale;
    }
    const vRect = deepClone(rect);
    const p = formatPadding(padding);
    rect.x -= p[3] * _scale;
    rect.y -= p[0] * _scale;
    rect.width += (p[3] + p[1]) * _scale;
    rect.height += (p[0] + p[2]) * _scale;
    const scale = (maxWidth || 1920) / rect.width;
    rect.width *= scale;
    rect.height *= scale;
    calcRightBottom(rect);
    const canvas = document.createElement("canvas");
    canvas.width = rect.width;
    canvas.height = rect.height;
    if (canvas.width > 32767 || canvas.height > 32767 || !navigator.userAgent.includes("Firefox") && canvas.height * canvas.width > 268435456 || navigator.userAgent.includes("Firefox") && canvas.height * canvas.width > 472907776) {
      throw new Error("can not to png, because the size exceeds the browser limit");
    }
    const ctx = canvas.getContext("2d");
    ctx.textBaseline = "middle";
    ctx.scale(scale, scale);
    const background = this.store.data.background || this.store.styles.background;
    if (background && isV) {
      ctx.save();
      ctx.fillStyle = background;
      ctx.fillRect(0, 0, vRect.width + (p[1] + p[3]) * _scale, vRect.height + (p[0] + p[2]) * _scale);
      ctx.restore();
    }
    if (isDrawBkImg) {
      if (isV) {
        ctx.drawImage(this.store.bkImg, p[3] * _scale || 0, p[0] * _scale || 0, vRect.width, vRect.height);
      } else {
        const x = rect.x < 0 ? -rect.x : 0;
        const y = rect.y < 0 ? -rect.y : 0;
        ctx.drawImage(this.store.bkImg, x, y, this.canvasRect.width, this.canvasRect.height);
      }
    }
    if (background && !isV) {
      if (isDrawBkImg) {
        const x = rect.x < 0 ? -rect.x : 0;
        const y = rect.y < 0 ? -rect.y : 0;
        ctx.save();
        ctx.fillStyle = background;
        ctx.fillRect(x, y, this.canvasRect.width, this.canvasRect.height);
        ctx.restore();
      } else {
        ctx.save();
        ctx.fillStyle = background;
        ctx.fillRect(0, 0, oldRect.width + (p[3] + p[1]) * _scale, oldRect.height + (p[0] + p[2]) * _scale);
        ctx.restore();
      }
    }
    if (!isDrawBkImg) {
      ctx.translate(-rect.x, -rect.y);
    } else {
      if (isV) {
        ctx.translate(-rect.x, -rect.y);
      } else {
        ctx.translate((isRight ? storeData.x : -oldRect.x) + p[3] * _scale || 0, (isBottom ? storeData.y : -oldRect.y) + p[0] * _scale || 0);
      }
    }
    for (const pen of this.store.data.pens) {
      if (!isShowChild(pen, this.store) || pen.visible == false) {
        continue;
      }
      if (pen.name === "combine" && !pen.draw) {
        continue;
      }
      const { active } = pen.calculative;
      pen.calculative.active = false;
      if (pen.calculative.img) {
        renderPenRaw2(ctx, pen);
      } else {
        renderPen(ctx, pen, true);
      }
      pen.calculative.active = active;
    }
    if (callback) {
      canvas.toBlob(callback);
      return;
    }
    return canvas.toDataURL();
  }
  activeToPng(padding = 2, maxWidth) {
    return this.pensToPng(this.store.active, padding, maxWidth);
  }
  pensToPng(pens = this.store.active, padding = 2, maxWidth) {
    if (pens.length === 0) {
      return;
    }
    const allPens = this.getAllByPens(pens);
    let ids = allPens.map((pen) => pen.id);
    const rect = getRect2(allPens);
    if (!isFinite(rect.width)) {
      throw new Error("can not to png, because width is not finite");
    }
    const oldRect = deepClone(rect);
    const p = formatPadding(padding);
    rect.x -= p[3];
    rect.y -= p[0];
    rect.width += p[3] + p[1];
    rect.height += p[0] + p[2];
    calcRightBottom(rect);
    const scale = (maxWidth || rect.width) / rect.width;
    rect.width *= scale;
    rect.height *= scale;
    const canvas = document.createElement("canvas");
    canvas.width = rect.width;
    canvas.height = rect.height;
    if (canvas.width > 32767 || canvas.height > 32767 || !navigator.userAgent.includes("Firefox") && canvas.height * canvas.width > 268435456 || navigator.userAgent.includes("Firefox") && canvas.height * canvas.width > 472907776) {
      throw new Error("can not to png, because the size exceeds the browser limit");
    }
    const ctx = canvas.getContext("2d");
    ctx.textBaseline = "middle";
    ctx.scale(scale, scale);
    const background = this.store.data.background || this.store.styles.background;
    if (background) {
      ctx.save();
      ctx.fillStyle = background;
      ctx.fillRect(0, 0, oldRect.width + (p[3] + p[1]), oldRect.height + (p[0] + p[2]));
      ctx.restore();
    }
    ctx.translate(-oldRect.x + p[3], -oldRect.y + p[0]);
    for (const pen of this.store.data.pens) {
      if (ids.includes(pen.id)) {
        if (!isShowChild(pen, this.store) || pen.visible == false) {
          continue;
        }
        if (pen.name === "combine" && !pen.draw) {
          continue;
        }
        const { active } = pen.calculative;
        pen.calculative.active = false;
        if (pen.calculative.img) {
          renderPenRaw2(ctx, pen);
        } else {
          renderPen(ctx, pen);
        }
        pen.calculative.active = active;
      }
    }
    return canvas.toDataURL();
  }
  toggleAnchorMode() {
    var _a;
    if (!this.hotkeyType) {
      if (this.store.options.disableAnchor || ((_a = this.store.hover) == null ? void 0 : _a.disableAnchor)) {
        return;
      }
      this.hotkeyType = HotkeyType.AddAnchor;
      if (this.store.hover) {
        this.externalElements.style.cursor = "pointer";
      }
    } else if (this.hotkeyType === HotkeyType.AddAnchor) {
      this.hotkeyType = HotkeyType.None;
      if (this.store.hoverAnchor) {
        this.externalElements.style.cursor = "vertical-text";
      } else if (this.store.hover) {
        this.externalElements.style.cursor = "move";
      }
    }
    this.patchFlags = true;
  }
  addAnchorHand() {
    if (this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
      const initPens = [deepClone(this.store.active[0], true)];
      if (!this.store.activeAnchor.prev) {
        if (!this.store.activeAnchor.next) {
          this.store.activeAnchor.next = {
            penId: this.store.activeAnchor.penId,
            x: this.store.activeAnchor.x + 50,
            y: this.store.activeAnchor.y
          };
        }
        this.store.activeAnchor.prev = { ...this.store.activeAnchor.next };
        rotatePoint(this.store.activeAnchor.prev, 180, this.store.activeAnchor);
        this.initLineRect(this.store.active[0]);
        this.patchFlags = true;
      } else if (!this.store.activeAnchor.next) {
        this.store.activeAnchor.next = { ...this.store.activeAnchor.prev };
        rotatePoint(this.store.activeAnchor.next, 180, this.store.activeAnchor);
        this.initLineRect(this.store.active[0]);
        this.patchFlags = true;
      }
      this.pushHistory({
        type: EditType.Update,
        pens: [deepClone(this.store.active[0], true)],
        initPens
      });
    }
  }
  removeAnchorHand() {
    if (this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
      const initPens = [deepClone(this.store.active[0], true)];
      if (this.hoverType === HoverType.LineAnchorPrev) {
        this.store.activeAnchor.prev = void 0;
        this.initLineRect(this.store.active[0]);
        this.patchFlags = true;
      } else if (this.hoverType === HoverType.LineAnchorNext) {
        this.store.activeAnchor.next = void 0;
        this.initLineRect(this.store.active[0]);
        this.patchFlags = true;
      } else {
        this.store.activeAnchor.prev = void 0;
        this.store.activeAnchor.next = void 0;
        this.initLineRect(this.store.active[0]);
        this.patchFlags = true;
      }
      this.pushHistory({
        type: EditType.Update,
        pens: [deepClone(this.store.active[0])],
        initPens
      });
    }
  }
  toggleAnchorHand() {
    if (this.store.active.length === 1 && this.store.active[0].type && this.store.activeAnchor) {
      if (!this.store.activeAnchor.prevNextType) {
        this.store.activeAnchor.prevNextType = PrevNextType.Mirror;
      }
      this.store.activeAnchor.prevNextType = (this.store.activeAnchor.prevNextType + 1) % 3;
    }
  }
  gotoView(x, y) {
    let rect = getRect2(this.store.data.pens);
    if (!isFinite(rect.width)) {
      throw new Error("can not move view, because width is not finite");
    }
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    if (width && height) {
      rect = {
        x: this.store.data.origin.x,
        y: this.store.data.origin.y,
        width: width * this.store.data.scale,
        height: height * this.store.data.scale
      };
    }
    this.store.data.x = this.canvas.clientWidth / 2 - x * rect.width - rect.x;
    this.store.data.y = this.canvas.clientHeight / 2 - y * rect.height - rect.y;
    this.onMovePens();
    this.canvasTemplate.init();
    this.canvasImage.init();
    this.canvasImageBottom.init();
    this.render();
  }
  showMagnifier() {
    this.magnifierCanvas.canvas.style.zIndex = "100";
    this.externalElements.style.zIndex = "101";
    this.magnifierCanvas.magnifier = true;
    this.magnifierCanvas.updateDomOffscreen();
    this.externalElements.style.cursor = "default";
    this.render();
  }
  hideMagnifier() {
    this.magnifierCanvas.canvas.style.zIndex = "5";
    this.externalElements.style.zIndex = "5";
    this.magnifierCanvas.magnifier = false;
    this.externalElements.style.cursor = "default";
    this.render();
  }
  showFit() {
    this.store.data.locked = 0;
    this.canvasImage.fitFlag = true;
    this.canvasImage.activeFit = void 0;
    this.canvasImage.currentFit = void 0;
    if (!this.store.data.fits) {
      this.store.data.fits = [];
    }
    this.store.data.fits.forEach((fit) => fit.active = false);
    this.canvasImage.init();
    this.canvasImage.render();
  }
  hideFit() {
    this.canvasImage.fitFlag = false;
    this.canvasImage.activeFit = void 0;
    this.canvasImage.currentFit = void 0;
    this.canvasImage.init();
    this.canvasImage.render();
  }
  makeFit() {
    if (this.dragRect.width < 100 && this.dragRect.height < 100) {
      return;
    }
    const pens = this.store.data.pens.filter((pen) => {
      if (
        // pen.locked >= LockState.DisableMove || 
        pen.parentId || pen.isRuleLine
      ) {
        return false;
      }
      if (rectInRect(pen.calculative.worldRect, this.dragRect, true)) {
        if (pen.type === PenType.Line && !this.store.options.dragAllIn) {
          return lineInRect(pen, this.dragRect);
        }
        return true;
      }
    });
    if (!pens.length) {
      return;
    }
    const _rect = this.parent.getRect(pens);
    const scale = this.store.data.scale;
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    let x = (Math.floor(_rect.x) - this.store.data.origin.x) / scale / width;
    let y = (Math.floor(_rect.y) - this.store.data.origin.y) / scale / height;
    let rect = {
      x,
      y,
      width: (Math.ceil(_rect.width) + 1) / scale / width,
      height: (Math.ceil(_rect.height) + 1) / scale / height,
      children: pens.map((pen) => pen.id),
      id: s8(),
      active: true
    };
    if (rect.x < -0.1) {
      rect.x = -0.1;
    }
    if (rect.y < -0.1) {
      rect.y = -0.1;
    }
    if (rect.width > 0.5) {
      rect.left = true;
      rect.right = true;
      rect.leftValue = (rect.x - 0) * scale * width;
      rect.rightValue = (1 - (rect.x + rect.width)) * scale * width;
    } else {
      if (rect.x < 0.5) {
        rect.left = true;
        rect.leftValue = (rect.x - 0) * scale * width;
      } else {
        rect.right = true;
        rect.rightValue = (1 - (rect.x + rect.width)) * scale * width;
      }
    }
    if (rect.leftValue < 1) {
      rect.leftValue = 0;
    }
    if (rect.rightValue < 1) {
      rect.rightValue = 0;
    }
    if (rect.height > 0.5) {
      rect.top = true;
      rect.bottom = true;
      rect.topValue = (rect.y - 0) * scale * height;
      rect.bottomValue = (1 - (rect.y + rect.height)) * scale * height;
    } else {
      if (rect.y < 0.5) {
        rect.top = true;
        rect.topValue = (rect.y - 0) * scale * height;
      } else {
        rect.bottom = true;
        rect.bottomValue = (1 - (rect.y + rect.height)) * scale * height;
      }
    }
    if (rect.topValue < 1) {
      rect.topValue = 0;
    }
    if (rect.bottomValue < 1) {
      rect.bottomValue = 0;
    }
    if (!this.store.data.fits) {
      this.store.data.fits = [];
    }
    this.store.data.fits.forEach((fit) => {
      fit.active = false;
    });
    this.store.data.fits.push(rect);
    this.canvasImage.activeFit = rect;
    this.store.emitter.emit("fit", rect);
    this.canvasImage.init();
    this.canvasImage.render();
  }
  updateFit(e) {
    const scale = this.store.data.scale;
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    let x = (e.x - this.store.data.origin.x) / scale / width;
    let y = (e.y - this.store.data.origin.y) / scale / height;
    if (this.canvasImage.currentFit) {
      const fit = this.canvasImage.activeFit;
      if (this.canvasImage.currentFit === "top") {
        if (y < -0.1) {
          y = -0.1;
        }
        let gap = y - fit.y;
        fit.height -= gap;
        if (fit.height < 0.01) {
          fit.height = 0.01;
          return;
        }
        fit.y = y;
      }
      if (this.canvasImage.currentFit === "bottom") {
        if (y > 1.1) {
          y = 1.1;
        }
        fit.height = y - fit.y;
        if (fit.height <= 0.01) {
          fit.height = 0.01;
        }
      }
      if (this.canvasImage.currentFit === "left") {
        if (x < -0.1) {
          x = -0.1;
        }
        let gap = x - fit.x;
        fit.width -= gap;
        if (fit.width < 0.01) {
          fit.width = 0.01;
          return;
        }
        fit.x = x;
      }
      if (this.canvasImage.currentFit === "right") {
        if (x > 1.1) {
          x = 1.1;
        }
        fit.width = x - fit.x;
        if (fit.width <= 0.01) {
          fit.width = 0.01;
        }
      }
      let rect = {
        x: fit.x * width * scale + this.store.data.origin.x,
        y: fit.y * height * scale + this.store.data.origin.y,
        width: fit.width * width * scale,
        height: fit.height * height * scale
      };
      calcRightBottom(rect);
      const pens = this.store.data.pens.filter((pen) => {
        if (
          // pen.locked >= LockState.DisableMove || 
          pen.parentId || pen.isRuleLine
        ) {
          return false;
        }
        if (rectInRect(pen.calculative.worldRect, rect, true)) {
          if (pen.type === PenType.Line && !this.store.options.dragAllIn) {
            return lineInRect(pen, rect);
          }
          return true;
        }
      });
      fit.left = void 0;
      fit.leftValue = void 0;
      fit.right = void 0;
      fit.rightValue = void 0;
      fit.top = void 0;
      fit.topValue = void 0;
      fit.bottom = void 0;
      fit.bottomValue = void 0;
      if (fit.width > 0.5) {
        fit.left = true;
        fit.right = true;
        fit.leftValue = (fit.x - 0) * scale * width;
        fit.rightValue = (1 - (fit.x + fit.width)) * scale * width;
      } else {
        if (fit.x < 0.5) {
          fit.left = true;
          fit.leftValue = (fit.x - 0) * scale * width;
        } else {
          fit.right = true;
          fit.rightValue = (1 - (fit.x + fit.width)) * scale * width;
        }
      }
      if (Math.abs(fit.leftValue) < 1) {
        fit.leftValue = 0;
      }
      if (Math.abs(fit.rightValue) < 1) {
        fit.rightValue = 0;
      }
      if (fit.height > 0.5) {
        fit.top = true;
        fit.bottom = true;
        fit.topValue = (fit.y - 0) * scale * height;
        fit.bottomValue = (1 - (fit.y + fit.height)) * scale * height;
      } else {
        if (fit.y < 0.5) {
          fit.top = true;
          fit.topValue = (fit.y - 0) * scale * height;
        } else {
          fit.bottom = true;
          fit.bottomValue = (1 - (fit.y + fit.height)) * scale * height;
        }
      }
      if (Math.abs(fit.topValue) < 1) {
        fit.topValue = 0;
      }
      if (Math.abs(fit.bottomValue) < 1) {
        fit.bottomValue = 0;
      }
      fit.children = pens.map((pen) => pen.id);
      this.store.emitter.emit("fit", fit);
      this.mouseDown.x = e.x;
      this.mouseDown.y = e.y;
      this.canvasImage.init();
      this.canvasImage.render();
    }
  }
  updateFitRect(fit = this.canvasImage.activeFit) {
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    if (fit.left) {
      if (fit.leftValue) {
        fit.x = Math.abs(fit.leftValue) < 1 ? fit.leftValue : fit.leftValue / width;
      } else {
        fit.x = 0;
      }
    }
    if (fit.right) {
      if (fit.rightValue) {
        fit.width = 1 - (Math.abs(fit.rightValue) < 1 ? fit.rightValue : fit.rightValue / width) - fit.x;
      } else {
        fit.width = 1 - fit.x;
      }
    }
    if (fit.top) {
      if (fit.topValue) {
        fit.y = Math.abs(fit.topValue) < 1 ? fit.topValue : fit.topValue / height;
      } else {
        fit.y = 0;
      }
    }
    if (fit.bottom) {
      if (fit.bottomValue) {
        fit.height = 1 - (Math.abs(fit.bottomValue) < 1 ? fit.bottomValue : fit.bottomValue / height) - fit.y;
      } else {
        fit.height = 1 - fit.y;
      }
    }
    this.canvasImage.init();
    this.canvasImage.render();
  }
  deleteFit(fit = this.canvasImage.activeFit) {
    if (!fit) {
      return;
    }
    const index = this.store.data.fits.findIndex((item) => item.id === fit.id);
    this.store.data.fits.splice(index, 1);
    this.canvasImage.activeFit = void 0;
    this.canvasImage.init();
    this.canvasImage.render();
    this.store.emitter.emit("fit", void 0);
  }
  calcuActiveFit() {
    var _a;
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    let downX = (this.mouseDown.x - this.store.data.origin.x) / this.store.data.scale / width;
    let downY = (this.mouseDown.y - this.store.data.origin.y) / this.store.data.scale / height;
    let idx = -1;
    let lastActiveIdx = -1;
    (_a = this.store.data.fits) == null ? void 0 : _a.forEach((fit, index) => {
      fit.ex = null;
      fit.ey = null;
      if (pointInRect({ x: downX, y: downY }, fit)) {
        idx = index;
      }
      ;
      if (fit.active) {
        lastActiveIdx = index;
      }
    });
    if (idx !== -1 && idx !== lastActiveIdx) {
      this.canvasImage.activeFit = this.store.data.fits[idx];
      this.store.data.fits[idx].active = true;
      if (lastActiveIdx !== -1) {
        this.store.data.fits[lastActiveIdx].active = false;
      }
      this.store.emitter.emit("fit", this.store.data.fits[idx]);
    } else if (idx === -1 && lastActiveIdx !== -1) {
      this.store.data.fits[lastActiveIdx].active = false;
      this.store.emitter.emit("fit", void 0);
      this.canvasImage.activeFit = null;
    }
    this.inactive();
    this.canvasImage.init();
    this.canvasImage.render();
  }
  toggleMagnifier() {
    this.magnifierCanvas.magnifier = !this.magnifierCanvas.magnifier;
    if (this.magnifierCanvas.magnifier) {
      this.externalElements.style.cursor = "default";
    }
    this.render();
  }
  destroy() {
    var _a, _b, _c, _d;
    this.scroll && this.scroll.destroy();
    (_a = this.tooltip) == null ? void 0 : _a.destroy();
    (_b = this.dialog) == null ? void 0 : _b.destroy();
    (_c = this.title) == null ? void 0 : _c.destroy();
    (_d = this.popconfirm) == null ? void 0 : _d.destroy();
    this.externalElements.removeEventListener("gesturestart", this.onGesturestart);
    this.externalElements.ondragover = (e) => e.preventDefault();
    this.externalElements.ondrop = void 0;
    this.externalElements.ontouchstart = void 0;
    this.externalElements.ontouchmove = void 0;
    this.externalElements.ontouchend = void 0;
    this.externalElements.onmousedown = void 0;
    this.externalElements.onmousemove = void 0;
    this.externalElements.onmouseup = void 0;
    this.externalElements.onmouseleave = void 0;
    this.externalElements.ondblclick = void 0;
    switch (this.store.options.keydown) {
      case KeydownType.Document:
        document.removeEventListener("keydown", this.onkeydown);
        document.removeEventListener("keyup", this.onkeyup);
        break;
      case KeydownType.Canvas:
        this.externalElements.removeEventListener("keydown", this.onkeydown);
        this.externalElements.removeEventListener("keyup", this.onkeyup);
        break;
    }
    document.removeEventListener("copy", this.onCopy);
    document.removeEventListener("cut", this.onCut);
    document.removeEventListener("paste", this.onPaste);
    window && window.removeEventListener("message", this.onMessage);
    window && window.removeEventListener("resize", this.onResize);
    window && window.removeEventListener("scroll", this.onScroll);
    this.parentElement.innerHTML = "";
  }
};

// node_modules/@meta2d/core/src/diagrams/form.js
function form(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  if (!pen.onDestroy) {
    pen.onDestroy = destory3;
    pen.onMove = move3;
    pen.onRotate = move3;
    pen.onMouseEnter = mouseEnter;
    pen.onMouseLeave = mouseLeave;
    pen.onMouseMove = mouseMove2;
    pen.onMouseUp = mouseUp;
    pen.onInput = input;
  }
  pen.formId = pen.id;
  let wr = pen.calculative.borderRadius || 0, hr = wr;
  const { x, y, width, height, ex, ey } = pen.calculative.worldRect;
  const { x: textX } = pen.calculative.worldTextRect;
  if (wr < 1) {
    wr = width * wr;
    hr = height * hr;
  }
  let r = wr < hr ? wr : hr;
  if (width < 2 * r) {
    r = width / 2;
  }
  if (height < 2 * r) {
    r = height / 2;
  }
  path.moveTo(x + r, y);
  path.arcTo(ex, y, ex, ey, r);
  path.arcTo(ex, ey, x, ey, r);
  path.arcTo(x, ey, x, y, r);
  path.arcTo(x, y, ex, y, r);
  if (path instanceof Path2D) {
    return path;
  }
}
function input(pen, text) {
  pen.text = text;
  pen.calculative.text = pen.text;
  pen.calculative.canvas.updatePenRect(pen);
}
function destory3(pen) {
}
function move3(pen) {
}
function mouseEnter(pen) {
}
function mouseLeave(pen) {
  const activePens = pen.calculative.canvas.store.active;
  if (activePens && activePens.length) {
    activePens.forEach((activePen) => {
      if (pen.followers) {
        let idx = pen.followers.findIndex((id) => id === activePen.id);
        if (idx !== -1) {
          const movingPen = pen.calculative.canvas.store.pens[activePen.id + movingSuffix];
          if (movingPen && movingPen.calculative) {
            let isIn = rectInRect(movingPen.calculative.worldRect, pen.calculative.worldRect, true);
            if (!isIn) {
              pen.followers.splice(idx, 1);
              delete activePen.formId;
            }
          }
        }
      }
    });
  }
}
function mouseUp(pen) {
  const activePens = pen.calculative.canvas.store.active;
  if (activePens && activePens.length) {
    activePens.forEach((activePen) => {
      const movingPen = pen.calculative.canvas.store.pens[activePen.id + movingSuffix];
      if (movingPen && movingPen.calculative) {
        let inRect = deepClone(pen.calculative.worldRect);
        inRect.x -= 1;
        inRect.y -= 1;
        inRect.width += 2;
        inRect.height += 2;
        if (rectInRect(movingPen.calculative.worldRect, inRect, true)) {
          if (!pen.followers) {
            pen.followers = [];
          }
          if (!pen.followers.includes(activePen.id)) {
            pen.followers.push(activePen.id);
          }
          activePen.formId = pen.id;
        }
      }
    });
  }
}
function mouseMove2(pen, e) {
}
function updateFormData(pen, key) {
  if (pen.formId && pen.formKey && pen.formValue) {
    const leaderPen = pen.calculative.canvas.store.pens[pen.formId];
    if (leaderPen) {
      if (!leaderPen.formData) {
        leaderPen.formData = {};
      }
      leaderPen.formData[pen.formKey] = pen[pen.formValue];
    }
  }
}
function reset(pen) {
  const formPen = pen.calculative.canvas.store.pens[pen.formId];
  formPen.followers.forEach((id) => {
    const follower = pen.calculative.canvas.store.pens[id];
    if (follower.formId && follower.formKey && formPen.formData[follower.formKey]) {
      const value4 = follower[follower.formValue];
      let data = "";
      if (Array.isArray(value4)) {
        data = [];
      }
      pen.calculative.canvas.parent.setValue({ id: follower.id, [follower.formValue]: data }, { render: false, doEvent: false, history: false });
    }
  });
  formPen.formData = {};
  pen.calculative.canvas.parent.render();
}

// node_modules/@meta2d/core/src/diagrams/gif.js
var gifsList = {};
function gif(pen) {
  if (!pen.onDestroy) {
    pen.onDestroy = destory4;
    pen.onMove = move4;
    pen.onResize = resize2;
    pen.onRotate = move4;
    pen.onValue = value2;
    pen.onChangeId = changeId2;
  }
  const path = new Path2D();
  if (!pen.image) {
    return;
  }
  const meta2dId = pen.calculative.canvas.store.id;
  const id = meta2dId + "-" + pen.id;
  if (!gifsList[id]) {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = pen.image;
    if (pen.calculative.canvas.parent.store.options.cdn && !(pen.image.startsWith("http") || pen.image.startsWith("//") || pen.image.startsWith("data:image"))) {
      img.src = pen.calculative.canvas.parent.store.options.cdn + pen.image;
    }
    gifsList[id] = img;
    img.onload = () => {
      var _a;
      if (gifsList[id] !== img) {
        return;
      }
      pen.calculative.img = img;
      pen.calculative.imgNaturalWidth = img.naturalWidth || pen.iconWidth;
      pen.calculative.imgNaturalHeight = img.naturalHeight || pen.iconHeight;
      (_a = pen.calculative.canvas.externalElements) == null ? void 0 : _a.parentElement.appendChild(img);
      setImagePosition(pen, img);
    };
  }
  if (pen.calculative.patchFlags && gifsList[id]) {
    setImagePosition(pen, gifsList[id]);
  }
  return path;
}
function destory4(pen) {
  const meta2dId = pen.calculative.canvas.store.id;
  const id = meta2dId + "-" + pen.id;
  if (gifsList[id]) {
    gifsList[id].remove();
    gifsList[id] = void 0;
  }
}
function move4(pen) {
  const meta2dId = pen.calculative.canvas.store.id;
  const id = meta2dId + "-" + pen.id;
  if (!gifsList[id]) {
    return;
  }
  setImagePosition(pen, gifsList[id]);
}
function resize2(pen) {
  const meta2dId = pen.calculative.canvas.store.id;
  const id = meta2dId + "-" + pen.id;
  if (!gifsList[id]) {
    return;
  }
  setImagePosition(pen, gifsList[id]);
}
function value2(pen) {
  const meta2dId = pen.calculative.canvas.store.id;
  const id = meta2dId + "-" + pen.id;
  if (!gifsList[id]) {
    return;
  }
  setImagePosition(pen, gifsList[id]);
  if (gifsList[id].getAttribute("src") !== pen.image) {
    gifsList[id].src = pen.image;
  }
}
function changeId2(pen, oldId, newId) {
  const meta2dId = pen.calculative.canvas.store.id;
  if (!gifsList[meta2dId + "-" + oldId]) {
    return;
  }
  gifsList[meta2dId + "-" + newId] = gifsList[meta2dId + "-" + oldId];
  delete gifsList[meta2dId + "-" + oldId];
}
function setImagePosition(pen, elem) {
  elem.style.objectFit = pen.imageRatio ? "contain" : "fill";
  setElemPosition(pen, elem);
}

// node_modules/@meta2d/core/src/diagrams/mindNode.js
function mindNode(pen, ctx) {
  if (!pen.onResize) {
    pen.onResize = resize3;
    pen.onValue = value3;
  }
  return rectangle(pen, ctx);
}
function resize3(pen) {
  const manualPoints = pen.anchors.filter((point) => point.flag !== 1);
  mindNodeAnchors(pen);
  pen.anchors = pen.anchors.concat(...manualPoints);
}
function value3(pen) {
  resize3(pen);
  calcWorldAnchors(pen);
}
function mindNodeAnchors(pen) {
  const anchors = [];
  const { x: rectX, y: rectY, width, height } = pen;
  const r = borderRadius(pen);
  const topN = 5;
  for (let i = 0; i < topN; i++) {
    if (i === 2) {
      continue;
    }
    let x = rectX + width * (i + 1) / (topN + 1);
    let y = rectY;
    if (x < rectX + r) {
      y = getYByCircle(rectX + r, y + r, x, r, -1);
    } else if (x > rectX + width - r) {
      y = getYByCircle(rectX + width - r, y + r, x, r, -1);
    }
    anchors.push({
      id: String(anchors.length),
      flag: 1,
      penId: pen.id,
      x: (x - rectX) / width,
      y: (y - rectY) / height
    });
  }
  const rightN = 3;
  for (let i = 0; i < rightN; i++) {
    let y = rectY + height * (i + 1) / (rightN + 1);
    let x = rectX + width;
    if (y < rectY + r) {
      x = getXByCircle(x - r, rectY + r, y, r);
    } else if (y > rectY + height - r) {
      x = getXByCircle(x - r, rectY + height - r, y, r);
    }
    anchors.push({
      id: String(anchors.length),
      flag: 1,
      penId: pen.id,
      x: (x - rectX) / width,
      y: (y - rectY) / height
    });
  }
  const bottomN = 5;
  for (let i = 0; i < bottomN; i++) {
    if (i === 2) {
      continue;
    }
    let x = rectX + width * (i + 1) / (bottomN + 1);
    let y = rectY + height;
    if (x < rectX + r) {
      y = getYByCircle(rectX + r, y - r, x, r);
    } else if (x > rectX + width - r) {
      y = getYByCircle(rectX + width - r, y - r, x, r);
    }
    anchors.push({
      id: String(anchors.length),
      flag: 1,
      penId: pen.id,
      x: (x - rectX) / width,
      y: (y - rectY) / height
    });
  }
  const leftN = 3;
  for (let i = 0; i < leftN; i++) {
    let y = rectY + height * (i + 1) / (leftN + 1);
    let x = rectX;
    if (y < rectY + r) {
      x = getXByCircle(x + r, rectY + r, y, r, -1);
    } else if (y > rectY + height - r) {
      x = getXByCircle(x + r, rectY + height - r, y, r, -1);
    }
    anchors.push({
      id: String(anchors.length),
      flag: 1,
      penId: pen.id,
      x: (x - rectX) / width,
      y: (y - rectY) / height
    });
  }
  pen.anchors = anchors;
}
function borderRadius(pen) {
  let wr = pen.calculative.borderRadius || 0;
  let hr = pen.calculative.borderRadius || 0;
  const { width, height } = pen;
  if (pen.calculative.borderRadius < 1) {
    wr = width * pen.calculative.borderRadius;
    hr = height * pen.calculative.borderRadius;
  }
  let r = wr < hr ? wr : hr;
  if (width < 2 * r) {
    r = width / 2;
  }
  if (height < 2 * r) {
    r = height / 2;
  }
  return r;
}
function getXByCircle(ox, oy, y, r, sqrt = 1) {
  return sqrt * Math.sqrt(r ** 2 - (y - oy) ** 2) + ox;
}
function getYByCircle(ox, oy, x, r, sqrt = 1) {
  return sqrt * Math.sqrt(r ** 2 - (x - ox) ** 2) + oy;
}

// node_modules/@meta2d/core/src/diagrams/mindLine.js
function mindLine(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const { x, y, width, height } = pen.calculative.worldRect;
  path.moveTo(x, y + height);
  path.lineTo(x + width, y + height);
  path.closePath();
  if (path instanceof Path2D)
    return path;
}
function mindLineAnchors(pen) {
  const points = [
    {
      x: 0,
      y: 1
    },
    {
      x: 1,
      y: 1
    }
  ];
  pen.anchors = points.map(({ x, y }, index) => {
    return {
      id: index + "",
      x,
      y,
      penId: pen.id
    };
  });
}

// node_modules/@meta2d/core/src/diagrams/index.js
function commonPens() {
  return {
    rectangle,
    square,
    circle,
    svgPath,
    diamond,
    triangle,
    pentagon,
    pentagram,
    hexagon,
    leftArrow,
    rightArrow,
    twowayArrow,
    message,
    cloud,
    file,
    people,
    line,
    iframe,
    video,
    gif,
    mindNode,
    mindLine,
    mindNode2: rectangle,
    form,
    combine: rectangle
  };
}
function commonAnchors() {
  return {
    triangle: triangleAnchors,
    pentagon: pentagonAnchors,
    pentagram: pentagramAnchors,
    mindNode: mindNodeAnchors,
    mindLine: mindLineAnchors
  };
}

// node_modules/@meta2d/core/src/pen/text.js
function calcTextRect(pen) {
  const { paddingTop, paddingBottom, paddingLeft, paddingRight, worldRect, canvas } = pen.calculative;
  let { textLeft, textTop, textWidth, textHeight } = pen.calculative;
  let x = paddingLeft;
  let y = paddingTop;
  const width = worldRect.width - paddingLeft - paddingRight;
  const height = worldRect.height - paddingTop - paddingBottom;
  if (textWidth && textWidth < 1) {
    textWidth *= worldRect.width;
  }
  if (textHeight && textHeight < 1) {
    textHeight *= worldRect.height;
  }
  if (textWidth < pen.calculative.fontSize) {
    textWidth = pen.calculative.fontSize;
  }
  x += (textLeft || 0) + worldRect.x;
  y += (textTop || 0) + worldRect.y;
  const textAlign = pen.textAlign || canvas.store.options.textAlign;
  const textBaseline = pen.textBaseline || canvas.store.options.textBaseline;
  switch (textAlign) {
    case "center":
      x += (width - (textWidth || width)) / 2;
      break;
    case "right":
      x += width - (textWidth || width);
      break;
  }
  switch (textBaseline) {
    case "middle":
      y += (height - (textHeight || height)) / 2;
      break;
    case "bottom":
      y += height - (textHeight || height);
      break;
  }
  const rect = {
    x,
    y,
    width: textWidth || width,
    height: textHeight || height
  };
  calcRightBottom(rect);
  pen.calculative.worldTextRect = rect;
  calcTextLines(pen);
  pen.calculative.textDrawRect = void 0;
}
function calcTextDrawRect(ctx, pen) {
  const lineHeight = pen.calculative.fontSize * pen.calculative.lineHeight;
  const h = pen.calculative.textLines.length * lineHeight;
  const textWidth = calcTextAdaptionWidth(ctx, pen);
  const rect = pen.calculative.worldTextRect;
  let x = rect.x + (rect.width - textWidth) / 2;
  let y = rect.y + (rect.height - h) / 2;
  const options = pen.calculative.canvas.store.options;
  const textAlign = pen.textAlign || options.textAlign;
  switch (textAlign) {
    case "left":
      x = rect.x;
      break;
    case "right":
      x = rect.x + rect.width - textWidth;
      break;
  }
  const textBaseline = pen.textBaseline || options.textBaseline;
  switch (textBaseline) {
    case "top":
      y = rect.y;
      break;
    case "bottom":
      y = rect.ey - h;
      break;
  }
  pen.calculative.textDrawRect = {
    x,
    y,
    width: textWidth,
    height: h
  };
  calcRightBottom(pen.calculative.textDrawRect);
}
function calcTextLines(pen, text = pen.calculative.text) {
  if (text == void 0) {
    pen.calculative.textLines = [];
    return;
  }
  text = text.toString();
  const keepDecimal = pen.calculative.keepDecimal;
  if (keepDecimal != void 0) {
    const textNum = Number(text);
    if (!isNaN(textNum)) {
      text = textNum.toFixed(keepDecimal);
    }
  }
  let lines = [];
  const oneRowHeight = pen.calculative.fontSize * pen.calculative.lineHeight;
  const textHeight = pen.calculative.worldTextRect.height;
  const calcRows = Math.floor(textHeight / oneRowHeight);
  const maxRows = calcRows > 1 ? calcRows : 1;
  switch (pen.whiteSpace) {
    case "nowrap":
      if (pen.ellipsis !== false) {
        const allLines = wrapLines(text.split(""), pen);
        if (allLines[0]) {
          lines.push(allLines[0]);
          if (allLines.length > 1) {
            setEllipsisOnLastLine(lines);
          }
        }
      } else {
        lines.push(text);
      }
      break;
    case "pre-line":
      lines = text.split(/[\n]/g);
      if (pen.ellipsis !== false && lines.length > maxRows) {
        lines = lines.slice(0, maxRows);
        setEllipsisOnLastLine(lines);
      }
      break;
    case "break-all":
    default:
      const paragraphs = text.split(/[\n]/g);
      let currentRow = 0;
      outer:
        for (const paragraph of paragraphs) {
          const words = pen.whiteSpace === "break-all" ? paragraph.split("") : getWords(paragraph);
          let items = wrapLines(words, pen);
          if (items.length === 0)
            items = [""];
          if (pen.ellipsis != false) {
            for (const l of items) {
              currentRow++;
              if (currentRow > maxRows) {
                setEllipsisOnLastLine(lines);
                break outer;
              } else {
                lines.push(l);
              }
            }
          } else {
            lines.push(...items);
          }
        }
      break;
  }
  pen.calculative.textLines = lines;
  return lines;
}
function getWords(txt = "") {
  const words = [];
  let word = "";
  for (let i = 0; i < txt.length; ++i) {
    const ch = txt.charCodeAt(i);
    if (ch < 33 || ch > 126) {
      if (word) {
        words.push(word);
        word = "";
      }
      words.push(txt[i]);
    } else {
      word += txt[i];
    }
  }
  if (word) {
    words.push(word);
  }
  return words;
}
function wrapLines(words, pen) {
  const canvas = pen.calculative.canvas;
  const ctx = canvas.offscreen.getContext("2d");
  const { fontStyle, fontWeight, fontSize, fontFamily, lineHeight } = pen.calculative;
  ctx.save();
  const lines = [];
  let currentLine = words[0] || "";
  for (let i = 1; i < words.length; ++i) {
    const word = words[i] || "";
    const text = currentLine + word;
    let currentWidth = 0;
    if (canvas.store.options.measureTextWidth) {
      ctx.font = getFont({
        fontStyle,
        fontWeight,
        fontFamily: fontFamily || canvas.store.options.fontFamily,
        fontSize,
        lineHeight
      });
      currentWidth = ctx.measureText(text).width;
    } else {
      const chinese = text.match(/[^\x00-\xff]/g) || "";
      const chineseWidth = chinese.length * fontSize;
      const spaces = text.match(/\s/g) || "";
      const spaceWidth = spaces.length * fontSize * 0.3;
      const otherWidth = (text.length - chinese.length - spaces.length) * fontSize * 0.6;
      currentWidth = chineseWidth + spaceWidth + otherWidth;
    }
    const textWidth = pen.calculative.worldTextRect.width;
    if (currentWidth <= textWidth + 0.1) {
      currentLine += word;
    } else {
      currentLine.length && lines.push(currentLine);
      currentLine = word;
    }
  }
  currentLine.length && lines.push(currentLine);
  ctx.restore();
  return lines;
}
function calcTextAdaptionWidth(ctx, pen) {
  let maxWidth = 0;
  pen.calculative.textLineWidths = [];
  pen.calculative.textLines.forEach((text) => {
    const width = ctx.measureText(text).width;
    pen.calculative.textLineWidths.push(width);
    maxWidth < width && (maxWidth = width);
  });
  return maxWidth;
}
function setEllipsisOnLastLine(lines) {
  lines[lines.length - 1] = lines[lines.length - 1].slice(0, -3) + "...";
}
function calcTextAutoWidth(pen) {
  let arr = pen.text.split("\n");
  const canvas = pen.calculative.canvas;
  const ctx = canvas.offscreen.getContext("2d");
  const { fontStyle, fontWeight, fontSize, fontFamily, lineHeight } = pen.calculative;
  let textWidth = 0;
  let currentWidth = 0;
  ctx.save();
  for (let i = 0; i < arr.length; i++) {
    if (canvas.store.options.measureTextWidth) {
      ctx.font = getFont({
        fontStyle,
        fontWeight,
        fontFamily: fontFamily || canvas.store.options.fontFamily,
        fontSize,
        lineHeight
      });
      currentWidth = ctx.measureText(arr[i]).width;
    } else {
      const chinese = arr[i].match(/[^\x00-\xff]/g) || "";
      const chineseWidth = chinese.length * fontSize;
      const spaces = arr[i].match(/\s/g) || "";
      const spaceWidth = spaces.length * fontSize * 0.3;
      const otherWidth = (arr[i].length - chinese.length - spaces.length) * fontSize * 0.6;
      currentWidth = chineseWidth + spaceWidth + otherWidth;
    }
    if (currentWidth > textWidth) {
      textWidth = currentWidth;
    }
  }
  ctx.restore();
  let textHeight = arr.length * fontSize * lineHeight;
  if (pen.textAlign === "left") {
  } else if (pen.textAlign === "right") {
    pen.x = pen.x - (textWidth - pen.width);
  } else {
    pen.x = pen.x - (textWidth - pen.width) / 2;
  }
  if (pen.textBaseline === "top") {
  } else if (pen.textBaseline === "bottom") {
    pen.y = pen.y - (textHeight - pen.height);
  } else {
    pen.y = pen.y - (textHeight - pen.height) / 2;
  }
  pen.height = textHeight + 2;
  pen.width = textWidth + 2;
  pen.calculative.canvas.updatePenRect(pen);
  pen.calculative.canvas.calcActiveRect();
}

// node_modules/@meta2d/core/src/pen/arrow.js
var arrows = {};
function renderFromArrow(ctx, pen, store) {
  if (!arrows[pen.fromArrow]) {
    return;
  }
  const from = getFromAnchor(pen);
  const { x, y } = from;
  const pt = { x, y };
  pt.step = (pen.fromArrowSize || 10) * store.data.scale;
  if (from.next) {
    pt.rotate = calcRotate(from.next, from) + 90;
  } else {
    const p = pen.calculative.worldAnchors[1];
    if (!p) {
      return;
    }
    if (p.prev) {
      pt.rotate = calcRotate(p.prev, from) + 90;
    } else {
      pt.rotate = calcRotate(p, from) + 90;
    }
  }
  ctx.save();
  ctx.beginPath();
  ctx.setLineDash([]);
  const fromArrowColor = pen.fromArrowColor || pen.calculative.color;
  fromArrowColor && (ctx.strokeStyle = fromArrowColor);
  arrows[pen.fromArrow](ctx, pen, store, pt);
  ctx.restore();
}
function renderToArrow(ctx, pen, store) {
  if (!arrows[pen.toArrow] || pen.calculative.worldAnchors.length < 2) {
    return;
  }
  ctx.save();
  const to = getToAnchor(pen);
  const { x, y } = to;
  const pt = { x, y };
  pt.step = (pen.toArrowSize || 10) * store.data.scale;
  if (to.prev) {
    pt.rotate = calcRotate(to.prev, to) + 90;
  } else {
    const p = pen.calculative.worldAnchors[pen.calculative.worldAnchors.length - 2];
    if (p.next) {
      pt.rotate = calcRotate(p.next, to) + 90;
    } else {
      pt.rotate = calcRotate(p, to) + 90;
    }
  }
  ctx.beginPath();
  ctx.setLineDash([]);
  const toArrowColor = pen.toArrowColor || pen.calculative.color;
  toArrowColor && (ctx.strokeStyle = toArrowColor);
  arrows[pen.toArrow](ctx, pen, store, pt);
  ctx.restore();
}
arrows.triangleSolid = (ctx, pen, store, point) => {
  ctx.save();
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const fromX = point.x - point.step;
  ctx.moveTo(fromX, point.y - point.step / 4);
  ctx.lineTo(point.x, point.y);
  ctx.lineTo(fromX, point.y + point.step / 4);
  ctx.closePath();
  ctx.stroke();
  ctx.fillStyle = ctx.strokeStyle;
  ctx.fill();
  ctx.restore();
};
arrows.triangle = (ctx, pen, store, point) => {
  ctx.save();
  if (ctx.lineWidth < 2) {
    ctx.lineWidth = 2;
  }
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const fromX = point.x - point.step;
  ctx.moveTo(fromX, point.y - point.step / 4);
  ctx.lineTo(point.x, point.y);
  ctx.lineTo(fromX, point.y + point.step / 4);
  ctx.closePath();
  ctx.stroke();
  ctx.fillStyle = store.data.background || "#ffffff";
  ctx.fill();
  ctx.restore();
};
arrows.circleSolid = (ctx, pen, store, point) => {
  ctx.save();
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const r = point.step / 2;
  ctx.arc(point.x - r, point.y, r, 0, 2 * Math.PI);
  ctx.stroke();
  ctx.fillStyle = ctx.strokeStyle;
  ctx.fill();
  ctx.restore();
};
arrows.circle = (ctx, pen, store, point) => {
  ctx.save();
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const r = point.step / 2;
  ctx.arc(point.x - r, point.y, r, 0, 2 * Math.PI);
  ctx.stroke();
  ctx.fillStyle = store.data.background || "#ffffff";
  ctx.fill();
  ctx.restore();
};
arrows.diamondSolid = (ctx, pen, store, point) => {
  ctx.save();
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const fromX = point.x - point.step;
  const r = point.step / 2;
  ctx.moveTo(fromX, point.y);
  ctx.lineTo(fromX + r, point.y - r / 2);
  ctx.lineTo(point.x, point.y);
  ctx.lineTo(fromX + r, point.y + r / 2);
  ctx.closePath();
  ctx.stroke();
  ctx.fillStyle = ctx.strokeStyle;
  ctx.fill();
  ctx.restore();
};
arrows.diamond = (ctx, pen, store, point) => {
  ctx.save();
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const fromX = point.x - point.step;
  const r = point.step / 2;
  ctx.moveTo(fromX, point.y);
  ctx.lineTo(fromX + r, point.y - r / 2);
  ctx.lineTo(point.x, point.y);
  ctx.lineTo(fromX + r, point.y + r / 2);
  ctx.closePath();
  ctx.stroke();
  ctx.fillStyle = store.data.background || "#ffffff";
  ctx.fill();
  ctx.restore();
};
arrows.line = (ctx, pen, store, point) => {
  ctx.save();
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const fromX = point.x - point.step;
  ctx.moveTo(fromX, point.y - point.step / 3);
  ctx.lineTo(point.x, point.y);
  ctx.lineTo(fromX, point.y + point.step / 3);
  ctx.stroke();
  ctx.restore();
};
arrows.lineUp = (ctx, pen, store, point) => {
  ctx.save();
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const fromX = point.x - point.step;
  ctx.moveTo(fromX, point.y - point.step / 3);
  ctx.lineTo(point.x, point.y);
  ctx.stroke();
  ctx.restore();
};
arrows.lineDown = (ctx, pen, store, point) => {
  ctx.save();
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const fromX = point.x - point.step;
  ctx.moveTo(fromX, point.y + point.step / 3);
  ctx.lineTo(point.x, point.y);
  ctx.stroke();
  ctx.restore();
};

// node_modules/@meta2d/core/src/pen/render.js
function isAncestor(pen, ancestor) {
  if (!pen || !ancestor) {
    return false;
  }
  let parent = getParent(pen);
  while (parent) {
    if (parent.id === ancestor.id) {
      return true;
    }
    parent = getParent(parent);
  }
  return false;
}
function getParent(pen, root) {
  if (!pen || !pen.parentId || !pen.calculative) {
    return void 0;
  }
  const store = pen.calculative.canvas.store;
  const parent = store.pens[pen.parentId];
  if (!root) {
    return parent;
  }
  return getParent(parent, root) || parent;
}
function getAllChildren(pen, store) {
  if (!pen || !pen.children) {
    return [];
  }
  const children = [];
  pen.children.forEach((id) => {
    const child = store.pens[id];
    if (child) {
      children.push(child);
      children.push(...getAllChildren(child, store));
    }
  });
  return children;
}
function getAllFollowers(pen, store) {
  if (!pen || !pen.followers) {
    return [];
  }
  const followers = [];
  pen.followers.forEach((id) => {
    const follower = store.pens[id];
    if (follower && !follower.parentId) {
      followers.push(follower);
      followers.push(...getAllFollowers(follower, store));
    }
  });
  return followers;
}
function drawBkLinearGradient(ctx, pen) {
  const { worldRect, gradientFromColor, gradientToColor, gradientAngle } = pen.calculative;
  return linearGradient(ctx, worldRect, gradientFromColor, gradientToColor, gradientAngle);
}
function drawBkRadialGradient(ctx, pen) {
  const { worldRect, gradientFromColor, gradientToColor, gradientRadius } = pen.calculative;
  if (!gradientFromColor || !gradientToColor) {
    return;
  }
  const { width, height, center } = worldRect;
  const { x: centerX, y: centerY } = center;
  let r = width;
  if (r < height) {
    r = height;
  }
  r *= 0.5;
  const grd = ctx.createRadialGradient(centerX, centerY, r * (gradientRadius || 0), centerX, centerY, r);
  grd.addColorStop(0, gradientFromColor);
  grd.addColorStop(1, gradientToColor);
  return grd;
}
function getLinearGradientPoints(x1, y1, x2, y2, r) {
  let slantAngle = 0;
  slantAngle = Math.PI / 2 - Math.atan2(y2 - y1, x2 - x1);
  const originX = (x1 + x2) / 2;
  const originY = (y1 + y2) / 2;
  const perpX1 = originX + r * Math.sin(90 * Math.PI / 180 - slantAngle);
  const perpY1 = originY + r * -Math.cos(90 * Math.PI / 180 - slantAngle);
  const perpX2 = originX + r * Math.sin(270 * Math.PI / 180 - slantAngle);
  const perpY2 = originY + r * -Math.cos(270 * Math.PI / 180 - slantAngle);
  return [perpX1, perpY1, perpX2, perpY2];
}
function getBkRadialGradient(ctx, pen) {
  const { worldRect, gradientColors, gradientRadius } = pen.calculative;
  if (!gradientColors) {
    return;
  }
  let color = pen.calculative.gradientColors;
  if (pen.calculative.checked) {
    color = pen.calculative.onGradientColors;
  }
  const { width, height, center } = worldRect;
  const { x: centerX, y: centerY } = center;
  let r = width;
  if (r < height) {
    r = height;
  }
  r *= 0.5;
  const { colors } = formatGradient(color);
  const grd = ctx.createRadialGradient(centerX, centerY, r * (gradientRadius || 0), centerX, centerY, r);
  colors.forEach((stop) => {
    grd.addColorStop(stop.i, stop.color);
  });
  return grd;
}
function getBkGradient(ctx, pen) {
  const { x, y, ex, width, height, center } = pen.calculative.worldRect;
  let points = [
    { x: ex, y: y + height / 2 },
    { x, y: y + height / 2 }
  ];
  let color = pen.calculative.gradientColors;
  if (pen.calculative.checked) {
    color = pen.calculative.onGradientColors;
  }
  const { angle, colors } = formatGradient(color);
  let r = getGradientR(angle, width, height);
  points.forEach((point) => {
    rotatePoint(point, angle, center);
  });
  return getLinearGradient(ctx, points, colors, r);
}
function getTextRadialGradient(ctx, pen) {
  const { worldRect, textGradientColors } = pen.calculative;
  if (!textGradientColors) {
    return;
  }
  const { width, height, center } = worldRect;
  const { x: centerX, y: centerY } = center;
  let r = width;
  if (r < height) {
    r = height;
  }
  r *= 0.5;
  const { colors } = formatGradient(textGradientColors);
  const grd = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, r);
  colors.forEach((stop) => {
    grd.addColorStop(stop.i, stop.color);
  });
  return grd;
}
function getTextGradient(ctx, pen) {
  const { x, y, ex, width, height, center } = pen.calculative.worldRect;
  let points = [
    { x: ex, y: y + height / 2 },
    { x, y: y + height / 2 }
  ];
  const { angle, colors } = formatGradient(pen.calculative.textGradientColors);
  let r = getGradientR(angle, width, height);
  points.forEach((point) => {
    rotatePoint(point, angle, center);
  });
  return getLinearGradient(ctx, points, colors, r);
}
function getGradientR(angle, width, height) {
  const dividAngle = Math.atan(height / width) / Math.PI * 180;
  let calculateAngle = (angle - 90) % 360;
  let r = 0;
  if (calculateAngle > dividAngle && calculateAngle < 180 - dividAngle || calculateAngle > 180 + dividAngle && calculateAngle < 360 - dividAngle || calculateAngle < 0) {
    if (calculateAngle > 270) {
      calculateAngle = 360 - calculateAngle;
    } else if (calculateAngle > 180) {
      calculateAngle = calculateAngle - 180;
    } else if (calculateAngle > 90) {
      calculateAngle = 180 - calculateAngle;
    }
    r = Math.abs(height / Math.sin(calculateAngle / 180 * Math.PI) / 2);
  } else {
    if (calculateAngle > 270) {
      calculateAngle = 360 - calculateAngle;
    } else if (calculateAngle > 180) {
      calculateAngle = calculateAngle - 180;
    } else if (calculateAngle > 90) {
      calculateAngle = 180 - calculateAngle;
    }
    r = Math.abs(width / Math.cos(calculateAngle / 180 * Math.PI) / 2);
  }
  return r;
}
function formatGradient(color) {
  if (typeof color == "string" && color.startsWith("linear-gradient")) {
    let arr = color.slice(16, -2).split("deg,");
    if (arr.length > 1) {
      let _arr = arr[1].split("%,");
      const colors = [];
      _arr.forEach((stap) => {
        if (/rgba?/.test(stap)) {
          let _arr2 = stap.split(") ");
          colors.push({
            color: rgbaToHex(_arr2[0] + ")"),
            i: parseFloat(_arr2[1]) / 100
          });
        } else {
          let _arr2 = stap.split(" ");
          if (_arr2.length > 2) {
            colors.push({
              color: _arr2[1],
              i: parseFloat(_arr2[2]) / 100
            });
          } else {
            colors.push({
              color: _arr2[0],
              i: parseFloat(_arr2[1]) / 100
            });
          }
        }
      });
      return {
        angle: parseFloat(arr[0]),
        colors
      };
    } else {
      return {
        angle: parseFloat(arr[0]),
        colors: []
      };
    }
  } else {
    return {
      angle: 0,
      colors: []
    };
  }
}
function rgbaToHex(value4) {
  if (/rgba?/.test(value4)) {
    let array = value4.split(",");
    if (array.length < 3)
      return "";
    value4 = "#";
    for (let i = 0, color; color = array[i++]; ) {
      if (i < 4) {
        color = parseInt(color.replace(/[^\d]/gi, ""), 10).toString(16);
        value4 += color.length == 1 ? "0" + color : color;
      } else {
        color = color.replace(")", "");
        let colorA = parseInt(color * 255 + "");
        let colorAHex = colorA.toString(16);
        colorAHex = colorAHex.length === 2 ? colorAHex : "0" + colorAHex;
        value4 += colorAHex;
      }
    }
    value4 = value4.toUpperCase();
  }
  return value4;
}
function getLineGradient(ctx, pen) {
  const { x, y, ex, width, height, center } = pen.calculative.worldRect;
  let points = [
    { x: ex, y: y + height / 2 },
    { x, y: y + height / 2 }
  ];
  const { angle, colors } = formatGradient(pen.calculative.lineGradientColors);
  let r = getGradientR(angle, width, height);
  points.forEach((point) => {
    rotatePoint(point, angle, center);
  });
  return getLinearGradient(ctx, points, colors, r);
}
function getLinearGradient(ctx, points, colors, radius) {
  let arr = getLinearGradientPoints(points[0].x, points[0].y, points[1].x, points[1].y, radius);
  let gradient = ctx.createLinearGradient(arr[0], arr[1], arr[2], arr[3]);
  colors.forEach((stop) => {
    gradient.addColorStop(stop.i, stop.color);
  });
  return gradient;
}
function drawLinearGradientLine(ctx, pen, points) {
  let colors = [];
  if (pen.calculative.gradientColorStop) {
    colors = pen.calculative.gradientColorStop;
  } else {
    colors = formatGradient(pen.calculative.lineGradientColors).colors;
    pen.calculative.gradientColorStop = colors;
  }
  ctx.strokeStyle = getLinearGradient(ctx, points, colors, pen.calculative.lineWidth / 2);
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  ctx.lineTo(points[1].x, points[1].y);
  ctx.stroke();
}
function ctxDrawLinearGradientPath(ctx, pen) {
  const anchors = pen.calculative.worldAnchors;
  let smoothLenth = pen.calculative.lineWidth * (pen.calculative.gradientSmooth || pen.calculative.lineSmooth || 0);
  for (let i = 0; i < anchors.length - 1; i++) {
    if ((pen.lineName === "curve" || pen.lineName === "mind") && anchors[i].curvePoints) {
      if (i > 0) {
        let lastCurvePoints = anchors[i - 1].curvePoints;
        if (lastCurvePoints) {
          smoothTransition(ctx, pen, smoothLenth, lastCurvePoints[lastCurvePoints.length - 1], anchors[i], anchors[i].curvePoints[0]);
        } else {
          smoothTransition(ctx, pen, smoothLenth, anchors[i - 1], anchors[i], anchors[i].curvePoints[0]);
        }
        let next = getSmoothAdjacent(smoothLenth, anchors[i], anchors[i].curvePoints[0]);
        drawLinearGradientLine(ctx, pen, [next, anchors[i].curvePoints[1]]);
      } else {
        drawLinearGradientLine(ctx, pen, [
          anchors[i],
          anchors[i].curvePoints[0]
        ]);
        drawLinearGradientLine(ctx, pen, [
          anchors[i].curvePoints[0],
          anchors[i].curvePoints[1]
        ]);
      }
      let len = anchors[i].curvePoints.length - 1;
      for (let j = 1; j < len; j++) {
        drawLinearGradientLine(ctx, pen, [
          anchors[i].curvePoints[j],
          anchors[i].curvePoints[j + 1]
        ]);
      }
      let last = getSmoothAdjacent(smoothLenth, anchors[i + 1], anchors[i].curvePoints[len]);
      drawLinearGradientLine(ctx, pen, [anchors[i].curvePoints[len], last]);
    } else {
      let _next = anchors[i];
      let _last = anchors[i + 1];
      if (i > 0 && i < anchors.length - 1) {
        let lastCurvePoints = anchors[i - 1].curvePoints;
        if (lastCurvePoints) {
          smoothTransition(ctx, pen, smoothLenth, lastCurvePoints[lastCurvePoints.length - 1], anchors[i], anchors[i + 1]);
        } else {
          smoothTransition(ctx, pen, smoothLenth, anchors[i - 1], anchors[i], anchors[i + 1]);
        }
      }
      if (i > 0 && i < anchors.length - 1) {
        _next = getSmoothAdjacent(smoothLenth, anchors[i], anchors[i + 1]);
      }
      if (i < anchors.length - 2) {
        _last = getSmoothAdjacent(smoothLenth, anchors[i + 1], anchors[i]);
      }
      let flag = false;
      if (i === 0) {
        if (pen.fromLineCap && pen.fromLineCap !== "butt") {
          ctx.save();
          flag = true;
          ctx.lineCap = pen.fromLineCap;
        }
      }
      if (i !== 0 && i === anchors.length - 2) {
        if (pen.toLineCap && pen.toLineCap !== "butt") {
          ctx.save();
          flag = true;
          ctx.lineCap = pen.toLineCap;
        }
      }
      drawLinearGradientLine(ctx, pen, [_next, _last]);
      if (flag) {
        ctx.restore();
      }
      if (anchors.length === 2 && i === 0) {
        ctx.save();
        flag = true;
        ctx.lineCap = pen.toLineCap;
        let _y = 0.1;
        let _x = 0.1;
        if (_next.x - _last.x === 0) {
          _x = 0;
        } else {
          _y = (_next.y - _last.y) / (_next.x - _last.x) * 0.1;
        }
        drawLinearGradientLine(ctx, pen, [
          { x: _last.x - _x, y: _last.y - _y },
          _last
        ]);
        ctx.restore();
      }
    }
  }
}
function getSmoothAdjacent(smoothLenth, p1, p2) {
  let nexLength = Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));
  if (nexLength === 0) {
    return {
      x: p1.x,
      y: p1.y
    };
  }
  if (smoothLenth < nexLength) {
    return {
      x: p1.x + (p2.x - p1.x) * smoothLenth / nexLength,
      y: p1.y + (p2.y - p1.y) * smoothLenth / nexLength
    };
  } else {
    return {
      x: p1.x + (p2.x - p1.x) / nexLength / 2,
      y: p1.y + (p2.y - p1.y) / nexLength / 2
    };
  }
}
function smoothTransition(ctx, pen, smoothLenth, p1, p2, p3) {
  let last = getSmoothAdjacent(smoothLenth, p2, p1);
  let next = getSmoothAdjacent(smoothLenth, p2, p3);
  let contrlPoint = { x: p2.x, y: p2.y };
  let points = getBezierPoints(pen.calculative.canvas.store.data.smoothNum || 20, last, contrlPoint, next);
  for (let k = 0; k < points.length - 1; k++) {
    drawLinearGradientLine(ctx, pen, [
      {
        x: points[k].x,
        y: points[k].y
      },
      {
        x: points[k + 1].x,
        y: points[k + 1].y
      }
    ]);
  }
}
function smoothAnimateTransition(ctx, smoothLenth, p2, p3) {
  let next = getSmoothAdjacent(smoothLenth, p2, p3);
  let contrlPoint = { x: p2.x, y: p2.y };
  ctx.quadraticCurveTo(contrlPoint.x, contrlPoint.y, next.x, next.y);
}
function getGradientAnimatePath(pen) {
  const anchors = pen.calculative.worldAnchors;
  let smoothLenth = pen.calculative.lineWidth * (pen.calculative.gradientSmooth || pen.calculative.lineSmooth || 0);
  const _path = new Path2D();
  for (let i = 0; i < anchors.length - 1; i++) {
    let _next = anchors[i];
    let _last = anchors[i + 1];
    if (i == 0) {
      _path.moveTo(anchors[i].x, anchors[i].y);
    }
    if (i > 0 && i < anchors.length - 1) {
      let lastCurvePoints = anchors[i - 1].curvePoints;
      if (lastCurvePoints) {
        smoothAnimateTransition(_path, smoothLenth, anchors[i], anchors[i + 1]);
      } else {
        smoothAnimateTransition(_path, smoothLenth, anchors[i], anchors[i + 1]);
      }
    }
    if (i > 0 && i < anchors.length - 1) {
      _next = getSmoothAdjacent(smoothLenth, anchors[i], anchors[i + 1]);
    }
    if (i < anchors.length - 2) {
      _last = getSmoothAdjacent(smoothLenth, anchors[i + 1], anchors[i]);
    }
    _path.lineTo(_last.x, _last.y);
  }
  return _path;
}
function getBezierPoints(num = 100, p1, p2, p3, p4) {
  let func = null;
  const points = [];
  if (!p3 && !p4) {
    func = oneBezier;
  } else if (p3 && !p4) {
    func = twoBezier;
  } else if (p3 && p4) {
    func = threeBezier;
  }
  for (let i = 0; i < num; i++) {
    points.push(func(i / num, p1, p2, p3, p4));
  }
  if (p4) {
    points.push(p4);
  } else if (p3) {
    points.push(p3);
  }
  return points;
}
function oneBezier(t, p1, p2) {
  const { x: x1, y: y1 } = p1;
  const { x: x2, y: y2 } = p2;
  let x = x1 + (x2 - x1) * t;
  let y = y1 + (y2 - y1) * t;
  return { x, y };
}
function twoBezier(t, p1, cp, p2) {
  const { x: x1, y: y1 } = p1;
  const { x: cx, y: cy } = cp;
  const { x: x2, y: y2 } = p2;
  let x = (1 - t) * (1 - t) * x1 + 2 * t * (1 - t) * cx + t * t * x2;
  let y = (1 - t) * (1 - t) * y1 + 2 * t * (1 - t) * cy + t * t * y2;
  return { x, y };
}
function threeBezier(t, p1, cp1, cp2, p2) {
  const { x: x1, y: y1 } = p1;
  const { x: x2, y: y2 } = p2;
  const { x: cx1, y: cy1 } = cp1;
  const { x: cx2, y: cy2 } = cp2;
  let x = x1 * (1 - t) * (1 - t) * (1 - t) + 3 * cx1 * t * (1 - t) * (1 - t) + 3 * cx2 * t * t * (1 - t) + x2 * t * t * t;
  let y = y1 * (1 - t) * (1 - t) * (1 - t) + 3 * cy1 * t * (1 - t) * (1 - t) + 3 * cy2 * t * t * (1 - t) + y2 * t * t * t;
  return { x, y };
}
function strokeLinearGradient(ctx, pen) {
  const { worldRect, lineGradientFromColor, lineGradientToColor, lineGradientAngle } = pen.calculative;
  return linearGradient(ctx, worldRect, lineGradientFromColor, lineGradientToColor, lineGradientAngle);
}
function linearGradient(ctx, worldRect, fromColor, toColor, angle) {
  if (!fromColor || !toColor) {
    return;
  }
  const { x, y, center, ex, ey } = worldRect;
  const from = {
    x,
    y: center.y
  };
  const to = {
    x: ex,
    y: center.y
  };
  if (angle % 90 === 0 && angle % 180) {
    from.x = center.x;
    to.x = center.x;
    if (angle % 270) {
      from.y = y;
      to.y = ey;
    } else {
      from.y = ey;
      to.y = y;
    }
  } else if (angle) {
    rotatePoint(from, angle, worldRect.center);
    rotatePoint(to, angle, worldRect.center);
  }
  const grd = ctx.createLinearGradient(from.x, from.y, to.x, to.y);
  grd.addColorStop(0, fromColor);
  grd.addColorStop(1, toColor);
  return grd;
}
function getImagePosition(pen) {
  const { worldIconRect: rect, iconWidth, iconHeight, imgNaturalWidth, imgNaturalHeight } = pen.calculative;
  let { x, y, width: w, height: h } = rect;
  if (iconWidth) {
    w = iconWidth;
  }
  if (iconHeight) {
    h = iconHeight;
  }
  if (imgNaturalWidth && imgNaturalHeight && pen.imageRatio) {
    const scaleW = rect.width / imgNaturalWidth;
    const scaleH = rect.height / imgNaturalHeight;
    const scaleMin = Math.min(scaleW, scaleH);
    const wDivideH = imgNaturalWidth / imgNaturalHeight;
    if (iconWidth) {
      h = iconWidth / wDivideH;
    } else if (iconHeight) {
      w = iconHeight * wDivideH;
    } else {
      w = scaleMin * imgNaturalWidth;
      h = scaleMin * imgNaturalHeight;
    }
  }
  x += (rect.width - w) / 2;
  y += (rect.height - h) / 2;
  switch (pen.iconAlign) {
    case "top":
      y = rect.y;
      break;
    case "bottom":
      y = rect.ey - h;
      break;
    case "left":
      x = rect.x;
      break;
    case "right":
      x = rect.ex - w;
      break;
    case "left-top":
      x = rect.x;
      y = rect.y;
      break;
    case "right-top":
      x = rect.ex - w;
      y = rect.y;
      break;
    case "left-bottom":
      x = rect.x;
      y = rect.ey - h;
      break;
    case "right-bottom":
      x = rect.ex - w;
      y = rect.ey - h;
      break;
  }
  return {
    x,
    y,
    width: w,
    height: h
  };
}
function drawImage(ctx, pen) {
  const { x, y, width, height } = getImagePosition(pen);
  const { worldIconRect, iconRotate, img } = pen.calculative;
  if (iconRotate) {
    const { x: centerX, y: centerY } = worldIconRect.center;
    ctx.translate(centerX, centerY);
    ctx.rotate(iconRotate * Math.PI / 180);
    ctx.translate(-centerX, -centerY);
  }
  if (pen.imageRadius) {
    ctx.save();
    let wr = pen.calculative.imageRadius || 0, hr = wr;
    const { x: _x, y: _y, width: w, height: h, ex, ey } = pen.calculative.worldRect;
    if (wr < 1) {
      wr = w * wr;
      hr = h * hr;
    }
    let r = wr < hr ? wr : hr;
    if (w < 2 * r) {
      r = w / 2;
    }
    if (h < 2 * r) {
      r = h / 2;
    }
    ctx.beginPath();
    ctx.moveTo(_x + r, _y);
    ctx.arcTo(ex, _y, ex, ey, r);
    ctx.arcTo(ex, ey, _x, ey, r);
    ctx.arcTo(_x, ey, _x, _y, r);
    ctx.arcTo(_x, _y, ex, _y, r);
    ctx.clip();
    ctx.drawImage(img, x, y, width, height);
    ctx.restore();
  } else {
    ctx.drawImage(img, x, y, width, height);
  }
}
function getTextColor(pen, store) {
  const { textColor, color } = pen.calculative;
  const { styles } = store;
  return textColor || color || styles.textColor || styles.color;
}
function drawText(ctx, pen) {
  const { fontStyle, fontWeight, fontSize, fontFamily, lineHeight, text, hiddenText, canvas, textHasShadow, textBackground, textType } = pen.calculative;
  if (text == void 0 || hiddenText) {
    return;
  }
  const store = canvas.store;
  ctx.save();
  if (!textHasShadow) {
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
  }
  let fill = void 0;
  if (pen.calculative.disabled) {
    fill = pen.disabledTextColor || pen.disabledColor || pSBC(0.4, getTextColor(pen, store));
  } else if (pen.calculative.hover) {
    fill = pen.hoverTextColor || pen.hoverColor || store.styles.hoverColor;
  } else if (pen.calculative.active) {
    fill = pen.activeTextColor || pen.activeColor || store.styles.activeColor;
  }
  let gradient = void 0;
  if (textType === Gradient.Linear) {
    gradient = getTextGradient(ctx, pen);
  } else if (textType === Gradient.Radial) {
    gradient = getTextRadialGradient(ctx, pen);
  }
  ctx.fillStyle = fill || gradient || getTextColor(pen, store);
  ctx.font = getFont({
    fontStyle,
    fontWeight,
    fontFamily: fontFamily || store.options.fontFamily,
    fontSize,
    lineHeight
  });
  !pen.calculative.textDrawRect && calcTextDrawRect(ctx, pen);
  const { x: drawRectX, y: drawRectY, width, height } = pen.calculative.textDrawRect;
  if (textBackground) {
    ctx.save();
    ctx.fillStyle = textBackground;
    ctx.fillRect(drawRectX, drawRectY, width, height);
    ctx.restore();
  }
  const y = 0.55;
  const textAlign = pen.textAlign || store.options.textAlign;
  const oneRowHeight = fontSize * lineHeight;
  pen.calculative.textLines.forEach((text2, i) => {
    const textLineWidth = pen.calculative.textLineWidths[i];
    let x = 0;
    if (textAlign === "center") {
      x = (width - textLineWidth) / 2;
    } else if (textAlign === "right") {
      x = width - textLineWidth;
    }
    ctx.fillText(text2, drawRectX + x, drawRectY + (i + y) * oneRowHeight);
    const { textDecorationColor, textDecorationDash, textDecoration } = pen;
    if (textDecoration) {
      drawUnderLine(ctx, {
        x: drawRectX + x,
        y: drawRectY + (i + y) * oneRowHeight,
        width: textLineWidth
      }, { textDecorationColor, textDecorationDash, fontSize });
    }
    const { textStrickoutColor, textStrickoutDash, textStrickout } = pen;
    if (textStrickout) {
      drawStrickout(ctx, {
        x: drawRectX + x,
        y: drawRectY + (i + y) * oneRowHeight,
        width: textLineWidth
      }, { textStrickoutColor, textStrickoutDash, fontSize });
    }
  });
  ctx.restore();
}
function drawUnderLine(ctx, location2, config) {
  const { textDecorationColor, textDecorationDash, fontSize } = config;
  let { x, y, width } = location2;
  switch (ctx.textBaseline) {
    case "top":
      y += fontSize;
      break;
    case "middle":
      y += fontSize / 2;
      break;
  }
  ctx.save();
  ctx.beginPath();
  ctx.strokeStyle = textDecorationColor ? textDecorationColor : ctx.fillStyle;
  ctx.lineWidth = 1;
  ctx.moveTo(x, y);
  ctx.setLineDash(textDecorationDash || []);
  ctx.lineTo(x + width, y);
  ctx.stroke();
  ctx.restore();
}
function drawStrickout(ctx, location2, config) {
  const { textStrickoutColor, textStrickoutDash, fontSize } = config;
  let { x, y, width } = location2;
  switch (ctx.textBaseline) {
    case "top":
      y += fontSize / 2;
      break;
    case "bottom":
      y -= fontSize / 2;
      break;
  }
  ctx.save();
  ctx.beginPath();
  ctx.strokeStyle = textStrickoutColor ? textStrickoutColor : ctx.fillStyle;
  ctx.lineWidth = 1;
  ctx.moveTo(x, y);
  ctx.setLineDash(textStrickoutDash || []);
  ctx.lineTo(x + width, y);
  ctx.stroke();
  ctx.restore();
}
function drawFillText(ctx, pen, text) {
  if (text == void 0) {
    return;
  }
  const { fontStyle, fontWeight, fontSize, fontFamily, lineHeight, canvas } = pen.calculative;
  const store = canvas.store;
  ctx.save();
  let fill = void 0;
  if (pen.calculative.hover) {
    fill = pen.hoverTextColor || pen.hoverColor || store.styles.hoverColor;
  } else if (pen.calculative.active) {
    fill = pen.activeTextColor || pen.activeColor || store.styles.activeColor;
  }
  ctx.fillStyle = fill || getTextColor(pen, store);
  ctx.font = getFont({
    fontStyle,
    fontWeight,
    fontFamily: fontFamily || store.options.fontFamily,
    fontSize,
    lineHeight
  });
  const w = ctx.measureText(text).width;
  let t;
  let prev;
  for (const anchor of pen.calculative.worldAnchors) {
    if (!prev) {
      prev = anchor;
      continue;
    }
    const dis = distance(prev, anchor);
    const n = Math.floor(dis / w);
    t = "";
    for (let i = 0; i < n; i++) {
      t += text;
    }
    const angle = calcRotate(prev, anchor) - 270;
    ctx.save();
    if (angle % 360 !== 0) {
      const { x, y } = prev;
      ctx.translate(x, y);
      let rotate = angle * Math.PI / 180;
      ctx.rotate(rotate);
      ctx.translate(-x, -y);
    }
    ctx.fillText(t, prev.x, prev.y + lineHeight / 2);
    ctx.restore();
    prev = anchor;
  }
  ctx.restore();
}
function drawIcon(ctx, pen) {
  const store = pen.calculative.canvas.store;
  ctx.save();
  ctx.shadowColor = "";
  ctx.shadowBlur = 0;
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 0;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  const iconRect = pen.calculative.worldIconRect;
  let x = iconRect.x + iconRect.width / 2;
  let y = iconRect.y + iconRect.height / 2;
  switch (pen.iconAlign) {
    case "top":
      y = iconRect.y;
      ctx.textBaseline = "top";
      break;
    case "bottom":
      y = iconRect.ey;
      ctx.textBaseline = "bottom";
      break;
    case "left":
      x = iconRect.x;
      ctx.textAlign = "left";
      break;
    case "right":
      x = iconRect.ex;
      ctx.textAlign = "right";
      break;
    case "left-top":
      x = iconRect.x;
      y = iconRect.y;
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      break;
    case "right-top":
      x = iconRect.ex;
      y = iconRect.y;
      ctx.textAlign = "right";
      ctx.textBaseline = "top";
      break;
    case "left-bottom":
      x = iconRect.x;
      y = iconRect.ey;
      ctx.textAlign = "left";
      ctx.textBaseline = "bottom";
      break;
    case "right-bottom":
      x = iconRect.ex;
      y = iconRect.ey;
      ctx.textAlign = "right";
      ctx.textBaseline = "bottom";
      break;
  }
  const fontWeight = pen.calculative.iconWeight;
  let fontSize = void 0;
  const fontFamily = pen.calculative.iconFamily;
  if (pen.calculative.iconSize > 0) {
    fontSize = pen.calculative.iconSize;
  } else if (iconRect.width > iconRect.height) {
    fontSize = iconRect.height;
  } else {
    fontSize = iconRect.width;
  }
  ctx.font = getFont({
    fontSize,
    fontWeight,
    fontFamily
  });
  ctx.fillStyle = pen.calculative.iconColor || getTextColor(pen, store);
  if (pen.calculative.iconRotate) {
    ctx.translate(iconRect.center.x, iconRect.center.y);
    ctx.rotate(pen.calculative.iconRotate * Math.PI / 180);
    ctx.translate(-iconRect.center.x, -iconRect.center.y);
  }
  ctx.beginPath();
  ctx.fillText(pen.calculative.icon, x, y);
  ctx.restore();
}
function drawDropdown(ctx, pen) {
  const scale = pen.calculative.canvas.store.data.scale;
  const inputPenId = pen.calculative.canvas.inputDiv.dataset.penId;
  const { x, y, width, height } = pen.calculative.worldRect;
  ctx.save();
  ctx.beginPath();
  if (pen.id === inputPenId) {
    ctx.moveTo(x + width - 20 * scale, y + height / 2 + 2 * scale);
    ctx.lineTo(x + width - 14 * scale, y + height / 2 - 4 * scale);
    ctx.lineTo(x + width - 8 * scale, y + height / 2 + 2 * scale);
  } else {
    ctx.moveTo(x + width - 20 * scale, y + height / 2 - 4 * scale);
    ctx.lineTo(x + width - 14 * scale, y + height / 2 + 2 * scale);
    ctx.lineTo(x + width - 8 * scale, y + height / 2 - 4 * scale);
  }
  ctx.stroke();
  ctx.restore();
}
function getFont({
  fontStyle = "normal",
  textDecoration = "normal",
  fontWeight = "normal",
  fontSize = 12,
  fontFamily = "Arial",
  lineHeight = 1
  // TODO: lineHeight 
} = {}) {
  return `${fontStyle} ${textDecoration} ${fontWeight} ${fontSize}px/${lineHeight} ${fontFamily}`;
}
function ctxFlip(ctx, pen) {
  const { x, ex, y, ey } = pen.calculative.worldRect || {};
  if (pen.calculative.flipX) {
    ctx.translate(x + ex + 0.5, 0.5);
    ctx.scale(-1, 1);
  }
  if (pen.calculative.flipY) {
    ctx.translate(0.5, y + ey + 0.5);
    ctx.scale(1, -1);
  }
}
function ctxRotate(ctx, pen, noFlip = false) {
  const { x, y } = pen.calculative.worldRect.pivot || pen.calculative.worldRect.center;
  ctx.translate(x, y);
  let rotate = pen.calculative.rotate * Math.PI / 180;
  if (!noFlip) {
    if (pen.calculative.flipX) {
      rotate *= -1;
    }
    if (pen.calculative.flipY) {
      rotate *= -1;
    }
  }
  ctx.rotate(rotate);
  ctx.translate(-x, -y);
}
function renderPen(ctx, pen, download) {
  ctx.save();
  ctx.translate(0.5, 0.5);
  ctx.beginPath();
  const store = pen.calculative.canvas.store;
  const textFlip = pen.textFlip || store.options.textFlip;
  const textRotate = pen.textRotate || store.options.textRotate;
  if (!textFlip || !textRotate) {
    ctx.save();
  }
  ctxFlip(ctx, pen);
  if (pen.calculative.rotate && pen.name !== "line") {
    ctxRotate(ctx, pen);
  }
  if (pen.calculative.lineWidth > 1 || download) {
    ctx.lineWidth = pen.calculative.lineWidth;
  }
  inspectRect(ctx, store, pen);
  let fill;
  let lineGradientFlag = false;
  let _stroke = void 0;
  if (pen.calculative.disabled) {
    _stroke = pen.disabledColor || store.styles.disabledColor || pSBC(0.4, pen.calculative.color || store.styles.color);
    fill = pen.disabledBackground || store.styles.disabledBackground || pSBC(0.4, pen.calculative.background || store.styles.penBackground);
  } else if (pen.mouseDownValid && pen.calculative.mouseDown) {
    _stroke = pen.mouseDownColor || pSBC(-0.4, pen.calculative.color || store.styles.color);
    fill = pen.mouseDownBackground || pSBC(-0.4, pen.calculative.background || store.styles.penBackground);
  } else if (pen.switch && pen.calculative.checked) {
    if (!pen.calculative.bkType) {
      fill = pen.onBackground;
    }
  } else if (pen.calculative.hover) {
    _stroke = pen.hoverColor || store.styles.hoverColor;
    fill = pen.hoverBackground || store.styles.hoverBackground;
  } else if (pen.calculative.active) {
    _stroke = pen.activeColor || store.styles.activeColor;
    fill = pen.activeBackground || store.styles.activeBackground;
  } else if (pen.calculative.isDock) {
    if (pen.type === PenType.Line) {
      _stroke = store.styles.dockPenColor;
    } else {
      fill = rgba(store.styles.dockPenColor, 0.2);
    }
  }
  const strokeImg = pen.calculative.strokeImg;
  if (pen.calculative.strokeImage && strokeImg) {
    ctx.strokeStyle = _stroke || ctx.createPattern(strokeImg, "repeat");
  } else {
    let stroke;
    if (pen.calculative.strokeType) {
      if (pen.calculative.lineGradientColors) {
        if (pen.name === "line") {
          lineGradientFlag = true;
        } else {
          if (pen.calculative.lineGradient) {
            stroke = pen.calculative.lineGradient;
          } else {
            stroke = getLineGradient(ctx, pen);
            pen.calculative.lineGradient = stroke;
          }
        }
      } else {
        stroke = strokeLinearGradient(ctx, pen);
      }
    } else {
      stroke = pen.calculative.color || (pen.type ? store.data.lineColor : "") || store.styles.color;
    }
    ctx.strokeStyle = _stroke || stroke;
  }
  const backgroundImg = pen.calculative.backgroundImg;
  if (pen.calculative.backgroundImage && backgroundImg) {
    ctx.fillStyle = fill || ctx.createPattern(backgroundImg, "repeat");
    fill = true;
  } else {
    let back;
    if (pen.calculative.bkType === Gradient.Linear) {
      if (pen.calculative.gradientColors) {
        if (pen.calculative.gradient) {
          back = pen.calculative.gradient;
        } else {
          back = getBkGradient(ctx, pen);
          pen.calculative.gradient = back;
        }
      } else {
        back = drawBkLinearGradient(ctx, pen);
      }
    } else if (pen.calculative.bkType === Gradient.Radial) {
      if (pen.calculative.gradientColors) {
        if (pen.calculative.radialGradient) {
          back = pen.calculative.radialGradient;
        } else {
          back = getBkRadialGradient(ctx, pen);
          pen.calculative.radialGradient = back;
        }
      } else {
        back = drawBkRadialGradient(ctx, pen);
      }
    } else {
      back = pen.calculative.background || store.styles.penBackground;
    }
    ctx.fillStyle = fill || back;
    fill = !!back;
  }
  setLineCap(ctx, pen);
  setLineJoin(ctx, pen);
  setGlobalAlpha(ctx, pen);
  if (pen.calculative.lineDash) {
    ctx.setLineDash(pen.calculative.lineDash.map((item) => item * pen.calculative.canvas.store.data.scale));
  }
  if (pen.calculative.lineDashOffset) {
    ctx.lineDashOffset = pen.calculative.lineDashOffset;
  }
  if (pen.calculative.shadowColor) {
    ctx.shadowColor = pen.calculative.shadowColor;
    ctx.shadowOffsetX = pen.calculative.shadowOffsetX;
    ctx.shadowOffsetY = pen.calculative.shadowOffsetY;
    ctx.shadowBlur = pen.calculative.shadowBlur;
  }
  if (lineGradientFlag) {
    ctxDrawLinearGradientPath(ctx, pen);
    ctxDrawLinePath(true, ctx, pen, store);
  } else {
    ctxDrawPath(true, ctx, pen, store, fill);
    ctxDrawCanvas(ctx, pen);
  }
  if (!(pen.image && pen.calculative.img) && pen.calculative.icon) {
    drawIcon(ctx, pen);
  }
  if (pen.dropdownList) {
    drawDropdown(ctx, pen);
  }
  if (!textFlip || !textRotate) {
    ctx.restore();
  }
  if (textFlip && !textRotate) {
    ctxFlip(ctx, pen);
  }
  if (!textFlip && textRotate) {
    if (pen.calculative.rotate && pen.name !== "line") {
      ctxRotate(ctx, pen, true);
    }
  }
  drawText(ctx, pen);
  if (pen.type === PenType.Line && pen.fillTexts) {
    for (const text of pen.fillTexts) {
      drawFillText(ctx, pen, text);
    }
  }
  ctx.restore();
}
function setLineCap(ctx, pen) {
  const lineCap = pen.lineCap || (pen.type ? "round" : "square");
  if (lineCap) {
    ctx.lineCap = lineCap;
  } else if (pen.type) {
    ctx.lineCap = "round";
  }
}
function setLineJoin(ctx, pen) {
  const lineJoin = pen.lineJoin;
  if (lineJoin) {
    ctx.lineJoin = lineJoin;
  } else if (pen.type) {
    ctx.lineJoin = "round";
  }
}
function renderPenRaw2(ctx, pen, rect, download) {
  var _a;
  ctx.save();
  if (rect) {
    ctx.translate(-rect.x, -rect.y);
  }
  (_a = ctx.setAttrs) == null ? void 0 : _a.call(ctx, pen);
  let lineGradientFlag = false;
  const store = pen.calculative.canvas.store;
  const textFlip = pen.textFlip || store.options.textFlip;
  const textRotate = pen.textRotate || store.options.textRotate;
  ctx.beginPath();
  if (!textFlip || !textRotate) {
    ctx.save();
  }
  if (pen.calculative.flipX) {
    if (rect) {
      ctx.translate(pen.calculative.worldRect.x + pen.calculative.worldRect.ex, 0);
    } else {
      ctx.translate(pen.calculative.worldRect.x + pen.calculative.worldRect.ex, 0);
    }
    ctx.scale(-1, 1);
  }
  if (pen.calculative.flipY) {
    if (rect) {
      ctx.translate(0, pen.calculative.worldRect.y + pen.calculative.worldRect.ey);
    } else {
      ctx.translate(0, pen.calculative.worldRect.y + pen.calculative.worldRect.ey);
    }
    ctx.scale(1, -1);
  }
  if (pen.calculative.rotate && pen.name !== "line") {
    ctxRotate(ctx, pen);
  }
  if (pen.calculative.lineWidth > 1 || download) {
    ctx.lineWidth = pen.calculative.lineWidth;
  }
  let fill;
  if (pen.calculative.hover) {
    ctx.strokeStyle = pen.hoverColor || store.styles.hoverColor;
    ctx.fillStyle = pen.hoverBackground || store.styles.hoverBackground;
    fill = pen.hoverBackground || store.styles.hoverBackground;
  } else if (pen.calculative.active) {
    ctx.strokeStyle = pen.activeColor || store.styles.activeColor;
    ctx.fillStyle = pen.activeBackground || store.styles.activeBackground;
    fill = pen.activeBackground || store.styles.activeBackground;
  } else {
    if (pen.strokeImage) {
      if (pen.calculative.strokeImg) {
        ctx.strokeStyle = ctx.createPattern(pen.calculative.strokeImg, "repeat");
        fill = true;
      }
    } else {
      let stroke;
      if (pen.calculative.strokeType && pen.calculative.lineGradientColors && pen.name === "line") {
        lineGradientFlag = true;
      } else {
        stroke = pen.calculative.color || store.styles.color;
      }
      ctx.strokeStyle = stroke;
    }
    if (pen.backgroundImage) {
      if (pen.calculative.backgroundImg) {
        ctx.fillStyle = ctx.createPattern(pen.calculative.backgroundImg, "repeat");
        fill = true;
      }
    } else {
      ctx.fillStyle = pen.background;
      fill = !!pen.background;
    }
  }
  setLineCap(ctx, pen);
  setLineJoin(ctx, pen);
  setGlobalAlpha(ctx, pen);
  if (pen.calculative.lineDash) {
    ctx.setLineDash(pen.calculative.lineDash);
  }
  if (pen.calculative.lineDashOffset) {
    ctx.lineDashOffset = pen.calculative.lineDashOffset;
  }
  if (pen.calculative.shadowColor) {
    ctx.shadowColor = pen.calculative.shadowColor;
    ctx.shadowOffsetX = pen.calculative.shadowOffsetX;
    ctx.shadowOffsetY = pen.calculative.shadowOffsetY;
    ctx.shadowBlur = pen.calculative.shadowBlur;
  }
  if (lineGradientFlag) {
    ctxDrawLinearGradientPath(ctx, pen);
    ctxDrawLinePath(true, ctx, pen, store);
  } else {
    ctxDrawPath(false, ctx, pen, store, fill);
    ctxDrawCanvas(ctx, pen);
  }
  if (pen.calculative.img) {
    ctx.save();
    ctx.shadowColor = "";
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    drawImage(ctx, pen);
    ctx.restore();
  } else if (pen.calculative.icon) {
    drawIcon(ctx, pen);
  }
  if (pen.dropdownList) {
    drawDropdown(ctx, pen);
  }
  if (!textFlip || !textRotate) {
    ctx.restore();
  }
  if (textFlip && !textRotate) {
    if (pen.calculative.flipX) {
      if (rect) {
        ctx.translate(pen.calculative.worldRect.x + pen.calculative.worldRect.ex, 0);
      } else {
        ctx.translate(pen.calculative.worldRect.x + pen.calculative.worldRect.ex, 0);
      }
      ctx.scale(-1, 1);
    }
    if (pen.calculative.flipY) {
      if (rect) {
        ctx.translate(0, pen.calculative.worldRect.y + pen.calculative.worldRect.ey);
      } else {
        ctx.translate(0, pen.calculative.worldRect.y + pen.calculative.worldRect.ey);
      }
      ctx.scale(1, -1);
    }
  }
  if (!textFlip && textRotate) {
    if (pen.calculative.rotate && pen.name !== "line") {
      ctxRotate(ctx, pen, true);
    }
  }
  drawText(ctx, pen);
  if (pen.type === PenType.Line && pen.fillTexts) {
    for (const text of pen.fillTexts) {
      drawFillText(ctx, pen, text);
    }
  }
  ctx.restore();
}
function ctxDrawPath(canUsePath = true, ctx, pen, store, fill) {
  if (pen.name === "drawCommand")
    return;
  const path = canUsePath ? store.path2dMap.get(pen) : globalStore.path2dDraws[pen.name];
  let path_from = null;
  let path_to = null;
  if (pen.type === PenType.Line) {
    if (pen.fromLineCap && pen.fromLineCap !== "butt") {
      ctx.lineCap = "butt";
      path_from = new Path2D();
      path_from.moveTo(pen.calculative.worldAnchors[0].x, pen.calculative.worldAnchors[0].y);
      path_from.lineTo(pen.calculative.worldAnchors[0].x, pen.calculative.worldAnchors[0].y);
    }
    if (pen.toLineCap && pen.toLineCap !== "butt") {
      ctx.lineCap = "butt";
      path_to = new Path2D();
      path_to.moveTo(pen.calculative.worldAnchors[pen.calculative.worldAnchors.length - 1].x, pen.calculative.worldAnchors[pen.calculative.worldAnchors.length - 1].y);
      path_to.lineTo(pen.calculative.worldAnchors[pen.calculative.worldAnchors.length - 1].x, pen.calculative.worldAnchors[pen.calculative.worldAnchors.length - 1].y);
    }
  }
  if (path) {
    if (pen.type === PenType.Line && pen.borderWidth) {
      ctx.save();
      ctx.beginPath();
      const lineWidth = pen.calculative.lineWidth + pen.calculative.borderWidth;
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = pen.borderColor;
      if (path_from) {
        ctx.save();
        ctx.lineCap = pen.fromLineCap;
        ctx.stroke(path_from);
        ctx.restore();
      }
      if (path instanceof Path2D) {
        fill && ctx.fill(path);
        lineWidth && ctx.stroke(path);
      } else {
        path(pen, ctx);
        fill && ctx.fill();
        lineWidth && ctx.stroke();
      }
      if (path_to) {
        ctx.save();
        ctx.lineCap = pen.toLineCap;
        ctx.stroke(path_to);
        ctx.restore();
      }
      ctx.restore();
    }
    if (path instanceof Path2D) {
      if (pen.type) {
        if (pen.close) {
          fill && ctx.fill(path);
        }
      } else {
        fill && ctx.fill(path);
      }
    } else {
      ctx.save();
      path(pen, ctx);
      fill && ctx.fill();
      ctx.restore();
    }
    const progress = pen.calculative.progress;
    if (progress != null) {
      ctx.save();
      const { ex, x, y, width, height, ey } = pen.calculative.worldRect;
      let grd = null;
      if (!pen.calculative.verticalProgress) {
        grd = !pen.reverseProgress ? ctx.createLinearGradient(x, y, x + width * progress, y) : ctx.createLinearGradient(ex, y, x + width * (1 - progress), y);
      } else {
        grd = !pen.reverseProgress ? ctx.createLinearGradient(x, ey, x, y + height * (1 - progress)) : ctx.createLinearGradient(x, y, x, y + height * progress);
      }
      if (pen.calculative.progressGradientColors) {
        const { colors } = formatGradient(pen.calculative.progressGradientColors);
        colors.forEach((stop) => {
          grd.addColorStop(stop.i, stop.color);
        });
      } else {
        const color = pen.calculative.progressColor || pen.calculative.color || store.options.activeColor || store.data.color;
        grd.addColorStop(0, color);
        grd.addColorStop(1, color);
      }
      grd.addColorStop(1, "transparent");
      ctx.fillStyle = grd;
      if (path instanceof Path2D) {
        ctx.fill(path);
      } else {
        path(pen, ctx);
        ctx.fill();
      }
      ctx.restore();
    }
    if (pen.calculative.lineWidth) {
      if (path instanceof Path2D) {
        if (store.options.svgPathStroke || pen.name !== "svgPath") {
          if (path_from) {
            ctx.save();
            ctx.lineCap = pen.fromLineCap;
            ctx.stroke(path_from);
            ctx.restore();
          }
          ctx.stroke(path);
          if (path_to) {
            ctx.save();
            ctx.lineCap = pen.toLineCap;
            ctx.stroke(path_to);
            ctx.restore();
          }
        }
      } else {
        path(pen, ctx);
        ctx.stroke();
      }
    }
    if (pen.type) {
      if (pen.calculative.animatePos) {
        ctx.save();
        setCtxLineAnimate(ctx, pen, store);
        if (pen.lineAnimateType === LineAnimateType.Arrow || pen.lineAnimateType === LineAnimateType.WaterDrop) {
          let _path = drawArrow(pen, ctx);
          if (_path instanceof Path2D) {
            ctx.stroke(_path);
            ctx.fill(_path);
          } else {
            ctx.stroke();
            ctx.fill();
          }
        } else {
          if (path instanceof Path2D) {
            if (path_from && !pen.lineAnimateType) {
              ctx.save();
              ctx.lineCap = pen.fromLineCap;
              ctx.stroke(path_from);
              ctx.restore();
            }
            ctx.lineCap = pen.lineCap;
            ctx.stroke(path);
          } else {
            path(pen, ctx);
            ctx.stroke();
          }
        }
        ctx.restore();
      }
      pen.fromArrow && renderFromArrow(ctx, pen, store);
      pen.toArrow && renderToArrow(ctx, pen, store);
      if (pen.calculative.active && !pen.calculative.pencil && !store.options.disableAnchor && !store.data.locked) {
        renderLineAnchors(ctx, pen);
      }
    }
  }
}
function ctxDrawLinePath(canUsePath = true, ctx, pen, store) {
  const path = canUsePath ? store.path2dMap.get(pen) : globalStore.path2dDraws[pen.name];
  if (path) {
    if (pen.type) {
      if (pen.calculative.animatePos) {
        ctx.save();
        setCtxLineAnimate(ctx, pen, store);
        ctx.beginPath();
        if (path instanceof Path2D) {
          if (pen.lineName === "polyline" || pen.lineName === "line") {
            if (pen.lineAnimateType === LineAnimateType.Arrow || pen.lineAnimateType === LineAnimateType.WaterDrop) {
              const _path = drawArrow(pen);
              ctx.stroke(_path);
              ctx.fill(_path);
            } else {
              if (pen.calculative.gradientSmooth || pen.calculative.lineSmooth) {
                if (!pen.calculative.gradientAnimatePath) {
                  pen.calculative.gradientAnimatePath = getGradientAnimatePath(pen);
                }
                if (pen.calculative.gradientAnimatePath instanceof Path2D) {
                  ctx.stroke(pen.calculative.gradientAnimatePath);
                }
              } else {
                ctx.stroke(path);
              }
            }
          } else {
            ctx.stroke(path);
          }
        } else {
          path(pen, ctx);
          ctx.stroke();
        }
        ctx.restore();
      }
      pen.fromArrow && renderFromArrow(ctx, pen, store);
      pen.toArrow && renderToArrow(ctx, pen, store);
      if (pen.calculative.active && !pen.calculative.pencil && !store.options.disableAnchor && !store.data.locked) {
        renderLineAnchors(ctx, pen);
      }
    }
  }
}
function setCtxLineAnimate(ctx, pen, store) {
  ctx.strokeStyle = pen.animateColor || store.styles.animateColor;
  if (pen.animateShadow) {
    ctx.shadowBlur = pen.animateShadowBlur || pen.animateLineWidth || 6;
    ctx.shadowColor = pen.animateShadowColor || pen.animateColor || store.styles.animateColor;
  }
  pen.calculative.animateLineWidth && (ctx.lineWidth = pen.calculative.animateLineWidth * store.data.scale);
  let len = 0;
  switch (pen.lineAnimateType) {
    case LineAnimateType.Beads:
      if (pen.animateReverse) {
        ctx.lineDashOffset = pen.calculative.animatePos;
      } else {
        ctx.lineDashOffset = pen.length - pen.calculative.animatePos;
      }
      len = pen.calculative.lineWidth || 5;
      if (len < 5) {
        len = 5;
      }
      const dash = pen.animateLineDash && pen.animateLineDash.map((item) => item * len / 5);
      ctx.setLineDash(dash || [len, len * 2]);
      break;
    case LineAnimateType.Dot:
      if (pen.animateReverse) {
        ctx.lineDashOffset = pen.calculative.animatePos;
      } else {
        ctx.lineDashOffset = pen.length - pen.calculative.animatePos;
      }
      len = pen.calculative.animateDotSize || pen.calculative.lineWidth * 2 || 6;
      if (len < 6) {
        len = 6;
      }
      if (len > 40) {
        len = 40;
      }
      ctx.lineWidth = (pen.calculative.animateLineWidth || len) * store.data.scale;
      ctx.setLineDash([0.1, pen.length]);
      break;
    case LineAnimateType.Arrow:
      ctx.fillStyle = pen.animateColor || store.styles.animateColor;
      ctx.lineWidth = 1;
      break;
    case LineAnimateType.WaterDrop:
      ctx.fillStyle = pen.animateColor || store.styles.animateColor;
      ctx.lineWidth = 1;
      break;
    default:
      if (pen.animateReverse) {
        ctx.lineDashOffset = Number.EPSILON;
        ctx.setLineDash([
          0,
          pen.length - pen.calculative.animatePos + 1,
          pen.calculative.animatePos
        ]);
      } else {
        ctx.setLineDash([
          pen.calculative.animatePos,
          pen.length + 0.01 - pen.calculative.animatePos
          //
        ]);
      }
      break;
  }
}
function getGlobalColor(store) {
  const { data, options } = store;
  return data.color || options.color;
}
function renderLineAnchors(ctx, pen) {
  const store = pen.calculative.canvas.store;
  ctx.save();
  ctx.lineWidth = 1;
  ctx.fillStyle = pen.activeColor || store.styles.activeColor;
  pen.calculative.worldAnchors.forEach((pt) => {
    !pt.hidden && !pt.isTemp && renderAnchor(ctx, pt, pen);
  });
  ctx.restore();
}
function renderAnchor(ctx, pt, pen) {
  if (!pt) {
    return;
  }
  const active = pen.calculative.canvas.store.activeAnchor === pen.calculative.activeAnchor && pen.calculative.activeAnchor === pt;
  let r = 3;
  if (pen.calculative.lineWidth > 3) {
    r = pen.calculative.lineWidth;
  }
  if (pen.anchorRadius) {
    r = pen.anchorRadius;
  }
  if (pt.radius) {
    r = pt.radius;
  }
  if (active) {
    if (pt.prev) {
      ctx.save();
      ctx.strokeStyle = "#4dffff";
      ctx.beginPath();
      ctx.moveTo(pt.prev.x, pt.prev.y);
      ctx.lineTo(pt.x, pt.y);
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(pt.prev.x, pt.prev.y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }
    if (pt.next) {
      ctx.save();
      ctx.strokeStyle = "#4dffff";
      ctx.beginPath();
      ctx.moveTo(pt.x, pt.y);
      ctx.lineTo(pt.next.x, pt.next.y);
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(pt.next.x, pt.next.y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
    }
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  } else {
    ctx.save();
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }
}
function calcWorldRects(pen) {
  const store = pen.calculative.canvas.store;
  let rect = {
    x: pen.x,
    y: pen.y
  };
  if (!pen.parentId || pen.parentId && !store.pens[pen.parentId]) {
    pen.parentId = void 0;
    rect.width = pen.width;
    rect.height = pen.height;
    rect.rotate = pen.rotate;
    calcRightBottom(rect);
    calcCenter(rect);
    if (pen.pivot) {
      calcPivot(rect, pen.pivot);
    }
  } else {
    const parent = store.pens[pen.parentId];
    let parentRect = parent.calculative.worldRect;
    if (!parentRect) {
      parentRect = calcWorldRects(parent);
    }
    rect.x = parentRect.x + parentRect.width * pen.x;
    rect.y = parentRect.y + parentRect.height * pen.y;
    rect.width = parentRect.width * pen.width;
    rect.height = parentRect.height * pen.height;
    if (parent.flipX) {
      rect.x = parentRect.width - (rect.x - parentRect.x + rect.width) + parentRect.x;
    }
    if (parent.flipY) {
      rect.y = parentRect.height - (rect.y - parentRect.y + rect.height) + parentRect.y;
    }
    calcRightBottom(rect);
    rect.rotate = parentRect.rotate + pen.rotate;
    calcCenter(rect);
    if (pen.pivot) {
      calcPivot(rect, pen.pivot);
    }
  }
  pen.calculative.worldRect = rect;
  calcPadding(pen, rect);
  return rect;
}
function calcPadding(pen, rect) {
  !pen.paddingTop && (pen.calculative.paddingTop = 0);
  !pen.paddingBottom && (pen.calculative.paddingBottom = 0);
  !pen.paddingLeft && (pen.calculative.paddingLeft = 0);
  !pen.paddingRight && (pen.calculative.paddingRight = 0);
  Math.abs(pen.calculative.paddingTop) < 1 && (pen.calculative.paddingTop *= rect.height);
  Math.abs(pen.calculative.paddingBottom) < 1 && (pen.calculative.paddingBottom *= rect.height);
  Math.abs(pen.calculative.paddingLeft) < 1 && (pen.calculative.paddingLeft *= rect.width);
  Math.abs(pen.calculative.paddingRight) < 1 && (pen.calculative.paddingRight *= rect.width);
}
function calcPenRect(pen) {
  const worldRect = deepClone(pen.calculative.worldRect);
  delete worldRect.pivot;
  if (!pen.parentId) {
    Object.assign(pen, worldRect);
    return;
  }
  const store = pen.calculative.canvas.store;
  const parentRect = store.pens[pen.parentId].calculative.worldRect;
  Object.assign(pen, calcRelativeRect(worldRect, parentRect));
}
function calcWorldAnchors(pen) {
  const store = pen.calculative.canvas.store;
  let anchors = [];
  if (pen.anchors) {
    let _anchors = deepClone(pen.anchors);
    if (pen.flipX) {
      _anchors.forEach((anchor) => {
        anchor.x = 0.5 - (anchor.x - 0.5);
      });
    }
    if (pen.flipY) {
      _anchors.forEach((anchor) => {
        anchor.y = 0.5 - (anchor.y - 0.5);
      });
    }
    _anchors.forEach((anchor) => {
      anchors.push(calcWorldPointOfPen(pen, anchor));
    });
  }
  if (!anchors.length && !pen.type && !pen.calculative.canvas.parent.isCombine(pen)) {
    const { x, y, width, height } = pen.calculative.worldRect;
    anchors = store.options.defaultAnchors.map((anchor, index) => {
      return {
        id: `${index}`,
        penId: pen.id,
        x: x + width * anchor.x,
        y: y + height * anchor.y
      };
    });
  }
  if (pen.calculative.rotate) {
    anchors.forEach((anchor) => {
      rotatePoint(anchor, pen.calculative.rotate, pen.calculative.worldRect.pivot || pen.calculative.worldRect.center);
    });
  }
  if (!pen.type || pen.anchors) {
    pen.calculative.worldAnchors = anchors;
  }
  if (pen.calculative.activeAnchor && anchors.length) {
    pen.calculative.activeAnchor = anchors.find((a) => {
      a.id === pen.calculative.activeAnchor.id;
    });
  }
  pen.calculative.gradientAnimatePath = void 0;
}
function calcChildrenInitRect(pen) {
  var _a;
  if ((_a = pen.children) == null ? void 0 : _a.length) {
    let parentRect = pen.calculative.worldRect;
    pen.children.forEach((id) => {
      const child = pen.calculative.canvas.store.pens[id];
      if (child.calculative.initRect && child.calculative.initRelativeRect) {
        child.calculative.initRect.x = parentRect.x + parentRect.width * child.calculative.initRelativeRect.x;
        child.calculative.initRect.y = parentRect.y + parentRect.height * child.calculative.initRelativeRect.y;
        child.calculative.initRect.ex = child.calculative.initRect.x + parentRect.width * child.calculative.initRelativeRect.width;
        child.calculative.initRect.ey = child.calculative.initRect.y + parentRect.height + child.calculative.initRelativeRect.height;
        calcCenter(child.calculative.initRect);
      }
      calcChildrenInitRect(child);
    });
  }
}
function calcWorldPointOfPen(pen, pt) {
  const p = { ...pt };
  const { x, y, width, height } = pen.calculative.worldRect;
  p.x = x + width * pt.x;
  p.y = y + height * pt.y;
  if (pt.prev) {
    p.prev = {
      penId: pen.id,
      connectTo: pt.prev.connectTo,
      x: x + width * pt.prev.x,
      y: y + height * pt.prev.y
    };
  }
  if (pt.next) {
    p.next = {
      penId: pen.id,
      connectTo: pt.next.connectTo,
      x: x + width * pt.next.x,
      y: y + height * pt.next.y
    };
  }
  return p;
}
function calcIconRect(pens, pen) {
  const { paddingTop, paddingBottom, paddingLeft, paddingRight } = pen.calculative;
  let x = paddingLeft;
  let y = paddingTop;
  let width = pen.calculative.worldRect.width - paddingLeft - paddingRight;
  let height = pen.calculative.worldRect.height - paddingTop - paddingBottom;
  let iconLeft = pen.calculative.iconLeft;
  let iconTop = pen.calculative.iconTop;
  if (iconLeft && Math.abs(iconLeft) < 1) {
    iconLeft = pen.calculative.worldRect.width * iconLeft;
  }
  if (iconTop && Math.abs(iconTop) < 1) {
    iconTop = pen.calculative.worldRect.height * iconTop;
  }
  x += iconLeft || 0;
  y += iconTop || 0;
  width -= iconLeft || 0;
  height -= iconTop || 0;
  let rotate = pen.calculative.iconRotate || 0;
  if (pen.parentId) {
    const parentPen = pens[pen.parentId].calculative;
    if (parentPen) {
      rotate += parentPen.rotate;
      rotate %= 360;
    }
  }
  x = pen.calculative.worldRect.x + x;
  y = pen.calculative.worldRect.y + y;
  pen.calculative.worldIconRect = {
    x,
    y,
    width,
    height,
    rotate
  };
  calcRightBottom(pen.calculative.worldIconRect);
  calcCenter(pen.calculative.worldIconRect);
}
function scalePen(pen, scale, center) {
  scaleRect(pen.calculative.worldRect, scale, center, pen.pivot);
  if (pen.calculative.initRect) {
    scaleRect(pen.calculative.initRect, scale, center, pen.pivot);
  }
  scaleChildrenInitRect(pen, scale, center);
  if (pen.calculative.x) {
    scalePoint(pen.calculative, scale, center);
  }
  if (pen.type) {
    calcWorldAnchors(pen);
  }
}
function scaleChildrenInitRect(pen, scale, center) {
  var _a;
  if (!pen) {
    return;
  }
  if ((_a = pen.children) == null ? void 0 : _a.length) {
    pen.children.forEach((id) => {
      const child = pen.calculative.canvas.store.pens[id];
      if (child) {
        if (child.calculative.initRect) {
          scaleRect(child.calculative.initRect, scale, center);
        }
        scaleChildrenInitRect(child, scale, center);
      }
    });
  }
}
function pushPenAnchor(pen, pt) {
  if (!pen.anchors) {
    pen.anchors = [];
  }
  if (!pen.calculative.worldAnchors) {
    pen.calculative.worldAnchors = [];
  }
  const worldAnchor = {
    id: pt.id,
    penId: pen.id,
    x: pt.x,
    y: pt.y
  };
  pen.calculative.worldAnchors.push(worldAnchor);
  if (pen.calculative.worldRect) {
    if (pen.rotate % 360) {
      rotatePoint(pt, -pen.rotate, pen.calculative.worldRect.center);
    }
    const anchor = {
      id: pt.id,
      penId: pen.id,
      x: (pt.x - pen.calculative.worldRect.x) / pen.calculative.worldRect.width,
      y: (pt.y - pen.calculative.worldRect.y) / pen.calculative.worldRect.height
    };
    pen.anchors.push(anchor);
  }
  return worldAnchor;
}
function addLineAnchor(pen, pt, index) {
  if (!pen.anchors) {
    pen.anchors = [];
  }
  if (!pen.calculative.worldAnchors) {
    pen.calculative.worldAnchors = [];
  }
  const worldAnchor = getSplitAnchor(pen, pt, index);
  pen.calculative.worldAnchors.splice(index + 1, 0, worldAnchor);
  pen.anchors.splice(index + 1, 0, calcRelativePoint(worldAnchor, pen.calculative.worldRect));
  pen.calculative.activeAnchor = worldAnchor;
  return worldAnchor;
}
function removePenAnchor(pen, anchor) {
  if (!pen || !pen.calculative.worldAnchors) {
    return;
  }
  let i = pen.calculative.worldAnchors.findIndex((a) => a.id === anchor.id);
  if (i > -1) {
    pen.calculative.worldAnchors.splice(i, 1);
  }
  i = pen.anchors.findIndex((a) => a.id === anchor.id);
  if (i > -1) {
    pen.anchors.splice(i, 1);
  }
}
function facePen(pt, pen) {
  if (!pen || !pen.calculative || !pen.calculative.worldRect.center) {
    return Direction.None;
  }
  if (pt.anchorId) {
    let anchor = pen.anchors.filter((_anchor) => _anchor.id === pt.anchorId);
    if (anchor.length) {
      if (anchor[0].direction > -1) {
        return anchor[0].direction;
      }
    }
  }
  return facePoint(pt, pen.calculative.worldRect.center);
}
function nearestAnchor(pen, pt) {
  let dis = Infinity;
  let anchor;
  pen.calculative.worldAnchors.forEach((a) => {
    const d = distance(pt, a);
    if (dis > d) {
      dis = d;
      anchor = a;
    }
  });
  return anchor;
}
function translateLine(pen, x, y) {
  pen.x += x;
  pen.y += y;
  if (pen.anchors) {
    pen.anchors.forEach((a) => {
      translatePoint(a, x, y);
    });
  }
  if (pen.calculative.worldAnchors) {
    pen.calculative.worldAnchors.forEach((a) => {
      translatePoint(a, x, y);
    });
  }
}
function deleteTempAnchor(pen) {
  if (pen && pen.calculative && pen.calculative.worldAnchors.length) {
    let to = getToAnchor(pen);
    if (!pen.anchors || !pen.anchors.length) {
      while (pen.calculative.worldAnchors.length && to !== pen.calculative.activeAnchor) {
        pen.calculative.worldAnchors.pop();
        to = getToAnchor(pen);
      }
    } else if (to === pen.calculative.activeAnchor) {
      pen.calculative.worldAnchors = [pen.calculative.worldAnchors[0]];
    } else if (pen.calculative.worldAnchors[0] === pen.calculative.activeAnchor) {
      pen.calculative.worldAnchors = [
        pen.calculative.worldAnchors[pen.calculative.worldAnchors.length - 1]
      ];
    }
  }
}
function connectLine(pen, anchor, line2, lineAnchor) {
  var _a, _b, _c, _d, _e, _f;
  if (!pen || !anchor || !line2 || !lineAnchor || anchor.twoWay === TwoWay.DisableConnected || anchor.twoWay === TwoWay.Disable || lineAnchor.twoWay === TwoWay.DisableConnectTo || lineAnchor.twoWay === TwoWay.Disable) {
    return;
  }
  if (anchor.twoWay === TwoWay.In) {
    if (line2.calculative.worldAnchors.length === 1) {
      return;
    }
    const to = getToAnchor(line2);
    if (lineAnchor.id !== to.id) {
      return;
    }
  }
  if (anchor.twoWay === TwoWay.Out) {
    const from = getFromAnchor(line2);
    if (lineAnchor.id !== from.id) {
      return;
    }
  }
  if (lineAnchor.connectTo === pen.id && lineAnchor.anchorId === anchor.id) {
    return;
  }
  if (lineAnchor.connectTo) {
    const p = pen.calculative.canvas.store.pens[lineAnchor.connectTo];
    disconnectLine(p, getAnchor(p, lineAnchor.anchorId), line2, lineAnchor);
  }
  if (!pen.connectedLines) {
    pen.connectedLines = [];
  }
  const i = pen.connectedLines.findIndex((item) => item.lineId === line2.id && item.lineAnchor === lineAnchor.id && item.anchor === anchor.id);
  if (i < 0) {
    pen.connectedLines.push({
      lineId: line2.id,
      lineAnchor: lineAnchor.id,
      anchor: anchor.id
    });
  }
  lineAnchor.connectTo = pen.id;
  lineAnchor.anchorId = anchor.id;
  if (pen.type) {
    connectLine(line2, lineAnchor, pen, anchor);
  }
  pen.calculative.canvas.store.emitter.emit("connectLine", {
    line: line2,
    lineAnchor,
    pen,
    anchor
  });
  let fromPen = ((_a = line2.calculative.worldAnchors) == null ? void 0 : _a.length) >= 2 ? (_b = line2.calculative.worldAnchors) == null ? void 0 : _b[0].connectTo : void 0;
  let fromAnchor = ((_c = line2.calculative.worldAnchors) == null ? void 0 : _c.length) >= 2 ? (_e = line2.calculative.canvas.store.pens[(_d = line2.calculative.worldAnchors) == null ? void 0 : _d[0].connectTo]) == null ? void 0 : _e.anchors.find((i2) => {
    var _a2;
    return i2.id === ((_a2 = line2.calculative.worldAnchors) == null ? void 0 : _a2[0].anchorId);
  }) : void 0;
  (_f = pen.onConnectLine) == null ? void 0 : _f.call(pen, pen, {
    line: line2,
    lineAnchor,
    pen,
    anchor,
    fromPen,
    fromAnchor
  });
  return true;
}
function disconnectLine(pen, anchor, line2, lineAnchor) {
  if (!pen || !anchor || !line2 || !lineAnchor) {
    return;
  }
  if (!pen.connectedLines || !pen.connectedLines.length) {
    return;
  }
  if (!line2.lastConnected) {
    line2.lastConnected = {};
  }
  if (!line2.lastConnected[pen.id]) {
    line2.lastConnected[pen.id] = deepClone(pen.connectedLines);
  }
  pen.connectedLines.forEach((item, index, arr) => {
    if ((item.lineId === line2.id || item.lineId === line2.id) && item.lineAnchor === lineAnchor.id && item.anchor === anchor.id) {
      arr.splice(index, 1);
    }
  });
  lineAnchor.connectTo = void 0;
  lineAnchor.anchorId = void 0;
  if (pen.type && anchor.connectTo === line2.id && anchor.anchorId === lineAnchor.id) {
    disconnectLine(line2, lineAnchor, pen, anchor);
  }
  pen.calculative.canvas.store.emitter.emit("disconnectLine", {
    line: line2,
    lineAnchor,
    pen,
    anchor
  });
  return true;
}
function getAnchor(pen, anchorId) {
  var _a;
  if (!pen || !anchorId) {
    return;
  }
  return (_a = pen.calculative.worldAnchors) == null ? void 0 : _a.find((item) => item.id === anchorId);
}
function getFromAnchor(pen) {
  if (!pen || !pen.calculative.worldAnchors) {
    return;
  }
  return pen.calculative.worldAnchors[0];
}
function getToAnchor(pen) {
  if (!pen || !pen.calculative.worldAnchors) {
    return;
  }
  return pen.calculative.worldAnchors[pen.calculative.worldAnchors.length - 1];
}
function setNodeAnimate(pen, now) {
  var _a, _b;
  if (pen.calculative.start === 0 || !pen.frames || !pen.frames.length) {
    pen.calculative.start = void 0;
    return 0;
  }
  if (!pen.calculative.duration) {
    pen.calculative.duration = 0;
    for (const f of pen.frames) {
      pen.calculative.duration += f.duration;
      for (const k in f) {
        if (k !== "duration" && !pen[k]) {
          if (k === "scale") {
            pen[k] = 1;
          }
        }
      }
    }
  }
  if (!pen.animateCycle) {
    pen.animateCycle = Infinity;
  }
  if (!pen.calculative.start) {
    pen.calculative.start = now;
    pen.calculative.frameIndex = 0;
    pen.calculative.frameStart = pen.calculative.start;
    pen.calculative.frameDuration = pen.frames[0].duration;
    pen.calculative.frameEnd = pen.calculative.frameStart + pen.calculative.frameDuration;
    pen.calculative.cycleIndex = 1;
    pen.calculative.x = pen.calculative.worldRect.x;
    pen.calculative.y = pen.calculative.worldRect.y;
    pen.calculative.initRect = deepClone(pen.calculative.worldRect);
    if (pen.parentId) {
      pen.calculative.initRelativeRect = {
        x: pen.x,
        y: pen.y,
        width: pen.width,
        height: pen.height
      };
    }
    if ((_a = pen.children) == null ? void 0 : _a.length) {
      const store = pen.calculative.canvas.store;
      pen.calculative.childrenVisible = {};
      pen.children.forEach((id) => {
        pen.calculative.childrenVisible[id] = store.pens[id].visible;
      });
    }
    pen.calculative.initRect.rotate = pen.calculative.rotate || 0;
    initPrevFrame(pen);
  } else {
    let frameIndex = 0;
    const cycleIndex = Math.ceil((now - pen.calculative.start) / pen.calculative.duration);
    if (cycleIndex > pen.animateCycle) {
      pen.currentAnimation = void 0;
      pen.calculative.start = void 0;
      setNodeAnimateProcess(pen, 1);
      return 0;
    }
    const pos = (now - pen.calculative.start) % pen.calculative.duration || pen.calculative.duration;
    let d = 0;
    for (const frame of pen.frames) {
      d += frame.duration;
      if (pos > d) {
        ++frameIndex;
      } else {
        break;
      }
    }
    if (!pen.frames[frameIndex]) {
      return true;
    }
    let frameChanged = false;
    if (frameIndex !== pen.calculative.frameIndex) {
      frameChanged = true;
      pen.calculative.frameIndex = frameIndex;
      pen.calculative.frameDuration = pen.frames[frameIndex].duration;
      if (frameIndex > 0) {
        pen.calculative.frameStart += pen.frames[frameIndex - 1].duration;
      }
      pen.calculative.frameEnd = pen.calculative.frameStart + pen.calculative.frameDuration;
    }
    let cycleChanged = false;
    if (cycleIndex > pen.calculative.cycleIndex) {
      pen.calculative.cycleIndex = cycleIndex;
      pen.calculative.frameStart = pen.calculative.start + pen.calculative.duration * (cycleIndex - 1);
      cycleChanged = true;
    }
    if (frameChanged || cycleChanged) {
      pen.calculative.x = pen.calculative.initRect.x;
      pen.calculative.y = pen.calculative.initRect.y;
      if (((_b = pen.children) == null ? void 0 : _b.length) && !pen.parentId) {
        pen.calculative.canvas.rotatePen(pen, (pen.calculative.initRect.rotate || 0) - (pen.calculative.rotate || 0), pen.calculative.initRect);
      } else {
        pen.calculative.rotate = pen.calculative.initRect.rotate || 0;
      }
      if (frameIndex > 0) {
        pen.prevFrame = {};
        const prevFrame = pen.frames[frameIndex - 1];
        for (const k in prevFrame) {
          pen.prevFrame[k] = prevFrame[k];
        }
        Object.assign(pen.prevFrame, {
          rotate: prevFrame.rotate || 0,
          x: prevFrame.x || 0,
          y: prevFrame.y || 0,
          scale: prevFrame.scale || 1
        });
      } else {
        initPrevFrame(pen);
      }
    }
  }
  const process = (now - pen.calculative.frameStart) / pen.calculative.frameDuration % 1;
  process > 0 && setNodeAnimateProcess(pen, process);
  return true;
}
function initPrevFrame(pen) {
  pen.prevFrame = {};
  for (const k in pen) {
    if (typeof pen[k] !== "object" || k === "lineDash") {
      pen.prevFrame[k] = pen[k];
    }
  }
  pen.prevFrame.rotate = 0;
  pen.prevFrame.x = 0;
  pen.prevFrame.y = 0;
  pen.prevFrame.scale = 1;
}
function setNodeAnimateProcess(pen, process) {
  var _a, _b, _c, _d, _e, _f;
  if (process < 0) {
    return;
  }
  if (process > 1) {
    process = 1;
  }
  const frame = pen.frames[pen.calculative.frameIndex];
  const scale = pen.calculative.canvas.store.data.scale;
  for (const k in frame) {
    if (k === "duration") {
      continue;
    } else if (k === "scale") {
      pen.calculative.worldRect = deepClone(pen.calculative.initRect);
      scaleRect(pen.calculative.worldRect, pen.prevFrame.scale, pen.calculative.worldRect.center);
      const newScale = pen.prevFrame.scale + (frame[k] - pen.prevFrame.scale) * process;
      scaleRect(pen.calculative.worldRect, newScale / pen.prevFrame.scale, pen.calculative.worldRect.center);
      pen.calculative.patchFlags = true;
    } else if (k === "x") {
      const lastVal = getFrameValue(pen, k, pen.calculative.frameIndex) * scale;
      pen.calculative.worldRect.x = pen.calculative.initRect.x + lastVal;
      pen.calculative.worldRect.ex = pen.calculative.initRect.ex + lastVal;
      pen.calculative.worldRect.center.x = pen.calculative.initRect.center.x + lastVal;
      if ((_a = pen.calculative.worldRect.pivot) == null ? void 0 : _a.x) {
        pen.calculative.worldRect.pivot.x = ((_b = pen.calculative.initRect.pivot) == null ? void 0 : _b.x) + lastVal;
      }
      translateRect(pen.calculative.worldRect, frame[k] * process * scale, 0);
      pen.calculative.patchFlags = true;
    } else if (k === "y") {
      const lastVal = getFrameValue(pen, k, pen.calculative.frameIndex) * scale;
      pen.calculative.worldRect.y = pen.calculative.initRect.y + lastVal;
      pen.calculative.worldRect.ey = pen.calculative.initRect.ey + lastVal;
      pen.calculative.worldRect.center.y = pen.calculative.initRect.center.y + lastVal;
      if ((_c = pen.calculative.worldRect.pivot) == null ? void 0 : _c.x) {
        pen.calculative.worldRect.pivot.y = ((_d = pen.calculative.initRect.pivot) == null ? void 0 : _d.y) + lastVal;
      }
      translateRect(pen.calculative.worldRect, 0, frame[k] * process * scale);
      pen.calculative.patchFlags = true;
    } else if (k === "width") {
      const lastVal = getFrameValue(pen, k, pen.calculative.frameIndex) * scale;
      pen.calculative.worldRect.width = pen.calculative.initRect.width + lastVal;
      pen.calculative.worldRect.ex = pen.calculative.initRect.ex + lastVal;
      pen.calculative.worldRect.center.x = pen.calculative.initRect.center.x + lastVal;
      let value4 = frame[k] * process * scale;
      pen.calculative.worldRect.width += value4;
      pen.calculative.worldRect.ex += value4;
      pen.calculative.worldRect.center.x += value4;
      pen.calculative.patchFlags = true;
    } else if (k === "height") {
      const lastVal = getFrameValue(pen, k, pen.calculative.frameIndex) * scale;
      pen.calculative.worldRect.height = pen.calculative.initRect.height + lastVal;
      pen.calculative.worldRect.ey = pen.calculative.initRect.ey + lastVal;
      pen.calculative.worldRect.center.y = pen.calculative.initRect.center.y + lastVal;
      let value4 = frame[k] * process * scale;
      pen.calculative.worldRect.height += value4;
      pen.calculative.worldRect.ey += value4;
      pen.calculative.worldRect.center.y += value4;
      pen.calculative.patchFlags = true;
    } else if (k === "rotate") {
      if (pen.prevFrame[k] >= 360) {
        pen.prevFrame[k] %= 360;
      }
      const lastVal = getFrameValue(pen, k, pen.calculative.frameIndex);
      const offsetRotate = (pen.calculative.initRect.rotate + lastVal + frame[k] * process) % 360 - (pen.calculative.rotate || 0);
      if ((_e = pen.children) == null ? void 0 : _e.length) {
        pen.calculative.canvas.rotatePen(pen, offsetRotate, pen.calculative.initRect);
      } else {
        pen.calculative.rotate = (pen.calculative.initRect.rotate + lastVal + frame[k] * process) % 360;
      }
      pen.calculative.patchFlags = true;
    } else if (k === "image") {
      pen.image = frame["image"];
      pen.calculative.image = void 0;
      pen.calculative.canvas.loadImage(pen);
      if (pen.canvasLayer === CanvasLayer.CanvasImageBottom) {
        pen.calculative.canvas.canvasImageBottom.init();
      } else if (pen.canvasLayer === CanvasLayer.CanvasImage) {
        pen.calculative.canvas.canvasImage.init();
      }
    } else if (isLinear(frame[k], k, pen)) {
      if (pen.prevFrame[k] == null) {
        if (k === "globalAlpha") {
          pen.prevFrame[k] = 1;
        } else {
          pen.prevFrame[k] = 0;
        }
      }
      const current = pen.prevFrame[k] + (frame[k] - pen.prevFrame[k]) * process;
      pen.calculative[k] = Math.round(current * 100) / 100;
    } else {
      if (k === "visible") {
        if (pen.calculative.image) {
        } else if ((_f = pen.children) == null ? void 0 : _f.length) {
          const childs = getAllChildren(pen, pen.calculative.canvas.store);
          pen.calculative.canvas.initImageCanvas(childs);
        }
      }
      pen.calculative[k] = frame[k];
      const v = {};
      v[k] = frame[k];
      setChildValue(pen, v);
    }
    if (k === "text") {
      calcTextLines(pen);
    }
  }
}
function isLinear(value4, key, pen) {
  const noLinear = ["strokeType", "bkType", "showChild"];
  return typeof value4 === "number" && pen.linear !== false && !noLinear.includes(key);
}
function setLineAnimate(pen, now) {
  if (pen.calculative.start === 0) {
    pen.calculative.start = void 0;
    return 0;
  }
  if (!pen.animateCycle) {
    pen.animateCycle = Infinity;
  }
  if (!pen.animateSpan) {
    pen.animateSpan = 1;
  }
  pen.calculative.animatePos += pen.animateSpan * (pen.calculative.canvas.store.data.scale || 1);
  if (!pen.calculative.start) {
    pen.calculative.start = Date.now();
    pen.calculative.animatePos = pen.animateSpan * (pen.calculative.canvas.store.data.scale || 1);
    pen.calculative.cycleIndex = 1;
  } else if (pen.calculative.animatePos > pen.length) {
    ++pen.calculative.cycleIndex;
    if (pen.calculative.cycleIndex > pen.animateCycle) {
      pen.currentAnimation = void 0;
      pen.calculative.start = void 0;
      return 0;
    }
    pen.calculative.animatePos = pen.animateSpan;
  }
  return true;
}
function setChildrenActive(pen, active = true) {
  if (!pen.children || pen.childActive === false) {
    return;
  }
  const store = pen.calculative.canvas.store;
  pen.children.forEach((id) => {
    const child = store.pens[id];
    if (child) {
      child.calculative.active = active;
      setChildrenActive(child, active);
    }
  });
}
function setHover(pen, hover = true) {
  if (!pen) {
    return;
  }
  const store = pen.calculative.canvas.store;
  pen.calculative.hover = hover;
  if (pen.childHover === false) {
    return;
  }
  if (pen.children) {
    pen.children.forEach((id) => {
      var _a, _b;
      if (((_a = store.pens[id]) == null ? void 0 : _a.hoverColor) == void 0 && ((_b = store.pens[id]) == null ? void 0 : _b.hoverBackground) == void 0) {
        setHover(store.pens[id], hover);
      }
    });
  }
}
function setElemPosition(pen, elem) {
  if (!elem) {
    return;
  }
  const store = pen.calculative.canvas.store;
  const worldRect = pen.calculative.worldRect;
  elem.style.opacity = pen.globalAlpha + "";
  elem.style.position = "absolute";
  elem.style.outline = "none";
  elem.style.left = worldRect.x + store.data.x + "px";
  elem.style.top = worldRect.y + store.data.y + "px";
  elem.style.width = worldRect.width + "px";
  elem.style.height = worldRect.height + "px";
  elem.style.display = pen.calculative.inView != false ? pen.calculative.cssDisplay || "inline" : "none";
  !pen.calculative.rotate && (pen.calculative.rotate = 0);
  elem.style.transform = `rotate(${pen.calculative.rotate}deg)`;
  if (!pen.calculative.rotate) {
    if (pen.calculative.flipX) {
      elem.style.transform = `rotateY(180deg)`;
    }
    if (pen.calculative.flipY) {
      elem.style.transform = `rotateX(180deg)`;
    }
    if (pen.calculative.flipX && pen.calculative.flipY) {
      elem.style.transform = `rotateZ(180deg)`;
    }
  }
  elem.style.zIndex = pen.calculative.zIndex !== void 0 ? pen.calculative.zIndex + "" : "5";
  if (pen.calculative.zIndex > pen.calculative.canvas.maxZindex) {
    pen.calculative.canvas.maxZindex = pen.calculative.zIndex;
  }
  if (pen.locked === LockState.DisableEdit || pen.locked === LockState.DisableMove || store.data.locked) {
    elem.style.userSelect = "initial";
    elem.style.pointerEvents = "initial";
    if (pen.name === "gif") {
      elem.style.userSelect = "none";
      elem.style.pointerEvents = "none";
    }
  } else {
    elem.style.userSelect = "none";
    elem.style.pointerEvents = "none";
  }
}
function setElemImg(pen, elem) {
  if (!elem) {
    return;
  }
  globalThis.html2canvas && globalThis.html2canvas(elem).then(function(canvas) {
    const img = new Image();
    img.src = canvas.toDataURL("image/png", 0.1);
    if (img.src.length > 10) {
      pen.calculative.img = img;
    }
  });
}
function getPensLock(pens) {
  return pens.every((pen) => pen.locked);
}
function getPensDisableRotate(pens) {
  return pens.every((pen) => pen.disableRotate);
}
function rotatePen(pen, angle, rect) {
  var _a;
  if (pen.type) {
    pen.calculative.worldAnchors.forEach((anchor) => {
      rotatePoint(anchor, angle, rect.center);
    });
    initLineRect(pen);
    calcPenRect(pen);
  } else {
    if (pen.calculative.rotate) {
      pen.calculative.rotate += angle;
    } else {
      pen.calculative.rotate = angle;
    }
    rotatePoint(pen.calculative.worldRect.center, angle, rect.center);
    if (pen.parentId) {
      pen.calculative.worldRect.x = pen.calculative.worldRect.center.x - pen.calculative.worldRect.width / 2;
      pen.calculative.worldRect.y = pen.calculative.worldRect.center.y - pen.calculative.worldRect.height / 2;
      pen.x = (pen.calculative.worldRect.x - rect.x) / rect.width;
      pen.y = (pen.calculative.worldRect.y - rect.y) / rect.height;
    }
  }
  (_a = pen.children) == null ? void 0 : _a.forEach((id) => {
    const child = pen.calculative.canvas.store.pens[id];
    rotatePen(child, angle, rect);
  });
}
function initLineRect(pen) {
  var _a;
  if (!((_a = pen.calculative.worldAnchors) == null ? void 0 : _a.length)) {
    return;
  }
  if (!isFinite(pen.x) || !isFinite(pen.x)) {
    return;
  }
  if (pen.x == null || pen.y == null) {
    return;
  }
  const rect = getLineRect(pen);
  if (!pen.parentId) {
    Object.assign(pen, rect);
  }
  const { fontSize, lineHeight } = pen.calculative.canvas.store.options;
  if (!pen.fontSize) {
    pen.fontSize = fontSize >= 0 ? fontSize : 12;
    pen.calculative.fontSize = pen.fontSize * pen.calculative.canvas.store.data.scale;
  } else if (pen.fontSize < 0) {
    pen.fontSize = 0;
    pen.calculative.fontSize = 0;
  }
  if (!pen.lineHeight) {
    pen.lineHeight = lineHeight;
    pen.calculative.lineHeight = pen.lineHeight;
  }
  calcCenter(rect);
  pen.calculative.worldRect = rect;
  calcPadding(pen, rect);
  calcTextRect(pen);
  if (pen.calculative.worldAnchors) {
    pen.anchors = pen.calculative.worldAnchors.map((pt) => {
      return calcRelativePoint(pt, pen.calculative.worldRect);
    });
  }
}
function getPensDisableResize(pens) {
  return pens.every((pen) => pen.disableSize || pen.pivot);
}
function getFrameValue(pen, prop, frameIndex) {
  if (!pen.frames || !prop) {
    return 0;
  }
  let v = 0;
  for (let i = 0; i < frameIndex; i++) {
    if (pen.frames[i]) {
      v += pen.frames[i][prop] || 0;
    }
  }
  return v;
}
function isShowChild(pen, store) {
  var _a;
  let selfPen = pen;
  while (selfPen && selfPen.parentId) {
    const oldPen = selfPen;
    selfPen = store.pens[selfPen.parentId];
    const showChildIndex = (_a = selfPen == null ? void 0 : selfPen.calculative) == null ? void 0 : _a.showChild;
    if (showChildIndex != void 0) {
      const showChildId = selfPen.children[showChildIndex];
      if (showChildId !== oldPen.id) {
        return false;
      }
    }
  }
  return true;
}
function calcInView(pen, calcChild = false) {
  var _a, _b, _c;
  const { store, canvasRect } = pen.calculative.canvas;
  if (calcChild) {
    (_a = pen.children) == null ? void 0 : _a.forEach((id) => {
      const child = store.pens[id];
      child && calcInView(child, true);
    });
  }
  pen.calculative.inView = true;
  if (!isShowChild(pen, store)) {
    pen.calculative.inView = false;
  } else if (pen.visible == false || pen.calculative.visible == false) {
    pen.calculative.inView = false;
    if ((pen.canvasLayer === CanvasLayer.CanvasImageBottom || pen.canvasLayer === CanvasLayer.CanvasImage) && ((_b = pen.frames) == null ? void 0 : _b.length)) {
      pen.calculative.inView = pen.frames.some((obj) => obj.hasOwnProperty("visible"));
    }
  }
  if (pen.calculative.inView) {
    const { x, y, width, height, rotate } = pen.calculative.worldRect;
    const penRect = {
      x: x + store.data.x,
      y: y + store.data.y,
      width,
      height,
      rotate
    };
    calcRightBottom(penRect);
    if (!rectInRect(penRect, canvasRect)) {
      pen.calculative.inView = false;
    }
  }
  ((_c = pen.calculative.singleton) == null ? void 0 : _c.div) && setElemPosition(pen, pen.calculative.singleton.div);
}
function inspectRect(ctx, store, pen) {
  if (store.fillWorldTextRect) {
    ctx.save();
    ctx.fillStyle = "#c3deb7";
    const { x, y, width, height } = pen.calculative.worldTextRect;
    ctx.fillRect(x, y, width, height);
    ctx.restore();
  }
}
function setGlobalAlpha(ctx, pen) {
  const globalAlpha = pen.calculative.globalAlpha;
  if (typeof globalAlpha === "number" && globalAlpha < 1 && !isNaN(globalAlpha)) {
    ctx.globalAlpha = globalAlpha;
  }
}
function ctxDrawCanvas(ctx, pen) {
  const canvasDraw = drawFuncGenerator(ctx, pen) || globalStore.canvasDraws[pen.name];
  if (canvasDraw) {
    ctx.save();
    canvasDraw(ctx, pen);
    ctx.restore();
  }
}
function drawFuncGenerator(ctx, pen) {
  const drawCommand = pen.drawCommand;
  if (!drawCommand || pen.name === "line")
    return;
  return (ctx2, pen2) => {
    drawCommand.forEach((command) => {
      try {
        command.steps = command.steps.flat(Infinity);
        command.steps.reduce((calculate, step) => {
          const cs = commandTransfer(step, pen2, calculate.x, calculate.y);
          try {
            if (cs.c) {
              if (cs.c.startsWith("_")) {
                const prop = cs.c.split("_")[1];
                if (typeof cs.v.value === "number")
                  cs.v.value *= pen2.calculative.canvas.store.data.scale;
                (cs.p || ctx2)[prop] = cs.v.value;
                return { x: calculate.x, y: calculate.y };
              }
              let l = [];
              for (const csKey in cs.v) {
                l.push(cs.v[csKey]);
              }
              (cs.p || ctx2)[cs.c](...l);
              return { x: cs.startX || cs.v.x, y: cs.startY || cs.v.y };
            }
            return { x: calculate.x, y: calculate.y };
          } catch (e) {
          }
        }, {});
      } catch (e) {
      }
    });
    ctx2.stroke();
  };
}
function commandTransfer(command, pen, startX, startY) {
  var _a;
  const map = {
    "visio": dealWithVisio,
    "dxf": dealWithDXF,
    "canvas": dealWithCanvas
  };
  return ((_a = map[pen.parseType]) == null ? void 0 : _a.call(map, command, pen, startX, startY)) || command;
}
function dealWithDXF(command, pen, startX, startY) {
  const { x, y, width, height } = pen.calculative.worldRect;
  const { originWidth, originHeight } = pen.dxfOrigin;
  switch (command.c) {
    case "beginPath":
      return {
        c: "beginPath",
        v: {}
      };
    case "closePath":
      return {
        c: "closePath",
        v: {}
      };
    case "moveTo":
      return {
        c: "moveTo",
        v: {
          x: command.v.x * (width / originWidth) + x,
          y: command.v.y * (height / originHeight) + y
        }
      };
    case "lineTo":
      return {
        c: "lineTo",
        v: {
          x: command.v.x * (width / originWidth) + x,
          y: command.v.y * (height / originHeight) + y
        }
      };
    case "arc":
      return {
        c: "ellipse",
        v: {
          x: command.v.x * (width / originWidth) + x,
          y: command.v.y * (height / originHeight) + y,
          rx: command.v.xr * (width / originWidth),
          ry: command.v.yr * (height / originHeight),
          rotation: command.v.rotation || 0,
          startAngle: command.v.startAngle,
          endAngle: command.v.endAngle,
          a: command.v.aclockwise ?? true
        }
      };
    case "ellipse":
      return {
        c: "ellipse",
        v: {
          x: command.v.x * (width / originWidth) + x,
          y: command.v.y * (height / originHeight) + y,
          rx: command.v.xr * (width / originWidth),
          ry: command.v.yr * (height / originHeight),
          rotation: command.v.rotation || 0,
          startAngle: command.v.startAngle,
          endAngle: command.v.endAngle,
          a: command.v.aclockwise ?? true
        }
      };
    case "_font":
      return {
        c: "_font",
        v: {
          value: command.v.fontSize * pen.calculative.canvas.store.data.scale + "px " + (command.v.fontFamily || pen.calculative.canvas.store.options.fontFamily)
        }
      };
    case "_fillStyle":
      return {
        c: "_fillStyle",
        v: {
          value: pen.color || command.v.value
        }
      };
    default:
      const c = {
        c: command.c,
        v: {
          ...command.v
        }
      };
      if (c.v.x !== void 0)
        c.v.x = command.v.x * (width / originWidth) + x;
      if (c.v.y !== void 0)
        c.v.y = command.v.y * (height / originHeight) + y;
      return c;
  }
}
function dealWithCanvas(command, pen, startX, startY) {
  const { x, y, width, height } = pen.calculative.worldRect;
  const { originWidth, originHeight } = pen.origin;
  switch (command.c) {
    case "beginPath":
      return {
        c: "beginPath",
        v: {}
      };
    case "closePath":
      return {
        c: "closePath",
        v: {}
      };
    case "moveTo":
      return {
        c: "moveTo",
        v: {
          x: command.v.x * (width / originWidth) + x,
          y: command.v.y * (height / originHeight) + y
        }
      };
    case "lineTo":
      return {
        c: "lineTo",
        v: {
          x: command.v.x * (width / originWidth) + x,
          y: command.v.y * (height / originHeight) + y
        }
      };
    case "arc":
      return {
        c: "ellipse",
        v: {
          x: command.v.x * (width / originWidth) + x,
          y: command.v.y * (height / originHeight) + y,
          rx: command.v.xr * (width / originWidth),
          ry: command.v.yr * (height / originHeight),
          rotation: command.v.rotation || 0,
          startAngle: command.v.startAngle,
          endAngle: command.v.endAngle,
          a: command.v.aclockwise ?? true
        }
      };
    case "ellipse":
      return {
        c: "ellipse",
        v: {
          x: command.v.x * (width / originWidth) + x,
          y: command.v.y * (height / originHeight) + y,
          rx: command.v.xr * (width / originWidth),
          ry: command.v.yr * (height / originHeight),
          rotation: command.v.rotation || 0,
          startAngle: command.v.startAngle,
          endAngle: command.v.endAngle,
          a: command.v.aclockwise ?? true
        }
      };
    case "_font":
      return {
        c: "_font",
        v: {
          value: command.v.fontSize * pen.calculative.canvas.store.data.scale + "px " + (command.v.fontFamily || pen.calculative.canvas.store.options.fontFamily)
        }
      };
    default:
      const c = {
        c: command.c,
        v: {
          ...command.v
        }
      };
      if (c.v.x !== void 0)
        c.v.x = command.v.x * (width / originWidth) + x;
      if (c.v.y !== void 0)
        c.v.y = command.v.y * (height / originHeight) + y;
      return c;
  }
}
function dealWithVisio(command, pen, startX, startY) {
  const { x, y, width, height } = pen.calculative.worldRect;
  const { width: originWidth, height: originHeight } = pen.origin;
  switch (command.c) {
    case "MoveTo":
      return {
        c: "moveTo",
        v: {
          x: +command.v.X * 100 * (width / originWidth) + x,
          y: +command.v.Y * 100 * (height / originHeight) + y
        }
      };
    case "RelMoveTo":
      return {
        c: "moveTo",
        v: {
          x: +command.v.X * originWidth * (width / originWidth) + x,
          y: +command.v.Y * originHeight * (height / originHeight) + y
        }
      };
    case "LineTo":
      return {
        c: "lineTo",
        v: {
          x: +command.v.X * 100 * (width / originWidth) + x,
          y: +command.v.Y * 100 * (height / originHeight) + y
        }
      };
    case "RelLineTo":
      return {
        c: "lineTo",
        v: {
          x: +command.v.X * originWidth * (width / originWidth) + x,
          y: +command.v.Y * originHeight * (height / originHeight) + y
        }
      };
    case "Ellipse":
      let centerX1 = command.v.X;
      let centerY1 = command.v.Y;
      let longAxis = Math.abs(command.v.A - command.v.C);
      let shortAxis = Math.abs(command.v.B - command.v.D);
      return {
        c: "ellipse",
        v: {
          x: centerX1 * 100 * (width / originWidth) + x,
          y: centerY1 * 100 * (height / originHeight) + y,
          radiuX: longAxis * 100 * (width / originWidth),
          radiuY: shortAxis * 100 * (height / originHeight),
          rotation: 0,
          startAngle: 0,
          endAngle: Math.PI * 2,
          anticlockwise: true
        }
      };
    case "EllipticalArcTo":
      const endX = command.v.X * 100 * (width / originWidth) + x;
      const endY = command.v.Y * 100 * (height / originHeight) + y;
      const ctrlX = command.v.A * 100 * (width / originWidth) + x;
      const ctrlY = command.v.B * 100 * (height / originHeight) + y;
      const angleDeg = command.v.C;
      const axisRatio = command.v.D * (width / height) * (originHeight / originWidth);
      const crossProduct = (endX - startX) * (ctrlY - startY) - (endY - startY) * (ctrlX - startX) > 0;
      const params = calculateEllipseParameters(startX, startY, endX, endY, ctrlX, ctrlY, axisRatio);
      !command.orign && (command.orign = {});
      !command.orign.startA && (command.orign.startA = calculateAngleInRadians(params.x0, params.y0, startX, startY));
      !command.orign.endA && (command.orign.endA = calculateAngleInRadians(params.x0, params.y0, endX, endY));
      return {
        c: "ellipse",
        v: {
          centerX: params.x0,
          centerY: params.y0,
          radiuX: params.a,
          radiuY: params.b,
          // rotation:radiansToDegrees(angleDeg),
          rotation: 0,
          startAngle: command.orign.startA,
          endAngle: command.orign.endA,
          // startAngle: 0,
          // endAngle: Math.PI * 2,
          // anticlockwise: startA > 0 && startA>endA
          anticlockwise: crossProduct
          // anticlockwise: Math.abs(endA - startA) < Math.PI
        },
        startX: endX,
        startY: endY
      };
    case "RelEllipticalArcTo":
      const endX3 = command.v.X * originWidth * (width / originWidth) + x;
      const endY3 = command.v.Y * originHeight * (height / originHeight) + y;
      const ctrlX3 = command.v.A * originWidth * (width / originWidth) + x;
      const ctrlY3 = command.v.B * originHeight * (height / originHeight) + y;
      const angleDeg3 = command.v.C;
      const axisRatio3 = command.v.D * (width / height) * (originHeight / originWidth);
      const crossProduct2 = (endX3 - startX) * (ctrlY3 - startY) - (endY3 - startY) * (ctrlX3 - startX) > 0;
      const params2 = calculateEllipseParameters(startX, startY, endX3, endY3, ctrlX3, ctrlY3, axisRatio3);
      !command.orign && (command.orign = {});
      !command.orign.startA && (command.orign.startA = calculateAngleInRadians(params2.x0, params2.y0, startX, startY));
      !command.orign.endA && (command.orign.endA = calculateAngleInRadians(params2.x0, params2.y0, endX3, endY3));
      return {
        c: "ellipse",
        v: {
          centerX: params2.x0,
          centerY: params2.y0,
          radiuX: params2.a,
          radiuY: params2.b,
          // rotation:radiansToDegrees(angleDeg),
          rotation: 0,
          startAngle: command.orign.startA,
          endAngle: command.orign.endA,
          // startAngle: 0,
          // endAngle: Math.PI * 2,
          // anticlockwise: startA > 0 && startA>endA
          anticlockwise: crossProduct2
          // anticlockwise: Math.abs(endA - startA) < Math.PI
        },
        startX: endX3,
        startY: endY3
      };
    case "ArcTo":
      let endX2 = command.v.X * 100 * width / originWidth + x;
      let endY2 = command.v.Y * 100 * height / originHeight + y;
      let h = command.v.A * 100 * (width / height) * (originHeight / originWidth);
      let xm = (startX + endX2) / 2;
      let ym = (startY + endY2) / 2;
      let d = Math.sqrt((endX2 - startX) ** 2 + (endY2 - startY) ** 2);
      let R = d ** 2 / (8 * h) + h / 2;
      let ux = -(endY2 - startY) / d;
      let uy = (endX2 - startX) / d;
      let xc1 = xm + ux * R;
      let yc1 = ym + uy * R;
      let xc2 = xm - ux * R;
      let yc2 = ym - uy * R;
      let xc = xc1;
      let yc = yc1;
      let startAngle = Math.atan2(startY - yc, startX - xc);
      let endAngle = Math.atan2(endY2 - yc, endX2 - xc);
      return {
        c: "arc",
        v: {
          x: xc,
          y: yc,
          radius: R,
          startAngle,
          endAngle,
          aclockwise: true
        }
      };
    default:
      const cloneCommand = deepClone(command);
      Object.entries(cloneCommand.v).forEach(([k, v]) => {
        var _a, _b;
        if ((_a = k.endsWith) == null ? void 0 : _a.call(k, "_x")) {
          if (typeof v === "number")
            cloneCommand.v[k] = v * (width / originWidth) + x;
        } else if ((_b = k.endsWith) == null ? void 0 : _b.call(k, "_y")) {
          if (typeof v === "number")
            cloneCommand.v[k] = v * (height / originHeight) + y;
        } else {
          if (typeof v === "number")
            cloneCommand.v[k] = v;
        }
      });
      return cloneCommand;
  }
}
function setChildValue(pen, data) {
  for (const k in data) {
    if (inheritanceProps.includes(k)) {
      if (k == "fontSize" && data[k] < 0) {
        data[k] = 0;
      }
      pen[k] = data[k];
      if (["fontSize", "lineWidth"].includes(k)) {
        pen.calculative[k] = data[k] * pen.calculative.canvas.store.data.scale;
        calcTextRect(pen);
      } else {
        pen.calculative[k] = data[k];
      }
    }
  }
  if (pen.calculative.canvas.parent.isCombine(pen)) {
    const children = pen.children;
    children == null ? void 0 : children.forEach((childId) => {
      let _data = deepClone(data);
      if (pen.calculative.childrenVisible) {
        if (pen.calculative.childrenVisible[childId] === false) {
          delete _data.visible;
        }
      }
      const child = pen.calculative.canvas.store.pens[childId];
      child && setChildValue(child, _data);
    });
  }
}
function calculateEllipseParameters(x1, y1, x2, y2, x3, y3, D) {
  let numeratorX0 = (x1 - x2) * (x1 + x2) * (y2 - y3) - (x2 - x3) * (x2 + x3) * (y1 - y2) + D * D * (y1 - y2) * (y2 - y3) * (y1 - y3);
  let denominatorX0 = 2 * ((x1 - x2) * (y2 - y3) - (x2 - x3) * (y1 - y2));
  let x0 = numeratorX0 / denominatorX0;
  let numeratorY0 = (x1 - x2) * (x2 - x3) * (x1 - x3) + D * D * ((x2 - x3) * (y1 - y2) * (y1 + y2) - (x1 - x2) * (y2 - y3) * (y2 + y3));
  let denominatorY0 = 2 * D * D * ((x2 - x3) * (y1 - y2) - (x1 - x2) * (y2 - y3));
  let y0 = numeratorY0 / denominatorY0;
  let a = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(D * (y1 - y0), 2));
  let b = a / D;
  return { x0, y0, a, b };
}
function calculateAngleInRadians(x1, y1, x2, y2) {
  let dx = x2 - x1;
  let dy = y2 - y1;
  let angleRadians = Math.atan2(dy, dx);
  if (angleRadians < 0) {
    angleRadians += 2 * Math.PI;
  }
  return angleRadians;
}

// node_modules/@meta2d/core/src/pen/math.js
function calcAnchorDock(store, e, curAnchor) {
  let xDock;
  let yDock;
  let x = Infinity;
  let y = Infinity;
  const size = 8;
  for (const pen of store.data.pens) {
    if (pen.calculative.inView === false) {
      continue;
    }
    const points = getPointsByPen(pen);
    points.forEach((pt) => {
      if (pt === e || pt === curAnchor) {
        return;
      }
      let distance2 = (pen.calculative.worldRect.center.x - e.x) * (pen.calculative.worldRect.center.x - e.x) + (pen.calculative.worldRect.center.y - e.y) * (pen.calculative.worldRect.center.y - e.y);
      const disX = Math.abs(pt.x - e.x);
      if (disX > 0 && disX < size && distance2 < x) {
        xDock = {
          x: Math.round(pt.x) + 0.5,
          y: Math.round(pt.y) + 0.5,
          prev: {
            x: Math.round(e.x) + 0.5,
            y: Math.round(e.y) + 0.5
          },
          step: pt.x - e.x
        };
        x = distance2;
      }
      const disY = Math.abs(pt.y - e.y);
      if (disY > 0 && disY < size && distance2 < y) {
        yDock = {
          x: Math.round(pt.x) + 0.5,
          y: Math.round(pt.y) + 0.5,
          prev: {
            x: Math.round(e.x) + 0.5,
            y: Math.round(e.y) + 0.5
          },
          step: pt.y - e.y
        };
        y = distance2;
      }
    });
  }
  return {
    xDock,
    yDock
  };
}
function calcMoveDock(store, rect, pens, offset) {
  let activePoints = [];
  if (pens.length === 1) {
    activePoints = deepClone(getPointsByPen(pens[0]));
    activePoints.forEach((point) => {
      point.x += offset.x;
      point.y += offset.y;
    });
  } else {
    calcCenter(rect);
    activePoints = [rect.center, ...rectToPoints(rect)];
  }
  return calcDockByPoints(store, activePoints, rect, true);
}
function getPointsByPen(pen) {
  if (!pen.type) {
    const outerPoints = rectToPoints(pen.calculative.worldRect);
    calcCenter(pen.calculative.worldRect);
    return [
      ...pen.calculative.worldAnchors,
      ...outerPoints,
      pen.calculative.worldRect.center
    ];
  } else if (pen.type === PenType.Line) {
    return pen.calculative.worldAnchors;
  }
}
function calcResizeDock(store, rect, pens, resizeIndex) {
  const activePoints = rectToPoints(rect);
  return calcDockByPoints(store, activePoints, rect);
}
function calcDockByPoints(store, activePoints, rect, calcActive = false) {
  let xDock;
  let yDock;
  let minCloseX = Infinity;
  let minCloseY = Infinity;
  const closeSize = 10;
  const paddingRect = expandRect(rect, closeSize);
  store.data.pens.forEach((pen) => {
    const { inView, worldRect, active } = pen.calculative;
    if (inView === false || !calcActive && active || // 
    rectInFourAngRect(paddingRect, worldRect) || //  
    pen.type && store.active.some((active2) => isConnectLine(store, active2, pen))) {
      return;
    }
    const points = getPointsByPen(pen);
    if (!points) {
      return;
    }
    for (const point of points) {
      for (const activePoint of activePoints) {
        const stepX = point.x - activePoint.x;
        const stepY = point.y - activePoint.y;
        const absStepX = Math.abs(stepX);
        const absStepY = Math.abs(stepY);
        if (!rect.center) {
          rect.center = {
            x: rect.x + rect.width / 2,
            y: rect.y + rect.height / 2
          };
        }
        if (absStepX < closeSize && absStepX < minCloseX) {
          xDock = {
            x: Math.round(point.x) + 0.5,
            y: Math.round(point.y) + 0.5,
            step: stepX,
            prev: {
              x: Math.round(activePoint.x) + 0.5,
              y: Math.round(activePoint.y) + 0.5
            },
            penId: pen.id,
            anchorId: activePoint.id,
            dockAnchorId: point.id
          };
          minCloseX = absStepX;
        }
        if (absStepY < closeSize && absStepY < minCloseY) {
          yDock = {
            x: Math.round(point.x) + 0.5,
            y: Math.round(point.y) + 0.5,
            step: stepY,
            prev: {
              x: Math.round(activePoint.x) + 0.5,
              y: Math.round(activePoint.y) + 0.5
            },
            penId: pen.id,
            anchorId: activePoint.id,
            dockAnchorId: point.id
          };
          minCloseY = absStepY;
        }
      }
    }
  });
  return {
    xDock,
    yDock
  };
}
function isConnectLine(store, active, line2) {
  if (!line2.type) {
    return false;
  }
  if (Array.isArray(active == null ? void 0 : active.connectedLines)) {
    for (const cline of active == null ? void 0 : active.connectedLines) {
      if (cline.lineId === line2.id) {
        return true;
      }
    }
  }
  if (Array.isArray(active == null ? void 0 : active.children)) {
    for (const id of active.children) {
      const child = store.pens[id];
      if (isConnectLine(store, child, line2)) {
        return true;
      }
    }
  }
  return false;
}
function isEqual(source, target) {
  return source.toFixed(12) == target;
}

// node_modules/@meta2d/core/src/pen/utils.js
function randomId(pen) {
  pen.id = s8();
  if (Array.isArray(pen.anchors)) {
    for (const pt of pen.anchors) {
      pen.type && (pt.id = s8());
      pt.penId = pen.id;
      if (pt.prev) {
        pen.type && (pt.prev.id = s8());
        pt.prev.penId = pen.id;
      }
      if (pt.next) {
        pen.type && (pt.next.id = s8());
        pt.next.penId = pen.id;
      }
    }
  }
}

// node_modules/@meta2d/core/src/pen/plugin.js
function rewritePenLifeCycle() {
  let funcMap = null;
  let funcPenMap = /* @__PURE__ */ new Map();
  return (pen, lifeCycle, func, del = false) => {
    if (funcPenMap.has(pen) && funcPenMap.get(pen)) {
      funcMap = funcPenMap.get(pen);
    } else {
      funcPenMap.set(pen, funcMap = /* @__PURE__ */ new Map());
    }
    if (typeof func !== "function")
      return () => {
        console.warn("[rewritePenLifeCycle] warn: not a function ");
      };
    let funcListSet = /* @__PURE__ */ new Set();
    let originFuncMap = /* @__PURE__ */ new Map();
    if (funcMap.has(lifeCycle) && funcMap.get(lifeCycle)) {
      funcListSet = funcMap.get(lifeCycle);
    } else {
      originFuncMap.set(lifeCycle, pen[lifeCycle]);
      funcMap.set(lifeCycle, funcListSet);
    }
    if (del) {
      funcListSet.delete(func);
    } else {
      funcListSet.add(func);
    }
    let originLifeCycle = originFuncMap.get(lifeCycle);
    let rewriteFunc = (...args) => {
      originLifeCycle == null ? void 0 : originLifeCycle(...args);
      funcListSet.forEach((i) => {
        i(...args);
      });
    };
    pen[lifeCycle] = rewriteFunc;
  };
}
var setLifeCycleFunc = rewritePenLifeCycle();
function validationPlugin(plugin) {
  if (!plugin.name && !plugin.install) {
    console.error("installPenPlugin Error: Validation Failed");
    return false;
  }
  return true;
}

// node_modules/@meta2d/core/src/rect/rect.js
function pointInRect(pt, rect) {
  if (!rect) {
    return;
  }
  if (rect.ex == null) {
    calcRightBottom(rect);
  }
  if (!rect.rotate || // rect.width < 20 ||
  // rect.height < 20 ||
  rect.rotate % 360 === 0) {
    return pt.x > rect.x && pt.x < rect.ex && pt.y > rect.y && pt.y < rect.ey;
  }
  if (!rect.center) {
    calcCenter(rect);
  }
  const pts = [
    { x: rect.x, y: rect.y },
    { x: rect.ex, y: rect.y },
    { x: rect.ex, y: rect.ey },
    { x: rect.x, y: rect.ey }
  ];
  pts.forEach((item) => {
    rotatePoint(item, rect.rotate, rect.pivot || rect.center);
  });
  return pointInVertices(pt, pts);
}
function pointInSimpleRect(pt, rect, r = 0) {
  const { x, y, ex, ey } = rect;
  return pt.x >= x - r && pt.x <= ex + r && pt.y >= y - r && pt.y <= ey + r;
}
function calcCenter(rect) {
  if (!rect.center) {
    rect.center = {};
  }
  rect.center.x = rect.x + rect.width / 2;
  rect.center.y = rect.y + rect.height / 2;
}
function calcRightBottom(rect) {
  rect.ex = rect.x + rect.width;
  rect.ey = rect.y + rect.height;
}
function calcPivot(rect, pivot) {
  if (!rect.pivot) {
    rect.pivot = {};
  }
  rect.pivot.x = rect.x + rect.width * pivot.x;
  rect.pivot.y = rect.y + rect.height * pivot.y;
}
function pointInVertices(point, vertices) {
  if (vertices.length < 3) {
    return false;
  }
  let isIn = false;
  let last = vertices[vertices.length - 1];
  for (const item of vertices) {
    if (last.y > point.y !== item.y > point.y) {
      if (item.x + (point.y - item.y) * (last.x - item.x) / (last.y - item.y) > point.x) {
        isIn = !isIn;
      }
    }
    last = item;
  }
  return isIn;
}
function getRect2(pens) {
  const points = [];
  pens.forEach((pen) => {
    if (pen.isRuleLine) {
      return;
    }
    const rect2 = pen.calculative.worldRect;
    if (rect2) {
      const pts = rectToPoints(rect2);
      points.push(...pts);
    }
  });
  const rect = getRectOfPoints(points);
  calcCenter(rect);
  return rect;
}
function rectToPoints(rect) {
  const pts = [
    { x: rect.x, y: rect.y },
    { x: rect.ex, y: rect.y },
    { x: rect.ex, y: rect.ey },
    { x: rect.x, y: rect.ey }
  ];
  if (rect.rotate) {
    if (!rect.center) {
      calcCenter(rect);
    }
    pts.forEach((pt) => {
      rotatePoint(pt, rect.rotate, rect.pivot || rect.center);
    });
  }
  return pts;
}
function getRectOfPoints(points) {
  let x = Infinity;
  let y = Infinity;
  let ex = -Infinity;
  let ey = -Infinity;
  points == null ? void 0 : points.forEach((item) => {
    if (!isFinite(item.x) || !isFinite(item.y)) {
      return;
    }
    x = Math.min(x, item.x);
    y = Math.min(y, item.y);
    ex = Math.max(ex, item.x);
    ey = Math.max(ey, item.y);
  });
  return { x, y, ex, ey, width: ex - x, height: ey - y };
}
function rectInRect(source, target, allIn) {
  if (source.rotate) {
    source = getRectOfPoints(rectToPoints(source));
  }
  if (allIn) {
    return source.x > target.x && source.ex < target.ex && source.y > target.y && source.ey < target.ey;
  }
  return !(source.x > target.ex || source.ex < target.x || source.ey < target.y || source.y > target.ey);
}
function rectInFourAngRect(source, target) {
  return (target.x > source.ex || target.ex < source.x) && (target.y > source.ey || target.ey < source.y);
}
function expandRect(rect, size) {
  const padding = formatPadding(size);
  const retRect = {
    x: rect.x - padding[3],
    y: rect.y - padding[0],
    width: rect.width + padding[1] + padding[3],
    height: rect.height + padding[0] + padding[2]
  };
  calcRightBottom(retRect);
  return retRect;
}
function translateRect(rect, x, y) {
  rect.x += x;
  rect.y += y;
  rect.ex += x;
  rect.ey += y;
  if (rect.center) {
    rect.center.x += x;
    rect.center.y += y;
  }
  if (rect.pivot) {
    rect.pivot.x += x;
    rect.pivot.y += y;
  }
}
function getIntersectPoint(line1, line2) {
  const k1 = (line1.to.y - line1.from.y) / (line1.to.x - line1.from.x);
  const k2 = (line2.to.y - line2.from.y) / (line2.to.x - line2.from.x);
  return getIntersectPointByK({
    k: k1,
    point: line1.from
  }, {
    k: k2,
    point: line2.from
  });
}
function getIntersectPointByK(line1, line2) {
  if (isEqual(line1.k, 0)) {
    return {
      x: line2.point.x,
      y: line1.point.y
    };
  } else if (isEqual(line2.k, 0)) {
    return {
      x: line1.point.x,
      y: line2.point.y
    };
  }
  const b1 = line1.point.y - line1.k * line1.point.x;
  const b2 = line2.point.y - line2.k * line2.point.x;
  const x = (b2 - b1) / (line1.k - line2.k);
  const y = line1.k * x + b1;
  return {
    x,
    y
  };
}
function pointsToRect(pts, rotate) {
  const center = getIntersectPoint({
    from: pts[0],
    to: pts[2]
  }, {
    from: pts[1],
    to: pts[3]
  });
  for (const pt of pts) {
    rotatePoint(pt, -rotate, center);
  }
  return getRectOfPoints(pts);
}
function resizeRect(rect, offsetX, offsetY, resizeIndex) {
  let calcRotate2 = rect.rotate ? rect.rotate % 360 : 0;
  if (calcRotate2) {
    const pts = rectToPoints(rect);
    const k1 = (pts[0].y - pts[1].y) / (pts[0].x - pts[1].x);
    const k2 = (pts[1].y - pts[2].y) / (pts[1].x - pts[2].x);
    if (resizeIndex < 4) {
      pts[resizeIndex].x += offsetX;
      if (rect.ratio) {
        if (resizeIndex === 0 || resizeIndex === 2) {
          let calcOffsetY = offsetX * Math.tan((90 - (360 - calcRotate2) - Math.atan(rect.width / rect.height) / Math.PI * 180) / 180 * Math.PI);
          pts[resizeIndex].y += calcOffsetY;
        } else {
          let calcOffsetY = offsetX * Math.tan((90 - (360 - calcRotate2) + Math.atan(rect.width / rect.height) / Math.PI * 180) / 180 * Math.PI);
          pts[resizeIndex].y += calcOffsetY;
        }
      } else {
        pts[resizeIndex].y += offsetY;
      }
      const noChangePoint = pts[(resizeIndex + 2) % 4];
      pts[(resizeIndex + 1) % 4] = getIntersectPointByK({ k: resizeIndex % 2 ? k2 : k1, point: pts[resizeIndex] }, { k: resizeIndex % 2 ? k1 : k2, point: noChangePoint });
      pts[(resizeIndex + 4 - 1) % 4] = getIntersectPointByK({ k: resizeIndex % 2 ? k1 : k2, point: pts[resizeIndex] }, { k: resizeIndex % 2 ? k2 : k1, point: noChangePoint });
    } else {
      const k = [4, 6].includes(resizeIndex) ? k2 : k1;
      if (!isEqual(k, 0)) {
        pts[resizeIndex % 4].y += offsetY;
        pts[resizeIndex % 4].x += offsetY / k;
        pts[(resizeIndex + 1) % 4].y += offsetY;
        pts[(resizeIndex + 1) % 4].x += offsetY / k;
      } else {
        pts[resizeIndex % 4].x += offsetX;
        pts[(resizeIndex + 1) % 4].x += offsetX;
      }
    }
    if ((pts[0].x - pts[1].x) ** 2 + (pts[0].y - pts[1].y) ** 2 < 25 || (pts[1].x - pts[2].x) ** 2 + (pts[1].y - pts[2].y) ** 2 < 25) {
      return;
    }
    const retRect = pointsToRect(pts, rect.rotate);
    calcCenter(retRect);
    Object.assign(rect, retRect);
    return;
  }
  switch (resizeIndex) {
    case 0:
      if (rect.width - offsetX < 5 || rect.height - offsetY < 5) {
        break;
      }
      rect.x += offsetX;
      rect.y += offsetY;
      rect.width -= offsetX;
      rect.height -= offsetY;
      break;
    case 1:
      if (rect.width + offsetX < 5 || rect.height - offsetY < 5) {
        break;
      }
      rect.ex += offsetX;
      rect.y += offsetY;
      rect.width += offsetX;
      rect.height -= offsetY;
      break;
    case 2:
      if (rect.width + offsetX < 5 || rect.height + offsetY < 5) {
        break;
      }
      rect.ex += offsetX;
      rect.ey += offsetY;
      rect.width += offsetX;
      rect.height += offsetY;
      break;
    case 3:
      if (rect.width - offsetX < 5 || rect.height + offsetY < 5) {
        break;
      }
      rect.x += offsetX;
      rect.ey += offsetY;
      rect.width -= offsetX;
      rect.height += offsetY;
      break;
    case 4:
      if (rect.height - offsetY < 5) {
        break;
      }
      rect.y += offsetY;
      rect.height -= offsetY;
      break;
    case 5:
      if (rect.width + offsetX < 5) {
        break;
      }
      rect.ex += offsetX;
      rect.width += offsetX;
      break;
    case 6:
      if (rect.height + offsetY < 5) {
        break;
      }
      rect.ey += offsetY;
      rect.height += offsetY;
      break;
    case 7:
      if (rect.width - offsetX < 5) {
        break;
      }
      rect.x += offsetX;
      rect.width -= offsetX;
      break;
  }
}
function scaleRect(rect, scale, center, pivot) {
  if (!rect) {
    return;
  }
  rect.width *= scale;
  rect.height *= scale;
  scalePoint(rect, scale, center);
  calcRightBottom(rect);
  calcCenter(rect);
  if (pivot) {
    calcPivot(rect, pivot);
  }
}
function calcRelativeRect(rect, worldRect) {
  const relRect = {
    x: (rect.x - worldRect.x) / worldRect.width,
    y: (rect.y - worldRect.y) / worldRect.height,
    width: rect.width / worldRect.width,
    height: rect.height / worldRect.height
  };
  calcRightBottom(relRect);
  return relRect;
}
function calcRelativePoint(pt, worldRect) {
  const { x, y, width, height } = worldRect;
  const { penId, connectTo } = pt;
  const point = Object.assign({}, pt, {
    x: width ? (pt.x - x) / width : 0,
    y: height ? (pt.y - y) / height : 0
  });
  if (pt.prev) {
    point.prev = {
      penId,
      connectTo,
      x: width ? (pt.prev.x - x) / width : 0,
      y: height ? (pt.prev.y - y) / height : 0
    };
  }
  if (pt.next) {
    point.next = {
      penId,
      connectTo,
      x: width ? (pt.next.x - x) / width : 0,
      y: height ? (pt.next.y - y) / height : 0
    };
  }
  return point;
}
function pointInPolygon(pt, pts) {
  let inside = false;
  for (let i = 0, j = pts.length - 1; i < pts.length; j = i++) {
    let xi = pts[i].x, yi = pts[i].y;
    let xj = pts[j].x, yj = pts[j].y;
    let intersect = yi > pt.y != yj > pt.y && pt.x < (xj - xi) * (pt.y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}

// node_modules/@meta2d/core/src/point/point.js
var PrevNextType;
(function(PrevNextType2) {
  PrevNextType2[PrevNextType2["Mirror"] = 0] = "Mirror";
  PrevNextType2[PrevNextType2["Bilateral"] = 1] = "Bilateral";
  PrevNextType2[PrevNextType2["Free"] = 2] = "Free";
})(PrevNextType || (PrevNextType = {}));
var TwoWay;
(function(TwoWay2) {
  TwoWay2[TwoWay2["Default"] = 0] = "Default";
  TwoWay2[TwoWay2["In"] = 1] = "In";
  TwoWay2[TwoWay2["Out"] = 2] = "Out";
  TwoWay2[TwoWay2["DisableConnected"] = 3] = "DisableConnected";
  TwoWay2[TwoWay2["DisableConnectTo"] = 4] = "DisableConnectTo";
  TwoWay2[TwoWay2["Disable"] = 10] = "Disable";
})(TwoWay || (TwoWay = {}));
var PointType;
(function(PointType2) {
  PointType2[PointType2["Default"] = 0] = "Default";
  PointType2[PointType2["Line"] = 1] = "Line";
})(PointType || (PointType = {}));
function rotatePoint(pt, angle, center) {
  if (!angle || angle % 360 === 0) {
    return;
  }
  const a = angle * Math.PI / 180;
  const x = (pt.x - center.x) * Math.cos(a) - (pt.y - center.y) * Math.sin(a) + center.x;
  const y = (pt.x - center.x) * Math.sin(a) + (pt.y - center.y) * Math.cos(a) + center.y;
  pt.x = x;
  pt.y = y;
  pt.prev && rotatePoint(pt.prev, angle, center);
  pt.next && rotatePoint(pt.next, angle, center);
}
function hitPoint(pt, target, radius = 5, pen) {
  if (target.type === PointType.Line) {
    let _rotate = pen.rotate;
    if (pen.flipX) {
      _rotate *= -1;
    }
    if (pen.flipY) {
      _rotate *= -1;
    }
    let rotate = target.rotate + _rotate;
    if (pen.flipX) {
      rotate *= -1;
    }
    if (pen.flipY) {
      rotate *= -1;
    }
    return pointInRect(pt, {
      x: target.x - target.length * pen.calculative.canvas.store.data.scale / 2,
      y: target.y - radius,
      width: target.length * pen.calculative.canvas.store.data.scale,
      height: radius * 2,
      rotate
    });
  } else {
    return pt.x > target.x - radius && pt.x < target.x + radius && pt.y > target.y - radius && pt.y < target.y + radius;
  }
}
function scalePoint(pt, scale, center) {
  pt.x = center.x - (center.x - pt.x) * scale;
  pt.y = center.y - (center.y - pt.y) * scale;
}
function calcRotate(pt, center) {
  if (pt.x === center.x) {
    return pt.y <= center.y ? 0 : 180;
  }
  if (pt.y === center.y) {
    return pt.x < center.x ? 270 : 90;
  }
  const x = pt.x - center.x;
  const y = pt.y - center.y;
  let angle = Math.atan(Math.abs(x / y)) / (2 * Math.PI) * 360;
  if (x > 0 && y > 0) {
    angle = 180 - angle;
  } else if (x < 0 && y > 0) {
    angle += 180;
  } else if (x < 0 && y < 0) {
    angle = 360 - angle;
  }
  return angle;
}
function distance(pt1, pt2) {
  const x = pt1.x - pt2.x;
  const y = pt1.y - pt2.y;
  return Math.sqrt(x * x + y * y);
}
function facePoint(pt, targetPt) {
  let d = Direction.None;
  if (!targetPt) {
    return d;
  }
  const disX = pt.x - targetPt.x;
  const disY = pt.y - targetPt.y;
  if (Math.abs(disX) > Math.abs(disY)) {
    if (disX > 0) {
      d = Direction.Right;
    } else {
      d = Direction.Left;
    }
  } else {
    if (disY > 0) {
      d = Direction.Bottom;
    } else {
      d = Direction.Up;
    }
  }
  return d;
}
function translatePoint(pt, x, y) {
  if (!pt) {
    return;
  }
  pt.x += x;
  pt.y += y;
  if (pt.next) {
    pt.next.x += x;
    pt.next.y += y;
  }
  if (pt.prev) {
    pt.prev.x += x;
    pt.prev.y += y;
  }
}
function samePoint(pt1, pt2) {
  return pt1.anchorId === pt2.anchorId && pt1.connectTo === pt2.connectTo;
}
function getDistance(form2, to, store) {
  let dis = Math.sqrt((form2.x - to.x) * (form2.x - to.x) + (form2.y - to.y) * (form2.y - to.y)) / store.data.scale;
  if (to.rotate === 0) {
    if (form2.x < to.x) {
      if (!store.pens[to.penId].flipX) {
        dis *= -1;
      }
    } else {
      if (store.pens[to.penId].flipX) {
        dis *= -1;
      }
    }
  } else {
    if (form2.y < to.y) {
      if (!store.pens[to.penId].flipY) {
        dis *= -1;
      }
    } else {
      if (store.pens[to.penId].flipY) {
        dis *= -1;
      }
    }
  }
  form2.distance = dis;
}

export {
  rectangle,
  PenType,
  LockState,
  AnchorMode,
  Gradient,
  CanvasLayer,
  needCalcTextRectProps,
  needSetPenProps,
  needPatchFlagsPenRectProps,
  needCalcIconRectProps,
  LineAnimateType,
  isDomShapes,
  isInteraction,
  formatAttrs,
  clearLifeCycle,
  HoverType,
  HotkeyType,
  MouseRight,
  Direction,
  defaultCursors,
  rotatedCursors,
  defaultDrawLineFns,
  inheritanceProps,
  PrevNextType,
  TwoWay,
  PointType,
  rotatePoint,
  hitPoint,
  scalePoint,
  calcRotate,
  distance,
  facePoint,
  translatePoint,
  samePoint,
  getDistance,
  globalStore,
  register,
  registerCanvasDraw,
  registerAnchors,
  KeydownType,
  defaultOptions,
  themeKeys,
  defaultTheme,
  le5leTheme,
  EditType,
  createStore,
  useStore,
  clearStore,
  calcTextRect,
  calcTextDrawRect,
  calcTextLines,
  getWords,
  wrapLines,
  calcTextAdaptionWidth,
  calcTextAutoWidth,
  deepClone,
  deepSetValue,
  pSBCr,
  pSBC,
  rgba,
  abs,
  valueInRange,
  valueInArray,
  s4,
  s8,
  s12,
  s16,
  formatPadding,
  fileToBase64,
  uploadFile,
  loadCss,
  queryURLParams,
  getRootDomain,
  getCookie,
  TokenType,
  getToken,
  getMeta2dData,
  getter,
  setter,
  formatTime,
  isAncestor,
  getParent,
  getAllChildren,
  getAllFollowers,
  getGradientAnimatePath,
  drawImage,
  getTextColor,
  drawIcon,
  drawDropdown,
  getFont,
  ctxFlip,
  ctxRotate,
  renderPen,
  setLineCap,
  setLineJoin,
  renderPenRaw2 as renderPenRaw,
  ctxDrawPath,
  ctxDrawLinePath,
  setCtxLineAnimate,
  getGlobalColor,
  renderLineAnchors,
  renderAnchor,
  calcWorldRects,
  calcPadding,
  calcPenRect,
  calcWorldAnchors,
  calcChildrenInitRect,
  calcWorldPointOfPen,
  calcIconRect,
  scalePen,
  scaleChildrenInitRect,
  pushPenAnchor,
  addLineAnchor,
  removePenAnchor,
  facePen,
  nearestAnchor,
  translateLine,
  deleteTempAnchor,
  connectLine,
  disconnectLine,
  getAnchor,
  getFromAnchor,
  getToAnchor,
  setNodeAnimate,
  initPrevFrame,
  setNodeAnimateProcess,
  setLineAnimate,
  setChildrenActive,
  setHover,
  setElemPosition,
  setElemImg,
  getPensLock,
  getPensDisableRotate,
  rotatePen,
  getPensDisableResize,
  getFrameValue,
  isShowChild,
  calcInView,
  setGlobalAlpha,
  setChildValue,
  calcAnchorDock,
  calcMoveDock,
  getPointsByPen,
  calcResizeDock,
  isEqual,
  randomId,
  setLifeCycleFunc,
  validationPlugin,
  pointInRect,
  pointInSimpleRect,
  calcCenter,
  calcRightBottom,
  calcPivot,
  pointInVertices,
  getRect2 as getRect,
  rectToPoints,
  getRectOfPoints,
  rectInRect,
  rectInFourAngRect,
  expandRect,
  translateRect,
  resizeRect,
  scaleRect,
  calcRelativeRect,
  calcRelativePoint,
  pointInPolygon,
  parseSvgPath,
  getRect as getRect2,
  EventAction,
  Meta2d
};
//# sourceMappingURL=chunk-PFF6Q7CQ.js.map
