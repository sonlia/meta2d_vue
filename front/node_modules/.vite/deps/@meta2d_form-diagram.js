import "./chunk-RDEAKAAS.js";
import {
  calcRightBottom,
  calcTextLines,
  calcTextRect,
  deepClone,
  getFont,
  getTextColor,
  pSBC
} from "./chunk-PFF6Q7CQ.js";
import "./chunk-USJHI7ER.js";

// node_modules/@meta2d/form-diagram/src/table.js
function table(ctx, pen) {
  if (!pen.onAdd) {
    pen.onAdd = onAdd;
    pen.onMouseMove = onMouseMove;
    pen.onMouseLeave = onMouseLeave;
    pen.onMouseDown = onMouseDown;
    pen.onShowInput = onShowInput;
    pen.onInput = onInput;
    pen.onValue = onValue;
    pen.onBeforeValue = beforeValue;
  }
  const data = pen.calculative.canvas.store.data;
  const options = pen.calculative.canvas.store.options;
  pen.color = pen.color || data.color || options.color;
  pen.activeColor = pen.activeColor || options.activeColor;
  pen.hoverColor = pen.hoverColor || options.hoverColor;
  pen.activeBackground = pen.activeBackground || options.activeBackground;
  pen.hoverBackground = pen.hoverBackground || options.hoverBackground;
  drawGridLine(ctx, pen);
  drawCell(ctx, pen);
}
function initRect(pen) {
  const colPos = [];
  const rowPos = [];
  if (!pen.table.rowHeight) {
    pen.table.rowHeight = 40;
  }
  if (!pen.table.colWidth) {
    pen.table.colWidth = 150;
  }
  let width = 0;
  for (const item of pen.table.header.data) {
    width += item.width || pen.table.colWidth;
    colPos.push(width);
  }
  let height = 0;
  if (pen.table.header.show != false) {
    height += pen.table.header.height || pen.table.rowHeight;
    rowPos.push(height);
  }
  for (const item of pen.table.data) {
    height += item.height || pen.table.rowHeight;
    rowPos.push(height);
  }
  pen.colPos = colPos;
  pen.rowPos = rowPos;
  pen.tableWidth = width;
  pen.tableHeight = height;
  if (!pen.width) {
    pen.width = width;
    pen.height = height;
    pen.calculative.width = width;
    pen.calculative.height = height;
    pen.calculative.worldRect = {
      x: pen.x,
      y: pen.y,
      height: pen.height,
      width: pen.width
    };
    calcRightBottom(pen.calculative.worldRect);
  }
}
function drawGridLine(ctx, pen) {
  if (!pen.colPos) {
    return;
  }
  const worldRect = pen.calculative.worldRect;
  ctx.save();
  ctx.strokeStyle = pen.color;
  ctx.beginPath();
  ctx.rect(worldRect.x, worldRect.y, worldRect.width, worldRect.height);
  if (pen.background) {
    ctx.fillStyle = pen.background;
    ctx.fill();
  }
  ctx.stroke();
  let last = pen.rowPos[pen.rowPos.length - 1];
  for (const item of pen.rowPos) {
    if (item === last) {
      continue;
    }
    const y = item * pen.calculative.worldRect.height / pen.tableHeight;
    ctx.beginPath();
    ctx.moveTo(pen.calculative.worldRect.x, pen.calculative.worldRect.y + y);
    ctx.lineTo(pen.calculative.worldRect.ex, pen.calculative.worldRect.y + y);
    ctx.stroke();
  }
  last = pen.colPos[pen.colPos.length - 1];
  pen.colPos.forEach((item, i) => {
    if (item === last) {
      return;
    }
    const x = item * pen.calculative.worldRect.width / pen.tableWidth;
    ctx.beginPath();
    ctx.moveTo(pen.calculative.worldRect.x + x, pen.calculative.worldRect.y);
    ctx.lineTo(pen.calculative.worldRect.x + x, pen.calculative.worldRect.ey);
    ctx.stroke();
  });
  ctx.restore();
}
function drawCell(ctx, pen) {
  var _a, _b, _c, _d;
  if (!pen.colPos) {
    return;
  }
  if (!pen.calculative.texts) {
    pen.calculative.texts = [];
  }
  const textScale = 1;
  for (let i = 0; i < pen.rowPos.length; i++) {
    for (let j = 0; j < pen.colPos.length; j++) {
      let cell = getCell(pen, i, j);
      let color = cell.color || pen.color;
      let background = cell.background;
      let activeColor;
      if (((_a = pen.calculative.activeCell) == null ? void 0 : _a.row) === i && ((_b = pen.calculative.activeCell) == null ? void 0 : _b.col) === j) {
        color = pen.activeColor;
        background = pen.activeBackground;
        activeColor = color;
      }
      if (((_c = pen.calculative.hoverCell) == null ? void 0 : _c.row) === i && ((_d = pen.calculative.hoverCell) == null ? void 0 : _d.col) === j) {
        color = pen.hoverColor;
        background = pen.hoverBackground;
        activeColor = color;
      }
      const rect = getCellRect(pen, i, j);
      if (background) {
        ctx.save();
        ctx.fillStyle = background;
        ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
        ctx.restore();
      }
      if (activeColor) {
        ctx.save();
        ctx.strokeStyle = activeColor;
        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
        ctx.restore();
      }
      pen.calculative.worldTextRect = rect;
      let rowText = pen.calculative.texts[i];
      if (!pen.calculative.texts[i]) {
        rowText = [];
        pen.calculative.texts.push(rowText);
      }
      if (rowText[j] == null) {
        if (Array.isArray(cell)) {
          rowText[j] = "";
          if (!cell[0].id) {
            calcChildrenRect(pen, rect, cell);
            pen.calculative.canvas.parent.pushChildren(pen, cell);
          }
          continue;
        } else {
          rowText[j] = cell.text || cell + "";
        }
        if (!rowText[j]) {
          continue;
        }
        rowText[j] = calcTextLines(pen, rowText[j]);
      }
      if (!rowText[j]) {
        continue;
      }
      ctx.save();
      ctx.fillStyle = color;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = (pen.calculative.fontStyle || "") + " normal " + (pen.calculative.fontWeight || "") + " " + (pen.calculative.fontSize || 12) * textScale + "px " + pen.calculative.fontFamily;
      if (rowText[j].length === 1) {
        ctx.fillText(rowText[j][0], rect.x + rect.width / 2, rect.y + rect.height / 2);
      } else {
        const y = 0.55;
        const lineHeight = pen.calculative.fontSize * pen.calculative.lineHeight * textScale;
        const h = rowText[j].length * lineHeight;
        let top = (rect.height - h) / 2;
        rowText[j].forEach((text, i2) => {
          ctx.fillText(text, rect.x + rect.width / 2, rect.y + top + (i2 + y) * lineHeight);
        });
      }
      ctx.restore();
    }
  }
}
function onAdd(pen) {
  initRect(pen);
}
function onShowInput(pen, e) {
  if (!pen.calculative.hoverCell) {
    return;
  }
  const cell = getCell(pen, pen.calculative.hoverCell.row, pen.calculative.hoverCell.col);
  if (Array.isArray(cell)) {
    return;
  }
  pen.calculative.inputCell = pen.calculative.hoverCell;
  const rect = getCellRect(pen, pen.calculative.hoverCell.row, pen.calculative.hoverCell.col);
  pen.calculative.tempText = cell.text || cell + "";
  pen.calculative.canvas.showInput(pen, rect, "#ffffff");
}
function onInput(pen, text) {
  if (!pen.calculative.inputCell) {
    return;
  }
  setCellText(pen, pen.calculative.inputCell.row, pen.calculative.inputCell.col, text);
  pen.calculative.canvas.render();
}
function onMouseMove(pen, e) {
  pen.calculative.hoverCell = getCellIndex(pen, e);
  pen.calculative.canvas.render();
}
function onMouseLeave(pen, e) {
  pen.calculative.hoverCell = void 0;
  pen.calculative.canvas.render();
}
function onMouseDown(pen, e) {
  pen.calculative.activeCell = getCellIndex(pen, e);
  pen.calculative.canvas.render();
}
function getCellIndex(pen, e) {
  const scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  const scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  const pos = { row: 0, col: 0 };
  for (let i = 0; i < pen.colPos.length; i++) {
    if (e.x > pen.calculative.worldRect.x + pen.colPos[i] * scaleX) {
      pos.col = i + 1;
    }
  }
  for (let i = 0; i < pen.rowPos.length; i++) {
    if (e.y > pen.calculative.worldRect.y + pen.rowPos[i] * scaleY) {
      pos.row = i + 1;
    }
  }
  return pos;
}
function getCell(pen, rowIndex, colIndex) {
  if (!pen.table.data || !Array.isArray(pen.table.data)) {
    return;
  }
  if (pen.table.header.show == false) {
    const row2 = pen.table.data[rowIndex];
    if (Array.isArray(row2)) {
      return row2[colIndex];
    } else if (!row2.data || !Array.isArray(row2.data)) {
      return;
    }
    return row2.data[colIndex];
  }
  if (rowIndex === 0) {
    const cell = pen.table.header.data[colIndex];
    cell.fontWeight = pen.table.header.fontWeight;
    return cell;
  }
  const row = pen.table.data[rowIndex - 1];
  if (!row) {
    return;
  } else if (Array.isArray(row)) {
    return row[colIndex];
  } else if (!row.data || !Array.isArray(row.data)) {
    return;
  }
  return row.data[colIndex];
}
function setCellText(pen, rowIndex, colIndex, text) {
  if (!pen.table.data || !Array.isArray(pen.table.data)) {
    return;
  }
  pen.calculative.texts = void 0;
  let rowData;
  if (pen.table.header.show == false) {
    rowData = pen.table.data[rowIndex];
    if (Array.isArray(rowData)) {
    } else if (rowData.data && Array.isArray(rowData.data)) {
      rowData = rowData.data;
    }
  } else {
    if (rowIndex === 0) {
      rowData = pen.table.header.data;
    } else {
      rowData = pen.table.data[rowIndex - 1];
      if (Array.isArray(rowData)) {
      } else if (rowData.data && Array.isArray(rowData.data)) {
        rowData = rowData.data;
      }
    }
  }
  if (!rowData) {
    return;
  }
  if (rowData[colIndex] instanceof Object) {
    rowData[colIndex].text = text;
  } else {
    rowData[colIndex] = text;
  }
  pen.calculative.canvas.store.emitter.emit("valueUpdate", pen);
}
function getCellRect(pen, rowIndex, colIndex) {
  const scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  const scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  let x = 0;
  let ex = pen.colPos[colIndex] * scaleX;
  if (colIndex > 0) {
    x = pen.colPos[colIndex - 1] * scaleX;
  }
  let y = 0;
  let ey = pen.rowPos[rowIndex] * scaleY;
  if (rowIndex > 0) {
    y = pen.rowPos[rowIndex - 1] * scaleY;
  }
  return {
    x: pen.calculative.worldRect.x + x,
    y: pen.calculative.worldRect.y + y,
    ex: pen.calculative.worldRect.x + ex,
    ey: pen.calculative.worldRect.y + ey,
    width: ex - x,
    height: ey - y
  };
}
function calcChildrenRect(pen, rect, children) {
  const scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  const scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  let height = 0;
  let lastX = 0;
  let lastY = 0;
  for (const item of children) {
    if (lastX + item.width * scaleX + 20 * scaleX < rect.width) {
      item.x = rect.x + lastX + 10 * scaleX;
      item.y = rect.y + lastY + 10 * scaleY;
      lastX += (item.width + 10) * scaleX;
      height = Math.max(height, lastY + (item.height + 10) * scaleY);
    } else {
      lastX = 0;
      lastY = height;
      item.x = rect.x + lastX + 10 * scaleX;
      item.y = rect.y + lastY + 10 * scaleY;
      height += (item.height + 10) * scaleY;
    }
  }
  if (height + 20 * scaleY < rect.height) {
    const top = (rect.height - height - 10 * scaleY) / 2;
    for (const item of children) {
      item.y += top;
    }
  }
}
function onValue(pen) {
  pen.calculative.texts = void 0;
}
function beforeValue(pen, value) {
  if (value.table || value.col == void 0 && value.row == void 0) {
    return value;
  }
  setCellText(pen, value.row, value.col, value.value);
  pen.calculative.canvas.render();
  delete value.col;
  delete value.row;
  return value;
}

// node_modules/@meta2d/form-diagram/src/common.js
var ReplaceMode;
(function(ReplaceMode2) {
  ReplaceMode2[ReplaceMode2["Add"] = 0] = "Add";
  ReplaceMode2[ReplaceMode2["Replace"] = 1] = "Replace";
  ReplaceMode2[ReplaceMode2["ReplaceAll"] = 2] = "ReplaceAll";
})(ReplaceMode || (ReplaceMode = {}));
function getTextLength(text, pen) {
  const textScale = pen.calculative.worldRect.height * 14 / 16;
  const chinese = text.match(/[\u4e00-\u9fa5]/g) || "";
  const chineseLen = chinese.length;
  const width = (text.length - chineseLen) * textScale * 0.6 + chineseLen * textScale;
  return width;
}
function initOptions(pen) {
  if (pen.direction == "horizontal") {
    const optionPos = [];
    let textLength = 0;
    const h = pen.height;
    pen.checkboxHeight = h;
    pen.options.forEach((item, index) => {
      optionPos.push(index * (40 + h) + textLength);
      textLength += getTextLength(item.text, pen);
    });
    pen.optionPos = optionPos;
    const width = optionPos.length * (40 + h) + textLength;
    pen.checkboxWidth = width;
    pen.width = width;
    pen.calculative.width = width;
    pen.calculative.worldRect = {
      x: pen.x,
      y: pen.y,
      height: pen.height,
      width: pen.width,
      center: {
        x: pen.x + pen.width / 2,
        y: pen.y + pen.height / 2
      }
    };
    calcRightBottom(pen.calculative.worldRect);
  } else if (pen.direction == "vertical") {
    if (pen.optionInterval == void 0) {
      pen.optionInterval = 20;
    }
    if (!pen.optionHeight) {
      pen.optionHeight = 20;
    }
    const optionPos = [];
    pen.options.forEach((item, index) => {
      optionPos.push(index * (pen.optionInterval + pen.optionHeight));
    });
    pen.optionPos = optionPos;
    const height = optionPos[optionPos.length - 1] + pen.optionHeight;
    pen.checkboxHeight = height;
    if (!pen.width) {
      pen.height = height;
      pen.calculative.height = height;
      pen.calculative.worldRect = {
        x: pen.x,
        y: pen.y,
        height: pen.height,
        width: pen.width,
        center: {
          x: pen.x + pen.width / 2,
          y: pen.y + pen.height / 2
        }
      };
      calcRightBottom(pen.calculative.worldRect);
    }
  }
}

// node_modules/@meta2d/form-diagram/src/table2.js
function table2(ctx, pen) {
  if (!pen.onAdd) {
    pen.onAdd = onAdd2;
    if (!pen.rowPos || !pen.colPos || !pen.calculative.maxOffsetY) {
      pen.onAdd(pen);
    }
    pen.onMouseMove = onMouseMove2;
    pen.onMouseLeave = onMouseLeave2;
    pen.onMouseDown = onMouseDown2;
    pen.onShowInput = onShowInput2;
    pen.onInput = onInput2;
    pen.onValue = onValue2;
    pen.onBeforeValue = beforeValue2;
    pen.onMouseEnter = onMouseEnter;
    pen.onWheel = onWheel;
    pen.onDestroy = onDestroy;
  }
  if (pen.data.length !== pen.rowPos.length) {
    pen.initWorldRect = null;
    pen.calculative.isUpdateData = true;
    pen.onValue(pen);
  }
  if (pen.data[0].length !== pen.colPos.length) {
    pen.initWorldRect = null;
    pen.calculative.isUpdateData = true;
    pen.onValue(pen);
  }
  const data = pen.calculative.canvas.store.data;
  const options = pen.calculative.canvas.store.options;
  pen.color = pen.color || data.color || options.color;
  pen.textColor = pen.textColor || pen.color || data.textColor || options.textColor;
  pen.activeColor = pen.activeColor || options.activeColor;
  pen.hoverColor = pen.hoverColor || options.hoverColor;
  pen.activeBackground = pen.activeBackground || options.activeBackground;
  pen.hoverBackground = pen.hoverBackground || options.hoverBackground;
  if (!pen.hasHeader) {
    ctx.save();
    ctx.beginPath();
    const { x, y, width, height } = pen.calculative.worldRect;
    ctx.fillStyle = "#fff0";
    ctx.rect(x - 1, y - 1, width + 2, height + 2);
    ctx.fill();
    ctx.clip();
  }
  drawGridLine2(ctx, pen);
  drawCell2(ctx, pen);
  drawNote(ctx, pen);
  ctx.restore();
  pen.isFirstTime = false;
}
function drawNote(ctx, pen) {
  if (!pen.calculative.hover) {
    return;
  }
  if (!pen.calculative.hoverCell) {
    return;
  }
  if (pen.calculative.isInput) {
    return;
  }
  if (!pen.calculative.isHover) {
    return;
  }
  let rect = pen.calculative.worldRect;
  let mousePos = pen.calculative.canvas.mousePos;
  if (!(mousePos.x > rect.x && mousePos.x < rect.x + rect.width && mousePos.y > rect.y && mousePos.y < rect.y + rect.height)) {
    pen.calculative.hover = false;
    pen.calculative.isHover = false;
    pen.calculative.hoverCell = void 0;
    return;
  }
  const { row, col } = pen.calculative.hoverCell;
  const { x, y } = pen.calculative.canvas.mousePos;
  if (!pen.data[row]) {
    return;
  }
  let text = pen.data[row][col];
  if (typeof text === "object" || !text) {
    return;
  }
  ctx.save();
  ctx.beginPath();
  ctx.textAlign = "start";
  ctx.textBaseline = "middle";
  ctx.font = ctx.font = (pen.calculative.fontStyle || "") + " normal " + (pen.calculative.fontWeight || "") + " " + (pen.calculative.fontSize || 12) + "px " + pen.calculative.fontFamily;
  const noteWidth = ctx.measureText(text).width;
  ctx.beginPath();
  ctx.fillStyle = "#fff";
  ctx.strokeStyle = "#000";
  ctx.moveTo(x, y);
  ctx.rect(x - 10, y, noteWidth + 20, 20);
  ctx.fill();
  ctx.stroke();
  ctx.beginPath();
  ctx.fillStyle = "#000";
  ctx.fillText(text, x, y + 10);
  ctx.restore();
}
function initRect2(pen) {
  const colPos = [];
  const rowPos = [];
  const colStyle = {};
  if (!pen.rowHeight) {
    pen.rowHeight = 40;
  }
  if (!pen.colWidth) {
    pen.colWidth = 150;
  }
  let width = 0;
  const _col = pen.styles && pen.styles.filter((item) => {
    return item.col !== void 0 && item.row === void 0 && item.width;
  });
  let _colWidthMap = {};
  _col && _col.forEach((_c) => {
    _colWidthMap[_c.col] = _c.width;
  });
  for (let i = 0; i < pen.data[0].length; i++) {
    width += (_colWidthMap[i] || pen.colWidth) * pen.calculative.canvas.store.data.scale;
    colPos.push(width);
    let style = pen.styles && pen.styles.filter((item) => {
      return item.col === i && item.row === void 0;
    });
    if (style) {
      colStyle[i] = style[0];
    }
  }
  let height = 0;
  const _row = pen.styles && pen.styles.filter((item) => {
    return item.col === void 0 && item.row !== void 0 && item.height;
  });
  let _rowHeightMap = {};
  _row && _row.forEach((_r) => {
    _rowHeightMap[_r.row] = _r.height;
  });
  let finalHight = height;
  for (let j = 0; j < pen.data.length; j++) {
    height += (_rowHeightMap[j] || pen.rowHeight) * pen.calculative.canvas.store.data.scale;
    rowPos.push(height);
    if (j < pen.maxNum) {
      finalHight = height;
    }
  }
  pen.calculative.maxOffsetY = (height - finalHight) / pen.calculative.canvas.store.data.scale;
  if (pen.initWorldRect) {
    return;
  }
  pen.colPos = colPos;
  pen.rowPos = rowPos;
  pen.colStyle = colStyle;
  pen.initScale = pen.calculative.canvas.store.data.scale;
  pen.tableWidth = width;
  pen.tableHeight = finalHight || height;
  pen.calculative.width = width;
  pen.calculative.height = finalHight || height;
  pen.calculative.width = width;
  pen.calculative.height = finalHight || height;
  if (!pen.height) {
    pen.height = pen.calculative.height;
  }
  if (!pen.width) {
    pen.width = pen.calculative.width;
  }
  let x = pen.x;
  let y = pen.y;
  if (pen.parentId) {
    let parentPen = pen.calculative.canvas.store.pens[pen.parentId];
    x = parentPen.calculative.worldRect.x + parentPen.calculative.worldRect.width * pen.x;
    y = parentPen.calculative.worldRect.y + parentPen.calculative.worldRect.height * pen.y;
  }
  pen.calculative.worldRect = {
    x,
    y,
    height: pen.calculative.height,
    width: pen.calculative.width,
    center: {
      x: pen.x + pen.calculative.width / 2,
      y: pen.y + pen.calculative.height / 2
    }
  };
  pen.width = pen.calculative.width;
  pen.height = pen.calculative.height;
  if (!pen.initWorldRect) {
    pen.initWorldRect = {
      width: pen.calculative.worldRect.width,
      height: pen.calculative.worldRect.height
    };
  }
  calcRightBottom(pen.calculative.worldRect);
}
function drawGridLine2(ctx, pen) {
  if (!pen.colPos) {
    return;
  }
  const { x, y, width, height, ex, ey } = pen.calculative.worldRect;
  ctx.save();
  ctx.beginPath();
  ctx.strokeStyle = pen.color;
  let wr = pen.calculative.borderRadius || 0, hr = wr;
  if (wr < 1) {
    wr = width * wr;
    hr = height * hr;
  }
  let r = wr < hr ? wr : hr;
  if (width < 2 * r) {
    r = width / 2;
  }
  if (height < 2 * r) {
    r = height / 2;
  }
  ctx.moveTo(x + r, y);
  ctx.arcTo(ex, y, ex, ey, r);
  ctx.arcTo(ex, ey, x, ey, r);
  ctx.arcTo(x, ey, x, y, r);
  ctx.arcTo(x, y, ex, y, r);
  if (pen.background) {
    ctx.fillStyle = pen.background;
    ctx.fill();
  }
  if (pen.bordered !== false) {
    ctx.strokeStyle = pen.borderColor || "#424B61";
    ctx.stroke();
  }
  if (pen.hLine !== false) {
    let last = pen.rowPos[pen.rowPos.length - 1];
    if (pen.hasHeader) {
      ctx.beginPath();
      ctx.moveTo(pen.calculative.worldRect.x, pen.calculative.worldRect.y + pen.rowPos[0] * pen.calculative.worldRect.height / pen.tableHeight);
      ctx.lineTo(pen.calculative.worldRect.ex, pen.calculative.worldRect.y + pen.rowPos[0] * pen.calculative.worldRect.height / pen.tableHeight);
      ctx.strokeStyle = pen.borderColor || "#424B61";
      ctx.stroke();
    }
    for (const item of pen.rowPos) {
      if (item === last) {
        continue;
      }
      const y2 = item * pen.calculative.worldRect.height / pen.tableHeight - pen.offsetY * pen.calculative.canvas.store.data.scale;
      if (pen.hasHeader) {
        if (y2 < 0 + pen.rowPos[0] || y2 > pen.calculative.worldRect.height) {
          continue;
        }
      } else {
        if (y2 < 0 || y2 > pen.calculative.worldRect.height) {
          continue;
        }
      }
      ctx.beginPath();
      ctx.moveTo(pen.calculative.worldRect.x, pen.calculative.worldRect.y + y2);
      ctx.lineTo(pen.calculative.worldRect.ex, pen.calculative.worldRect.y + y2);
      ctx.strokeStyle = pen.borderColor || "#424B61";
      ctx.stroke();
    }
  }
  if (pen.vLine !== false) {
    let last = pen.colPos[pen.colPos.length - 1];
    pen.colPos.forEach((item, i) => {
      if (item === last) {
        return;
      }
      const x2 = item * pen.calculative.worldRect.width / pen.tableWidth;
      ctx.beginPath();
      ctx.moveTo(pen.calculative.worldRect.x + x2, pen.calculative.worldRect.y);
      ctx.lineTo(pen.calculative.worldRect.x + x2, pen.calculative.worldRect.ey);
      ctx.strokeStyle = pen.borderColor || "#424B61";
      ctx.stroke();
    });
  }
  ctx.restore();
}
function drawCell2(ctx, pen) {
  var _a, _b, _c, _d, _e;
  if (!pen.colPos) {
    return;
  }
  if (!pen.calculative.texts) {
    pen.calculative.texts = [];
  }
  const textScale = 1;
  for (let i = 0; i < pen.rowPos.length; i++) {
    if (pen.hasHeader && i === 1) {
      ctx.save();
      ctx.beginPath();
      const { x, y, width, height } = pen.calculative.worldRect;
      ctx.fillStyle = "#fff0";
      ctx.rect(x - 1, y + pen.rowPos[0] * pen.calculative.worldRect.height / pen.tableHeight - 1, width + 2, height - pen.rowPos[0] * pen.calculative.worldRect.height / pen.tableHeight + 2);
      ctx.fill();
      ctx.clip();
    }
    let { style: rowStyle } = getRow(pen, i);
    for (let j = 0; j < pen.colPos.length; j++) {
      let { value: cell, style: cellStyle } = getCell2(pen, i, j);
      let isSuccess = true;
      if (Array.isArray(cellStyle) && cellStyle.length > 0) {
        let successIdx = 0;
        cellStyle.forEach((item, idx) => {
          if (item.wheres) {
            let success = item.wheres.every((where) => {
              const fn = new Function("attr", `return attr ${where.comparison} ${where.value}`);
              return fn(cell);
            });
            if (success) {
              successIdx = idx;
            }
          }
        });
        cellStyle = cellStyle[successIdx];
      } else {
        if (cellStyle.wheres && Array.isArray(cellStyle.wheres)) {
          isSuccess = false;
          isSuccess = cellStyle.wheres.every(function(where) {
            const fn = new Function("attr", `return attr ${where.comparison} ${where.value}`);
            return fn(cell);
          });
        }
      }
      let color = pen.color;
      let textColor = pen.textColor || pen.color;
      let background = null;
      let fontSize = null;
      let fontWeight = null;
      let fontStyle = null;
      if (isSuccess) {
        color = cellStyle.color || rowStyle.color || pen.color;
        textColor = cellStyle.textColor || rowStyle.textColor || pen.textColor;
        background = cellStyle.background || rowStyle.background;
        fontSize = (cellStyle.fontSize || rowStyle.fontSize || 0) * pen.calculative.canvas.store.data.scale;
        fontWeight = cellStyle.fontWeight || rowStyle.fontWeight;
        fontStyle = cellStyle.fontStyle || rowStyle.fontStyle;
      }
      let activeColor;
      if (pen.stripe) {
        if (pen.hasHeader !== false) {
          if (i % 2 === 1) {
            background = background || pen.stripeColor || "#407FFF1F";
          }
        } else {
          if (i % 2 === 0) {
            background = background || pen.stripeColor || "#407FFF1F";
          }
        }
      }
      if (pen.calculative.active && ((_a = pen.calculative.activeCell) == null ? void 0 : _a.row) === i && ((_b = pen.calculative.activeCell) == null ? void 0 : _b.col) === j) {
        color = pen.activeColor;
        background = pen.activeBackground;
        activeColor = color;
        textColor = pen.activeTextColor || pen.activeColor;
      }
      if (pen.calculative.hover && ((_c = pen.calculative.hoverCell) == null ? void 0 : _c.row) === i && ((_d = pen.calculative.hoverCell) == null ? void 0 : _d.col) === j) {
        color = pen.hoverColor;
        background = pen.hoverBackground;
        textColor = pen.hoverTextColor || pen.hoverColor;
        activeColor = color;
      }
      const rect = getCellRect2(pen, i, j);
      if (rect.y + rect.height < pen.calculative.worldRect.y || rect.y > pen.calculative.worldRect.height + pen.calculative.worldRect.y) {
        continue;
      }
      if (background) {
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = background;
        ctx.fillRect(rect.x, rect.y, rect.width + 0.25 * pen.calculative.canvas.store.data.scale, rect.height);
        ctx.restore();
      }
      if (activeColor) {
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = activeColor;
        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
        ctx.restore();
      }
      pen.calculative.worldTextRect = rect;
      let rowText = pen.calculative.texts[i];
      if (!pen.calculative.texts[i]) {
        rowText = [];
        pen.calculative.texts.push(rowText);
      }
      if (rowText[j] == null) {
        if (typeof cell === "object") {
          const _colPen = pen.styles && pen.styles.filter((item) => {
            return item.col === j && item.row === void 0 && item.pens;
          });
          if (_colPen.length > 0) {
            rowText[j] = "";
            if (pen.isFirstTime) {
              if (pen.maxNum) {
                if (pen.hasHeader && i >= pen.maxNum) {
                  cell.visible = false;
                }
              }
              let childrenPen = JSON.parse(JSON.stringify(_colPen[0].pens));
              childrenPen.forEach((item) => {
                Object.assign(item, { row: i, col: j }, cell);
                item.activeBackground = item.background;
                item.hoverBackground = item.background;
                item.activeColor = item.color;
                item.hoverColor = item.color;
                item.activeTextColor = item.textColor;
                item.hoverTextColor = item.textColor;
                item.height *= pen.calculative.canvas.store.data.scale;
                item.width *= pen.calculative.canvas.store.data.scale;
              });
              calcChildrenRect2(pen, rect, childrenPen);
              pen.calculative.canvas.parent.pushChildren(pen, childrenPen);
            }
            continue;
          }
        } else if (cell === void 0) {
          rowText[j] = "";
        } else {
          rowText[j] = cell.text || cell + "";
        }
        if (!rowText[j]) {
          continue;
        }
        rowText[j] = calcTextLines(pen, rowText[j]);
      }
      if (!rowText[j]) {
        continue;
      }
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = textColor;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = (fontStyle || pen.calculative.fontStyle || "") + " normal " + (fontWeight || pen.calculative.fontWeight || "") + " " + (fontSize || pen.calculative.fontSize || 12) * textScale + "px " + pen.calculative.fontFamily;
      let textAlign = pen.colStyle && ((_e = pen.colStyle[j]) == null ? void 0 : _e.textAlign);
      if (textAlign) {
        ctx.textAlign = textAlign;
      }
      if (rowText[j].length === 1) {
        if (textAlign === "left") {
          ctx.fillText(rowText[j][0], rect.x, rect.y + rect.height / 2);
        } else if (textAlign === "right") {
          ctx.fillText(rowText[j][0], rect.x + rect.width, rect.y + rect.height / 2);
        } else {
          ctx.fillText(rowText[j][0], rect.x + rect.width / 2, rect.y + rect.height / 2);
        }
      } else {
        const y = 0.55;
        const lineHeight = (fontSize || pen.calculative.fontSize) * pen.calculative.lineHeight * textScale;
        const h = rowText[j].length * lineHeight;
        let top = (rect.height - h) / 2;
        if (textAlign === "left") {
          rowText[j].forEach((text, i2) => {
            ctx.fillText(text, rect.x, rect.y + top + (i2 + y) * lineHeight);
          });
        } else if (textAlign === "right") {
          rowText[j].forEach((text, i2) => {
            ctx.fillText(text, rect.x + rect.width, rect.y + top + (i2 + y) * lineHeight);
          });
        } else {
          rowText[j].forEach((text, i2) => {
            ctx.fillText(text, rect.x + rect.width / 2, rect.y + top + (i2 + y) * lineHeight);
          });
        }
      }
      ctx.restore();
    }
  }
}
function onAdd2(pen) {
  var _a;
  createInterval(pen);
  if (!((_a = pen.children) == null ? void 0 : _a.length)) {
    pen.isFirstTime = true;
  }
  if (!pen.offsetY) {
    pen.offsetY = 0;
  }
  initRect2(pen);
}
function onShowInput2(pen, e) {
  if (!pen.calculative.hoverCell) {
    return;
  }
  const { value: cell } = getCell2(pen, pen.calculative.hoverCell.row, pen.calculative.hoverCell.col);
  if (typeof cell === "object") {
    return;
  }
  pen.calculative.isHover = false;
  pen.calculative.isInput = true;
  pen.calculative.canvas.render();
  pen.calculative.inputCell = pen.calculative.hoverCell;
  const rect = getCellRect2(pen, pen.calculative.hoverCell.row, pen.calculative.hoverCell.col);
  pen.calculative.tempText = cell.text || cell + "";
  pen.calculative.canvas.showInput(pen, rect, "#ffffff");
}
function onInput2(pen, text) {
  if (!pen.calculative.inputCell) {
    return;
  }
  setCellText2(pen, pen.calculative.inputCell.row, pen.calculative.inputCell.col, text);
  pen.calculative.isInput = false;
  pen.calculative.isHover = true;
  pen.calculative.canvas.render();
}
function onMouseMove2(pen, e) {
  if (pen.timer) {
    pen.calculative.isHover = false;
    clearTimeout(pen.timer);
  }
  pen.timer = setTimeout(() => {
    pen.calculative.isHover = true;
    pen.calculative.canvas.render();
  }, 500);
  pen.calculative.hoverCell = getCellIndex2(pen, e);
  pen.calculative.canvas.render();
}
function onMouseLeave2(pen, e) {
  createInterval(pen);
  pen.calculative.hoverCell = void 0;
  pen.calculative.canvas.render();
}
function onMouseDown2(pen, e) {
  pen.calculative.activeCell = getCellIndex2(pen, e);
  pen.calculative.canvas.render();
}
function getCellIndex2(pen, e) {
  const scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  const scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  const pos = { row: 0, col: 0 };
  for (let i = 0; i < pen.colPos.length; i++) {
    if (e.x > pen.calculative.worldRect.x + pen.colPos[i] * scaleX) {
      pos.col = i + 1;
    }
  }
  for (let i = 0; i < pen.rowPos.length; i++) {
    if (e.y > pen.calculative.worldRect.y + pen.rowPos[i] * scaleY - pen.offsetY * pen.calculative.canvas.store.data.scale) {
      pos.row = i + 1;
    }
  }
  return pos;
}
function getCell2(pen, rowIndex, colIndex) {
  if (!pen.data || !Array.isArray(pen.data)) {
    return;
  }
  const row = pen.data[rowIndex];
  const style = pen.styles && pen.styles.filter((item) => {
    return item.row === rowIndex && item.col === colIndex;
  });
  if (Array.isArray(row)) {
    return { value: row[colIndex], style: (style == null ? void 0 : style.length) > 0 ? style.length > 1 ? style : style[0] : {} };
  } else if (!row.data || !Array.isArray(row.data)) {
    return;
  }
}
function getRow(pen, rowIndex) {
  if (!pen.data || !Array.isArray(pen.data)) {
    return;
  }
  const row = pen.data[rowIndex];
  const style = pen.styles && pen.styles.filter((item) => {
    return item.row === rowIndex && item.col === void 0;
  });
  if (Array.isArray(row)) {
    return { value: row, style: (style == null ? void 0 : style.length) > 0 ? style[0] : {} };
  } else if (!row.data || !Array.isArray(row.data)) {
    return;
  }
}
function setCellText2(pen, rowIndex, colIndex, text) {
  if (!pen.data || !Array.isArray(pen.data)) {
    return;
  }
  pen.isFirstTime = false;
  pen.calculative.texts = void 0;
  let rowData = pen.data[rowIndex];
  if (!rowData) {
    return;
  }
  if (rowData[colIndex] instanceof Object) {
  } else {
    rowData[colIndex] = text;
  }
  pen.calculative.canvas.store.emitter.emit("valueUpdate", pen);
}
function getCellRect2(pen, rowIndex, colIndex) {
  const scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  const scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  let x = 0;
  let ex = pen.colPos[colIndex] * scaleX;
  if (colIndex > 0) {
    x = pen.colPos[colIndex - 1] * scaleX;
  }
  let y = 0;
  let ey = pen.rowPos[rowIndex] * scaleY;
  if (rowIndex > 0) {
    y = pen.rowPos[rowIndex - 1] * scaleY;
  }
  let offset = pen.offsetY * pen.calculative.canvas.store.data.scale;
  if (rowIndex === 0 && pen.hasHeader) {
    offset = 0;
  }
  return {
    x: pen.calculative.worldRect.x + x,
    y: pen.calculative.worldRect.y + y - offset,
    ex: pen.calculative.worldRect.x + ex,
    ey: pen.calculative.worldRect.y + ey - offset,
    width: ex - x,
    height: ey - y
  };
}
function calcChildrenRect2(pen, rect, children) {
  if (!(children && children.length)) {
    return;
  }
  const scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  const scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  let resizeX = 1;
  let resizeY = 1;
  if (pen.initWorldRect) {
    if (pen.calculative.worldRect.width !== pen.initWorldRect.width) {
      resizeX = pen.calculative.worldRect.width / pen.initWorldRect.width;
    }
    if (pen.calculative.worldRect.height !== pen.initWorldRect.height) {
      resizeY = pen.calculative.worldRect.height / pen.initWorldRect.height;
    }
  }
  let height = 0;
  let lastX = 0;
  let lastY = 0;
  const scale = pen.calculative.canvas.store.data.scale;
  if (children.length > 1) {
    for (const item of children) {
      if (lastX + item.width * scaleX + 20 * scale * scaleX < rect.width) {
        item.x = rect.x + lastX + 10 * scale * scaleX;
        item.y = rect.y + lastY + 10 * scale * scaleY;
        lastX += (item.width + 10 * scale) * scaleX;
        height = Math.max(height, lastY + (item.height + 10 * scale) * scaleY);
      } else {
        lastX = 0;
        lastY = height;
        item.x = rect.x + lastX + 10 * scale * scaleX;
        item.y = rect.y + lastY + 10 * scale * scaleY;
        height += (item.height + 10 * scale) * scaleY;
      }
    }
    if (height + 20 * scale * scaleY < rect.height) {
      const top = (rect.height - height - 10 * scale * scaleY) / 2;
      for (const item of children) {
        item.y += top;
      }
    }
  } else {
    children[0].x = rect.x + (rect.width - children[0].width) / 2;
    children[0].y = rect.y + (rect.height - children[0].height) / 2;
  }
  children.forEach((item) => {
    item.width = item.width * resizeX;
    item.height = item.height * resizeY;
  });
}
function onValue2(pen) {
  if (pen.calculative.isUpdateData) {
    delete pen.calculative.isUpdateData;
    let temChildren = deepClone(pen.children);
    pen.children = [];
    onAdd2(pen);
    temChildren && temChildren.forEach((child) => {
      pen.calculative.canvas.delForce(pen.calculative.canvas.findOne(child));
    });
    pen.calculative.texts = void 0;
  }
}
function beforeValue2(pen, value) {
  pen.calculative.isUpdateData = false;
  if (pen.swiper !== void 0) {
    if (pen.swiper) {
      createInterval(pen);
    } else {
      delInterval(pen);
    }
  }
  if (value.styles) {
    pen.initWorldRect = void 0;
  }
  if (value.table || value.col == void 0 && value.row == void 0) {
    if (value.dataY) {
      const replaceMode = pen.replaceMode;
      let data = [];
      if (!replaceMode) {
        data = pen.data.concat(value.dataY);
      } else if (replaceMode === ReplaceMode.Replace) {
        data = pen.data;
        value.dataX && value.dataX.forEach((item, index) => {
          data[item] = value.dataY[index];
        });
      } else if (replaceMode === ReplaceMode.ReplaceAll) {
        if (value.dataX) {
          data[0] = value.dataX;
        } else {
          data[0] = pen.data[0];
        }
        data = data.concat(value.dataY);
      }
      delete value.dataX;
      delete value.dataY;
      pen.calculative.isUpdateData = true;
      return Object.assign(value, { data });
    }
    if (value.data || value.styles || value.maxNum || value.rowHeight || value.colWidth) {
      pen.calculative.isUpdateData = true;
      pen.initWorldRect = null;
    }
    for (let key of Object.keys(value)) {
      if (key.includes("data.")) {
        pen.calculative.isUpdateData = true;
      }
    }
    return value;
  }
  let rowData = pen.data[value.row];
  if (!rowData) {
    return value;
  }
  if (rowData[value.col] instanceof Object) {
  } else {
    rowData[value.col] = value.value;
  }
  setCellText2(pen, value.row, value.col, value.value);
  pen.calculative.canvas.render();
  delete value.col;
  delete value.row;
  return value;
}
function onWheel(pen, e) {
  if (!pen.locked && !pen.calculative.canvas.store.data.locked) {
    return;
  }
  if (!pen.maxNum) {
    return;
  }
  let offset = 0;
  if (e.deltaY > 0) {
    offset = 4;
  } else {
    offset = -4;
  }
  scroll(pen, offset);
}
function scroll(pen, offset) {
  var _a;
  if (!pen.offsetY) {
    pen.offsetY = 0;
  }
  pen.offsetY += offset;
  if (pen.offsetY > pen.calculative.maxOffsetY) {
    pen.offsetY = pen.calculative.maxOffsetY;
  }
  if (pen.offsetY < 0) {
    pen.offsetY = 0;
  }
  (_a = pen.children) == null ? void 0 : _a.forEach((item) => {
    const _pen = pen.calculative.canvas.store.pens[item];
    changeChildVisible(pen, _pen);
  });
  pen.calculative.canvas.render();
}
function changeChildVisible(pen, _pen) {
  if (!_pen) {
    return;
  }
  if (!_pen.oldY) {
    _pen.oldY = _pen.y;
  }
  const { y, height } = _pen.calculative.worldRect;
  const { y: penY, height: penH } = pen.calculative.worldRect;
  const scale = pen.calculative.canvas.store.data.scale;
  const scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  const rowHeight = pen.rowHeight;
  _pen.y = _pen.oldY - pen.offsetY * scale / pen.calculative.worldRect.height;
  const oldOffset = rowHeight * (pen.initScale || 1) / pen.tableHeight * pen.maxNum;
  pen.calculative.canvas.updatePenRect(_pen);
  if (pen.hasHeader) {
    if (_pen.y < pen.rowPos[0] / pen.tableHeight) {
      _pen.calculative.visible = false;
      _pen.visible = false;
      if (_pen.y < pen.rowPos[0] / pen.tableHeight / 2) {
        _pen.oldY += oldOffset;
        let row = _pen.row + pen.maxNum;
        if (!pen.data[row]) {
          return;
        }
        let rowStyle = deepClone(pen.data[row][_pen.col]);
        if (rowStyle.background) {
          rowStyle.activeBackground = rowStyle.background;
          rowStyle.hoverBackground = rowStyle.background;
        }
        if (rowStyle.color) {
          rowStyle.hoverColor = rowStyle.color;
          rowStyle.activeColor = rowStyle.color;
        }
        if (rowStyle.textColor) {
          rowStyle.activeTextColor = rowStyle.textColor;
          rowStyle.hoverTextColor = rowStyle.textColor;
        }
        Object.assign(_pen, rowStyle, { row });
        Object.assign(_pen.calculative, rowStyle, { row });
      }
    } else if (_pen.y + _pen.height > 1) {
      _pen.calculative.visible = false;
      _pen.visible = false;
      if (_pen.y + _pen.height / 2 > 1) {
        _pen.oldY -= oldOffset;
        let row = _pen.row - pen.maxNum;
        if (!pen.data[row]) {
          return;
        }
        let rowStyle = deepClone(pen.data[row][_pen.col]);
        if (rowStyle.background) {
          rowStyle.activeBackground = rowStyle.background;
          rowStyle.hoverBackground = rowStyle.background;
        }
        if (rowStyle.color) {
          rowStyle.hoverColor = rowStyle.color;
          rowStyle.activeColor = rowStyle.color;
        }
        if (rowStyle.textColor) {
          rowStyle.activeTextColor = rowStyle.textColor;
          rowStyle.hoverTextColor = rowStyle.textColor;
        }
        Object.assign(_pen, rowStyle, { row });
        Object.assign(_pen.calculative, rowStyle, { row });
      }
    } else {
      _pen.visible = true;
      _pen.calculative.visible = true;
    }
  } else {
    if (_pen.y < 0) {
      _pen.calculative.visible = false;
      _pen.visible = false;
      if (_pen.y < -rowHeight / pen.tableHeight / 2) {
        _pen.oldY += oldOffset;
        let row = _pen.row + pen.maxNum;
        if (!pen.data[row]) {
          return;
        }
        let rowStyle = deepClone(pen.data[row][_pen.col]);
        if (rowStyle.background) {
          rowStyle.activeBackground = rowStyle.background;
          rowStyle.hoverBackground = rowStyle.background;
        }
        if (rowStyle.color) {
          rowStyle.hoverColor = rowStyle.color;
          rowStyle.activeColor = rowStyle.color;
        }
        if (rowStyle.textColor) {
          rowStyle.activeTextColor = rowStyle.textColor;
          rowStyle.hoverTextColor = rowStyle.textColor;
        }
        Object.assign(_pen, rowStyle, { row });
        Object.assign(_pen.calculative, rowStyle, { row });
      }
    } else if (_pen.y + _pen.height > 1) {
      _pen.calculative.visible = false;
      _pen.visible = false;
      if (_pen.y + _pen.height / 2 > 1) {
        _pen.oldY -= oldOffset;
        let row = _pen.row - pen.maxNum;
        if (!pen.data[row]) {
          return;
        }
        let rowStyle = deepClone(pen.data[row][_pen.col]);
        if (rowStyle.background) {
          rowStyle.activeBackground = rowStyle.background;
          rowStyle.hoverBackground = rowStyle.background;
        }
        if (rowStyle.color) {
          rowStyle.hoverColor = rowStyle.color;
          rowStyle.activeColor = rowStyle.color;
        }
        if (rowStyle.textColor) {
          rowStyle.activeTextColor = rowStyle.textColor;
          rowStyle.hoverTextColor = rowStyle.textColor;
        }
        Object.assign(_pen, rowStyle, { row });
        Object.assign(_pen.calculative, rowStyle, { row });
      }
    } else {
      _pen.calculative.visible = true;
      _pen.visible = true;
    }
  }
}
function onDestroy(pen) {
  delInterval(pen);
}
function delInterval(pen) {
  if (pen.interval) {
    globalThis.clearInterval(pen.interval);
    pen.interval = null;
  }
}
function createInterval(pen) {
  if (pen.maxNum && pen.swiper) {
    if (pen.interval) {
      return;
    }
    pen.interval = globalThis.setInterval(() => {
      if (pen.offsetY >= pen.calculative.maxOffsetY) {
        pen.offsetY = 0;
        initChildrenStyle(pen);
      } else {
        if (!(pen.offsetY % pen.rowHeight)) {
          if (!pen.calculative.stap) {
            pen.calculative.stap = 0;
          }
          pen.calculative.stap += 1;
          if (pen.calculative.stap == 12) {
            pen.calculative.stap = 0;
            scroll(pen, 1);
          }
        } else {
          scroll(pen, 1);
        }
      }
    }, 50);
  }
}
function initChildrenStyle(pen) {
  var _a;
  (_a = pen.children) == null ? void 0 : _a.forEach((item) => {
    const rowHeight = pen.rowHeight;
    const _pen = pen.calculative.canvas.store.pens[item];
    if (!_pen) {
      return;
    }
    const oldOffset = rowHeight * (pen.initScale || 1) / pen.tableHeight * pen.maxNum;
    _pen.oldY -= oldOffset;
    const row = _pen.row - pen.maxNum;
    if (!pen.data[row]) {
      return;
    }
    let rowStyle = deepClone(pen.data[row][_pen.col]);
    if (rowStyle.background) {
      rowStyle.activeBackground = rowStyle.background;
      rowStyle.hoverBackground = rowStyle.background;
    }
    if (rowStyle.color) {
      rowStyle.hoverColor = rowStyle.color;
      rowStyle.activeColor = rowStyle.color;
    }
    if (rowStyle.textColor) {
      rowStyle.activeTextColor = rowStyle.textColor;
      rowStyle.hoverTextColor = rowStyle.textColor;
    }
    _pen.calculative.visible = true;
    _pen.visible = true;
    Object.assign(_pen, rowStyle, { row });
    Object.assign(_pen.calculative, rowStyle, { row });
  });
  pen.calculative.canvas.render();
}
function onMouseEnter(pen) {
  delInterval(pen);
}

// node_modules/@meta2d/form-diagram/src/switch.js
function le5leSwitch(ctx, pen) {
  if (!pen.onClick) {
    pen.onClick = click;
  }
  let x = pen.calculative.worldRect.x;
  let y = pen.calculative.worldRect.y;
  let w = pen.calculative.worldRect.width;
  let h = pen.calculative.worldRect.height;
  if (w < h * 1.5) {
    w = 1.5 * h;
  }
  ctx.beginPath();
  ctx.arc(x + h / 2, y + h / 2, h / 2, Math.PI / 2, Math.PI * 3 / 2);
  ctx.lineTo(x + w - h / 2, y);
  ctx.arc(x + w - h / 2, y + h / 2, h / 2, -Math.PI / 2, Math.PI / 2);
  ctx.lineTo(x + h / 2, y + h);
  if (pen.checked) {
    ctx.fillStyle = pen.onColor;
    if (pen.disabled || pen.disable) {
      ctx.fillStyle = pen.disableOnColor || pSBC(0.6, pen.onColor);
    }
    if (pen.lineWidth) {
      ctx.strokeStyle = pen.onStrokeColor;
      ctx.stroke();
    }
    ctx.fill();
    ctx.closePath();
    ctx.beginPath();
    ctx.fillStyle = "#ffffff";
    ctx.moveTo(x + h * 2, y + h / 2);
    ctx.arc(x + w - h / 2, y + h / 2, h / 2 > 2 ? h / 2 - 2 : 1, 0, Math.PI * 2);
    ctx.fill();
  } else {
    ctx.fillStyle = pen.offColor;
    if (pen.disabled || pen.disable) {
      ctx.fillStyle = pen.disableOffColor || pSBC(0.6, pen.offColor);
    }
    if (pen.lineWidth) {
      ctx.strokeStyle = pen.offStrokeColor;
      ctx.stroke();
    }
    ctx.fill();
    ctx.closePath();
    ctx.beginPath();
    ctx.fillStyle = "#ffffff";
    ctx.moveTo(x + h, y + h / 2);
    ctx.arc(x + h / 2, y + h / 2, h / 2 > 2 ? h / 2 - 2 : 1, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.closePath();
}
function click(pen) {
  if (pen.disabled || pen.disable) {
    return;
  }
  pen.checked = !pen.checked;
  pen.calculative.canvas.store.emitter.emit("valueUpdate", pen);
  pen.calculative.canvas.render();
}

// node_modules/@meta2d/form-diagram/src/slider.js
function slider(ctx, pen) {
  if (!pen.onAdd) {
    pen.onAdd = initRect3;
    pen.onResize = initRect3;
    pen.onMove = initRect3;
    pen.onMouseMove = mouseMove;
    pen.onMouseDown = mouseDown;
    pen.onValue = onValue3;
    pen.onBeforeValue = beforeValue3;
  }
  if (!pen.calculative.barRect) {
    initRect3(pen);
  }
  const data = pen.calculative.canvas.store.data;
  const options = pen.calculative.canvas.store.options;
  let background = pen.background;
  if (pen.disabled) {
    background = pen.disabledBackground || pSBC(0.6, background);
  }
  ctx.fillStyle = background;
  ctx.beginPath();
  let x = pen.calculative.worldRect.x + pen.calculative.barRect.x;
  let y = pen.calculative.worldRect.y + pen.calculative.barRect.y;
  let w = pen.calculative.barRect.width;
  let h = pen.calculative.barRect.height;
  let r = h / 2;
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, pen.x, pen.y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.fill();
  let activeColor = pen.activeColor || options.activeColor;
  if (pen.disabled) {
    activeColor = pen.disabledColor || pSBC(0.6, activeColor);
  }
  ctx.fillStyle = activeColor;
  ctx.beginPath();
  w = pen.calculative.ballRect.x;
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, pen.x, pen.y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.fill();
  ctx.fillStyle = pen.btnBackground || "#fff";
  ctx.strokeStyle = activeColor;
  ctx.lineWidth = 2;
  ctx.beginPath();
  x = pen.calculative.worldRect.x + pen.calculative.ballRect.x;
  y = pen.calculative.worldRect.y + pen.calculative.ballRect.y + pen.calculative.ballRect.height / 2;
  ctx.lineWidth = pen.calculative.ballRect.width / 10;
  ctx.arc(x, y, pen.calculative.ballRect.width / 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
}
function initRect3(pen) {
  if (!pen._textWidth) {
    pen._textWidth = pen.textWidth || 50;
    pen._fontSize = pen.fontSize || 12;
  }
  pen.textWidth = pen.calculative.worldRect.width;
  pen.calculative.textWidth = pen.textWidth;
  if (!pen.unit) {
    pen.unit = "%";
  }
  if (!pen.sliderWidth) {
    pen.sliderWidth = pen.width;
  }
  if (!pen.sliderHeight) {
    pen.sliderHeight = pen.height;
  }
  if (!pen.calculative.worldRect) {
    return;
  }
  const scaleX = pen.calculative.worldRect.width / pen.sliderWidth;
  const scaleY = pen.calculative.worldRect.height / pen.sliderHeight;
  const textScale = Math.min(scaleX, scaleY);
  pen.fontSize = pen._fontSize * textScale;
  const barWidth = pen.calculative.worldRect.width - pen._textWidth * textScale;
  pen.textLeft = barWidth + 10 * textScale;
  pen.calculative.textLeft = pen.textLeft;
  pen.calculative.barRect = {
    x: 0,
    y: (pen.calculative.worldRect.height - pen.barHeight * scaleY) / 2,
    width: barWidth,
    height: pen.barHeight * scaleY
  };
  calcRightBottom(pen.calculative.barRect);
  calcBallRect(pen);
}
function calcBallRect(pen) {
  const height = pen.calculative.barRect.height * 3.5;
  const progress = pen.calculative.barRect.width * pen.value / 100;
  pen.calculative.ballRect = {
    x: progress,
    y: (pen.calculative.worldRect.height - height) / 2,
    width: height,
    height
  };
  calcRightBottom(pen.calculative.ballRect);
  pen.calculative.text = pen.value + pen.unit;
  calcTextRect(pen);
}
function mouseDown(pen, e) {
  if (pen.disabled) {
    return;
  }
  const pos = e.x - pen.calculative.worldRect.x;
  if (pos > pen.calculative.barRect.width) {
    return;
  }
  let value = Math.round(pos / pen.calculative.barRect.width * 100);
  if (value < pen.min || value > pen.max) {
    return;
  }
  if (value < 0 || value > 100) {
    return;
  }
  pen.value = value;
  calcBallRect(pen);
  pen.calculative.text = pen.value + pen.unit;
  calcTextRect(pen);
  pen.calculative.canvas.store.emitter.emit("valueUpdate", pen);
  pen.calculative.canvas.render();
}
function mouseMove(pen, e) {
  if (pen.calculative.canvas.mouseDown) {
    mouseDown(pen, e);
  }
}
function onValue3(pen) {
  if (pen.calculative.isUpdateData) {
    delete pen.calculative.isUpdateData;
    initRect3(pen);
  }
  calcBallRect(pen);
}
function beforeValue3(pen, value) {
  pen.calculative.isUpdateData = false;
  if (value.textWidth || value.barHeight) {
    if (value.textWidth) {
      pen._textWidth = 0;
    }
    pen.calculative.isUpdateData = true;
  }
  return value;
}

// node_modules/@meta2d/form-diagram/src/checkbox.js
function checkbox(ctx, pen) {
  if (!pen.onMouseDown) {
    pen.onMouseDown = onMousedown;
  }
  if (!pen.options) {
    pen.options = pen.data;
  }
  let x = pen.calculative.worldRect.x;
  let y = pen.calculative.worldRect.y;
  let h = pen.calculative.worldRect.height;
  let w = pen.calculative.worldRect.width;
  const { fontStyle, fontWeight, fontSize, fontFamily, lineHeight } = pen.calculative;
  let r = 2;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.arcTo(x + h, y, x + h, y + h, r);
  ctx.arcTo(x + h, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + h, y, r);
  ctx.strokeStyle = "#d9d9d9";
  ctx.fillStyle = "#ffffff00";
  if (pen.checked) {
    ctx.fillStyle = pen.background || "#1890ff";
    ctx.strokeStyle = pen.background || "#1890ff";
  }
  if (pen.isForbidden || pen.disabled) {
    ctx.fillStyle = pen.disabledBackground || pSBC(0.6, pen.background) || "#ebebeb";
    ctx.strokeStyle = pen.disabledColor || pSBC(0.6, pen.color) || "#d9d9d9";
  }
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.save();
  if (pen.checked) {
    ctx.beginPath();
    ctx.lineWidth = h / 10;
    ctx.strokeStyle = "#ffffff";
    ctx.moveTo(x + 102 / 506 * h, y + h / 2);
    ctx.lineTo(x + 220 / 506 * h, y + 346 / 460 * h);
    ctx.lineTo(x + 404 / 506 * h, y + 142 / 460 * h);
    ctx.stroke();
  }
  ctx.restore();
  ctx.save();
  ctx.fillStyle = pen.disabled || pen.isForbidden ? pen.disabledTextColor || pSBC(0.6, pen.textColor || pen.color) || "#00000040" : getTextColor(pen, pen.calculative.canvas.parent.store) || "#000000d9";
  ctx.textAlign = "start";
  ctx.textBaseline = "middle";
  ctx.font = getFont({
    fontStyle,
    fontWeight,
    fontFamily: fontFamily || pen.calculative.canvas.parent.store.options.fontFamily,
    fontSize,
    lineHeight
  });
  ctx.fillText(pen.value + "", x + h + 10, y + h / 2);
  ctx.restore();
}
function onMousedown(pen, e) {
  if (!pen.isForbidden) {
    pen.checked = !pen.checked;
    pen.calculative.canvas.store.emitter.emit("valueUpdate", pen);
    pen.calculative.canvas.render();
  }
}

// node_modules/@meta2d/form-diagram/src/radio.js
function radio(ctx, pen) {
  if (!pen.options) {
    pen.options = pen.data;
  }
  if (!pen.onAdd) {
    pen.onAdd = onAdd3;
    if (!pen.optionPos) {
      pen.onAdd(pen);
      pen.calculative.canvas.parent.active([pen]);
    }
    pen.onMouseDown = onMousedown2;
    pen.onValue = onValue4;
  }
  let x = pen.calculative.worldRect.x;
  let y = pen.calculative.worldRect.y;
  let h = pen.calculative.worldRect.height;
  let w = pen.calculative.worldRect.width;
  if (!pen.optionPos) {
    return;
  }
  const { fontStyle, fontWeight, fontSize, fontFamily, lineHeight } = pen.calculative;
  if (pen.direction == "horizontal") {
    for (let i = 0; i < pen.optionPos.length; i++) {
      const gap = pen.optionPos[i] * w / pen.checkboxWidth;
      const isForbidden = pen.options[i].isForbidden || pen.disabled;
      ctx.beginPath();
      ctx.arc(x + gap + h / 2, y + h / 2, h / 2, 0, Math.PI * 2);
      ctx.strokeStyle = "#d9d9d9";
      ctx.fillStyle = "#ffffff00";
      if (pen.options[i].text === pen.checked) {
        ctx.strokeStyle = pen.options[i].background || pen.background || "#1890ff";
      }
      if (isForbidden) {
        ctx.fillStyle = pen.disabledBackground || pSBC(0.6, pen.background) || "#ebebeb";
        ctx.strokeStyle = pen.disabledColor || pSBC(0.6, pen.color) || "#d9d9d9";
        if (pen.options[i].text === pen.checked) {
          ctx.fillStyle = "#ffffff00";
        }
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.save();
      if (pen.options[i].text === pen.checked) {
        ctx.beginPath();
        ctx.strokeStyle = pen.options[i].background ? pen.options[i].background + "20" : pen.background || "#1890ff20";
        if (isForbidden) {
          ctx.strokeStyle = pen.disabledBackground || pSBC(0.6, pen.background) || "#ebebeb";
        }
        ctx.arc(x + h / 2 + gap, y + h / 2, h / 2 + 1.5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.fillStyle = pen.options[i].background || pen.background || "#1890ff";
        if (isForbidden) {
          ctx.fillStyle = pen.disabledBackground || pSBC(0.6, pen.background) || "#ebebeb";
        }
        ctx.arc(x + h / 2 + gap, y + h / 2, h / 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
      }
      ctx.restore();
      ctx.save();
      ctx.fillStyle = isForbidden ? pen.disabledTextColor || "#00000040" : getTextColor(pen, pen.calculative.canvas.parent.store) || "#000000d9";
      const textScale = pen.calculative.worldRect.height * 14 / 16;
      ctx.textAlign = "start";
      ctx.textBaseline = "middle";
      ctx.font = getFont({
        fontStyle,
        fontWeight,
        fontFamily: fontFamily || pen.calculative.canvas.parent.store.options.fontFamily,
        fontSize: textScale,
        lineHeight
      });
      ctx.fillText(pen.options[i].text, x + h + gap + 10 / pen.checkboxWidth * w, y + h / 2);
      ctx.restore();
    }
  } else if (pen.direction == "vertical") {
    const optionHeight = pen.optionHeight * h / pen.checkboxHeight;
    for (let i = 0; i < pen.optionPos.length; i++) {
      const gap = pen.optionPos[i] * h / pen.checkboxHeight;
      const isForbidden = pen.options[i].isForbidden;
      ctx.beginPath();
      ctx.arc(x + optionHeight / 2, y + optionHeight / 2 + gap, optionHeight / 2, 0, Math.PI * 2);
      ctx.strokeStyle = "#d9d9d9";
      ctx.fillStyle = "#ffffff00";
      if (pen.options[i].text === pen.checked) {
        ctx.strokeStyle = pen.options[i].background || "#1890ff";
      }
      if (isForbidden) {
        ctx.fillStyle = "#ebebeb";
        ctx.strokeStyle = "#d9d9d9";
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.save();
      if (!isForbidden && pen.options[i].text === pen.checked) {
        ctx.beginPath();
        ctx.strokeStyle = pen.options[i].background ? pen.options[i].background + "20" : "#1890ff20";
        ctx.arc(x + optionHeight / 2, y + optionHeight / 2 + gap, optionHeight / 2 + 1.5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.fillStyle = pen.options[i].background || "#1890ff";
        ctx.arc(x + optionHeight / 2, y + optionHeight / 2 + gap, optionHeight / 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
      }
      ctx.restore();
      ctx.save();
      ctx.fillStyle = isForbidden ? "#00000040" : getTextColor(pen, pen.calculative.canvas.parent.store) || "#000000d9";
      const textScale = 14 * pen.calculative.worldRect.height / pen.checkboxHeight;
      ctx.textAlign = "start";
      ctx.textBaseline = "middle";
      ctx.font = getFont({
        fontStyle,
        fontWeight,
        fontFamily: fontFamily || pen.calculative.canvas.parent.store.options.fontFamily,
        fontSize: textScale,
        lineHeight
      });
      ctx.fillText(pen.options[i].text, x + optionHeight + 10, y + optionHeight / 2 + gap);
      ctx.restore();
    }
  }
}
function onAdd3(pen) {
  initOptions(pen);
}
function onMousedown2(pen, e) {
  if (pen.direction == "horizontal") {
    for (let i = 0; i < pen.optionPos.length; i++) {
      if (!pen.options[i].isForbidden && e.x > pen.calculative.worldRect.x + pen.optionPos[i] * pen.calculative.worldRect.width / pen.checkboxWidth && e.x < pen.calculative.worldRect.x + (pen.optionPos[i] + pen.height) / pen.checkboxWidth * pen.calculative.worldRect.width + getTextLength(pen.options[i].text, pen) + 10 / pen.checkboxWidth * pen.calculative.worldRect.width) {
        pen.checked = pen.options[i].text;
        pen.calculative.canvas.store.emitter.emit("valueUpdate", pen);
      }
    }
  } else if (pen.direction == "vertical") {
    const scaleY = pen.calculative.worldRect.height / pen.checkboxHeight;
    for (let i = 0; i < pen.optionPos.length; i++) {
      if (!pen.options[i].isForbidden && e.y > pen.calculative.worldRect.y + pen.optionPos[i] * scaleY && e.y < pen.calculative.worldRect.y + (pen.optionPos[i] + pen.optionHeight) * scaleY) {
        pen.checked = pen.options[i].text;
        pen.calculative.canvas.store.emitter.emit("valueUpdate", pen);
      }
    }
  }
  pen.calculative.canvas.render();
}
function onValue4(pen) {
  initOptions(pen);
}

// node_modules/@meta2d/form-diagram/src/time.js
function time(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const { x, y, width, height } = pen.calculative.worldRect;
  path.rect(x, y, width, height);
  if (!pen.onAdd) {
    pen.onAdd = onAdd4;
    pen.onDestroy = onDestroy2;
    if (pen.interval) {
      pen.onDestroy(pen);
      pen.onAdd(pen);
    }
  }
  if (!pen.interval) {
    pen.onAdd(pen);
  }
  if (path instanceof Path2D)
    return path;
  return;
}
function formatTime(pen) {
  const weeks = ["", "", "", "", "", "", ""];
  const now = /* @__PURE__ */ new Date();
  const year = now.getFullYear();
  let pad = "";
  if (pen.fillZero) {
    pad = "0";
  }
  const month = (now.getMonth() + 1 + "").padStart(2, pad);
  const day = (now.getDate() + "").padStart(2, pad);
  const week = now.getDay();
  const hours = (now.getHours() + "").padStart(2, pad);
  const minutes = (now.getMinutes() + "").padStart(2, pad);
  const seconds = (now.getSeconds() + "").padStart(2, pad);
  const fn = new Function("year", "month", "day", "week", "hours", "minutes", "seconds", pen.timeFormat ? `return ${pen.timeFormat}` : "return `${year}:${month}:${day} ${hours}:${minutes}:${seconds} ${week}`");
  const time2 = fn(year, month, day, weeks[week], hours, minutes, seconds);
  return time2;
}
function onAdd4(pen) {
  pen.interval = setInterval(() => {
    const text = formatTime(pen);
    pen.calculative.canvas.parent.setValue({ id: pen.id, text }, { history: false, doEvent: false, render: false });
    pen.calculative.canvas.render();
  }, pen.timeout || 1e3);
}
function onDestroy2(pen) {
  if (pen.interval) {
    clearInterval(pen.interval);
    pen.interval = void 0;
  }
}

// node_modules/@meta2d/form-diagram/src/register.js
function formPens() {
  return {
    radio,
    switch: le5leSwitch,
    slider,
    checkbox,
    table: table2,
    table2
  };
}
function formPath2DPens() {
  return {
    time
  };
}
export {
  checkbox,
  formPath2DPens,
  formPens,
  le5leSwitch,
  slider,
  table,
  table2,
  time
};
//# sourceMappingURL=@meta2d_form-diagram.js.map
