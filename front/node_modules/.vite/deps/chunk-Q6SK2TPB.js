import {
  connectLine,
  deepClone,
  disconnectLine,
  setLifeCycleFunc
} from "./chunk-PFF6Q7CQ.js";
import {
  __publicField
} from "./chunk-USJHI7ER.js";

// node_modules/@meta2d/plugin-mind-core/src/utils.js
function createDom(tag, config = {
  style: {},
  event: void 0,
  func: void 0,
  className: void 0
}) {
  let dom = document.createElement(tag);
  if (config.style) {
    if (typeof config.style === "object") {
      Object.assign(dom.style, config.style);
      config.className && dom.classList.add(config.className);
    } else {
      throw new Error('createDom error: parma "style" must be a Object');
    }
  }
  if (typeof config.event === "string" && typeof config.func === "function") {
    dom.addEventListener(config.event, (e) => {
      config.func(e);
    });
  }
  return dom;
}
function debounce(fn, delay) {
  let timer = null;
  return function(pen, recursion = true) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.call(this, pen, recursion);
    }, delay);
  };
}
function deepMerge(obj1, obj2) {
  if (Array.isArray(obj1) && Array.isArray(obj2)) {
    return obj2;
  }
  let newObj = Object.assign({}, obj1);
  for (let key in obj2) {
    if (typeof obj1[key] === "object" && typeof obj2[key] === "object") {
      newObj[key] = deepMerge(obj1[key], obj2[key]);
    } else {
      newObj[key] = obj2[key];
    }
  }
  return newObj;
}
function replaceAfterPosition(str, position, regex, replacement) {
  if (position >= str.length)
    return str;
  const substringToReplace = str.slice(position);
  const replacedSubstring = substringToReplace.replace(regex, replacement);
  const resultString = str.slice(0, position) + replacedSubstring;
  return resultString;
}
function debounceFirstOnly(func, wait) {
  let timeout;
  let executed = false;
  return function(...args) {
    const context = this;
    if (!executed) {
      func.apply(context, args);
      executed = true;
    }
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      executed = false;
    }, wait);
  };
}
function isObjectLiteral(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
}
function removeDuplicates(list) {
  const uniqueResults = [];
  const uniqueNames = /* @__PURE__ */ new Set();
  for (const res of list) {
    if (!uniqueNames.has(res.name)) {
      uniqueNames.add(res.name);
      uniqueResults.push(res);
    }
  }
  return uniqueResults;
}
function scopedEval(scope, expr) {
  const scopeKeys = Object.keys(scope);
  const scopeValues = Object.values(scope);
  const func = new Function(...scopeKeys, `return ${expr};`);
  try {
    let re = func(...scopeValues);
    return re;
  } catch (e) {
    error("[ScopedEval] Error: ", e.message);
  }
}
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function error(scope, message) {
  throw new Error(`plugin-mind-core ${scope} Error: ${message}`);
}
function warn(scope, message) {
  console.warn(`mind-plugin-core ${scope} Warn: ${message}`);
}
function deepCopy(obj, cache = /* @__PURE__ */ new WeakMap()) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (obj instanceof Date) {
    return new Date(obj);
  }
  if (obj instanceof RegExp) {
    return new RegExp(obj.source, obj.flags);
  }
  if (typeof obj === "function") {
    return obj.bind(null);
  }
  if (cache.has(obj)) {
    return cache.get(obj);
  }
  let copy = Array.isArray(obj) ? [] : {};
  cache.set(obj, copy);
  Object.keys(obj).forEach((key) => {
    copy[key] = deepCopy(obj[key], cache);
  });
  const proto = Object.getPrototypeOf(obj);
  if (proto) {
    Object.setPrototypeOf(copy, proto);
  }
  return copy;
}
function isObject(object) {
  return object != null && typeof object === "object";
}
function compareObjects(object1, object2) {
  const diffs = {};
  const compare = function(item1, item2, key) {
    const type1 = Object.prototype.toString.call(item1);
    const type2 = Object.prototype.toString.call(item2);
    if (type1 !== type2) {
      diffs[key] = { oldVal: item1, newVal: item2 };
      return;
    }
    if (isObject(item1) && isObject(item2)) {
      const objDiffs = compareObjects(item1, item2);
      if (Object.keys(objDiffs).length > 0) {
        diffs[key] = objDiffs;
      }
    } else if (item1 !== item2) {
      diffs[key] = { oldVal: item1, newVal: item2 };
    }
  };
  for (const key in object1) {
    if (object1.hasOwnProperty(key)) {
      compare(object1[key], object2[key], key);
    }
  }
  for (const key in object2) {
    if (object2.hasOwnProperty(key)) {
      if (!object1.hasOwnProperty(key)) {
        diffs[key] = { oldVal: void 0, newVal: object2[key] };
      }
    }
  }
  return diffs;
}
function isIntersection(arr1, arr2, res = false) {
  if (!Array.isArray(arr1) || !Array.isArray(arr2))
    return;
  const set1 = new Set(arr1);
  const set2 = new Set(arr2);
  let isIntersection2 = false;
  const intersection = [];
  for (const item of set1) {
    if (set2.has(item)) {
      if (res) {
        intersection.push(item);
      } else {
        isIntersection2 = true;
        break;
      }
    }
  }
  return res ? intersection : isIntersection2;
}

// node_modules/@meta2d/plugin-mind-core/src/parse.js
var EVENTTAG = ["@", "on"];
var env = Symbol("env");
function Scope(config, { template = "", script = {}, style = "" }, output = "dom", root, oldScript) {
  var _a;
  let res = createDom("div");
  let namespace = config.key;
  window[env] ? "" : window[env] = {};
  window[env][namespace] ? "" : window[env][namespace] = {};
  let symbols = Object.getOwnPropertySymbols(window);
  let targetSymbol;
  for (let i = 0; i < symbols.length; i++) {
    let symbol = symbols[i];
    if (window[symbol] === window[env]) {
      targetSymbol = i;
      break;
    }
  }
  if (!namespace)
    error("Scope", "The config parameter is invalid [have no key]");
  let duty = [];
  template = addUniqueIdsToHtmlString(template);
  script.$update = () => {
    if (!root)
      root = res;
    root.innerHTML = Scope(config, {
      template,
      style,
      script: window[env][namespace]
    }, output, root, oldScript).innerHTML;
    duty = [];
  };
  let proxyScript = createDeepProxy(script, (p, v) => {
    if (!["$update", "init", "mounted", "__depMap"].includes(p)) {
      if (p.includes(".")) {
        p = p.split(".")[0];
      }
      duty.push(p);
    }
  });
  window[env] ? "" : window[env] = {};
  window[env][namespace] ? "" : window[env][namespace] = {};
  let { dom, funcObjs, varObj } = parse(template);
  let keys = Object.keys(script);
  window[env][namespace] = proxyScript;
  window[env][namespace].__depMap = null;
  if (!root) {
    (_a = proxyScript.init) == null ? void 0 : _a.call(proxyScript);
    Promise.resolve().then(() => {
      var _a2;
      (_a2 = proxyScript.mounted) == null ? void 0 : _a2.call(proxyScript, res);
    });
  }
  let funcOffset = 0;
  funcObjs.forEach((i) => {
    if (keys.indexOf(i.name) !== -1) {
      i.params.forEach((j) => {
        if (!j.param.startsWith("this") && j.param !== "event" && !isLiteral(j.param)) {
          let oldDom = dom;
          dom = replaceAfterPosition(dom, j.index - funcOffset, j.param, `window[Object.getOwnPropertySymbols(window)[${targetSymbol}]].${namespace}.${j.param}`);
          funcOffset += oldDom.length - dom.length;
        }
      });
      dom = dom.replaceAll(i.name + "(", `window[Object.getOwnPropertySymbols(window)[${targetSymbol}]].${namespace}.${i.name}(`);
    }
  });
  window[env][namespace].__depMap = varObj;
  varObj.forEach((i) => {
    let res2 = scopedEval(window[env][namespace], i.name);
    i.res = res2;
    let regex = new RegExp(`\\{\\{\\s*${escapeRegExp(i.name)}\\s*\\}\\}`);
    dom = replaceAfterPosition(dom, 0, regex, res2);
  });
  let sty = "";
  if (style) {
    style.startsWith("<style>") ? sty = style : sty = `<style>${style}</style>`;
  }
  if (output === "string") {
    return dom + sty;
  } else if (output === "dom") {
    res.innerHTML = dom + sty;
    res.expose = proxyScript;
    return res;
  }
}
function parse(html) {
  let funcReg = new RegExp(`(${EVENTTAG.join("|")})(?<event>\\w+)\\s*=\\s*["'](?<name>[a-zA-Z][a-zA-Z0-9]*)\\s*\\(\\s*(?<param>[^)]*)\\s*\\)["']`, "g");
  let reHtml = html.replaceAll("\n", "").replaceAll(/@(\w+)="([^"]+)"/g, 'on$1="$2"');
  let funcMatchs = reHtml.matchAll(funcReg);
  let varParseObj = variableParse(html);
  let result = [];
  for (let match of funcMatchs) {
    let { event, name, param } = match.groups;
    let params = param.replaceAll(/\s/g, "").split(",");
    let lastIndex = 0;
    params = params.map((i) => {
      let strIndex = match[0].indexOf(i, lastIndex);
      let index = match.index + strIndex;
      lastIndex = strIndex + i.length;
      return {
        param: i,
        index
      };
    });
    let re = { event, name, params, index: match.index };
    result.push(re);
  }
  let funcObjs = removeDuplicates(result);
  return { dom: reHtml, funcObjs, varObj: varParseObj };
}
function isLiteral(_) {
  if (_.startsWith('"') || _.startsWith("'"))
    return true;
  if (!Number.isNaN(+_))
    return true;
  if (_ === "true" || _ === "false")
    return true;
  return false;
}
function variableParse(html) {
  const results = [];
  const tagRegex = /<\s*[\w-]+.*?>[\s\S]*?<\/[\w-]+>/g;
  const attributeRegex = /(\w+)\s*=\s*(['"])(.*?)\2/g;
  const variableRegex = /{{\s*([^}]*)\s*}}/g;
  let tagMatch;
  while ((tagMatch = tagRegex.exec(html)) !== null) {
    const tag = tagMatch[0];
    let meta2dIdMatch = tag.match(/data-meta2d-id=['"]([\d|\w]+)['"]/);
    let meta2dId = meta2dIdMatch ? meta2dIdMatch[1] : void 0;
    let attributeMatch;
    while ((attributeMatch = attributeRegex.exec(tag)) !== null) {
      const attributeName = attributeMatch[1];
      const attributeValue = attributeMatch[3];
      let variableMatch2;
      while ((variableMatch2 = variableRegex.exec(attributeValue)) !== null) {
        const variableName = variableMatch2[1];
        if (attributeName === "style") {
          const styleAttributeRegex = /\s*(?<prop>[\w-]+)\s*:\s*{{\s*([^{}]+)\s*}};?/g;
          let stylePropMatch;
          while ((stylePropMatch = styleAttributeRegex.exec(attributeValue)) !== null) {
            const styleProp = stylePropMatch[1];
            const styleValue = stylePropMatch[2];
            if (results.findIndex((i) => {
              return i.styleProp === styleProp && i["meta2d-id"] === meta2dId && i.name === styleValue;
            }) > -1)
              continue;
            results.push({
              prop: "style",
              styleProp,
              "meta2d-id": meta2dId,
              name: styleValue
            });
          }
        } else {
          results.push({
            prop: attributeName,
            name: variableName,
            "meta2d-id": meta2dId
          });
        }
      }
    }
    let textContent = tag.replace(/<[\s\S]*?>/g, "");
    let variableMatch;
    while ((variableMatch = variableRegex.exec(textContent)) !== null) {
      const variableName = variableMatch[1];
      results.push({
        prop: "textContent",
        name: variableName,
        textContent,
        originTemp: variableMatch[0],
        "meta2d-id": meta2dId
      });
    }
  }
  return results;
}
function addUniqueIdsToHtmlString(htmlString) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(htmlString, "text/html");
  function generateUUID() {
    return "xxxxxxxxxxxxxxxxxxxx".replace(/[x]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  function addUniqueIdToElement(element) {
    if (element.nodeType === 1) {
      element.setAttribute("data-meta2d-id", generateUUID());
      Array.from(element.children).forEach(addUniqueIdToElement);
    }
  }
  addUniqueIdToElement(doc.body);
  const serializer = new XMLSerializer();
  let newHtmlString = serializer.serializeToString(doc);
  newHtmlString = newHtmlString.replaceAll(/\?&quot;/g, '"');
  const bodyContent = newHtmlString.match(/<body[^>]*>([\s\S]*)<\/body>/i)[1];
  return bodyContent;
}
function createDeepProxy(obj, onChange, path = []) {
  return new Proxy(obj, {
    get(target, key, receiver) {
      const value = Reflect.get(target, key, receiver);
      if (typeof value === "object" && value !== null) {
        return createDeepProxy(value, onChange, [...path, key]);
      }
      return value;
    },
    set(target, key, value, receiver) {
      const result = Reflect.set(target, key, value, receiver);
      onChange([...path, key].join("."), value);
      return result;
    }
  });
}

// node_modules/@meta2d/plugin-mind-core/src/config/default.js
function* generateColor(colorList) {
  if (colorList && !Array.isArray(colorList)) {
    console.warn("mindBoxPlugin warn: generateColor must take array param");
  }
  let index = 0;
  let list = colorList || mindBoxPlugin.colorList;
  while (true) {
    yield list[index];
    index = (index + 1) % list.length;
  }
}
var funcList = [
  //   {
  // key: "id",
  //     name:'id',
  // setDom(self,pen) {
  //   return pen.id
  // }
  //   },
  {
    key: "addChildNode",
    description: "用于新增子节点",
    menu: {
      text: "新增子级节点",
      // 该选项的选项名，当无icon或者img或者setDom时，会以此为准  优先级：setDom>icon>img>name
      img: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMzRweCIgaGVpZ2h0PSIzNHB4IiB2aWV3Qm94PSIwIDAgMzQgMzQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8dGl0bGU+5LiL57qn6IqC54K5PC90aXRsZT4KICAgIDxkZWZzPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTEiIHg9IjE0IiB5PSIxOCIgd2lkdGg9IjE2IiBoZWlnaHQ9IjciIHJ4PSIxIj48L3JlY3Q+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMiIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSIxNiIgaGVpZ2h0PSI3IiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgPC9kZWZzPgogICAgPGcgaWQ9Iumhtemdoi0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0i5Zu65a6aIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMzM2LjAwMDAwMCwgLTI3LjAwMDAwMCkiPgogICAgICAgICAgICA8ZyBpZD0i57yW57uELTLlpIfku70iIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE4Mi4wMDAwMDAsIDI0LjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9IuS4i+e6p+iKgueCuSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU0LjAwMDAwMCwgMy4wMDAwMDApIj4KICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0i6YCP5piO5bqV5Zu+IiBmaWxsLW9wYWNpdHk9IjAiIGZpbGw9IiNGRkZGRkYiIHg9IjAiIHk9IjAiIHdpZHRoPSIzNCIgaGVpZ2h0PSIzNCI+PC9yZWN0PgogICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSLnn6nlvaLlpIfku70tNiIgc3Ryb2tlPSIjODE4MTg3IiB4PSI0LjUiIHk9IjguNSIgd2lkdGg9IjE1IiBoZWlnaHQ9IjYiIHJ4PSIxIj48L3JlY3Q+CiAgICAgICAgICAgICAgICAgICAgPGxpbmUgeDE9IjEyIiB5MT0iMjIiIHgyPSIxNCIgeTI9IjIyIiBpZD0i55u057q/LTciIHN0cm9rZT0iIzgxODE4NyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj48L2xpbmU+CiAgICAgICAgICAgICAgICAgICAgPGxpbmUgeDE9IjEyIiB5MT0iMTUiIHgyPSIxMiIgeTI9IjIyIiBpZD0i55u057q/LTYiIHN0cm9rZT0iIzgxODE4NyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj48L2xpbmU+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBpZD0i55+p5b2i5aSH5Lu9LTUiIHN0cm9rZT0iIzlDOUNBNSIgbWFzaz0idXJsKCNtYXNrLTIpIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1kYXNoYXJyYXk9IjIiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4="
    },
    // 监听事件名
    // event: 'click',
    /**
     * @description 事件对应的回调函数
     * @param self 返回该选项自身
     * @param pen 返回当前操作的pen对象
     * */
    // func: async (self,pen)=>{
    //   mindBoxPlugin.bottomChildren(pen,0);
    //   },
    popupEvent: "mouseenter",
    shadowRoot: false,
    collapseEventOnMenu: false,
    // 是否在childrenDom中触发事件
    stopPropagation: true,
    collapseAnimate(self, pen, dom) {
      dom.style.transformOrigin = "top";
      dom.offsetHeight;
      dom.style.transition = "all .3s";
      dom.style.transform = "scaleY(0)";
      return true;
    },
    popupAnimate(self, pen, dom) {
      dom.style.transform = "scaleY(1)";
      return true;
    },
    popup: [
      {
        menu: {
          text: "矩形",
          icon: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" t="1698915834790" class="icon" viewBox="0 0 1365 1024" version="1.1" p-id="13181" width="50" height="30"><path d="M920.32924106 188.22098215H435.74469865c-178.43219866 0-323.49023438 145.05719866-323.49023438 323.49023436 0 178.43219866 145.05803572 323.49023438 323.49023438 323.49023439h484.58454241c178.43303572 0 323.49023438-145.05803572 323.49023437-323.49023439 0.14481026-178.28822544-144.91322544-323.49023438-323.49023437-323.49023436z m2.65345982 603.01339285H439.05440848c-145.05719866 0-281.40652902-137.4375-281.40652903-281.19475447 0-145.05803572 132.71735492-270.29966518 277.77455357-270.29966518h489.52064732c145.05803572 0 272.32700893 131.98995536 272.32700893 275.74720983 0 143.61328125-129.22935267 275.74720982-274.28738839 275.74720982z" p-id="13182"/></svg>'
        },
        event: "click",
        func(self, pen, dom, father) {
          mindBoxPlugin.addNode(pen, 0, "mindNode2", { width: 200, height: 50 });
          father.close();
        }
      },
      {
        menu: {
          text: "菱形",
          icon: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" t="1698916220010" class="icon" viewBox="0 0 1024 1024" version="1.1" p-id="13326" width="50" height="30"><path d="M485.213 869.904c6.744 4.822 18.199 8.603 26.787 8.603 8.588 0 21.779-2.476 28.32-7.442l467.957-336.878c13.427-9.665 13.47-26.284 0-35.915l-469.49-335.716c-6.726-4.81-19.733-10.927-28.321-10.927-8.588 0-23.313 7.122-29.855 12.088L15.723 498.272c-13.43 9.664-13.47 26.284 0 35.915z m23.719-671.51l452.01 322.481L512 835.227 63.058 518.553z" p-id="13327"/></svg>'
        },
        event: "click",
        func(self, pen, dom, father) {
          mindBoxPlugin.addNode(pen, 0, "diamond", { width: 200, height: 120 });
          father.close();
        }
      },
      {
        menu: {
          text: "椭圆",
          icon: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="50px" height="30px" viewBox="0 0 140 53" version="1.1">\n    <title>椭圆形备份 12</title>\n    <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g id="未固定" transform="translate(-372.000000, -738.000000)" stroke="#000000" stroke-width="2">\n            <ellipse id="椭圆形备份-12" cx="442" cy="764.5" rx="69" ry="25.5"/>\n        </g>\n    </g>\n</svg>'
        },
        event: "click",
        func(self, pen, dom, father) {
          mindBoxPlugin.addNode(pen, 0, "circle", { width: 200, height: 75 });
          father.close();
        }
      }
    ]
  },
  {
    key: "extra"
  },
  {
    key: "relayout",
    description: "用于重新布局某节点下的所有子节点",
    menu: {
      text: "重新布局",
      icon: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="34px" height="34px" viewBox="0 0 34 34" version="1.1">\n    <title>重新布局</title>\n    <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g id="未固定" transform="translate(-577.000000, -138.000000)" stroke="#818187">\n            <g id="编组-2" transform="translate(253.000000, 135.000000)">\n                <g id="仅重布局子集" transform="translate(324.000000, 3.000000)">\n                    <rect id="矩形备份-6" x="7.5" y="7.5" width="19" height="19" rx="1"/>\n                    <line x1="7.5" y1="13.5" x2="26.5" y2="13.5" id="直线-11" stroke-linecap="square"/>\n                    <line x1="14.325" y1="18.5" x2="26.325" y2="18.5" id="直线-11备份-4" stroke-linecap="square"/>\n                    <line x1="14.325" y1="23.5" x2="26.325" y2="23.5" id="直线-11备份-5" stroke-linecap="square"/>\n                    <line x1="13.5" y1="13.5" x2="13.5" y2="25.5" id="直线-11备份" stroke-linecap="square"/>\n                    <line x1="17.5" y1="13.5" x2="17.5" y2="25.5" id="直线-11备份-2" stroke-linecap="square"/>\n                    <line x1="22.5" y1="13.5" x2="22.5" y2="25.5" id="直线-11备份-3" stroke-linecap="square"/>\n                </g>\n            </g>\n        </g>\n    </g>\n</svg>'
    },
    event: "click",
    func(self, pen, dom, e) {
      var _a;
      let children = ((_a = pen.mind) == null ? void 0 : _a.children) || [];
      if (children.length > 0) {
        mindBoxPlugin.update(pen, true);
      }
    },
    // setDom(self,dom){
    //   // draw your dom freeDom！！！
    //   let result =  `<span>${self.name}</span>`;
    //   return result;
    // }
    closeOther: true
  },
  {
    key: "relayoutNext",
    description: "用于重新布局某节点下的第一级子节点",
    closeOther: true,
    menu: {
      text: "重新布局下一级",
      icon: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="34px" height="34px" viewBox="0 0 34 34" version="1.1">\n    <title>重新布局下一级</title>\n    <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g id="未固定" transform="translate(-531.000000, -138.000000)" stroke="#818187">\n            <g id="编组-2" transform="translate(253.000000, 135.000000)">\n                <g id="重新布局" transform="translate(278.000000, 3.000000)">\n                    <rect id="矩形备份-6" x="7.5" y="7.5" width="19" height="19" rx="1"/>\n                    <line x1="7.5" y1="13.5" x2="26.5" y2="13.5" id="直线-11" stroke-linecap="square"/>\n                    <line x1="13.5" y1="13.5" x2="13.5" y2="25.5" id="直线-11备份" stroke-linecap="square"/>\n                </g>\n            </g>\n        </g>\n    </g>\n</svg>'
    },
    event: "click",
    func(self, pen) {
      var _a;
      let children = ((_a = pen.mind) == null ? void 0 : _a.children) || [];
      if (children.length > 0) {
        mindBoxPlugin.update(pen, false);
      }
    }
  },
  {
    key: "extra"
  },
  {
    key: "nodeStyle",
    menu: {
      text: "边框样式",
      dom(self) {
        let color = self.color;
        let dash = self.dash;
        let width = self.width;
        let HTML = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="34px" height="34px" viewBox="0 0 34 34" version="1.1">
                    <title>边框样式</title>
                    <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g id="未固定" transform="translate(-628.000000, -138.000000)">
                            <g id="编组-2" transform="translate(253.000000, 135.000000)">
                                <g id="边框颜色" transform="translate(375.000000, 3.000000)">
                                    <rect id="透明底图" fill-opacity="0" fill="#FFFFFF" x="0" y="0" width="34" height="34"/>
                                    <circle id="椭圆形" stroke="${color}" stroke-width="${width}" cx="17" cy="17" r="8" stroke-dasharray="${dash}"/>
                                </g>
                            </g>
                        </g>
                    </g>
                </svg>`;
        return HTML;
      }
    },
    color: "#4D4DFF",
    dash: "5,5",
    width: 4,
    colorList: [
      "#5757F3",
      "#FD42DD",
      "#8C8CFF",
      "#19f1cc",
      "#6ffd97",
      "#efe864",
      "#ff931a",
      "#fa7878"
    ],
    popupEvent: "mouseover",
    /**
     * @description 初始化函数
     * @param self 配置项本身
     * @param pen 木匾画笔
     */
    init(self, pen) {
      self.dash = pen.lineDash ? `${pen.lineDash[0]},${pen.lineDash[1]}` : "0,0";
      self.width = (+pen.lineWidth).toFixed(0);
      self.color = pen.mind.color || pen.calculative.color || "#000000";
    },
    stopPropagation: true,
    collapseAnimate(self, pen, dom) {
      dom.style.transform = "scaleY(0)";
      return true;
    },
    popupAnimate(self, pen, dom) {
      dom.style.transform = "scaleY(1)";
      return true;
    },
    popup(self, pen) {
      let dom = createDom("div", {
        style: {
          display: "flex",
          flexDirection: "row",
          flexWrap: "wrap",
          justifyContent: "flex-start",
          transformOrigin: "top",
          transition: "all .3s",
          position: "absolute",
          top: "40px",
          backgroundColor: "#fff",
          borderRadius: "5px",
          padding: "16px",
          width: "140px",
          boxShadow: "0px 6px 20px rgba(25,25,26,.06), 0px 2px 12px rgba(25,25,26,.04)"
        }
      });
      dom.attachShadow({ mode: "open" });
      let gap = createDom("div", {
        style: {
          width: "100%",
          height: "20px",
          backgroundColor: "red",
          position: "absolute",
          top: "-10px",
          opacity: 0
        }
      });
      dom.shadowRoot.appendChild(gap);
      let str = Scope(self, {
        template: `
          <div class="container">
              <div class="item">
                <div class="title">边框粗细</div>
                <div class="main">
                  <input type="range" min="1" max="10" style="width: 81px" @change="sliderChange(this.value)" id="width" value="${self.width}">  <span id="t" style="display:block;vertical-align: top;margin-left: 10px;width: 41px;height: 20px;background-color:#f7f7f9;text-align: center;line-height: 20px">${self.width}</span>
                </div>
              </div>
                  <div class="item">
                <div class="title">边框样式</div>
                <div class="main_style ">
                  <div class="style_item ${self.dash === "0,0" ? "style_active" : ""}" data-style="直线" @click="setOutLineStyle(true)">
                     <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="50px" height="2px" viewBox="0 0 78 2" version="1.1">
                        <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
                            <g id="未固定" transform="translate(-402.000000, -306.000000)" stroke="#000000" stroke-width="2">
                                <line x1="403" y1="307" x2="479" y2="307" id="直线-12备份-9"/>
                            </g>
                        </g>
                    </svg>
                  </div>
                  <div class="style_item  ${self.dash === "5,5" ? "style_active" : ""}" data-style="虚线" @click="setOutLineStyle(false)">
                    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="50px" height="2px" viewBox="0 0 78 2" version="1.1">
                        <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-dasharray="4" stroke-linecap="round">
                            <g id="未固定" transform="translate(-402.000000, -306.000000)" stroke="#000000" stroke-width="2">
                                <line x1="403" y1="307" x2="479" y2="307" id="直线-12备份-9"/>
                            </g>
                        </g>
                    </svg>
                  </div>
                </div>
              </div>
              <div class="item">
                <div class="title">边框颜色
                <label for="color">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18px" height="17px" viewBox="0 0 18 17" version="1.1">
    <title>吸管</title>
    <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="未固定" transform="translate(-279.000000, -349.000000)" stroke="#818187">
            <g id="编组-6备份-2" transform="translate(208.000000, 188.000000)">
                <g id="吸管" transform="translate(72.062370, 161.000000)">
                    <g id="编组-8" transform="translate(7.937630, 8.095196) rotate(-315.000000) translate(-7.937630, -8.095196) translate(4.036351, 0.770971)">
                        <path d="M4.96179031,5.89679753 L4.96179031,10.0040546 C4.96179031,10.4930202 4.63081262,10.9045357 4.18105852,11.0275164 L4.18153455,13.8681947 L3.62149907,11.0275164 C3.17174496,10.9045357 2.84076728,10.4930202 2.84076728,10.0040546 L2.84076728,5.89679753 L4.96179031,5.89679753 Z" id="形状结合"/>
                        <path d="M3.90127879,0.5 C4.40959264,0.5 4.86978446,0.706034895 5.20289782,1.03914825 C5.53601117,1.37226161 5.74204607,1.83245343 5.74204607,2.34076728 L5.74204607,5.66776861 L2.06051152,5.66776861 L2.06051152,2.34076728 C2.06051152,1.83245343 2.26654641,1.37226161 2.59965977,1.03914825 C2.93277313,0.706034895 3.39296495,0.5 3.90127879,0.5 Z" id="形状结合"/>
                        <line x1="0.390127879" y1="5.78228307" x2="7.41242971" y2="5.78228307" id="直线-13" stroke-linecap="round"/>
                    </g>
                </g>
            </g>
        </g>
    </g>
</svg>
                  </div>
                  <input id="color" style="display: none" type="color"  @change="setColor(event,this.value)" value="${self.color}">
                </label>
                     <div class="main">

                     <div class="colorList" onclick="setColor(event)">
                     ${self.colorList.map((i, index) => `<span class="color_item ${self.color === i ? "active" : ""}" style="background-color: ${i};border: 3px solid ${i}" data-color="${i}"></span>`).join("")}
                     </div>
                </div>
              </div>
          </div>`,
        script: {
          // 能在这里面获取到dom
          init() {
            var _a;
            self.dash = ((_a = pen.lineDash) == null ? void 0 : _a.join(",")) || "0,0";
            if (self.dash === "0,0") {
              this.lineactive = "style_active";
              this.dashActive = "";
            } else {
              this.lineactive = "";
              this.dashActive = "style_active";
            }
          },
          value: 10,
          lineactive: "style_active",
          dashActive: "",
          setOutLineStyle(style) {
            let res = style ? [0, 0] : [5, 5];
            meta2d.setValue({
              id: pen.id,
              lineDash: res
            }, { render: true });
            self.dash = res.join(",");
            self.updateAll();
          },
          sliderChange: (value) => {
            self.width = value;
            meta2d.setValue({
              id: pen.id,
              lineWidth: value
            }, { render: true });
            self.update("menu");
            self.update("popup", true);
          },
          setColor(e, value) {
            let color = "";
            if (!value) {
              let t = e.target;
              let list = dom.shadowRoot.querySelector(".colorList");
              if (t === list)
                return;
              color = t.dataset.color;
            } else {
              color = value;
            }
            if (color === self.color) {
              color = "";
            } else {
              meta2d.setValue({
                id: pen.id,
                color
              }, { render: false });
            }
            pen.mind.color = color;
            mindBoxPlugin.calcChildrenColor(meta2d.store.pens[pen.mind.preNodeId] || pen);
            mindBoxPlugin.resetLinesColor(pen);
            mindBoxPlugin.render();
            self.color = color || pen.calculative.color;
            self.updateAll();
          }
        },
        style: `<style>
        .container {
            overflow: hidden;
        }
        .main {
            display: flex;
            flex-direction: row;
            justify-content: space-around;
            align-items: center;
        }
        .style_active{
            width: 30%;
            background-color:#fff;
            height: 20px;
            box-shadow: 0 0 5px 1px rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }
        .active{
            border: 3px solid deepskyblue !important;
        }
        .colorList {
            display: flex;
            justify-content: space-between;
            align-content: space-between;
            flex-wrap: wrap;
        }
        .main_style {
            display: flex;
            width: 100%;
            height: 30px;
            justify-content: space-around;
            align-items: center;
            border-radius: 3px;
            background-color:#f7f7f9;
        }
        .style_item {
            width:47%;
            height: 22px;
            display: flex;
            align-items: center;
            overflow: hidden;
            justify-content: center;
        }
        .color_item {
            width: 20px;
            height: 20px;
            border: 3px solid;
            margin: 5px 5px 5px 0;
            border-radius: 2px;
        }
        .color_item:hover {
            border: 3px solid rgba(128,128,128,0.5) !important;
        }
       .item {
          display:flex;
          justify-content: flex-start;
          align-items: flex-start;
          flex-direction: column;
          margin-bottom: 14px;
       }
       .title {
          width: 100%;
          height: 17px;
          font-size: 16px;
          display: flex;
          justify-content: flex-start;
          align-items: center;
          font-family: PingFang SC, PingFang SC-Regular;
          font-weight: 400;
          text-align: left;
          color: #7d7878;
          line-height: 17px;
          margin-bottom: 14px;
        }
    </style>
        `
      }, "dom");
      dom.shadowRoot.appendChild(str);
      return dom;
    }
    // children: [
    //   {
    //     name:'直线',
    //     event: 'click',
    //     func(self, pen, dom, father) {
    //       meta2d.setValue({id:pen.id,lineDash:[0,0]})
    //       father.dash = '0,0';
    //       toolbox.renderFuncList()
    //     }
    //   },
    //   {
    //     name:'虚线',
    //     event: 'click',
    //     func(self, pen, dom, father) {
    //       meta2d.setValue({id:pen.id,lineDash:[5,5]})
    //       father.dash = '5,5';
    //       toolbox.renderFuncList()
    //     }
    //   }
    // ]
  },
  {
    key: "lineStyle",
    description: "用于重新设置线条样式",
    menu: {
      text: "线条样式",
      dom(self, pen) {
        let html = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="34px" height="34px" viewBox="0 0 34 34" version="1.1">
        <title>连线样式</title>
        <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
          <g id="未固定" transform="translate(-674.000000, -138.000000)">
            <g id="编组-2" transform="translate(253.000000, 135.000000)">
              <g id="连线颜色" transform="translate(421.000000, 3.000000)">
                <rect id="透明底图" fill-opacity="0" fill="#FFFFFF" x="0" y="0" width="34" height="34"/>
                <line x1="7.5" y1="17.5" x2="27.5" y2="17.5" id="直线-9" stroke="${self.color || pen.color}" stroke-dasharray="${self.dash}" stroke-width="${self.width}" stroke-linecap="round"/>
              </g>
            </g>
          </g>
        </g>
      </svg>`;
        return html;
      }
    },
    color: "#4D4DFF",
    lineStyle: "mind",
    width: 3,
    init(self, pen) {
      self.color = pen.mind.lineColor || pen.calculative.color || "#000000";
      self.lineStyle = pen.mind.lineStyle || meta2d.findOne(pen.mind.rootId).mind.lineStyle;
      self.width = meta2d.findOne(pen.mind.rootId).mind.lineWidth;
    },
    /**
     * @description 设置下拉框的样式，你也可以使用webComponent，或者将vue组件转换为webComponent
     * @param self 本配置对象
     * @param pen 返回当前pen对象
     * @param dom 返回此容器dom
     * */
    colorList: [
      "#f13097",
      "#5757F3",
      "#fa7878",
      "#8C8CFF",
      "#19f1cc",
      "#6ffd97",
      "#efe864",
      "#ff931a"
    ],
    shadowRoot: false,
    collapseEventOnMenu: false,
    openEventOnTitle: true,
    popupEvent: "mouseenter",
    collapseEvent: "click",
    collapseAnimate(self, pen, dom) {
      dom.style.transform = "scaleY(0)";
      return true;
    },
    popupAnimate(self, pen, dom) {
      dom.style.transform = "scaleY(1)";
      return true;
    },
    popup(self, pen) {
      let dom = createDom("div", {
        style: {
          display: "flex",
          flexDirection: "row",
          flexWrap: "wrap",
          transformOrigin: "top",
          boxSizing: "content-box",
          transition: "all .3s",
          justifyContent: "flex-start",
          position: "absolute",
          top: "40px",
          backgroundColor: "#fff",
          borderRadius: "5px",
          padding: "16px",
          width: "140px",
          boxShadow: "0px 6px 20px rgba(25,25,26,.06), 0px 2px 12px rgba(25,25,26,.04)"
        }
      });
      dom.attachShadow({ mode: "open" });
      let str = Scope(self, {
        template: `
          <div class="container">
                <div class="item">
                <div class="title">线条粗细</div>
                <div class="main">
                  <input type="range" min="1" max="10" style="width: 81px" onchange="sliderChange(this.value)" id="width" value="${self.width}">  <span id="t" style="display:block;vertical-align: top;margin-left: 10px;width: 41px;height: 20px;background-color:#f7f7f9;text-align: center;line-height: 20px">${self.width}</span>
                </div>
              </div>
            <div class="item">
                <div class="title">连线样式</div>
                <div class="main_style ">
                  <div class="style_item ${self.lineStyle === "mind" ? "style_active" : ""}" data-style="曲线" onclick="setLineStyle(true)">
                    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="50px" height="20px">
                  <g fill="none" stroke="black" stroke-width="1">
                    <path d="M0 9 a100,50 0 0,1 85,0"></path>
                  </g>
                </svg>
                  </div>
                  <div class="style_item ${self.lineStyle === "polyline" ? "style_active" : ""}" data-style="折线" onclick="setLineStyle(false)">
                     <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="50px" height="20px">
                    <g fill="none" stroke="black" stroke-width="1">
                      <path d="M0 4 l25 0 l0 12 l40 0"></path>
                    </g>
                  </svg>
                  </div>
                </div>
              </div>
              <div class="item">
                <div class="title">连线颜色
                <label for="color">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18px" height="17px" viewBox="0 0 18 17" version="1.1">
    <title>吸管</title>
    <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="未固定" transform="translate(-279.000000, -349.000000)" stroke="#818187">
            <g id="编组-6备份-2" transform="translate(208.000000, 188.000000)">
                <g id="吸管" transform="translate(72.062370, 161.000000)">
                    <g id="编组-8" transform="translate(7.937630, 8.095196) rotate(-315.000000) translate(-7.937630, -8.095196) translate(4.036351, 0.770971)">
                        <path d="M4.96179031,5.89679753 L4.96179031,10.0040546 C4.96179031,10.4930202 4.63081262,10.9045357 4.18105852,11.0275164 L4.18153455,13.8681947 L3.62149907,11.0275164 C3.17174496,10.9045357 2.84076728,10.4930202 2.84076728,10.0040546 L2.84076728,5.89679753 L4.96179031,5.89679753 Z" id="形状结合"/>
                        <path d="M3.90127879,0.5 C4.40959264,0.5 4.86978446,0.706034895 5.20289782,1.03914825 C5.53601117,1.37226161 5.74204607,1.83245343 5.74204607,2.34076728 L5.74204607,5.66776861 L2.06051152,5.66776861 L2.06051152,2.34076728 C2.06051152,1.83245343 2.26654641,1.37226161 2.59965977,1.03914825 C2.93277313,0.706034895 3.39296495,0.5 3.90127879,0.5 Z" id="形状结合"/>
                        <line x1="0.390127879" y1="5.78228307" x2="7.41242971" y2="5.78228307" id="直线-13" stroke-linecap="round"/>
                    </g>
                </g>
            </g>
        </g>
    </g>
</svg>
                  </div>
                  <input id="color" style="display: none" type="color" onchange="setColor(event,this.value)" value="${self.color}">
                </label>
                     <div class="main">

                     <div class="colorList" onclick="setColor(event)">
                     ${self.colorList.map((i, index) => `<span class="color_item ${self.color === i ? "active" : ""}" style="background-color: ${i};border: 3px solid ${i}" data-color="${i}"></span>`).join("")}
                     </div>
                </div>
              </div>
          </div>`,
        script: {
          sliderChange: (value) => {
            dom.shadowRoot.querySelector("#t").innerHTML = value;
            self.width = value;
            let root = meta2d.findOne(pen.mind.rootId);
            root.mind.lineWidth = value;
            mindBoxPlugin.resetLinesStyle(root);
            self.update("menu");
          },
          setLineStyle(value) {
            let res = value ? "mind" : "polyline";
            let root = meta2d.findOne(pen.mind.rootId);
            root.mind.lineStyle = res;
            mindBoxPlugin.resetLinesStyle(root);
            self.lineStyle = res;
            self.updateAll();
          },
          setColor(e, value) {
            var _a;
            let color = "";
            if (!value) {
              let t = e.target;
              let list = dom.shadowRoot.querySelector(".colorList");
              if (t === list)
                return;
              color = t.dataset.color;
            } else {
              color = value;
            }
            if (color === self.color) {
              color = "";
            }
            (_a = pen.connectedLines) == null ? void 0 : _a.forEach((i) => {
              meta2d.setValue({
                id: pen.id,
                "mind.lineColor": color
              }, { render: true });
            });
            self.color = color;
            mindBoxPlugin.resetLinesColor(pen, true);
            self.updateAll();
          }
        },
        style: `<style>
        .container {
            overflow: hidden;
        }
        .main {
            display: flex;
            flex-direction: row;
            justify-content: space-around;
            align-items: center;
        }
        .style_active{
            width: 30%;
            background-color:#fff;
            height: 20px;
            box-shadow: 0 0 5px 1px rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }
        .active{
            border: 3px solid deepskyblue !important;
        }
        .colorList {
            display: flex;
            justify-content: space-between;
            align-content: space-between;
            flex-wrap: wrap;
        }
        .main_style {
            display: flex;
            width: 100%;
            height: 30px;
            justify-content: space-around;
            align-items: center;
            border-radius: 3px;
            background-color:#f7f7f9;
        }
        .style_item {
            width:47%;
            height: 22px;
            display: flex;
            align-items: center;
            overflow: hidden;
            justify-content: center;
        }
        .color_item {
            width: 20px;
            height: 20px;
            border: 3px solid;
            margin: 5px 5px 5px 0;
            border-radius: 2px;
        }
        .color_item:hover {
            border: 3px solid rgba(128,128,128,0.5) !important;
        }
       .item {
          display:flex;
          justify-content: flex-start;
          align-items: flex-start;
          flex-direction: column;
          margin-bottom: 14px;
       }
       .title {
          width: 100%;
          height: 17px;
          font-size: 16px;
          display: flex;
          justify-content: flex-start;
          align-items: center;
          font-family: PingFang SC, PingFang SC-Regular;
          font-weight: 400;
          text-align: left;
          color: #7d7878;
          line-height: 17px;
          margin-bottom: 14px;
        }
    </style>
        `
      }, "string");
      let gap = createDom("div", {
        style: {
          width: "100%",
          height: "20px",
          backgroundColor: "red",
          position: "absolute",
          top: "-10px",
          opacity: 0
        }
      });
      dom.shadowRoot.innerHTML = str;
      dom.shadowRoot.appendChild(gap);
      return dom;
    },
    event: "mouseenter",
    func(self, pen, dom) {
      self.open = true;
    }
  },
  {
    key: "extra"
  },
  {
    key: "layoutDirection",
    description: "用于重新设置脑图基本设置",
    menu: {
      text: "基本设置",
      icon: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" t="1698740367149" class="icon" viewBox="0 0 1024 1024" version="1.1" p-id="13181" width="34" height="20"><path d="M914.752 292.608c26.112 0 47.232 21.12 47.232 47.296v577.088c0 26.112-21.12 47.232-47.232 47.232H110.4a47.232 47.232 0 0 1-47.296-47.232V339.904c0-26.112 21.12-47.296 47.296-47.296h804.352z m-6.72 54.016H117.12v563.648h790.848V346.624z" p-id="13182"/><path d="M957.44 484.992v64H62.08v-64z" p-id="13183"/><path d="M957.44 484.992v64H62.08v-64zM409.536 735.36l63.104-0.128 0.896 198.528-63.104 0.192zM561.472 600.32l63.168-0.064 0.832 333.568-63.232 0.128zM578.368 62.016c8.704 0 15.744 7.04 15.744 15.744v268.864H430.976V77.76c0-8.704 7.04-15.744 15.744-15.744h131.648z m-38.272 54.016h-55.04v176.64h55.04v-176.64z" p-id="13184"/></svg>'
    },
    direction: "right",
    childrenGap: 20,
    levelGap: 0,
    init(self, pen) {
      self.direction = pen.mind.direction;
      self.childrenGap = mindBoxPlugin.childrenGap;
      self.levelGap = mindBoxPlugin.levelGap;
      self.animate = mindBoxPlugin.animate;
      pen.locked = 0;
      self.status = self.animate ? "已开启" : "已关闭";
    },
    activeDirection(self, pen, dom) {
      let rootDom = dom.querySelector(".main");
      let divs = rootDom.querySelectorAll("div");
      let index = ["right", "left", "top", "bottom", "butterfly", "sandglass"].findIndex((i) => i === self.direction);
      if (index === -1)
        return;
      divs.forEach((i) => {
        i.querySelectorAll(".toolbox_direction_svg").forEach((i2) => {
          i2.setAttribute("fill", "#DDDDE1");
        });
        i.querySelectorAll(".toolbox_direction_svg_base").forEach((i2) => {
          i2.setAttribute("fill", "#F8F8FC");
        });
        i.querySelectorAll(".toolbox_direction_svg_line").forEach((i2) => {
          i2.setAttribute("stroke", "#818187");
        });
      });
      divs[index].querySelector(".toolbox_direction_svg_base").setAttribute("fill", "#CDCDFC");
      divs[index].querySelector(".toolbox_direction_svg_line").setAttribute("stroke", "#7878FF");
      divs[index].querySelectorAll(".toolbox_direction_svg").forEach((i) => i.setAttribute("fill", "#7878FF"));
    },
    popupEvent: "mouseenter",
    collapseEventOnMenu: false,
    // 是否在childrenDom中触发事件
    collapseEvent: "none",
    stopPropagation: true,
    animate: false,
    collapseAnimate(self, pen, dom) {
      dom.style.transform = "scaleY(0)";
      return true;
    },
    mounted(self, pen, dom) {
      self.activeDirection(self, pen, dom);
    },
    popupAnimate(self, pen, dom) {
      dom.style.transform = "scaleY(1)";
      return true;
    },
    onPopup(self, pen, dom) {
      self.activeDirection(self, pen, dom);
      self.childrenGap = mindBoxPlugin.childrenGap;
      self.levelGap = mindBoxPlugin.levelGap;
      pen.locked = 1;
    },
    onCollapse(self, pen) {
      pen.locked = 0;
    },
    status: "已开启",
    // 设置下拉列表的样式和子元素布局
    popup(self, pen) {
      let dom = createDom("div", {
        style: {
          display: "flex",
          flexDirection: "row",
          transformOrigin: "top",
          transition: "all .3s",
          flexWrap: "wrap",
          justifyContent: "flex-start",
          position: "absolute",
          top: "40px",
          backgroundColor: "#fff",
          borderRadius: "5px",
          padding: "16px",
          zIndex: 999,
          width: "170px",
          boxShadow: "0px 6px 20px rgba(25,25,26,.06), 0px 2px 12px rgba(25,25,26,.04)"
        },
        event: "",
        func: void 0,
        className: "root"
      });
      let str = Scope(self, {
        template: `
          <div class="container">
              <div class="item">
                <div class="title">布局方向</div>
                <div class="main" >
                    <div onclick="setDirection('right')" >
                        <svg class="main_item" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="76px" height="50px" viewBox="0 0 76 50" version="1.1">
                          <title>向右布局</title>
                         <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                              <g id="未固定" transform="translate(-633.000000, -684.000000)">
                                <g id="编组-6备份" transform="translate(525.000000, 423.000000)">
                                     <g id="布局备份-9" transform="translate(108.000000, 261.000000)">
                                          <rect class="toolbox_direction_svg_base" id="偷摸底图" fill="#F8F8FC" x="0" y="0" width="76" height="50" rx="2"/>
                                          <g id="编组-3" transform="translate(20.000000, 7.000000)">
                                              <line class="toolbox_direction_svg" x1="13.5" y1="18.5" x2="22.969697" y2="18.5" id="直线-12备份-2" stroke="#818187" stroke-linecap="round"/>
                                              <rect class="toolbox_direction_svg_line" id="矩形" stroke="#818187" x="0.5" y="15.5" width="13" height="5" rx="2"/>
                                              <path class="toolbox_direction_svg_line" d="M28,35 C22.4771525,35 18,27.836556 18,19 C18,10.163444 22.4771525,3 28,3" id="路径" stroke="#818187" stroke-linecap="round"/>
                                              <rect class="toolbox_direction_svg" id="矩形备份-11" fill="#DDDDE1" x="25" y="0" width="10" height="5" rx="2"/>
                                              <rect class="toolbox_direction_svg" id="矩形备份-12" fill="#DDDDE1" x="25" y="16" width="10" height="5" rx="2"/>
                                              <rect class="toolbox_direction_svg" id="矩形备份-13" fill="#DDDDE1" x="25" y="32" width="10" height="5" rx="2"/>
                                          </g>
                                      </g>
                                 </g>
                              </g>
                          </g>
                        </svg>
                    </div>

                    <div onclick="setDirection('left')"  >
                      <svg class="main_item" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="76px" height="50px" viewBox="0 0 76 50" version="1.1">
                          <title>向左布局</title>
                          <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                              <g id="未固定" transform="translate(-541.000000, -684.000000)">
                                  <g id="编组-6备份" transform="translate(525.000000, 423.000000)">
                                      <g id="布局备份-8" transform="translate(16.000000, 261.000000)">
                                          <rect class="toolbox_direction_svg_base" id="透明底图" fill="#F8F8FC" x="0" y="0" width="76" height="50" rx="2"/>
                                          <g id="编组-3" transform="translate(37.500000, 25.500000) scale(-1, 1) translate(-37.500000, -25.500000) translate(20.000000, 7.000000)">
                                             <line class="toolbox_direction_svg" x1="13.5" y1="18.5" x2="22.969697" y2="18.5" id="直线-12备份-2" stroke="#818187" stroke-linecap="round"/>
                                              <rect class="toolbox_direction_svg_line" id="矩形" stroke="#818187" x="0.5" y="15.5" width="13" height="5" rx="2"/>
                                              <path class="toolbox_direction_svg_line" d="M28,35 C22.4771525,35 18,27.836556 18,19 C18,10.163444 22.4771525,3 28,3" id="路径" stroke="#818187" stroke-linecap="round"/>
                                              <rect class="toolbox_direction_svg" id="矩形备份-11" fill="#DDDDE1" x="25" y="0" width="10" height="5" rx="2"/>
                                              <rect class="toolbox_direction_svg" id="矩形备份-12" fill="#DDDDE1" x="25" y="16" width="10" height="5" rx="2"/>
                                              <rect class="toolbox_direction_svg" id="矩形备份-13" fill="#DDDDE1" x="25" y="32" width="10" height="5" rx="2"/>
                                          </g>
                                      </g>
                                  </g>+
                              </g>
                          </g>
                      </svg>
                    </div>

                    <div onclick="setDirection('top')" >
                      <svg class="main_item" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="76px" height="50px" viewBox="0 0 76 50" version="1.1">
                        <title>向上布局</title>
                        <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                            <g id="未固定" transform="translate(-633.000000, -616.000000)">
                                <g id="编组-6备份" transform="translate(525.000000, 423.000000)">
                                    <g id="布局备份-7" transform="translate(108.000000, 193.000000)">
                                        <rect class="toolbox_direction_svg_base" id="透明底图" fill="#F8F8FC" x="0" y="0" width="76" height="50" rx="2"/>
                                        <g id="编组-3" transform="translate(38.000000, 25.250000) scale(1, -1) rotate(-270.000000) translate(-38.000000, -25.250000) translate(25.750000, 0.750000)">
                                            <line class="toolbox_direction_svg" x1="6.06363636" y1="25.5" x2="15.5333333" y2="25.5" id="直线-12备份-2" stroke="#818187" stroke-linecap="round"/>
                                            <rect class="toolbox_direction_svg_line" id="矩形" stroke="#818187" transform="translate(3.000000, 25.500000) rotate(-90.000000) translate(-3.000000, -25.500000) " x="-3.5" y="23" width="13" height="5" rx="2"/>
                                            <path class="toolbox_direction_svg_line" d="M17.8386311,43 C15.0303966,40.513797 13,33.3135934 13,24.8187892 C13,16.7047472 14.8524591,9.77185117 17.465812,7" id="路径" stroke="#818187" stroke-linecap="round"/>
                                            <rect class="toolbox_direction_svg" id="矩形备份-11" fill="#DDDDE1" transform="translate(22.000000, 44.000000) rotate(-90.000000) translate(-22.000000, -44.000000) " x="17" y="41.5" width="10" height="5" rx="2"/>
                                            <rect class="toolbox_direction_svg" id="矩形备份-12" fill="#DDDDE1" transform="translate(22.000000, 25.000000) rotate(-90.000000) translate(-22.000000, -25.000000) " x="17" y="22.5" width="10" height="5" rx="2"/>
                                            <rect class="toolbox_direction_svg" id="矩形备份-13" fill="#DDDDE1" transform="translate(22.000000, 5.000000) rotate(-90.000000) translate(-22.000000, -5.000000) " x="17" y="2.5" width="10" height="5" rx="2"/>
                                        </g>
                                    </g>
                                </g>
                            </g>
                        </g>
                      </svg>
                    </div>

                    <div onclick="setDirection('bottom')">
                      <svg class="main_item" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="76px" height="50px" viewBox="0 0 76 50" version="1.1">
                        <title>向下布局</title>
                        <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                           <g id="未固定" transform="translate(-725.000000, -480.000000)">
                                <g id="编组-6备份" transform="translate(525.000000, 423.000000)">
                                    <g id="布局备份-2" transform="translate(200.000000, 57.000000)">
                                        <rect class="toolbox_direction_svg_base" id="透明底图" fill="#F8F8FC" x="0" y="0" width="76" height="50" rx="2"/>
                                        <g id="编组-3" transform="translate(38.000000, 25.250000) rotate(-270.000000) translate(-38.000000, -25.250000) translate(25.750000, 0.750000)">
                                            <line x1="6.06363636" y1="25.5" x2="15.5333333" y2="25.5" id="直线-12备份-2" stroke="#818187" stroke-linecap="round"/>
                                            <rect class="toolbox_direction_svg_line" id="矩形" stroke="#818187" transform="translate(3.000000, 25.500000) rotate(-90.000000) translate(-3.000000, -25.500000) " x="-3.5" y="23" width="13" height="5" rx="2"/>
                                            <path class="toolbox_direction_svg_line" d="M17.8386311,43 C15.0303966,40.513797 13,33.3135934 13,24.8187892 C13,16.7047472 14.8524591,9.77185117 17.465812,7" id="路径" stroke="#818187" stroke-linecap="round"/>
                                            <rect class="toolbox_direction_svg" id="矩形备份-11" fill="#DDDDE1" transform="translate(22.000000, 44.000000) rotate(-90.000000) translate(-22.000000, -44.000000) " x="17" y="41.5" width="10" height="5" rx="2"/>
                                            <rect class="toolbox_direction_svg" id="矩形备份-12" fill="#DDDDE1" transform="translate(22.000000, 25.000000) rotate(-90.000000) translate(-22.000000, -25.000000) " x="17" y="22.5" width="10" height="5" rx="2"/>
                                            <rect class="toolbox_direction_svg" id="矩形备份-13" fill="#DDDDE1" transform="translate(22.000000, 5.000000) rotate(-90.000000) translate(-22.000000, -5.000000) " x="17" y="2.5" width="10" height="5" rx="2"/>
                                        </g>
                                   </g>
                                </g>
                            </g>
                        </g>
                      </svg>
                    </div>

                    <div onclick="setDirection('butterfly')">
                    <svg class="main_item" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="76px" height="50px" viewBox="0 0 76 50" version="1.1">
                      <title>蝶形布局</title>
                      <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                          <g id="未固定" transform="translate(-541.000000, -480.000000)">
                              <g id="编组-6备份" transform="translate(525.000000, 423.000000)">
                                  <g id="布局" transform="translate(16.000000, 57.000000)">
                                      <rect class="toolbox_direction_svg_base" id="透明底图" fill="#F8F8FC" x="0.5" y="0.5" width="76" height="50" rx="2"/>
                                      <g id="编组-3" transform="translate(10.000000, 7.000000)">
                                          <line x1="12.5" y1="18.5" x2="21.969697" y2="18.5" id="直线-12备份" stroke="#818187" stroke-linecap="round"/>
                                          <line x1="35.5" y1="18.5" x2="44.969697" y2="18.5" id="直线-12备份-2" stroke="#818187" stroke-linecap="round"/>
                                          <rect class="toolbox_direction_svg_line" id="矩形" stroke="#818187" x="22.5" y="15.5" width="13" height="5" rx="2"/>
                                          <rect class="toolbox_direction_svg" id="矩形备份-8" fill="#DDDDE1" x="0" y="0" width="10" height="5" rx="2"/>
                                          <rect class="toolbox_direction_svg" id="矩形备份-11" fill="#DDDDE1" x="47" y="0" width="10" height="5" rx="2"/>
                                          <rect class="toolbox_direction_svg" id="矩形备份-9" fill="#DDDDE1" x="0" y="16" width="10" height="5" rx="2"/>
                                          <rect class="toolbox_direction_svg" id="矩形备份-12" fill="#DDDDE1" x="47" y="16" width="10" height="5" rx="2"/>
                                          <rect class="toolbox_direction_svg" id="矩形备份-10" fill="#DDDDE1" x="0" y="32" width="10" height="5" rx="2"/>
                                          <rect class="toolbox_direction_svg" id="矩形备份-13" fill="#DDDDE1" x="47" y="32" width="10" height="5" rx="2"/>
                                          <path class="toolbox_direction_svg_line" d="M11,3 C18.5461417,3 24.8721456,8.22403061 26.5588129,15.2528929 M26.9076362,20.7292725 C26.0454005,28.7525241 19.2522884,35 11,35" id="形状" stroke="#818187" stroke-linecap="round"/>
                                          <path class="toolbox_direction_svg_line" d="M30,3 C37.6543889,3 44.0533839,8.37497993 45.6285232,15.5564778 M45.9076362,20.7292725 C45.0454005,28.7525241 38.2522884,35 30,35" id="形状" stroke="#818187" transform="translate(37.953818, 19.000000) scale(-1, 1) translate(-37.953818, -19.000000) "/>
                                      </g>
                                  </g>
                              </g>
                          </g>
                      </g>
                    </svg>
                    </div>

                    <div onclick="setDirection('sandglass')">
                    <svg class="main_item" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="76px" height="50px" viewBox="0 0 76 50" version="1.1">
                    <title>沙漏布局</title>
                    <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g id="未固定" transform="translate(-725.000000, -616.000000)">
                            <g id="编组-6备份" transform="translate(525.000000, 423.000000)">
                                <g id="编组-10" transform="translate(200.000000, 193.000000)">
                                    <rect class="toolbox_direction_svg_base" id="透明底图" fill="#F8F8FC" x="0" y="0" width="76" height="50" rx="2"/>
                                    <g id="编组-3" transform="translate(17.000000, 6.000000)">
                                        <g id="编组-9" transform="translate(0.000000, 0.000000)">
                                            <line x1="21.5" y1="7.5" x2="21.5" y2="16.5" id="直线-12备份" stroke="#818187" stroke-linecap="round"/>
                                            <rect class="toolbox_direction_svg" id="矩形备份-8" fill="#DDDDE1" x="0" y="0" width="10" height="5" rx="2"/>
                                            <rect class="toolbox_direction_svg" id="矩形备份-9" fill="#DDDDE1" x="16" y="0" width="10" height="5" rx="2"/>
                                            <rect class="toolbox_direction_svg" id="矩形备份-10" fill="#DDDDE1" x="32" y="0" width="10" height="5" rx="2"/>
                                            <path d="M15.5,-3.5 C20.402536,-3.5 24.6208608,0.196011148 26.5,5.5 M26.5,19.5 C24.5749169,24.8145404 20.3733294,28.5 15.5,28.5" id="形状" stroke="#818187" stroke-linecap="round" transform="translate(21.000000, 12.500000) rotate(-270.000000) translate(-21.000000, -12.500000) "/>
                                        </g>
                                        <g id="编组-9" transform="translate(21.000000, 29.000000) scale(1, -1) translate(-21.000000, -29.000000) translate(0.000000, 20.000000)">
                                            <line x1="21.5" y1="7.5" x2="21.5" y2="16.5" id="直线-12备份" stroke="#818187" stroke-linecap="round"/>
                                            <rect class="toolbox_direction_svg" id="矩形备份-8" fill="#DDDDE1" x="0" y="0" width="10" height="5" rx="2"/>
                                            <rect class="toolbox_direction_svg" id="矩形备份-9" fill="#DDDDE1" x="16" y="0" width="10" height="5" rx="2"/>
                                            <rect class="toolbox_direction_svg" id="矩形备份-10" fill="#DDDDE1" x="32" y="0" width="10" height="5" rx="2"/>
                                            <path d="M15.5,-3.5 C20.402536,-3.5 24.6208608,0.196011148 26.5,5.5 M26.5,19.5 C24.5749169,24.8145404 20.3733294,28.5 15.5,28.5" id="形状" stroke="#818187" stroke-linecap="round" transform="translate(21.000000, 12.500000) rotate(-270.000000) translate(-21.000000, -12.500000) "/>
                                        </g>
                                        <rect class="toolbox_direction_svg_line" id="矩形" stroke="#818187" x="14.5" y="16.5" width="13" height="5" rx="2"/>
                                    </g>
                                </g>
                            </g>
                        </g>
                    </g>
                </svg>
                    </div>
                </div>
              </div>

              <div class="item">
                <div class="title">间隔设置</div>
                <div class="main">
                    <div class="number_container">
                     <div class="number_item" onclick="(e=>{e.stopPropagation()})(event)">
                        <div class="flag">同级间隔</div>
                        <div class="number">
                            <input type="number" onchange="setChildGap(this.value)" value="${self.childrenGap}"/>
                        </div>
                    </div>
                     <div class="number_item" onclick="(e=>{e.stopPropagation()})(event)">
                        <div class="flag">子级间隔</div>
                        <div class="number">
                            <input type="number" onchange="setLevelGap(this.value)" value="${self.levelGap}"/>
                        </div>
                    </div>
                     <div class="number_item" onclick="(e=>{e.stopPropagation()})(event)">
                        <div class="flag">是否开启动画</div>
                        <div class="button">
                            <input type="button" onclick="setAnimate()" value="${self.status}"/>
                        </div>
                    </div>
                  </div>

                </div>
              </div>
          </div>`,
        script: {
          // 能在这里面获取到dom
          status: "已开启",
          setAnimate() {
            mindBoxPlugin.animate = !mindBoxPlugin.animate;
            pen.mind.mindboxOption.animate = mindBoxPlugin.animate;
            self.animate = mindBoxPlugin.animate;
            self.animate ? self.status = "已开启" : self.status = "已关闭";
            self.updateAll();
          },
          setChildGap(value) {
            self.childrenGap = value;
            mindBoxPlugin.childrenGap = value;
            pen.mind.mindboxOption.childrenGap = value;
            mindBoxPlugin.update(meta2d.findOne(pen.mind.rootId));
          },
          setLevelGap(value) {
            self.levelGap = value;
            mindBoxPlugin.levelGap = value;
            pen.mind.mindboxOption.levelGap = value;
            mindBoxPlugin.update(meta2d.findOne(pen.mind.rootId));
          },
          setDirection(e) {
            mindBoxPlugin.record(pen);
            let root = meta2d.findOne(pen.mind.rootId);
            mindBoxPlugin.resetLayOut(root, e, true);
            mindBoxPlugin.update(root);
            self.direction = e;
            self.activeDirection(self, pen, dom);
            self.close();
          }
        },
        style: `<style>
        .container {
            overflow: hidden;
        }
        .flag{
            font-size: 14px;
        }
        .number{
            height:30px;
            display: flex;
            border: 1px solid #f7f7f9;
            border-radius: 5px;
            justify-content: space-around;
            align-items: center;
            background-color: #f7f7f9;
        }
        .button {

        }
        .number_container{
            display: flex;
            width: 100%;
            justify-content: space-between;
            align-items: center;
            flex-direction: column;
        }
        .number_item{
            width: 100%;
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            margin-top: 14px;
        }
        .number input{
            width: 70px;
            height: 100%;
            outline: none;
            background-color:#f7f7f9;
            border: 1px solid #f7f7f9;
            border-radius: 5px;
            font-size: 16px;
            text-indent: 10px;
        }
        .number_control{
            width: 20%;
            display: flex;
            flex-direction: column;
            transform: translateY(-3px);
            margin-right: 6px;
        }
        .number_control_item{
            display:block;
            flex:1;
            font-size: 25px;
            width: 30px;
            height: 15px;
        }
        .number_control_item:hover {
            color: #484848;
        }
        .main {
            display: flex;
            flex-direction: row;
            width: 100%;
            flex-wrap: wrap;
            justify-content: space-around;
            align-content: center;
        }
        .main_item{
            margin-top: 5px;
        }
        .main_item:hover{
            outline: 3px solid rgba(87,87,243,0.51);
        }
        .active{
        }
       .item {
          display:flex;
          justify-content: flex-start;
          align-items: flex-start;
          flex-direction: column;
          margin-bottom: 14px;
       }
       .title {
          width: 100%;
          height: 17px;
          font-size: 16px;
          display: flex;
          justify-content: flex-start;
          align-items: center;
          font-family: PingFang SC, PingFang SC-Regular;
          font-weight: 400;
          text-align: left;
          color: #7d7878;
          line-height: 17px;
          margin-bottom: 14px;
        }
    </style>
        `
      }, "dom");
      dom.appendChild(str);
      return dom;
    }
  },
  {
    key: "addSiblingNode",
    description: "用于新增某节点的子级节点，默认位于该节点之下",
    menu: {
      text: "新增同级节点",
      img: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMzRweCIgaGVpZ2h0PSIzNHB4IiB2aWV3Qm94PSIwIDAgMzQgMzQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8dGl0bGU+5ZCM57qn6IqC54K5PC90aXRsZT4KICAgIDxkZWZzPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTEiIHg9IjkiIHk9IjgiIHdpZHRoPSIxNiIgaGVpZ2h0PSI3Ij48L3JlY3Q+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMiIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSIxNiIgaGVpZ2h0PSI3IiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgPC9kZWZzPgogICAgPGcgaWQ9Iumhtemdoi0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0i5Zu65a6aIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjkwLjAwMDAwMCwgLTI3LjAwMDAwMCkiPgogICAgICAgICAgICA8ZyBpZD0i57yW57uELTLlpIfku70iIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE4Mi4wMDAwMDAsIDI0LjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9IuWQjOe6p+iKgueCuSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTA4LjAwMDAwMCwgMy4wMDAwMDApIj4KICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0i6YCP5piO5bqV5Zu+IiBmaWxsLW9wYWNpdHk9IjAiIGZpbGw9IiNGRkZGRkYiIHg9IjAiIHk9IjAiIHdpZHRoPSIzNCIgaGVpZ2h0PSIzNCI+PC9yZWN0PgogICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSLnn6nlvaIiIHN0cm9rZT0iIzgxODE4NyIgeD0iOS41IiB5PSIxOC41IiB3aWR0aD0iMTUiIGhlaWdodD0iNiIgcng9IjEiPjwvcmVjdD4KICAgICAgICAgICAgICAgICAgICA8bGluZSB4MT0iMTciIHkxPSIxNSIgeDI9IjE3IiB5Mj0iMTgiIGlkPSLnm7Tnur8tNiIgc3Ryb2tlPSIjODE4MTg3IiBzdHJva2UtbGluZWNhcD0icm91bmQiPjwvbGluZT4KICAgICAgICAgICAgICAgICAgICA8dXNlIGlkPSLnn6nlvaLlpIfku70tNCIgc3Ryb2tlPSIjOUM5Q0E1IiBtYXNrPSJ1cmwoI21hc2stMikiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWRhc2hhcnJheT0iMiIgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg=="
    },
    // 监听事件名
    // event: 'click',
    /**
     * @description 事件对应的回调函数
     * @param self 返回该选项自身
     * @param pen 返回当前操作的pen对象
     * */
    // func: async (self,pen)=>{
    //   mindBoxPlugin.bottomChildren(pen,0);
    //   },
    popupEvent: "mouseenter",
    shadowRoot: false,
    collapseEventOnMenu: false,
    // 是否在childrenDom中触发事件
    stopPropagation: true,
    collapseAnimate(self, pen, dom) {
      dom.style.transformOrigin = "top";
      dom.style.transition = "all .3s";
      dom.style.transform = "scaleY(0)";
      return true;
    },
    popupAnimate(self, pen, dom) {
      dom.style.transform = "scaleY(1)";
      return true;
    },
    popup: [
      {
        menu: {
          name: "",
          icon: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" t="1698915834790" class="icon" viewBox="0 0 1365 1024" version="1.1" p-id="13181" width="50" height="30"><path d="M920.32924106 188.22098215H435.74469865c-178.43219866 0-323.49023438 145.05719866-323.49023438 323.49023436 0 178.43219866 145.05803572 323.49023438 323.49023438 323.49023439h484.58454241c178.43303572 0 323.49023438-145.05803572 323.49023437-323.49023439 0.14481026-178.28822544-144.91322544-323.49023438-323.49023437-323.49023436z m2.65345982 603.01339285H439.05440848c-145.05719866 0-281.40652902-137.4375-281.40652903-281.19475447 0-145.05803572 132.71735492-270.29966518 277.77455357-270.29966518h489.52064732c145.05803572 0 272.32700893 131.98995536 272.32700893 275.74720983 0 143.61328125-129.22935267 275.74720982-274.28738839 275.74720982z" p-id="13182"/></svg>'
        },
        event: "click",
        func(self, pen, dom, father) {
          let parent = meta2d.findOne(pen.mind.preNodeId);
          let index = parent.mind.children.indexOf(pen.id);
          mindBoxPlugin.addNode(parent, index + 1, "mindNode2", { width: 200, height: 50 });
          father.close();
        }
      },
      {
        menu: {
          name: "",
          icon: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" t="1698916220010" class="icon" viewBox="0 0 1024 1024" version="1.1" p-id="13326" width="50" height="30"><path d="M485.213 869.904c6.744 4.822 18.199 8.603 26.787 8.603 8.588 0 21.779-2.476 28.32-7.442l467.957-336.878c13.427-9.665 13.47-26.284 0-35.915l-469.49-335.716c-6.726-4.81-19.733-10.927-28.321-10.927-8.588 0-23.313 7.122-29.855 12.088L15.723 498.272c-13.43 9.664-13.47 26.284 0 35.915z m23.719-671.51l452.01 322.481L512 835.227 63.058 518.553z" p-id="13327"/></svg>'
        },
        event: "click",
        func(self, pen, dom, father) {
          let parent = meta2d.findOne(pen.mind.preNodeId);
          let index = parent.mind.children.indexOf(pen.id);
          mindBoxPlugin.addNode(parent, index + 1, "diamond", { width: 200, height: 120 });
          father.close();
        }
      },
      {
        menu: {
          name: "",
          icon: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="50px" height="30px" viewBox="0 0 140 53" version="1.1">\n    <title>椭圆形备份 12</title>\n    <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g id="未固定" transform="translate(-372.000000, -738.000000)" stroke="#000000" stroke-width="2">\n            <ellipse id="椭圆形备份-12" cx="442" cy="764.5" rx="69" ry="25.5"/>\n        </g>\n    </g>\n</svg>'
        },
        event: "click",
        func(self, pen, dom, father) {
          let parent = meta2d.findOne(pen.mind.preNodeId);
          let index = parent.mind.children.indexOf(pen.id);
          mindBoxPlugin.addNode(parent, index + 1, "circle", { width: 200, height: 75 });
          father.close();
        }
      }
    ]
  },
  {
    key: "changeName",
    menu: {
      icon: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="34px" height="34px" viewBox="0 0 34 34" version="1.1">\n    <title>节点类型</title>\n    <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g id="未固定" transform="translate(-434.000000, -138.000000)" fill="#818187" fill-rule="nonzero">\n            <g id="编组-2" transform="translate(253.000000, 135.000000)">\n                <g id="图元标记" transform="translate(181.000000, 3.000000)">\n                    <g id="编组-2" transform="translate(8.000000, 7.000000)">\n                        <path d="M1,5.29023514 C1.17996138,5.29023514 1.35658782,5.33879874 1.51125216,5.43080438 L8.81859469,9.77774525 C9.12163862,9.95801791 9.30734253,10.284566 9.30734253,10.637176 L9.30734253,19.1113447 C9.30734253,19.6636294 8.85962728,20.1113447 8.30734253,20.1113447 C8.13049278,20.1113447 7.95680621,20.0644449 7.80399333,19.9754278 L0.496650804,15.7187249 C0.189138547,15.5395916 0,15.2105245 0,14.8546418 L0,6.29023514 C0,5.73795039 0.44771525,5.29023514 1,5.29023514 Z M1,6.29023514 L1,14.8546418 L8.30734253,19.1113447 L8.30734253,10.637176 L1,6.29023514 Z" id="矩形"/>\n                        <path d="M9.13847274,5.15451573 C9.31746803,5.15451573 9.49318237,5.20255964 9.64727631,5.29363309 L16.9004891,9.58046661 C17.2049191,9.76039253 17.3916855,10.0877237 17.3916855,10.4413492 L17.3916855,19.1172325 C17.3916855,19.6695172 16.9439702,20.1172325 16.3916855,20.1172325 C16.21583,20.1172325 16.0430842,20.0708584 15.8908716,19.9827875 L8.63765889,15.7860475 C8.32871653,15.6072921 8.13847274,15.2774223 8.13847274,14.9204925 L8.13847274,6.15451573 C8.13847274,5.60223098 8.58618799,5.15451573 9.13847274,5.15451573 Z M9.13847274,6.15451573 L9.13847274,14.9204925 L16.3916855,19.1172325 L16.3916855,10.4413492 L9.13847274,6.15451573 Z" id="矩形" transform="translate(12.765079, 12.635874) scale(-1, 1) translate(-12.765079, -12.635874) "/>\n                        <path d="M9.23526615,0.136303242 L16.7563729,4.52525678 C17.2333795,4.80361472 17.3944161,5.41595868 17.1160581,5.89296528 C17.0252467,6.04858385 16.8940773,6.17677619 16.7364153,6.26399174 L9.24604725,10.4075176 C8.93653945,10.5787312 8.55960992,10.5737048 8.25477772,10.3942987 L0.733805872,5.96790268 C0.257836233,5.68777531 0.0990747117,5.07483757 0.379202089,4.59886793 C0.470610522,4.44355416 0.602291713,4.31582883 0.760320508,4.22919876 L8.25055366,0.123115448 C8.55835631,-0.0456193953 8.93209266,-0.0406141191 9.23526615,0.136303242 Z M8.73125451,1.0000001 L1.24102136,5.10608342 L8.76199321,9.53247945 L16.2523613,5.38895364 L8.73125451,1.0000001 Z" id="矩形备份-5" transform="translate(8.746693, 5.266240) scale(-1, 1) translate(-8.746693, -5.266240) "/>\n                    </g>\n                </g>\n            </g>\n        </g>\n    </g>\n</svg>'
    },
    description: "更改节点类型",
    popupEvent: "mouseenter",
    shadowRoot: false,
    // collapseEventOnMenu:true, // 是否在childrenDom中触发事件
    stopPropagation: true,
    collapseAnimate(self, pen, dom) {
      dom.style.transformOrigin = "top";
      dom.style.transition = "all .3s";
      dom.style.transform = "scaleY(0)";
      return true;
    },
    popupAnimate(self, pen, dom) {
      dom.style.transform = "scaleY(1)";
      return true;
    },
    popup: [
      {
        menu: {
          icon: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" t="1698915834790" class="icon" viewBox="0 0 1365 1024" version="1.1" p-id="13181" width="50" height="30"><path d="M920.32924106 188.22098215H435.74469865c-178.43219866 0-323.49023438 145.05719866-323.49023438 323.49023436 0 178.43219866 145.05803572 323.49023438 323.49023438 323.49023439h484.58454241c178.43303572 0 323.49023438-145.05803572 323.49023437-323.49023439 0.14481026-178.28822544-144.91322544-323.49023438-323.49023437-323.49023436z m2.65345982 603.01339285H439.05440848c-145.05719866 0-281.40652902-137.4375-281.40652903-281.19475447 0-145.05803572 132.71735492-270.29966518 277.77455357-270.29966518h489.52064732c145.05803572 0 272.32700893 131.98995536 272.32700893 275.74720983 0 143.61328125-129.22935267 275.74720982-274.28738839 275.74720982z" p-id="13182"/></svg>'
        },
        event: "click",
        name: "mindNode2",
        func(self, pen, dom, father) {
          pen.name = self.name;
          pen.calculative.name = self.name;
          meta2d.setValue({ id: pen.id, width: 200, height: 50 });
          father.close();
        }
      },
      {
        menu: {
          icon: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" t="1698916220010" class="icon" viewBox="0 0 1024 1024" version="1.1" p-id="13326" width="50" height="30"><path d="M485.213 869.904c6.744 4.822 18.199 8.603 26.787 8.603 8.588 0 21.779-2.476 28.32-7.442l467.957-336.878c13.427-9.665 13.47-26.284 0-35.915l-469.49-335.716c-6.726-4.81-19.733-10.927-28.321-10.927-8.588 0-23.313 7.122-29.855 12.088L15.723 498.272c-13.43 9.664-13.47 26.284 0 35.915z m23.719-671.51l452.01 322.481L512 835.227 63.058 518.553z" p-id="13327"/></svg>'
        },
        event: "click",
        name: "diamond",
        func(self, pen, dom, father) {
          pen.name = self.name;
          pen.calculative.name = self.name;
          meta2d.setValue({ id: pen.id, width: 200, height: 120 });
          father.close();
        }
      },
      {
        menu: {
          icon: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="50px" height="30px" viewBox="0 0 140 53" version="1.1">\n    <title>椭圆形备份 12</title>\n    <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g id="未固定" transform="translate(-372.000000, -738.000000)" stroke="#000000" stroke-width="2">\n            <ellipse id="椭圆形备份-12" cx="442" cy="764.5" rx="69" ry="25.5"/>\n        </g>\n    </g>\n</svg>'
        },
        event: "click",
        name: "circle",
        func(self, pen, dom, father) {
          pen.name = self.name;
          pen.calculative.name = self.name;
          meta2d.setValue({ id: pen.id, width: 200, height: 50 });
          father.close();
        }
      }
    ]
  }
  // {
  //   name:'button',
  //   event: 'click',
  //   func(){
  //   },
  //   popupEvent:'mouseenter',
  //   collapseEvent: 'mouseleave',
  //
  //  setChildrenDom(){
  //    // return '<ele-button></ele-button'
  //    return "<my-count name='caicai' onclick='(e)=>{e.stopPropagation()}' ></my-count>"
  //  },
  // }
];
var defaultFuncs = {
  funcList,
  getAllFuncDocs() {
    return defaultFuncs.funcList.filter((i) => i.menu).map((i) => ({
      name: i.menu.text || "暂无名称",
      key: i.key,
      description: i.description || "暂无描述"
    }));
  },
  getFunc(...key) {
    let result = [];
    if (Array.isArray(key)) {
      key.forEach((i) => {
        let func = defaultFuncs.funcList.find((j) => j.key === i);
        func ? result.push(func) : console.warn(`[defaultFuncs warn]：No matching options ${i}`);
      });
    }
    return result;
  }
};
var defaultFuncList = {
  "root": funcList.filter((i) => i.key !== "addSiblingNode" && i.key !== "changeName"),
  "leaf": defaultFuncs.getFunc("addChildNode", "addSiblingNode", "changeName", "extra", "relayout", "relayoutNext", "extra", "nodeStyle", "lineStyle")
};
var toolboxDefault = {
  offset: 80,
  showControl: true
};
var toolboxStyle = {
  backgroundColor: "#fff",
  borderRadius: "8px",
  boxShadow: "0px 6px 20px rgba(25,25,26,.06), 0px 2px 12px rgba(25,25,26,.04)",
  transform: "translateX(-50%)",
  position: "absolute",
  outline: "none",
  userSelect: "none",
  visibility: "visibility",
  zIndex: 999,
  height: "42px",
  display: "flex",
  flexDirection: "row",
  justifyContent: "center",
  alignItems: "center"
};
var funcListStyle = {
  boxSizing: "content-box",
  width: "max-content",
  height: "30px",
  padding: "6px",
  display: "flex",
  alignItems: "center"
};
var controlStyle = {
  minWidth: "30px",
  opacity: "0.5",
  display: "flex",
  cursor: "pointer",
  alignItems: "center",
  justifyContent: "center",
  zIndex: 99,
  height: "inherit",
  backgroundColor: "#efefef",
  flexDirection: "column",
  borderRadius: "5px 0 0 5px"
};
var extraStyle = {
  width: "1px",
  height: "60%",
  borderRadius: "5px",
  margin: "0 4px",
  backgroundColor: "rgba(18,17,42,.1)"
};
var basicFuncConfig = {
  collapseEventOnMenu: true,
  collapseEvent: "click",
  popupEvent: "mouseenter",
  shadowRoot: true
};
var default_default = {
  funcList,
  controlStyle,
  extraStyle,
  defaultFuncList,
  basicFuncConfig
};
var DefaultCssVar = {
  "--toolboxItem-hover-backgroundColor": "#eee",
  "--toolboxSliderItem-hover-backgroundColor": "#eee",
  "--toolbox-move-outLine": "solid 2px #8585ff"
};

// node_modules/@meta2d/plugin-mind-core/src/core/toolbox.js
var extra = "extra";
var cssVarMap = {
  itemHoverBackgroundColor: "--toolboxItem-hover-backgroundColor",
  boxMoveOutLine: "--toolbox-move-outLine"
};
var mouseMoved = false;
var controlDom = {
  control: null,
  show: true
};
var CONFIGS = ["showControl", "offset", "style", "active"];
function configValid(config) {
  if (config.key)
    return true;
  return false;
}
var _ToolBox = class _ToolBox {
  constructor(parentHtml, config = {}) {
    __publicField(this, "open", false);
    __publicField(this, "offset", 80);
    __publicField(this, "showControl", true);
    __publicField(this, "parentHtml");
    __publicField(this, "box", createDom("div", { style: { ...toolboxStyle, left: "-9999px" }, className: "toolBox" }));
    __publicField(this, "_funcDom");
    __publicField(this, "active", true);
    __publicField(this, "animate", false);
    __publicField(this, "curItem", null);
    __publicField(this, "_freezePos", false);
    if (!_ToolBox.instance) {
      _ToolBox.instance = this;
    } else {
      return _ToolBox.instance;
    }
    this.parentHtml = parentHtml;
    this._loadOptions(config);
    this._init();
    this.parentHtml.appendChild(this.box);
  }
  _loadOptions(config) {
    if (!isObjectLiteral(config) && !(config == null))
      return;
    config == null ? config = {} : "";
    for (const conf in toolboxDefault) {
      this[conf] = toolboxDefault[conf];
    }
    for (const conf in config) {
      if (CONFIGS.includes(conf)) {
        this[conf] = config[conf];
      } else {
      }
    }
    this.setStyle(config.style);
    this._setControl();
  }
  _init() {
    if (!this.active)
      return;
    this.box.id = "toolbox";
    this._setControl();
    let funcContainer = createDom("div", { style: funcListStyle, className: "toolbox_func" });
    this.box.appendChild(funcContainer);
    this._funcDom = funcContainer;
    let style = document.createElement("style");
    style.type = "text/css";
    document.head.appendChild(style);
    let stylesheet = style.sheet;
    stylesheet.insertRule(".toolbox_item,.toolbox_slider_item {display: flex;justify-content: center;align-items: center;height: 100%;margin: 0 1px;cursor: pointer;border-radius: 5px;margin: 0 5px;padding: 0 3px;}", 0);
    stylesheet.insertRule(".toolbox_item:hover {background-color: var(--toolboxItem-hover-backgroundColor);}", 0);
    stylesheet.insertRule(".toolbox_slider_item:hover {background-color: var(--toolboxSliderItem-hover-backgroundColor)}", 0);
    stylesheet.insertRule(`.toolbox_control_move {
            outline: var(--toolbox-move-outLine) !important;
        }`);
    this.setCssVar();
  }
  setCssVar(cssVar) {
    let cssVarObj;
    cssVar ? cssVarObj = cssVar : cssVarObj = DefaultCssVar;
    for (const key in cssVarObj) {
      document.documentElement.style.setProperty(key, cssVarObj[key]);
    }
  }
  _setControl() {
    if (this.showControl) {
      if (controlDom.show && controlDom.control)
        return;
      if (!controlDom.show && controlDom.control) {
        controlDom.show = true;
        controlDom.control.style.display = "flex";
        return;
      }
      let self = this;
      let control = createDom("div", { style: controlStyle, className: "toolbox_control" });
      let icon = Scope({ key: "toolbox" }, {
        template: `
<div style="display: flex;flex-direction: row">
<div style="display: flex;justify-content: center;align-items: center"><svg style="margin: 0 10px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="6px" height="14px" viewBox="0 0 6 14" version="1.1">
                                <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                                    <g id="未固定" transform="translate(-266.000000, -148.000000)" fill="#BCBCC4">
                                        <g id="编组-2" transform="translate(253.000000, 135.000000)">
                                            <g id="上级节点备份" transform="translate(13.000000, 13.000000)">
                                                <circle id="椭圆形" cx="1" cy="1" r="1"/>
                                                <circle id="椭圆形备份-11" cx="5" cy="1" r="1"/>
                                                <circle id="椭圆形备份-5" cx="1" cy="5" r="1"/>
                                                <circle id="椭圆形备份-8" cx="5" cy="5" r="1"/>
                                                <circle id="椭圆形备份-6" cx="1" cy="9" r="1"/>
                                                <circle id="椭圆形备份-9" cx="5" cy="9" r="1"/>
                                                <circle id="椭圆形备份-7" cx="1" cy="13" r="1"/>
                                                <circle id="椭圆形备份-10" cx="5" cy="13" r="1"/>
                                            </g>
                                        </g>
                                    </g>
                                </g>
                            </svg></div>
                           <div id="rivet" style="display: {{ rivetVisible }};margin: 0 10px 0 0;justify-content: center;align-items: center" onclick="toggleFreeze(false)">
                               <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="8px" height="16px" viewBox="0 0 8 16" version="1.1">
                                    <title>钉子</title>
                                    <g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                                        <g id="固定" transform="translate(-212.000000, -37.000000)" fill="#4D4DFF" fill-rule="nonzero">
                                            <g id="编组-2备份" transform="translate(182.000000, 24.000000)">
                                                <g id="固定,图钉" transform="translate(30.000000, 13.000000)">
                                                    <path d="M7.87291263,9.16048419 C7.77010858,9.29012105 7.61515755,9.36196798 7.45573678,9.36196798 L7.45126705,9.36196798 L4.82901885,9.3432253 L4.00658646,15.9500195 L4.0006268,16 L3.99466715,15.9500195 L3.17223476,9.3432253 L0.54998656,9.36196798 L0.545516831,9.36196798 C0.384606145,9.36196798 0.229655117,9.29012105 0.128340979,9.16048419 C0.0255369263,9.02928544 -0.00277143338,8.87465834 0.000208395526,8.73408825 C0.00616805333,8.52948067 0.0851334745,8.33424444 0.214755972,8.18117923 L1.13701259,7.0894182 C1.36645931,6.81764936 1.50651119,6.47559548 1.53332964,6.11323702 L1.83578213,2.20070284 C1.84472162,2.07887544 1.80300403,1.95704802 1.71956885,1.87114408 L1.14446216,1.26825459 C0.850949145,1.00741898 0.818171042,0.743459594 0.879257504,0.524795 C0.967162412,0.210855125 1.24726619,0 1.55865817,0 L1.56163799,0 L3.99466715,0.00780945312 L4.00658646,0.00780945312 L6.43961561,0 L6.44259544,0 C6.75398741,0 7.03409119,0.210855141 7.1219961,0.524795 C7.18308257,0.743459578 7.15030446,1.00741897 6.85679145,1.26825459 L6.28019484,1.87114408 C6.19675968,1.95860991 6.15504209,2.07887544 6.16398156,2.20070284 L6.46643406,6.11323702 C6.49474242,6.47559547 6.6333044,6.81764936 6.86275111,7.0894182 L7.78500772,8.18117923 C7.91463022,8.33424444 7.99210572,8.52948067 7.9995553,8.73408825 C8.00402504,8.87465834 7.97571668,9.02928544 7.87291263,9.16048419 Z" id="路径"/>
                                                </g>
                                            </g>
                                        </g>
                                    </g>
                                </svg>
                            </div>
                            </div>
                           `,
        script: {
          rivetVisible: "none",
          toggleFreeze(v) {
            if (mouseMoved)
              return;
            if (!v) {
              self.freezePos(false);
            }
            if (self._freezePos) {
              this.rivetVisible = "flex";
            } else {
              this.rivetVisible = "none";
              self.translateWithPen(self.pen);
            }
            this.$update();
          }
        }
      }, "dom");
      control.addEventListener("mouseup", () => {
        icon.expose.rivetVisible = "flex";
      });
      control.addEventListener("click", () => {
        icon.expose.$update();
      });
      control.appendChild(icon);
      control.id = "toolbox_control";
      this.box.appendChild(control);
      this._dragElement(control, icon);
      controlDom.control = control;
      controlDom.show = true;
    } else {
      if (controlDom.control) {
        controlDom.control.style.display = "none";
      }
      controlDom.show = false;
    }
  }
  setStyle(style) {
    this._setDefaultStyle();
    if (!style)
      return;
    Object.keys(style).forEach((i) => {
      if (i in cssVarMap) {
        this.setCssVar({
          // @ts-ignore
          [cssVarMap[i]]: style[i]
        });
        return;
      }
      this.box.style[i] = style[i];
    });
  }
  _setDefaultStyle() {
    Object.keys(toolboxStyle).forEach((i) => {
      this.box.style[i] = toolboxStyle[i];
    });
    this.setCssVar();
  }
  // 重写dom函数
  _rewriteDom(dom) {
    this.dom = dom;
    return dom;
  }
  hide() {
    this.box.style.display = "none";
    this.open = false;
  }
  bindPen(pen) {
    this.pen = pen;
  }
  show() {
    if (this.active) {
      this.box.style.display = "flex";
      this.open = true;
    }
  }
  destroy() {
    this.box.parentNode.removeChild(this.box);
  }
  freezePos(freeze) {
    this._freezePos = freeze;
  }
  translateWithPen(pen) {
    if (!pen)
      pen = this.pen;
    const store = pen.calculative.canvas.store;
    const worldRect = pen.calculative.worldRect;
    let pos = {
      x: worldRect.x + store.data.x + worldRect.width / 2 + "px",
      y: worldRect.y + store.data.y + -this.offset + "px"
    };
    this.translatePosition(pos);
  }
  translatePosition(pos) {
    if (this._freezePos) {
      if (!this.animate)
        this.show();
      return;
    }
    if (!this.animate)
      this.hide();
    this.box.style.left = pos.x;
    this.box.style.top = pos.y;
    if (!this.animate)
      this.show();
  }
  renderFuncList() {
    if (!this.active)
      return;
    const fragmentChild = new DocumentFragment();
    this._funcDom.innerHTML = "";
    this.funcList.forEach((i) => {
      preprocess(i, this.pen);
      const extraEle = extraElement(i);
      if (extraEle) {
        fragmentChild.appendChild(extraEle);
        return;
      }
      if (configValid(i)) {
        let itemsSpan = this.setChildDom(this.pen, i);
        itemsSpan.className = "toolbox_item";
        fragmentChild.appendChild(itemsSpan);
      }
    });
    this._funcDom.appendChild(fragmentChild);
  }
  /**
   * @description 创造子节点  设置样式 配置事件函数等；
   * @param pen 操作的图元
   * @param item 该toolItem配置项 包含 显示name 事件event 回调函数func 和该按钮的样式style 与setDom自定义样式
   * */
  setChildDom(pen, item) {
    const dom = document.createElement("div");
    item.update = (target, keepOpen = true) => {
      var _a;
      if (target === "menu") {
        renderTitle(item, pen, dom.titleDom);
        return;
      } else if (target === "popup") {
        renderChildDom(item, pen, dom, dom.childrenDom, keepOpen);
        return;
      }
      renderInit(item, pen, dom);
      (_a = item.init) == null ? void 0 : _a.call(item, item, pen);
      let title = createDom("div", { className: "toolbox_title" });
      title = renderTitle(item, pen, title);
      item.dom = dom;
      item.dom.titleDom = title;
      if (item.popup) {
        let openFunc = () => {
          var _a2, _b;
          if (toolbox.curItem !== item) {
            toolbox.funcList.filter((i) => i.isOpen).forEach((i) => {
              i.close();
            });
          }
          if (toolbox.curItem === item && item.isOpen)
            return;
          ((_a2 = item.popupAnimate) == null ? void 0 : _a2.call(item, item, pen, item.dom.childrenDom)) || item.dom.childrenDom && (item.dom.childrenDom.style.visibility = "visible");
          (_b = item.onPopup) == null ? void 0 : _b.call(item, item, pen, item.dom.childrenDom);
          item.isOpen = true;
          toolbox.curItem = item;
        };
        title["on" + (item.popupEvent || basicFuncConfig.popupEvent)] = openFunc;
      }
      item.shadowRoot ? dom.shadowRoot.appendChild(title) : dom.appendChild(title);
      let containerDom = null;
      renderChildDom(item, pen, dom, containerDom);
    };
    item.updateAll = (keepOpen = true) => {
      item.update("menu");
      item.update("popup", keepOpen);
    };
    item.update();
    return dom;
  }
  setFuncList(funcList2) {
    if (!this.active)
      return;
    this.funcList = funcList2;
    this.renderFuncList();
  }
  // 点击控制按钮事件
  onControlClick() {
  }
  // 移动控制按钮事件
  onControlMove() {
    this.box.classList.add("toolbox_control_move");
    this.closeAll();
  }
  onControlUp() {
    this.box.classList.remove("toolbox_control_move");
  }
  closeAll() {
    toolbox.funcList.filter((i) => i.isOpen).forEach((i) => {
      i.close();
    });
  }
  clearFuncList() {
    this.setFuncList([]);
  }
  _dragElement(control, icon) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    control.onmousedown = dragMouseDown;
    let self = this;
    function dragMouseDown(e) {
      var _a;
      e = e || window.event;
      e.preventDefault();
      pos3 = e.clientX;
      pos4 = e.clientY;
      (_a = self.onControlClick) == null ? void 0 : _a.call(self);
      document.addEventListener("mouseup", closeDragElement);
      document.addEventListener("mousemove", elementDrag);
    }
    function elementDrag(e) {
      var _a;
      e = e || window.event;
      e.preventDefault();
      mouseMoved = true;
      pos1 = pos3 - e.clientX;
      pos2 = pos4 - e.clientY;
      pos3 = e.clientX;
      pos4 = e.clientY;
      (_a = self.onControlMove) == null ? void 0 : _a.call(self);
      self.freezePos(true);
      self.box.style.top = self.box.offsetTop - pos2 + "px";
      self.box.style.left = self.box.offsetLeft - pos1 + "px";
    }
    function closeDragElement() {
      var _a;
      (_a = self.onControlUp) == null ? void 0 : _a.call(self);
      mouseMoved = false;
      document.removeEventListener("mouseup", closeDragElement);
      document.removeEventListener("mousemove", elementDrag);
    }
  }
};
__publicField(_ToolBox, "instance");
var ToolBox = _ToolBox;
function renderInit(item, pen, dom) {
  if (dom.shadowRoot) {
    dom.shadowRoot.innerHTML = "";
  } else {
    item.shadowRoot ? dom.attachShadow({ mode: "open" }) : dom.innerHTML = "";
  }
  if (item.event) {
    let eventFunc = function(e) {
      if (item.closeOther) {
        toolbox.funcList.filter((i) => i.isOpen).forEach((i) => {
          i.close();
        });
      }
      item.func(item, this, dom, e);
    };
    dom.addEventListener(item.event, eventFunc.bind(pen));
  }
  return dom;
}
function renderTitle(item, pen, title) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  title.innerHTML = "";
  if (typeof ((_a = item.menu) == null ? void 0 : _a.dom) === "function") {
    let re = (_b = item.menu) == null ? void 0 : _b.dom(item, pen, title);
    switch (typeof re) {
      case "string":
        title.innerHTML = re;
        break;
      case "object":
        title.appendChild(re);
        break;
      default:
        throw new Error("function setDom must return string or node object");
    }
  } else {
    title.innerHTML = ((_c = item.menu) == null ? void 0 : _c.icon) ? (_d = item.menu) == null ? void 0 : _d.icon : ((_e = item.menu) == null ? void 0 : _e.img) ? `<img src="${(_f = item.menu) == null ? void 0 : _f.img}" title="${((_g = item.menu) == null ? void 0 : _g.text) || "图标"}" />` : (_h = item.menu) == null ? void 0 : _h.text;
  }
  return title;
}
function renderChildDom(item, pen, dom, containerDom, keepOpen = false) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
  if (dom.childrenDom)
    dom.shadowRoot ? dom.shadowRoot.removeChild(dom.childrenDom) : dom.removeChild(dom.childrenDom);
  if (item.popup) {
    if (typeof item.popup === "function") {
      let childDom = item.popup(item, pen, dom);
      if (typeof childDom === "string") {
        let div = document.createElement("div");
        if (typeof keepOpen === "boolean") {
          keepOpen ? ((_a = item.popupAnimate) == null ? void 0 : _a.call(item, item, pen, item.dom.childrenDom)) || (div.style.visibility = "visible") : ((_b = item.collapseAnimate) == null ? void 0 : _b.call(item, item, pen, div)) || (div.style.visibility = "hidden");
        }
        div.innerHTML = childDom;
        dom.shadowRoot ? dom.shadowRoot.appendChild(div) : dom.appendChild(div);
        containerDom = div;
      } else {
        containerDom = childDom;
        if (typeof keepOpen == "boolean") {
          keepOpen ? ((_c = item.popupAnimate) == null ? void 0 : _c.call(item, item, pen, item.dom.childrenDom)) || (childDom.style.visibility = "visible") : ((_d = item.collapseAnimate) == null ? void 0 : _d.call(item, item, pen, childDom)) || (childDom.style.visibility = "hidden");
        }
      }
    } else {
      containerDom = createDom("div", {
        style: {
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          position: "absolute",
          top: "40px",
          backgroundColor: "#fff",
          borderRadius: "5px",
          padding: "3px",
          width: "max-content",
          boxShadow: "0px 6px 20px rgba(25,25,26,.06), 0px 2px 12px rgba(25,25,26,.04)"
        }
      });
      let gap = createDom("div", {
        style: {
          position: "absolute",
          height: "10px",
          bottom: "-10px",
          backgroundColor: "#eee",
          width: "100%",
          opacity: 0
        },
        className: "toolbox_gap"
      });
      dom.shadowRoot ? dom.shadowRoot.appendChild(gap) : dom.appendChild(gap);
      if (typeof keepOpen === "boolean") {
        keepOpen ? ((_e = item.popupAnimate) == null ? void 0 : _e.call(item, item, pen, containerDom)) || (containerDom.style.visibility = "visible") : ((_f = item.collapseAnimate) == null ? void 0 : _f.call(item, item, pen, containerDom)) || (containerDom.style.visibility = "hidden");
      }
    }
    if (Array.isArray(item.popup)) {
      let fragment = new DocumentFragment();
      for (let i of item.popup || []) {
        let node = createDom("div", {
          style: {
            margin: "5px 8px"
          },
          event: i.event,
          func: (function(e) {
            i.stopPropagation ? e.stopPropagation() : "";
            i.func(i, this, dom, item, e);
          }).bind(pen),
          className: "toolbox_slider_item"
        });
        (_g = i.init) == null ? void 0 : _g.call(i, i, pen, node);
        if ((_h = i.menu) == null ? void 0 : _h.dom) {
          let re = (_i = i.menu) == null ? void 0 : _i.dom(i, pen, node);
          switch (typeof re) {
            case "string":
              node.innerHTML = re;
              break;
            case "object":
              node.appendChild(re);
              break;
            default:
              throw new Error("function setDom must return string or node object");
          }
        } else {
          node.innerHTML = ((_j = i.menu) == null ? void 0 : _j.icon) && ((_k = i.menu) == null ? void 0 : _k.text) || ((_l = i.menu) == null ? void 0 : _l.img) && ((_m = i.menu) == null ? void 0 : _m.text) ? '<span style="padding-right: 30px;width: max-content" >' + (((_n = i.menu) == null ? void 0 : _n.icon) || `<img src="${(_o = i.menu) == null ? void 0 : _o.img}"/>`) + "</span> <span>" + ((_p = i.menu) == null ? void 0 : _p.text) + "</span>" : "<span>" + (((_q = i.menu) == null ? void 0 : _q.text) || ((_r = i.menu) == null ? void 0 : _r.icon)) + "</span>";
        }
        fragment.appendChild(node);
      }
      containerDom == null ? void 0 : containerDom.appendChild(fragment);
    }
    dom.style.position = "relative";
    containerDom.classList.add("toolbox_container");
    containerDom.style.position = "absolute";
    (_s = item.mounted) == null ? void 0 : _s.call(item, item, pen, containerDom);
    item.shadowRoot ? dom.shadowRoot.appendChild(containerDom) : dom.appendChild(containerDom);
    dom.childrenDom = containerDom;
  }
  if (item.popup || item.closeOther) {
    if (!item.closeOther) {
      (item.collapseEventOnMenu ?? basicFuncConfig.collapseEventOnMenu ? item.dom.titleDom : dom.childrenDom)["on" + (item.collapseEvent || basicFuncConfig.collapseEvent)] = () => {
        dom.offsetHeight;
        item.close();
        toolbox.curItem = null;
      };
    }
  }
  return containerDom;
}
function preprocess(item, pen) {
  if (item.key === extra)
    return;
  if (item.shadowRoot == null) {
    item.shadowRoot = basicFuncConfig.shadowRoot;
  }
  if (item.popup) {
    item.isOpen = false;
    item.closeOther = false;
    item.close = () => {
      var _a, _b;
      if (!item.isOpen)
        return;
      ((_a = item.collapseAnimate) == null ? void 0 : _a.call(item, item, pen, item.dom.childrenDom)) || item.dom.childrenDom && (item.dom.childrenDom.style.visibility = "hidden");
      item.isOpen = false;
      (_b = item.onCollapse) == null ? void 0 : _b.call(item, item, pen, item.dom.childrenDom);
    };
    item.open = () => {
      var _a, _b;
      if (item.isOpen)
        return;
      ((_a = item.popupAnimate) == null ? void 0 : _a.call(item, item, pen, item.dom.childrenDom)) || item.dom.childrenDom && (item.dom.childrenDom.style.visibility = "visible");
      item.isOpen = true;
      (_b = item.onPopup) == null ? void 0 : _b.call(item, item, pen.item.dom.childrenDom);
    };
  }
}
function extraElement(config) {
  if (config.key === extra) {
    let node;
    let style = deepMerge(default_default.extraStyle, config.style);
    if (typeof config.dom === "function") {
      node = config.dom();
    } else {
      node = createDom("div", { style });
    }
    return node;
  }
}

// node_modules/@meta2d/plugin-mind-core/src/layout/right.js
function right(pen, recursion = true) {
  var _a, _b, _c, _d, _e, _f;
  pen.mind.direction = "right";
  let childrenGap = mindBoxPlugin.childrenGap;
  let levelGap = mindBoxPlugin.levelGap;
  let children = pen.mind.children || [];
  let worldReact = meta2d.getPenRect(pen);
  let topHeight = 0;
  let topWidth = 0;
  mindBoxPlugin.calcChildWandH(pen);
  for (let i = 0; i < children.length; i++) {
    let child = meta2d.store.pens[children[i]];
    if (!child)
      continue;
    let childRect = meta2d.getPenRect(child);
    topHeight += (((_b = (_a = meta2d.store.pens[children[i - 1]]) == null ? void 0 : _a.mind) == null ? void 0 : _b.maxHeight) || 0) + (meta2d.store.pens[children[i - 1]] ? +childrenGap : 0);
    topWidth += (((_d = (_c = meta2d.store.pens[children[i - 1]]) == null ? void 0 : _c.mind) == null ? void 0 : _d.maxWidth) || 0) + (meta2d.store.pens[children[i - 1]] ? +childrenGap : 0);
    child.mind.connect = right.connectRule(pen, child);
    child.mind.x = worldReact.x + worldReact.width + +levelGap;
    if (worldReact.height > pen.mind.childHeight) {
      child.mind.y = worldReact.y + 1 / 2 * pen.mind.maxHeight + topHeight - 1 / 2 * pen.mind.childHeight + (((_e = child.mind) == null ? void 0 : _e.maxHeight) / 2 - 1 / 2 * childRect.height || 0);
    } else {
      child.mind.y = worldReact.y - 1 / 2 * pen.mind.maxHeight + topHeight + 1 / 2 * worldReact.height + (((_f = child.mind) == null ? void 0 : _f.maxHeight) / 2 - 1 / 2 * childRect.height || 0);
    }
    meta2d.setValue({
      id: child.id,
      x: child.mind.x,
      y: child.mind.y
    }, { render: false });
    if (recursion)
      right(child, true);
  }
}
right.connectRule = (pen, child) => {
  return {
    from: pen.id,
    to: child.id,
    startIndex: 1,
    fromAnchor: pen.anchors[1],
    endIndex: 3,
    toAnchor: child.anchors[3]
  };
};

// node_modules/@meta2d/plugin-mind-core/src/layout/left.js
function left(pen, recursion = true) {
  var _a, _b, _c, _d, _e, _f;
  pen.mind.direction = "left";
  let childrenGap = mindBoxPlugin.childrenGap;
  let levelGap = mindBoxPlugin.levelGap;
  let children = pen.mind.children || [];
  let worldReact = meta2d.getPenRect(pen);
  let topHeight = 0;
  let topWidth = 0;
  mindBoxPlugin.calcChildWandH(pen);
  for (let i = 0; i < children.length; i++) {
    let child = meta2d.store.pens[children[i]];
    if (!child)
      continue;
    let childRect = meta2d.getPenRect(child);
    topHeight += (((_b = (_a = meta2d.store.pens[children[i - 1]]) == null ? void 0 : _a.mind) == null ? void 0 : _b.maxHeight) || 0) + (meta2d.store.pens[children[i - 1]] ? +childrenGap : 0);
    topWidth += (((_d = (_c = meta2d.store.pens[children[i - 1]]) == null ? void 0 : _c.mind) == null ? void 0 : _d.maxWidth) || 0) + (meta2d.store.pens[children[i - 1]] ? +childrenGap : 0);
    child.mind.connect = left.connectRule(pen, child);
    child.mind.x = worldReact.x - childRect.width - +levelGap;
    if (worldReact.height > pen.mind.childHeight) {
      child.mind.y = worldReact.y + 1 / 2 * pen.mind.maxHeight + topHeight - 1 / 2 * pen.mind.childHeight + (((_e = child.mind) == null ? void 0 : _e.maxHeight) / 2 - 1 / 2 * childRect.height || 0);
    } else {
      child.mind.y = worldReact.y - 1 / 2 * pen.mind.maxHeight + topHeight + 1 / 2 * worldReact.height + (((_f = child.mind) == null ? void 0 : _f.maxHeight) / 2 - 1 / 2 * childRect.height || 0);
    }
    meta2d.setValue({
      id: child.id,
      x: child.mind.x,
      y: child.mind.y,
      color: child.mind.color
    }, { render: false });
    if (recursion)
      left(child, true);
  }
}
left.connectRule = (pen, child) => {
  return {
    from: pen.id,
    to: child.id,
    startIndex: 3,
    fromAnchor: pen.anchors[3],
    endIndex: 1,
    toAnchor: child.anchors[1]
  };
};

// node_modules/@meta2d/plugin-mind-core/src/layout/top.js
function top(pen, recursion = true) {
  var _a, _b, _c, _d, _e, _f;
  pen.mind.direction = "top";
  let childrenGap = mindBoxPlugin.childrenGap;
  let levelGap = mindBoxPlugin.levelGap;
  let children = pen.mind.children;
  let worldReact = meta2d.getPenRect(pen);
  let topHeight = 0;
  let topWidth = 0;
  mindBoxPlugin.calcChildWandH(pen);
  for (let i = 0; i < children.length; i++) {
    let child = meta2d.store.pens[children[i]];
    if (!child)
      continue;
    let childRect = meta2d.getPenRect(child);
    topHeight += (((_b = (_a = meta2d.store.pens[children[i - 1]]) == null ? void 0 : _a.mind) == null ? void 0 : _b.maxHeight) || 0) + (meta2d.store.pens[children[i - 1]] ? +childrenGap : 0);
    topWidth += (((_d = (_c = meta2d.store.pens[children[i - 1]]) == null ? void 0 : _c.mind) == null ? void 0 : _d.maxWidth) || 0) + (meta2d.store.pens[children[i - 1]] ? +childrenGap : 0);
    child.mind.connect = top.connectRule(pen, child);
    if (worldReact.width > pen.mind.childWidth) {
      child.mind.x = worldReact.x + 1 / 2 * pen.mind.maxWidth + topWidth - 1 / 2 * pen.mind.childWidth + (((_e = child.mind) == null ? void 0 : _e.maxWidth) / 2 - 1 / 2 * childRect.width || 0);
    } else {
      child.mind.x = worldReact.x - 1 / 2 * pen.mind.maxWidth + topWidth + 1 / 2 * worldReact.width + (((_f = child.mind) == null ? void 0 : _f.maxWidth) / 2 - 1 / 2 * childRect.width || 0);
    }
    child.mind.y = worldReact.y - 1 / 2 * meta2d.getPenRect(child).height - +levelGap;
    meta2d.setValue({
      id: child.id,
      x: child.mind.x,
      y: child.mind.y,
      color: child.mind.color
    }, { render: false });
    if (recursion)
      top(child, true);
  }
}
top.connectRule = (pen, child) => {
  return {
    from: pen.id,
    to: child.id,
    startIndex: 0,
    fromAnchor: pen.anchors[0],
    endIndex: 2,
    toAnchor: child.anchors[2]
  };
};

// node_modules/@meta2d/plugin-mind-core/src/layout/bottom.js
function bottom(pen, recursion = true) {
  var _a, _b, _c, _d, _e, _f;
  pen.mind.direction = "bottom";
  let childrenGap = mindBoxPlugin.childrenGap;
  let levelGap = mindBoxPlugin.levelGap;
  let children = pen.mind.children || [];
  let worldReact = meta2d.getPenRect(pen);
  let topHeight = 0;
  let topWidth = 0;
  mindBoxPlugin.calcChildWandH(pen);
  for (let i = 0; i < children.length; i++) {
    let child = meta2d.store.pens[children[i]];
    let childRect = meta2d.getPenRect(child);
    topHeight += (((_b = (_a = meta2d.store.pens[children[i - 1]]) == null ? void 0 : _a.mind) == null ? void 0 : _b.maxHeight) || 0) + (meta2d.store.pens[children[i - 1]] ? +childrenGap : 0);
    topWidth += (((_d = (_c = meta2d.store.pens[children[i - 1]]) == null ? void 0 : _c.mind) == null ? void 0 : _d.maxWidth) || 0) + (meta2d.store.pens[children[i - 1]] ? +childrenGap : 0);
    child.mind.connect = bottom.connectRule(pen, child);
    if (worldReact.width > pen.mind.childWidth) {
      child.mind.x = worldReact.x + 1 / 2 * pen.mind.maxWidth + topWidth - 1 / 2 * pen.mind.childWidth + (((_e = child.mind) == null ? void 0 : _e.maxWidth) / 2 - 1 / 2 * childRect.width || 0);
    } else {
      child.mind.x = worldReact.x - 1 / 2 * pen.mind.maxWidth + topWidth + 1 / 2 * worldReact.width + (((_f = child.mind) == null ? void 0 : _f.maxWidth) / 2 - 1 / 2 * childRect.width || 0);
    }
    child.mind.y = worldReact.y + worldReact.height - 1 / 2 * meta2d.getPenRect(child).height + +levelGap;
    meta2d.setValue({
      id: child.id,
      x: child.mind.x,
      y: child.mind.y,
      color: child.mind.color
    }, { render: false });
    if (recursion)
      bottom(child, true);
  }
}
bottom.connectRule = (pen, child) => {
  return {
    from: pen.id,
    to: child.id,
    startIndex: 2,
    fromAnchor: pen.anchors[2],
    endIndex: 0,
    toAnchor: child.anchors[0]
  };
};

// node_modules/@meta2d/plugin-mind-core/src/layout/butterfly.js
function butterfly(pen, recursion = true) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  pen.mind.direction = "butterfly";
  let childrenGap = mindBoxPlugin.childrenGap;
  let levelGap = mindBoxPlugin.levelGap;
  let children = JSON.parse(JSON.stringify(pen.mind.children || []));
  let worldReact = meta2d.getPenRect(pen);
  let topHeight = 0;
  let topWidth = 0;
  let rightChildren = pen.mind.children.splice(0, butterfly.MAXLENGTH);
  let leftChildren = pen.mind.children;
  pen.mind.children = rightChildren;
  mindBoxPlugin.calcChildWandH(pen);
  for (let i = 0; i < children.length; i++) {
    let child = meta2d.store.pens[children[i]];
    if (!child)
      continue;
    let childRect = meta2d.getPenRect(child);
    if (i < butterfly.MAXLENGTH) {
      topHeight += (((_b = (_a = meta2d.store.pens[children[i - 1]]) == null ? void 0 : _a.mind) == null ? void 0 : _b.maxHeight) || 0) + (meta2d.store.pens[children[i - 1]] ? +childrenGap : 0);
      topWidth += (((_d = (_c = meta2d.store.pens[children[i - 1]]) == null ? void 0 : _c.mind) == null ? void 0 : _d.maxWidth) || 0) + (meta2d.store.pens[children[i - 1]] ? +childrenGap : 0);
      child.mind.connect = butterfly.connectRule(pen, child, i);
      child.mind.x = worldReact.x + worldReact.width + +levelGap;
      child.mind.y = worldReact.y - 1 / 2 * pen.mind.maxHeight + topHeight + 1 / 2 * worldReact.height + (((_e = child.mind) == null ? void 0 : _e.maxHeight) / 2 - 1 / 2 * childRect.height || 0);
      meta2d.setValue({
        id: child.id,
        x: child.mind.x,
        y: child.mind.y,
        color: child.mind.color
      }, { render: false });
      if (recursion)
        right(child, recursion);
      if (i === butterfly.MAXLENGTH - 1) {
        topHeight = 0;
        topWidth = 0;
        pen.mind.children = leftChildren;
        mindBoxPlugin.calcChildWandH(pen);
      }
    } else {
      topHeight += (((_g = (_f = meta2d.store.pens[children[i - 1]]) == null ? void 0 : _f.mind) == null ? void 0 : _g.maxHeight) || 0) + (meta2d.store.pens[children[i - 1]] ? +childrenGap : 0);
      topWidth += (((_i = (_h = meta2d.store.pens[children[i - 1]]) == null ? void 0 : _h.mind) == null ? void 0 : _i.maxWidth) || 0) + (meta2d.store.pens[children[i - 1]] ? +childrenGap : 0);
      if (i === butterfly.MAXLENGTH) {
        topHeight = 0;
        topWidth = 0;
      }
      child.mind.connect = butterfly.connectRule(pen, child, i);
      child.mind.x = worldReact.x - childRect.width - +levelGap;
      child.mind.y = worldReact.y - 1 / 2 * pen.mind.maxHeight + topHeight + 1 / 2 * worldReact.height + (((_j = child.mind) == null ? void 0 : _j.maxHeight) / 2 - 1 / 2 * childRect.height || 0);
      meta2d.setValue({
        id: child.id,
        x: child.mind.x,
        y: child.mind.y,
        color: child.mind.color
      }, { render: false });
      if (recursion)
        left(child, recursion);
    }
    pen.mind.children = children;
  }
}
butterfly.connectRule = (pen, child, index) => {
  return index < butterfly.MAXLENGTH ? right.connectRule(pen, child) : left.connectRule(pen, child);
};
butterfly.MAXLENGTH = 8;

// node_modules/@meta2d/plugin-mind-core/src/layout/sandglass.js
function sandglass(pen, recursion = true) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  pen.mind.direction = "sandglass";
  let childrenGap = mindBoxPlugin.childrenGap;
  let levelGap = mindBoxPlugin.levelGap;
  let children = JSON.parse(JSON.stringify(pen.mind.children || []));
  let worldReact = meta2d.getPenRect(pen);
  let topHeight = 0;
  let topWidth = 0;
  let bottomChildren = pen.mind.children.splice(0, sandglass.MAXLENGTH);
  let leftChildren = pen.mind.children;
  pen.mind.children = bottomChildren;
  mindBoxPlugin.calcChildWandH(pen);
  for (let i = 0; i < children.length; i++) {
    let child = meta2d.store.pens[children[i]];
    if (!child)
      continue;
    let childRect = meta2d.getPenRect(child);
    if (i < sandglass.MAXLENGTH) {
      child.mind.connect = sandglass.connectRule(pen, child, i);
      topHeight += (((_b = (_a = meta2d.store.pens[children[i - 1]]) == null ? void 0 : _a.mind) == null ? void 0 : _b.maxHeight) || 0) + (meta2d.store.pens[children[i - 1]] ? +childrenGap : 0);
      topWidth += (((_d = (_c = meta2d.store.pens[children[i - 1]]) == null ? void 0 : _c.mind) == null ? void 0 : _d.maxWidth) || 0) + (meta2d.store.pens[children[i - 1]] ? +childrenGap : 0);
      child.mind.x = worldReact.x - 1 / 2 * pen.mind.maxWidth + topWidth + 1 / 2 * worldReact.width + (((_e = child.mind) == null ? void 0 : _e.maxWidth) / 2 - 1 / 2 * childRect.width || 0);
      child.mind.y = worldReact.y - 1 / 2 * meta2d.getPenRect(child).height + +levelGap;
      meta2d.setValue({
        id: child.id,
        x: child.mind.x,
        y: child.mind.y,
        color: child.mind.color
      }, { render: false });
      if (recursion)
        bottom(child, recursion);
      if (i === sandglass.MAXLENGTH - 1) {
        topHeight = 0;
        topWidth = 0;
        pen.mind.children = leftChildren;
        mindBoxPlugin.calcChildWandH(pen);
      }
    } else {
      topHeight += (((_g = (_f = meta2d.store.pens[children[i - 1]]) == null ? void 0 : _f.mind) == null ? void 0 : _g.maxHeight) || 0) + (meta2d.store.pens[children[i - 1]] ? +childrenGap : 0);
      topWidth += (((_i = (_h = meta2d.store.pens[children[i - 1]]) == null ? void 0 : _h.mind) == null ? void 0 : _i.maxWidth) || 0) + (meta2d.store.pens[children[i - 1]] ? +childrenGap : 0);
      if (i === sandglass.MAXLENGTH) {
        topHeight = 0;
        topWidth = 0;
      }
      child.mind.connect = sandglass.connectRule(pen, child, i);
      child.mind.x = worldReact.x - 1 / 2 * pen.mind.maxWidth + topWidth + 1 / 2 * worldReact.width + (((_j = child.mind) == null ? void 0 : _j.maxWidth) / 2 - 1 / 2 * childRect.width || 0);
      child.mind.y = worldReact.y - 1 / 2 * meta2d.getPenRect(child).height - +levelGap;
      if (child.mind.visible) {
        meta2d.setValue({
          id: child.id,
          x: child.mind.x,
          y: child.mind.y,
          color: child.mind.color
        }, { render: false });
      } else {
        meta2d.setVisible(child, false, false);
      }
      if (recursion)
        top(child, recursion);
    }
    pen.mind.children = children;
  }
}
sandglass.connectRule = (pen, child, index) => {
  return index < sandglass.MAXLENGTH ? bottom.connectRule(pen, child) : top.connectRule(pen, child);
};
sandglass.MAXLENGTH = 8;

// node_modules/@meta2d/plugin-mind-core/src/color/default.js
function defaultColorRule(pen, recursion = true) {
  let children = pen.mind.children || [];
  let generateColorFunc = generateColor();
  for (let i = 0; i < children.length; i++) {
    let child = meta2d.store.pens[children[i]];
    if (!child)
      continue;
    let nodeColor = void 0;
    if (pen.mind.level === 0) {
      let nextColor = generateColorFunc.next().value;
      nodeColor = child.mind.color || nextColor;
    } else {
      nodeColor = child.mind.color || pen.mind.color || pen.color;
    }
    meta2d.setValue({
      id: child.id,
      color: nodeColor
    }, { render: false });
    if (recursion)
      defaultColorRule(child, true);
  }
}
var default_default2 = defaultColorRule;

// node_modules/@meta2d/plugin-mind-core/src/core/MindBoxPlugin.js
var CONFIGS2 = ["animate", "animateDuration", "childrenGap", "levelGap", "colorList"];
var destroyRes = null;
var optionMap = /* @__PURE__ */ new Map();
var pluginDefault = {
  animate: false,
  animateDuration: 200,
  childrenGap: 20,
  levelGap: 200,
  showControl: true,
  funcList,
  colorList: [
    "#FF2318",
    "#9C64A2",
    "#B4C926",
    "#0191B3",
    "#6F6EB9",
    "#9C64A2",
    "#FF291B",
    "#F4AE3C"
  ],
  getFuncList(pen) {
    return pen.mind.isRoot ? mindBoxPlugin.funcList["root"] : mindBoxPlugin.funcList["leaf"];
  }
};
var mindBoxPlugin = {
  name: "mindBox",
  target: [],
  // 已经绑定该插件的图元
  status: false,
  colorList: pluginDefault.colorList,
  childrenGap: pluginDefault.childrenGap,
  // 子节点间的间距
  levelGap: pluginDefault.levelGap,
  // 子级间的间距
  layoutFunc: /* @__PURE__ */ new Map(),
  // 布局位置函数map
  colorFunc: /* @__PURE__ */ new Map(),
  // 布局颜色函数map
  _history: [],
  animate: false,
  _colorRule: "default",
  animateDuration: 1e3,
  // 重新设置颜色规则
  resetColorRule(pen, rule = "default", recursion = true) {
    mindBoxPlugin._colorRule = rule;
    mindBoxPlugin.calcChildrenColor(pen, rule, recursion);
    mindBoxPlugin.resetLinesColor(pen, true);
    mindBoxPlugin.render(pen);
  },
  // 计算子节点的颜色和位置
  calcChildrenPosAndColor(pen, position = pen.mind.direction || "right", color = mindBoxPlugin._colorRule, recursion = true) {
    if (!pen)
      return;
    let layoutFunc = mindBoxPlugin.layoutFunc.get(position);
    let colorFunc = mindBoxPlugin.colorFunc.get(color);
    if (!layoutFunc)
      throw new Error("mindBoxPlugin error : The layout function does not exist");
    try {
      layoutFunc(pen, recursion);
      colorFunc(pen, recursion);
    } catch (e) {
      throw new Error(`[mindBoxPlugin calcChildrenPosAndColor] error : ${e.message}`);
    }
  },
  calcChildrenColor(pen, type = mindBoxPlugin._colorRule, recursion = true) {
    let colorFunc = mindBoxPlugin.colorFunc.get(type);
    if (!colorFunc)
      return;
    try {
      colorFunc(pen, recursion);
    } catch (e) {
      throw new Error(`[mindBoxPlugin calcChildrenColor] error : ${e.message}`);
    }
  },
  calcChildrenPos(pen, position = pen.mind.direction || "right", recursion = true) {
    let layoutFunc = mindBoxPlugin.layoutFunc.get(position);
    if (!layoutFunc)
      return;
    try {
      layoutFunc(pen, recursion);
    } catch (e) {
      throw new Error(`[mindBoxPlugin calcChildrenPos] error : ${e.message}`);
    }
  },
  connectLine(pen, newPen, style = "mind") {
    let from = meta2d.store.pens[newPen.mind.connect.from];
    let to = meta2d.store.pens[newPen.mind.connect.to];
    let line = meta2d.connectLine(from, to, newPen.mind.connect.fromAnchor, newPen.mind.connect.toAnchor, false);
    line.mind = {
      type: "line",
      from: from.id,
      fromAnchor: newPen.mind.connect.fromAnchor,
      to: to.id,
      toAnchor: newPen.mind.connect.toAnchor,
      rootId: newPen.mind.rootId
    };
    newPen.mind.lineId = line.id;
    meta2d.setValue({
      id: line.id,
      lineWidth: meta2d.findOne(pen.mind.rootId).mind.lineWidth,
      locked: 2
    }, { render: false });
    meta2d.updateLineType(line, style);
    return line;
  },
  // 重新设置线颜色
  resetLinesColor(pen, recursion = true) {
    var _a;
    let colors = generateColor();
    let children = pen.mind.children || [];
    if (!children || children.length === 0)
      return;
    for (let i = 0; i < children.length; i++) {
      const child = meta2d.store.pens[children[i]];
      if (!child)
        continue;
      let line = (_a = child.connectedLines) == null ? void 0 : _a[0];
      if (line) {
        line.mind ? "" : line.mind = {};
        if (child.mind.level > 1) {
          line.mind.color = pen.mind.lineColor || pen.mind.color || pen.calculative.color;
        } else {
          line.mind.color = pen.mind.lineColor || colors.next().value;
        }
        meta2d.setValue({
          id: line.lineId,
          color: line.mind.color
        }, { render: false });
      }
      if (recursion) {
        mindBoxPlugin.resetLinesColor(child, true);
      }
    }
  },
  // 重新递归设置连线的样式
  resetLinesStyle(pen, recursion = true) {
    var _a, _b;
    let children = pen.mind.children || [];
    if (!children || children.length === 0)
      return;
    let root = meta2d.findOne(pen.mind.rootId);
    if (!root)
      return;
    for (let i = 0; i < children.length; i++) {
      const child = meta2d.store.pens[children[i]];
      if (!child)
        continue;
      child.mind.lineStyle = pen.mind.lineStyle;
      let line = meta2d.findOne((_b = (_a = child.connectedLines) == null ? void 0 : _a[0]) == null ? void 0 : _b.lineId);
      if (line) {
        meta2d.updateLineType(line, meta2d.findOne(pen.mind.rootId).mind.lineStyle);
        meta2d.setValue({
          id: line.id,
          lineWidth: root.mind.lineWidth,
          ...child.mind.line || {}
        }, {
          render: false
        });
      }
      if (recursion) {
        mindBoxPlugin.resetLinesStyle(child, true);
      }
    }
  },
  disconnectLines(pen, recursion = true) {
    var _a;
    let children = pen.mind.children || [];
    if (!children || children.length === 0) {
      return;
    }
    for (let i = 0; i < children.length; i++) {
      const child = meta2d.store.pens[children[i]];
      if (!child)
        continue;
      if (!child.connectedLines || child.connectedLines.length === 0)
        return;
      let line = meta2d.findOne((_a = child.connectedLines[0]) == null ? void 0 : _a.lineId);
      if (!line)
        continue;
      let lineAnchor1 = line.anchors[0];
      let lineAnchor2 = line.anchors[line.anchors.length - 1];
      let from = meta2d.store.pens[child.mind.connect.from];
      let to = meta2d.store.pens[child.mind.connect.to];
      let fromAnchor = child.mind.connect.fromAnchor;
      let toAnchor = child.mind.connect.toAnchor;
      disconnectLine(from, fromAnchor, line, lineAnchor1);
      disconnectLine(to, toAnchor, line, lineAnchor2);
      if (recursion) {
        mindBoxPlugin.disconnectLines(child, true);
      }
    }
  },
  reconnectLines(pen, recursion = true) {
    let children = pen.mind.children || [];
    if (!children || children.length === 0) {
      return;
    }
    for (let i = 0; i < children.length; i++) {
      const child = meta2d.store.pens[children[i]];
      if (!child)
        continue;
      let line = meta2d.findOne(child.mind.lineId);
      if (!line)
        continue;
      let lineAnchor1 = line.anchors[0];
      let lineAnchor2 = line.anchors[line.anchors.length - 1];
      let from = meta2d.store.pens[child.mind.connect.from];
      let to = meta2d.store.pens[child.mind.connect.to];
      let fromAnchor = child.mind.connect.fromAnchor;
      let toAnchor = child.mind.connect.toAnchor;
      connectLine(from, fromAnchor, line, lineAnchor1);
      connectLine(to, toAnchor, line, lineAnchor2);
      meta2d.canvas.updateLines(child);
      meta2d.bottom(line);
      if (recursion) {
        mindBoxPlugin.reconnectLines(child, true);
      }
    }
    meta2d.canvas.updateLines(pen);
  },
  /**
   * @description 根据连接关系来判断父子关系，目前在计算calcMAXWandH方法中会造成栈溢出
   * */
  collectChildNodes(pen, recursion = true) {
    var _a;
    let lines = pen.connectedLines || [];
    let children = ((_a = pen.mind) == null ? void 0 : _a.children) || [];
    lines.forEach((i) => {
      let line = meta2d.store.pens[i.lineId];
      let index = line.anchors.findIndex((j) => j.connectTo === pen.id);
      if (index) {
        let preNode = meta2d.store.pens[line.anchors[0].connectTo];
        this.initPen(preNode, meta2d.store.pens[meta2d.store.pens[pen.mind.preNodeId].mind.preNodeId]);
        if (!preNode.children.includes(pen.id))
          preNode.children.push(pen.id);
      } else {
        let childNode = meta2d.store.pens[line.anchors[0].connectTo];
        if (!pen.mind.children.includes(childNode.id)) {
          pen.mind.children.push(childNode.id);
        }
      }
    });
    if (recursion) {
      children.forEach((child) => {
        this.collectChildNodes(child, true);
      });
    }
  },
  // 重新设置连线的位置
  resetLayOut(pen, pos, recursion = true) {
    if (!pen)
      return;
    if (!pos)
      pos = pen.mind.direction;
    mindBoxPlugin.disconnectLines(pen, recursion);
    mindBoxPlugin.calcChildrenPos(pen, pos, recursion);
    mindBoxPlugin.reconnectLines(pen, recursion);
    mindBoxPlugin.calcChildrenColor(pen, mindBoxPlugin._colorRule, recursion);
    mindBoxPlugin.resetLinesStyle(pen, recursion);
    mindBoxPlugin.resetLinesColor(pen, recursion);
    mindBoxPlugin.render(pen.mind.rootId);
  },
  /**
   * @description 删除连线
   * @param pen {Object} 图元对象
   * @param recursion {Boolean} 是否递归
   * @example
   * deleteLines(pen,true)
   */
  deleteLines(pen, recursion = false) {
    var _a;
    if (!pen)
      return;
    let lines = [];
    (_a = pen.connectedLines) == null ? void 0 : _a.forEach((i) => {
      let line = meta2d.findOne(i.lineId);
      if (!line)
        return;
      line.locked = 0;
      line && lines.push(line);
    });
    meta2d.delete(lines, false);
  },
  getLines(pen) {
    var _a;
    if (!pen)
      return;
    let lines = [];
    (_a = pen.connectedLines) == null ? void 0 : _a.forEach((i) => {
      let line = meta2d.findOne(i.lineId);
      if (!line)
        return;
      line.locked = 0;
      line && lines.push(line);
    });
    return lines;
  },
  // 删除node下的子节点
  async deleteChildrenNode(pen) {
    var _a;
    let lines = mindBoxPlugin.getLines(pen);
    let parent = meta2d.findOne(pen.mind.preNodeId);
    parent && (pen.mind.preNodeChildren = deepClone(parent.mind.children));
    parent && parent.mind.children.splice(parent.mind.children.indexOf(pen.id), 1);
    await meta2d.delete(((_a = pen.mind) == null ? void 0 : _a.children.map((i) => meta2d.store.pens[i]).filter(Boolean).concat(lines)) || [], true, false);
  },
  getChildrenList(pen, recursion = true) {
    if (pen || !pen.mind)
      return [];
    let childrenId = pen.mind.children;
    if (!childrenId || childrenId.length === 0)
      return [];
    let collect = [];
    childrenId.forEach((i) => {
      let child = meta2d.store.pens[i];
      if (!child)
        return;
      collect.push(child);
      if (recursion)
        collect.concat(mindBoxPlugin.getChildrenList(child));
    });
    return collect;
  },
  // 初始化pen
  initPen(pen, prePen) {
    if (pen.mind)
      return;
    let rootId = prePen ? prePen.mind.rootId : pen.id;
    let preNodeId = prePen ? prePen.id : "";
    let direction = prePen ? prePen.mind.direction : "";
    let lineStyle = prePen ? prePen.mind.lineStyle : "mind";
    let level = prePen ? 0 : prePen.mind.level + 1;
    if (pen.mind)
      return;
    pen.disableRotate = true;
    pen.mind = {
      type: "node",
      isRoot: false,
      rootId,
      preNodeId,
      children: [],
      width: void 0,
      height: void 0,
      maxHeight: 0,
      // 包含了自己和子节点的最大高度
      maxWidth: 0,
      // 包含了自己和子节点的最大宽度
      direction,
      childrenVisible: true,
      visible: true,
      lineStyle,
      lineColor: "",
      level
    };
    mindBoxPlugin.combineToolBox(pen);
    mindBoxPlugin.combineLifeCircle(pen);
  },
  install: (() => {
    let isInit = false;
    let addCallback = null;
    return (pen, options) => {
      if (!isInit) {
        document.addEventListener("keydown", async (e) => {
          var _a;
          if (!meta2d.store.options.keydown)
            return;
          if (e.key === "Backspace") {
            let stopPropagation = false;
            let collection = meta2d.store.active;
            (_a = meta2d.store.active) == null ? void 0 : _a.forEach((pen2) => {
              var _a2;
              if (pen2.mind) {
                stopPropagation = true;
                let lines = (_a2 = pen2.connectedLines) == null ? void 0 : _a2.map((i) => meta2d.findOne(i.LineId));
                collection.concat(lines);
              }
            });
            if (!stopPropagation)
              return;
            let initPens = deepClone(meta2d.store.data.pens.map((pen2) => {
              pen2.calculative.active = void 0;
              return pen2;
            }), true);
            await meta2d.delete(collection, false, false);
            let newPens = deepClone(meta2d.store.data.pens.map((pen2) => {
              pen2.calculative.active = void 0;
              return pen2;
            }), true);
            meta2d.pushHistory({ type: 3, pens: newPens, initPens });
            stopPropagation ? e.stopPropagation() : "";
          }
        }, true);
        mindBoxPlugin.layoutFunc.set("right", right);
        mindBoxPlugin.layoutFunc.set("left", left);
        mindBoxPlugin.layoutFunc.set("top", top);
        mindBoxPlugin.layoutFunc.set("bottom", bottom);
        mindBoxPlugin.layoutFunc.set("butterfly", butterfly);
        mindBoxPlugin.layoutFunc.set("sandglass", sandglass);
        mindBoxPlugin.colorFunc.set("default", default_default2);
        meta2d.on("opened", () => {
          let pens = meta2d.store.data.pens;
          pens.forEach((pen2) => {
            var _a;
            let t = meta2d.findOne((_a = pen2.mind) == null ? void 0 : _a.rootId) || {};
            let isAdd = isIntersection(mindBoxPlugin.target, pen2.tags) || mindBoxPlugin.target.includes(t.name) || pen2.mind;
            if (isAdd && pen2.mind.type === "node") {
              meta2d.emit("plugin:mindBox:open", pen2);
              mindBoxPlugin.combineToolBox(pen2);
              mindBoxPlugin.combineLifeCircle(pen2);
            }
          });
        });
        meta2d.on("scale", () => {
          if (toolbox2.open)
            toolbox2.translateWithPen();
        });
        meta2d.on("undo", (e) => {
          let { initPens } = e;
          let tag = false;
          let target2 = null;
          if (e.type === 3) {
            initPens == null ? void 0 : initPens.forEach((pen2) => {
              var _a;
              pen2.calculative.active = false;
              if (!tag) {
                if ((_a = pen2.mind) == null ? void 0 : _a.rootId) {
                  tag = true;
                  target2 = pen2;
                }
              }
            });
            if (tag) {
              let root = meta2d.findOne(target2.mind.rootId);
              mindBoxPlugin.reconnectLines(root);
            }
          }
        });
        meta2d.on("inactive", () => {
          toolbox2 == null ? void 0 : toolbox2.hide();
        });
        isInit = true;
      }
      let target = null;
      let isTag = false;
      if (pen.name) {
        target = pen.name;
      } else if (pen.tag) {
        isTag = true;
        target = pen.tag;
      } else if (pen.pen) {
        target = pen.pen;
      }
      let toolbox2 = window.toolbox;
      if (!toolbox2) {
        toolbox2 = new ToolBox(meta2d.canvas.externalElements.parentElement, options);
        window.toolbox = toolbox2;
      }
      if (mindBoxPlugin.target.includes(target))
        return;
      optionMap.set(target, deepClone(options || {}));
      mindBoxPlugin.target.push(target.id ? target.id : target);
      if (typeof target === "object") {
        let pen2 = target;
        mindBoxPlugin.combineToolBox(pen2);
        mindBoxPlugin.combineLifeCircle(pen2);
        meta2d.emit("plugin:mindBox:open", pen2);
        mindBoxPlugin.record(pen2.id);
        meta2d.render();
        return;
      } else {
        if (typeof addCallback === "function") {
          meta2d.off("add", addCallback);
        }
        addCallback = (pens) => {
          var _a, _b;
          let isAdd = isIntersection(mindBoxPlugin.target, pens[0].tags) || mindBoxPlugin.target.includes(pens[0].name);
          if (isAdd && pens && pens.length === 1 && !((_a = pens[0].mind) == null ? void 0 : _a.load)) {
            let pen2 = pens[0];
            pen2.disableAnchor = true;
            pen2.disableRotate = true;
            pen2.mind = Object.assign({
              isRoot: true,
              load: true,
              type: "node",
              preNodeId: null,
              rootId: pen2.id,
              children: [],
              width: 0,
              height: 0,
              maxWidth: 0,
              // 包含了自己和子节点的最大宽度
              maxHeight: 0,
              // 包含了自己和子节点的最大高度
              direction: "right",
              lineStyle: "mind",
              lineColor: "",
              childrenVisible: true,
              visible: true,
              lineWidth: 2,
              level: 0
            }, pen2.mind || {});
            pen2.mind.mindboxOption = optionMap.get((_b = isIntersection(mindBoxPlugin.target, pen2.tags, true)) == null ? void 0 : _b[0]) || optionMap.get(pens[0].name);
            mindBoxPlugin.combineToolBox(pen2);
            mindBoxPlugin.combineLifeCircle(pen2);
            mindBoxPlugin.loadOptions(pen2.mind.mindboxOption);
            meta2d.emit("plugin:mindBox:addRoot", pen2);
            mindBoxPlugin.record(pen2.id);
            meta2d.render();
          }
        };
        meta2d.on("add", addCallback);
      }
    };
  })(),
  // 卸载插件
  uninstall(pen, options) {
    let target = "";
    let isTag = false;
    if (pen.name) {
      target = pen.name;
    } else if (pen.tag) {
      isTag = true;
      target = pen.tag;
    } else if (pen.pen) {
      target = pen.pen.id;
    } else if (pen.id) {
      target = pen.id;
    } else {
      return error("mindBox", "uninstall parma error");
    }
    if (mindBoxPlugin.target.includes(target) || mindBoxPlugin.target.includes(pen.pen.id)) {
      if (typeof target === "string") {
        let pens = meta2d.store.data.pens.filter((pen2) => {
          var _a, _b;
          let root = meta2d.findOne((_a = pen2.mind) == null ? void 0 : _a.rootId);
          if (!root)
            return false;
          return ((_b = root.tags) == null ? void 0 : _b.includes(target)) || root.name === target || root.id === target;
        });
        pens.forEach((i) => {
          if (i.mind)
            this.unCombineToolBox(i);
        });
      } else {
        this.unCombineToolBox(target);
      }
      mindBoxPlugin.target.splice(mindBoxPlugin.target.indexOf(target), 1);
    }
    toolbox.hide();
  },
  unCombineToolBox(pen) {
    if (!pen.mind.children)
      return;
    this.combineToolBox(pen, true);
    pen.mind.children.forEach((i) => {
      let child = meta2d.store.pens[i];
      this.unCombineToolBox(child);
    });
  },
  funcList: defaultFuncList,
  setFuncList(funcList2) {
    if (Object.prototype.toString.call(funcList2) !== "[object Object]") {
      throw new Error(`The setFuncList function must take function arguments, get ${funcList2}
`);
    }
    this.funcList = funcList2;
  },
  calcChildWandH(pen) {
    if (!pen || !pen.mind)
      return {
        maxHeight: 0,
        childHeight: 0,
        childWidth: 0,
        maxWidth: 0
      };
    let position = pen.mind.direction;
    let children = pen.mind.children || [];
    let worldRect = meta2d.getPenRect(pen);
    if (children.length === 0 || !pen.mind.childrenVisible) {
      pen.mind.maxHeight = pen.mind.height ?? worldRect.height;
      pen.mind.maxWidth = pen.mind.width ?? worldRect.width;
      return {
        maxHeight: pen.mind.maxHeight,
        maxWidth: pen.mind.maxWidth,
        childHeight: 0,
        childWidth: 0
      };
    }
    let maxHeight = 0;
    let maxWidth = 0;
    let maxH = 0;
    let maxW = 0;
    if (position === "right" || position === "left" || position === "butterfly") {
      for (let i = 0; i < children.length; i++) {
        let child = meta2d.store.pens[children[i]];
        let maxObj = mindBoxPlugin.calcChildWandH(child, position);
        maxHeight += maxObj.maxHeight;
        maxWidth = maxWidth > maxObj.maxWidth ? maxWidth : maxObj.maxWidth;
      }
      maxHeight += +mindBoxPlugin.childrenGap * (children.length - 1);
      maxH = maxHeight > worldRect.height ? maxHeight : worldRect.height;
      pen.mind.maxWidth = maxWidth;
      pen.mind.maxHeight = maxH;
      pen.mind.childHeight = maxHeight;
      pen.mind.childWidth = maxWidth;
      return {
        maxHeight: maxH,
        maxWidth,
        childHeight: maxHeight,
        childWidth: maxWidth
      };
    } else {
      for (let i = 0; i < children.length; i++) {
        let child = meta2d.store.pens[children[i]];
        let maxObj = mindBoxPlugin.calcChildWandH(child, position);
        maxWidth += maxObj.maxWidth;
        maxHeight = maxHeight > maxObj.maxHeight ? maxHeight : maxObj.maxHeight;
      }
      maxWidth += (+pen.mind.childrenGap || +mindBoxPlugin.childrenGap) * (children.length - 1);
      maxW = maxWidth > worldRect.width ? maxWidth : worldRect.width;
      pen.mind.maxHeight = maxHeight;
      pen.mind.maxWidth = maxW;
      pen.mind.childWidth = maxWidth;
      return {
        maxHeight,
        maxWidth: maxW,
        childWidth: maxWidth,
        childHeight: maxHeight
      };
    }
  },
  /**
   * @description 自定义获取功能列表函数  返回值为最终展示的列表
   * @param pen 当前pen图元*/
  getFuncList(pen) {
    return pen.mind.isRoot ? mindBoxPlugin.funcList["root"] : mindBoxPlugin.funcList["leaf"];
  },
  /**
   * @description 动态添加方法函数
   * @param tag 添加到目标种类上
   * @param func 方法函数
   * @param pos 插入的目标位置
   * */
  appendFuncList(tag, func, pos) {
    if (typeof tag !== "string" || typeof func !== "object") {
      throw new Error("appendFuncList error: appendFuncList parma error ");
    }
    let funcList2 = this.funcList[tag];
    if (Object.prototype.toString.call(funcList2) === "[object Array]") {
      if (pos == null) {
        funcList2.push(func);
      } else {
        funcList2.splice(pos, 0, func);
      }
    } else {
      throw new Error("appendFuncList error: no such tag");
    }
  },
  __debounceFirstOnly: debounceFirstOnly(() => {
    destroyRes = new Promise((resolve) => {
      resolve(deepClone(meta2d.store.data.pens.filter((pen) => pen.mind), true));
    });
  }, 1e3),
  __debouncePushHistory: debounce(() => {
    destroyRes.then((res) => {
      let newPens = deepClone(meta2d.store.data.pens.filter((pen) => pen.mind), true);
      meta2d.pushHistory({ type: 3, pens: newPens, initPens: res });
    });
  }, 2e3),
  //
  combineLifeCircle(target, del = false) {
    const onDestroy = (targetPen) => {
      toolbox == null ? void 0 : toolbox.hide();
      mindBoxPlugin.deleteChildrenNode(targetPen);
      this.__debounceFirstOnly();
      this.__debouncePushHistory();
      mindBoxPlugin.update(meta2d.store.pens[targetPen.mind.rootId]);
    };
    const onAdd = (targetPen) => {
      if (!meta2d.store.data.locked) {
        toolbox.bindPen(targetPen);
        toolbox.setFuncList(deepClone(this.getFuncList(target)));
        toolbox.translateWithPen(targetPen);
        toolbox.show();
      }
    };
    const onResize = debounce((pen) => {
      mindBoxPlugin.record(pen.mind.rootId);
    }, 500);
    setLifeCycleFunc(target, "onAdd", onAdd, del);
    setLifeCycleFunc(target, "onDestroy", onDestroy, del);
    setLifeCycleFunc(target, "onResize", onResize);
  },
  deleteNodeOnlyOnce: debounceFirstOnly(async (pen) => {
    let children = mindBoxPlugin.getChildrenList(pen);
    if (!children || children.length === 0)
      return;
    await meta2d.delete(children, true, false);
  }, 1e3),
  combineToolBox(target, del = false) {
    var _a, _b;
    let option = meta2d.store.pens[target.mind.rootId].mind.mindboxOption;
    let showTrigger = ((_a = option.trigger) == null ? void 0 : _a.show) || "onMouseUp";
    let hideTrigger = ((_b = option.trigger) == null ? void 0 : _b.hide) || "onMouseDown";
    let toolbox2 = window.toolbox;
    let onMouseUp = (targetPen) => {
      var _a2, _b2;
      if (!meta2d.store.data.locked) {
        let root = meta2d.findOne((_a2 = targetPen.mind) == null ? void 0 : _a2.rootId);
        let op = optionMap.get((_b2 = isIntersection(mindBoxPlugin.target, root.tags, true)) == null ? void 0 : _b2[0]) || optionMap.get(root.name) || optionMap.get(root.id);
        mindBoxPlugin.loadOptions(op);
        meta2d.emit("plugin:mindBox:loadOption", { pen: targetPen, options: op });
        if (toolbox2) {
          toolbox2._loadOptions(op);
        }
        toolbox2.bindPen(targetPen);
        toolbox2.setFuncList(deepClone(this.getFuncList(target)));
        toolbox2.translateWithPen(targetPen);
        toolbox2.show();
      }
    };
    let onMouseDown = () => {
      toolbox2.hide();
    };
    if (del) {
      onMouseUp = target.mind.onMouseUp;
      onMouseDown = target.mind.onMouseDown;
    } else {
      target.mind.onMouseUp = onMouseUp;
      target.mind.onMouseDown = onMouseDown;
    }
    setLifeCycleFunc(target, showTrigger, onMouseUp, del);
    setLifeCycleFunc(target, hideTrigger, onMouseDown, del);
    if (del) {
      target.mind.onMouseUp = null;
      target.mind.onMouseDown = null;
    }
  },
  // setDirection(pen,direction){
  //   return pen.mind?.direction? pen.mind.direction = direction:((pen.mind = {}) && (pen.mind.direction = direction));
  // },
  // 增加节点  同级设level为true
  /**
   * @description 添加节点
   * @param pen 添加节点的目标节点
   * @param position 添加节点的位置 默认为追加*/
  async addNode(pen, position = 0, type = "mindNode2", option = {}) {
    let opt = {
      name: type,
      disableAnchor: true,
      disableRotate: true,
      mind: {
        type: "node",
        isRoot: false,
        rootId: pen.mind.rootId,
        preNodeId: pen.id,
        children: [],
        width: void 0,
        height: void 0,
        maxHeight: 0,
        // 包含了自己和子节点的最大高度
        maxWidth: 0,
        // 包含了自己和子节点的最大宽度
        direction: pen.mind.direction,
        childrenVisible: true,
        visible: true,
        lineStyle: pen.mind.lineStyle || "",
        lineColor: "",
        level: pen.mind.level + 1
      },
      calculative: {
        x: pen.x,
        y: pen.y
      },
      x: pen.x,
      y: pen.y,
      width: pen.width,
      height: pen.height,
      text: "分支主题",
      // color:generateColor((pen.mind.children[pen.mind.children.length-1])?.calculative.color),
      textColor: "#000",
      lineWidth: 3,
      fontSize: 14,
      borderRadius: pen.borderRadius
    };
    let scale = pen.calculative.canvas.store.data.scale;
    option.width && (option.width *= scale);
    option.height && (option.height *= scale);
    opt = deepMerge(opt, option);
    let initPens = deepClone(meta2d.store.data.pens.filter((pen2) => pen2.mind).map((i) => {
      i.calculative.active = false;
      return i;
    }), true);
    let newPen = await meta2d.addPen(opt, false);
    newPen.mind.connect = pen.mind.level === 0 ? mindBoxPlugin.layoutFunc.get(pen.mind.direction).connectRule(pen, newPen) : pen.mind.connect;
    meta2d.emit("plugin:mindBox:addNode", { plugin: "toolBox", pen, newPen });
    if (position) {
      pen.mind.children.splice(position, 0, newPen.id);
    } else {
      pen.mind.children.push(newPen.id);
    }
    mindBoxPlugin.combineToolBox(newPen);
    mindBoxPlugin.combineLifeCircle(newPen);
    let rootNode = meta2d.findOne(pen.mind.rootId);
    mindBoxPlugin.record(pen.mind.rootId);
    mindBoxPlugin.calcChildrenPos(pen, pen.mind.direction, true);
    let line = mindBoxPlugin.connectLine(pen, newPen, { position: pen.mind.direction, style: rootNode.mind.lineStyle });
    mindBoxPlugin.resetLayOut(rootNode);
    if (mindBoxPlugin.animate) {
      setTimeout(() => {
        toolbox.bindPen(newPen);
        toolbox.setFuncList(deepClone(this.getFuncList(newPen)));
        toolbox.translateWithPen(newPen);
      }, mindBoxPlugin.animateDuration + 100);
    } else {
      toolbox.bindPen(newPen);
      toolbox.setFuncList(deepClone(this.getFuncList(newPen)));
      toolbox.translateWithPen(newPen);
    }
    let newPens = deepClone(meta2d.store.data.pens.filter((pen2) => pen2.mind).map((i) => {
      i.calculative.active = false;
      return i;
    }), true);
    meta2d.pushHistory({ type: 3, pens: newPens, initPens });
    return newPen;
  },
  update: debounce((pen, recursion = true) => {
    if (!pen)
      return;
    mindBoxPlugin.record(pen);
    mindBoxPlugin.resetLayOut(pen, pen.mind.direction, recursion);
    meta2d.emit("plugin:mindBox:update", { form: "toolBox" });
  }, 50),
  // root 为根节点id
  render(root) {
    if (mindBoxPlugin.animate) {
      let pens = [];
      if (root) {
        pens = meta2d.store.data.pens.filter((i) => {
          var _a;
          return ((_a = i.mind) == null ? void 0 : _a.rootId) === root && i.mind.type === "node";
        });
      } else {
        pens = meta2d.store.data.pens.filter((i) => i.mind && i.mind.type === "node");
      }
      let scale = meta2d.store.data.scale;
      pens.forEach((pen) => {
        let source = deepClone(meta2d.getPenRect(pen));
        let origin = meta2d.store.data.origin;
        let x = source.x - pen.mind.oldWorldRect.x;
        let y = source.y - pen.mind.oldWorldRect.y;
        pen.calculative.worldRect.x = pen.mind.oldWorldRect.x * scale + origin.x;
        pen.calculative.worldRect.y = pen.mind.oldWorldRect.y * scale + origin.y;
        pen.calculative.worldRect.ex = pen.calculative.worldRect.x + pen.mind.oldWorldRect.width * scale;
        pen.calculative.worldRect.ey = pen.calculative.worldRect.y + pen.mind.oldWorldRect.height * scale;
        pen.animateCycle = 1;
        pen.keepAnimateState = true;
        pen.frames = [{
          duration: mindBoxPlugin.animateDuration,
          // 帧时长
          x,
          y
          // 变化属性,
        }];
        pen.showDuration = meta2d.calcAnimateDuration(pen);
      });
      meta2d.startAnimate(pens);
      mindBoxPlugin.record(root);
    } else {
      meta2d.render();
    }
    meta2d.emit("plugin:mindBox:render");
  },
  /**
   * @description 该方法用于记录节点位置坐标信息，用于动画过渡的初始状态
   * @param {string} root 根节点的id值*/
  record(root) {
    let pens = [];
    if (root)
      pens = meta2d.store.data.pens.filter((i) => {
        var _a;
        return ((_a = i.mind) == null ? void 0 : _a.rootId) === root && i.mind.type === "node";
      });
    else
      pens = meta2d.store.data.pens.filter((i) => i.mind && i.mind.type === "node");
    pens.forEach((i) => {
      i.mind.oldWorldRect = deepClone(meta2d.getPenRect(i));
    });
  },
  //  TODO 逻辑重写
  loadOptions(options) {
    for (const optionsKey of Object.keys(pluginDefault)) {
      this[optionsKey] = pluginDefault[optionsKey];
    }
    if (!options.funcList) {
      this.setFuncList(defaultFuncList);
    }
    for (let option in options) {
      if (option === "funcList") {
        this.setFuncList(deepClone(options.funcList));
        continue;
      }
      if (option === "getFuncList") {
        this.getFuncList = options[option];
        continue;
      }
      if (CONFIGS2.includes(option)) {
        this[option] = options[option];
      }
    }
  },
  /**
   * @description 从json数据中创建脑图图形
   * json数据结构
   * [{
   *    text:'',
   *    name:'',
   *    mind:{
   *    }
   *    childNodes:[{
   *      pen
   *    }]
   * }]
   * */
  async _recursionLoad(node, father) {
    let _father = null;
    if (!father) {
      _father = await meta2d.addPen(node, true);
    } else {
      _father = await this.addNode(father, 0, "mindNode2", node);
    }
    if (node.childNodes) {
      for (const childNode of node.childNodes) {
        await this._recursionLoad(childNode, _father);
      }
    }
    return _father;
  },
  async loadFromJson(json) {
    const res = [];
    if (json != null && typeof json[Symbol.iterator] === "function") {
      for (let rootNode of json) {
        res.push(await this._recursionLoad(rootNode));
      }
    }
    return res;
  }
};

export {
  createDom,
  debounce,
  deepMerge,
  replaceAfterPosition,
  debounceFirstOnly,
  isObjectLiteral,
  removeDuplicates,
  scopedEval,
  escapeRegExp,
  error,
  warn,
  deepCopy,
  compareObjects,
  isIntersection,
  Scope,
  generateColor,
  funcList,
  defaultFuncs,
  defaultFuncList,
  toolboxDefault,
  toolboxStyle,
  funcListStyle,
  controlStyle,
  extraStyle,
  basicFuncConfig,
  DefaultCssVar,
  ToolBox,
  right,
  left,
  top,
  bottom,
  butterfly,
  sandglass,
  mindBoxPlugin
};
//# sourceMappingURL=chunk-Q6SK2TPB.js.map
